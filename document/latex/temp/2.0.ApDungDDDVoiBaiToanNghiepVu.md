<!--Microserrvice= Microserrvice-->
<!--[](2.0.ApDungDDDVoiBaiToanNghiepVu.md)-->
<!--# DDD: ( EventSourcing, Sagas, CQRS )-->

[](2.0.ApDungDDDVoiBaiToanNghiepVu.md)
Phần mềm được tạo ra để giúp xử lý sự phức tạp trong cuộc sống hiện đại. Việc phát triển phần mềm liên kết chặt chẽ với một số khía cạnh cụ thể trong cuộc sống của chúng ta.

Thiết kế hướng miền (Domain-Driven Design - DDD) nhấn mạnh việc sử dụng lĩnh vực nghiệp vụ kinh doanh để thảo luận và đề xuất giải pháp đáp ứng nhu cầu, chứ không phải những chủ đề đặc thù kỹ thuật. Để tạo ra một phần mềm tốt, bạn cần phải hiểu rõ về chính phần mềm đó. Vì vậy, để đạt được kết quả mong muốn, chúng ta thường bắt đầu từ yêu cầu nghiệp vụ.

**Miền (Domain)**
Miền đề cập đến phạm vi kiến thức và vấn đề mà hệ thống hoặc dự án cụ thể đang xử lý.

Về góc độ kinh doanh: miền đại diện cho một lĩnh vực hoặc ngành mà doanh nghiệp hoạt động.
Về góc độ phần mềm: miền có thể coi là đại diện cho không gian vấn đề của phần mềm đó.

Trong một miền phức tạp, không có một chuyên gia duy nhất có thể có kiến thức tổng thể về tất cả các miền phụ.

Phần mềm cần phản ánh đúng miền và hiện thực hóa một cách chính xác quan hệ giữa các domain.

<!--$VD:-->

**Mô hình miền (Domain Models)**
Mô hình miền được định nghĩa là kiến thức có tổ chức và có cấu trúc về miền phù hợp để giải quyết vấn đề kinh doanh.

Mô hình miền không phải là kiến thức của chuyên gia ngành, mà nó là sự trừu tượng hóa của cả nhóm.

Trong suốt quá trình thiết kế, nhóm liên tưởng và đề cập tới mô hình này. Nhóm trao đổi thông qua mô hình, thể hiện mô hình, và giao tiếp với người khác.

**Tên miền phụ (Sub-Domain)**
Một miền doanh nghiệp bao gồm nhiều tên miền phụ.
Có nhiều yếu tố khác nhau góp phần tạo nên sự phức tạp của tên miền phụ.

<!--Phân loại các tên miền phụ.-->

Có ba loại tên miền phụ:
**Tên miền phụ chung (Generic Subdomain)**

Tên miền phụ chung cung cấp các giải pháp có sẵn mà doanh nghiệp có thể mua.

Không có gì đặc biệt về những tên miền phụ này và các phương pháp tốt nhất đã sẵn có cho những tên miền này.

Doanh nghiệp không thể đạt được bất kỳ lợi thế cạnh tranh nào bằng cách thực hiện những điều khác biệt trong tên miền phụ chung.

<!--$VD:-->

Ví dụ về các tên miền phụ như vậy là quản lý nguồn nhân lực và cơ sở vật chất. Vì vậy, bất kỳ ngành nào hoặc doanh nghiệp nào, các hoạt động quản lý nhân sự và quản lý cơ sở vật chất đều khá trưởng thành và không tạo thêm bất kỳ giá trị khác biệt nào cho doanh nghiệp.

**Tên miền phụ cốt lõi (Core Subdomain)**
Tên miền phụ cốt lõi là điểm khác biệt quan trọng cho doanh nghiệp.

Mỗi doanh nghiệp trong một ngành cụ thể hoạt động khác nhau trong các tên miền phụ cốt lõi để đạt được một số lợi thế so với đối thủ cạnh tranh.

Thành công của một doanh nghiệp nằm ở tên miền phụ cốt lõi.

Doanh nghiệp luôn tìm cách thực hiện những điều khác biệt trong các tên miền phụ cốt lõi này để có được một số lợi thế cạnh tranh.

<!--$VD:-->

**Tên miền phụ hỗ trợ (Supporting Subdomain)**
Các tên miền phụ cốt lõi phụ thuộc vào các tên miền phụ hỗ trợ.

Tên miền phụ hỗ trợ cung cấp các dịch vụ để tên miền phụ cốt lõi hoạt động hiệu quả.

Tên miền phụ hỗ trợ không có mức độ phức tạp cao về logic nghiệp vụ.

<!--$VD:-->
<!--phụ thuộc rất nhiều vào bộ phận hỗ trợ khách hàng-->
<!---->
<!---->
<!---->
<!--Xác định các tên miền phụ-->

Sơ đồ:
[](a.png)

Diễn giải:
Bắt đầu bằng cách xem xét nghiệp vụ kinh doanh.

Nếu có sẵn giải pháp đã biết thì có khả năng là Tên miền phụ chung. Ngược lại, nghiệp vụ đó thêm bất kỳ giá trị kinh doanh nào không.

Nếu không có giá trị kinh doanh thì kiểm tra xem các tên miền phụ cốt lõi có phụ thuộc vào tên miền phụ này hay không? Và câu trả lời đó là có thì có khả năng là tên miền phụ hỗ trợ. Nếu câu trả lời là không thì đó là tên miền phụ chung.

Nếu tên miền phụ có tiềm năng bổ sung một số giá trị kinh doanh thì bước kiểm tra tiếp theo là xem liệu tên miền doanh nghiệp có độ phức tạp cao hay không?

Nếu miền doanh nghiệp không có độ phức tạp cao thì có khả năng là tên miền phụ hỗ trợ. Nếu không thì nó có khả năng là tên miền phụ cốt lõi.

<!---->
<!---->
<!---->
<!---->

Hãy giúp tôi sửa lỗi chính và ngữ pháp:

<!--$VD:-->

<!--tại sao cần phân loại các tên miền phụ?-->

Đầu tiên là doanh nghiệp có nguồn lực hạn chế và những nguồn lực này ở đây đề cập đến nguồn nhân lực cũng như số tiền dành cho các sáng kiến ​​​​khác nhau trong toàn doanh nghiệp. Việc phân loại các tên miền phụ giúp ưu tiên các sáng kiến ​​​​khác nhau.

Lý do thứ hai là lợi tức đầu tư.
Các doanh nghiệp muốn tối đa hóa lợi tức đầu tư. Do đó, các sáng kiến ​​liên quan đến tên miền phụ cốt lõi sẽ được ưu tiên, điều này sẽ giúp tối đa hóa lợi tức đầu tư.

Lý do thứ ba là việc phân loại tên miền phụ giúp doanh nghiệp đưa ra quyết định mua gì. Hãy tìm hiểu sâu hơn một chút.

<!--Nếu tên miền phụ là tên miền phụ chung, doanh nghiệp đó sẽ mua giải pháp cho nó thay vì xây dựng.-->
<!--Sau đó, doanh nghiệp có thể quyết định xây dựng giải pháp bằng cách thuê ngoài hoặc họ có thể mua một giải pháp chung và tùy chỉnh giải pháp đó để đáp ứng nhu cầu về mã của họ.-->
<!--Nếu tên miền phụ được phân loại là cốt lõi thì doanh nghiệp sẽ sử dụng đội ngũ tốt nhất và tài năng tốt nhất của mình để xây dựng giải pháp trong tên miền phụ này.-->

Được bảo hiểm khỏi các đối thủ cạnh tranh, việc hỗ trợ tên miền phụ là cần thiết vì các tên miền phụ cốt lõi phụ thuộc vào tên miền phụ hỗ trợ, việc viết hoa của các tên miền phụ đã giúp doanh nghiệp đưa ra quyết định xây dựng và mua. Và doanh nghiệp nhận được lợi tức đầu tư cao nhất bằng cách đầu tư vào các giải pháp. Thông thường, doanh nghiệp sẽ sử dụng tài năng và nguồn lực tốt nhất của mình để xây dựng các giải pháp trong miền phụ cốt lõi.

<!--Hướng dẫn: 5/3-->

<!--! Bối cảnh kinh doanh-->

Bối cảnh kinh doanh (Business Context)

<!--bối cảnh là gì?(Context)-->

Với Câu hỏi: "Tôi nên thích một tài khoản có lãi suất cao hay tôi nên thích một tài khoản có lãi suất thấp?" và bạn cần đưa ra quyết định, bạn sẽ trả lời như thế nào?
Trả lời:
Nếu muốn mở một tài khoản tiết kiệm, lựa chọn lãi suất cao là phù hợp.
Nếu mở tài khoản thẻ tín dụng, lựa chọn lãi suất thấp là lựa chọn hợp lý, vì lãi suất thấp có nghĩa là sẽ trả lãi ít hơn.

<!--=> Vì vậy, để đưa ra quyết định khách quan, cần thêm thông tin hoặc sự kiện về tình huống để có quyết định chính xác.-->

=> bối cảnh là chính những hoàn cảnh hoặc sự kiện này hình thành nên bối cảnh cho một tuyên bố hay một ý tưởng?
Bối cảnh là quan trọng để đưa ra quyết định chính xác, cần thông tin hoặc sự kiện.

<!--bối cảnh kinh doanh (Business Context)-->

Áp dụng vào lĩnh vực CNTT: Cần hiểu bối cảnh kinh doanh để hiểu được lĩnh vực kinh doanh.
Việc thiếu hiểu biết về các mối liên hệ kinh doanh có thể dẫn đến nhầm lẫn và hiểu sai, đồng thời dẫn đến việc trình bày sai về các mô hình miền.
nhóm CNTT cần hiểu biết Bối cảnh kinh doanh để thực hiện công việc hiệu quả.

<!---->

<!--! Mô hình chiến lược (strategic): Ngôn ngữ phổ biến (Ubiquitous Language)-->

<!--Nhóm kinh doanh sử dụng ngôn ngữ kinh doanh, trong khi nhóm công nghệ có xu hướng sử dụng các thuật ngữ kỹ thuật trong giao tiếp của họ.-->
<!--Sự khác biệt về ngôn ngữ giữa các nhóm kinh doanh và I.T. các nhóm có thể dẫn đến những thách thức về ngôn ngữ.-->
<!--Thiết kế hướng miền đề xuất sử dụng ngôn ngữ phổ biến để giải quyết những thách thức ngôn ngữ này.-->
<!---->
<!--đối với ngôn ngữ kinh doanh được sử dụng trong nhiều miền có thể dẫn đến nhầm lẫn. Nếu bạn đang sử dụng các thuật ngữ kinh doanh từ tên miền này sang tên miền khác thì điều đó có thể dẫn đến nhầm lẫn và hiểu sai.-->

<!--Thách thức để xây dựng các hệ thống phức tạp, các nhóm phải học nhiều ngôn ngữ kinh doanh được các chuyên gia sử dụng trong bối cảnh các miền hoặc miền phụ khác nhau.-->
<!--Thách thức cùng một thuật ngữ có thể xuất hiện trong bối cảnh các lĩnh vực kinh doanh khác nhau.-->
<!--Vì vậy, thách thức ở đây là cùng một thời điểm trên nhiều miền có thể có ý nghĩa khác nhau, tùy thuộc vào ngữ cảnh và điều này có thể gây nhầm lẫn giữa các mục.-->
<!--Thử thách thứ ba liên quan đến việc nó có biệt ngữ riêng.-->
<!--Thiết kế hướng miền gợi ý thiết lập một ngôn ngữ chung trong từng bối cảnh kinh doanh và ngôn ngữ này được tất cả các bên liên quan sử dụng. Ngôn ngữ này được gọi là ngôn ngữ phổ biến.-->

<!--Ngôn ngữ phổ biến là một trong những mô hình chiến lược và thiết kế hướng miền, thiết kế hướng miền, chẳng hạn như thiết lập một ngôn ngữ chung trong từng bối cảnh kinh doanh.-->

<!--ngôn ngữ phổ biến giải quyết tất cả những thách thức-->

<!--Ngôn ngữ phổ biến có thể được coi là một phương ngữ được sử dụng bởi các nhóm khác nhau trong một tổ chức.-->

<!--xác định bởi từ vựng và ngôn ngữ phổ biến có định nghĩa rõ ràng về ngữ cảnh mà từ vựng hoặc bảng chú giải thuật ngữ áp dụng.-->
<!--Bảng thuật ngữ này chứa các thuật ngữ và từ viết tắt phổ biến được sử dụng trong ngữ cảnh được xác định. Tùy chọn, nó cũng có thể giúp làm ví dụ về cách sử dụng các thuật ngữ và từ viết tắt, đồng thời nó cũng có thể có tham chiếu hoặc liên kết đến nội dung có liên quan.-->
<!---->
<!--Tại thời điểm này, bạn có thể nói rằng nó trông giống như Từ điển Doanh nghiệp Doanh nghiệp và bạn đã đúng ở một mức độ nào đó.-->
<!--Đó là một thuật ngữ từ điển, nhưng có sự khác biệt. Hãy để tôi giải thích nó bằng một ví dụ. Trong một bài giảng, tôi đã nói về kinh nghiệm của mình khi xây dựng một mô hình kinh doanh doanh nghiệp thống nhất.-->
<!--Dự án đó cũng bao gồm việc tạo ra một từ điển kinh doanh. Và từ điển kinh doanh mà tôi đã tạo này có các thuật ngữ trong toàn doanh nghiệp và nó cũng có logic cho nhiều mục khác.-->
<!--Và logic này về cơ bản đã hướng dẫn người sử dụng từ điển về ý nghĩa của thuật ngữ này trong các ngữ cảnh khác nhau.-->
<!--Và điều đó đã làm tăng thêm sự phức tạp cho việc sử dụng từ điển kinh doanh này. Khi kết thúc dự án này, tôi đã giao cuốn từ điển kinh doanh này cho một nhà phân tích kinh doanh, người quản lý nó một cách tập trung trong một trang tính Excel.-->
<!--Bạn có thể tưởng tượng cuốn từ điển kinh doanh này đã đi đến đâu trong một khoảng thời gian.
-->
<!---->
<!--Ngôn ngữ phổ biến không được tạo và quản lý tập trung.-->
<!--Có nhiều ngôn ngữ phổ biến trong một tổ chức. Vì vậy, trong trường hợp của ngân hàng, sẽ có một ngôn ngữ phổ biến cho tài khoản tiết kiệm và một ngôn ngữ phổ biến cho tài khoản tín dụng, đồng thời các nhóm tài khoản tiết kiệm và thẻ tín dụng sẽ tạo và quản lý các ngôn ngữ phổ biến này một cách độc lập.-->

<!--Ngôn ngữ phổ biến bao gồm các cuốn sách thường được sử dụng bởi cả chuyên gia kinh doanh và chuyên gia công nghệ.-->

Và có một quan niệm sai lầm đằng sau ngôn ngữ phổ biến này rằng việc xuất khẩu kinh doanh luôn xác định ngôn ngữ.

<!--Trên thực tế, điều đó không phổ biến. Ngôn ngữ không bị áp đặt bởi các chuyên gia. Và không chỉ vậy, nó không phải là ngôn ngữ được sử dụng trong ngành.-->

<!--Hãy coi nó như một ngôn ngữ nhóm, một ngôn ngữ bộ lạc phát triển hoặc phát triển theo thời gian thông qua sự cộng tác giữa doanh nghiệp và các chuyên gia công nghệ.-->

<!--Nhóm tạo ra ngôn ngữ phổ biến có thể sử dụng nhiều kỹ thuật, chẳng hạn như vẽ sơ đồ quy trình, câu chuyện của người dùng, viết kịch bản phân cảnh và thậm chí là gây bão.-->

<!--Và điều này dẫn đến việc tạo ra ngôn ngữ phổ biến. Điều quan trọng cần ghi nhớ là việc tạo ra ngôn ngữ phổ biến không phải là công việc chỉ làm một lần.-->
<!--Đó là một quá trình liên tục vì ngôn ngữ phải mất một thời gian để đạt đến mức độ trưởng thành cao. Khi một câu hỏi phổ biến được đặt ra vào thời điểm này là liệu có bất kỳ công cụ đặc biệt nào để tạo và quản lý ngôn ngữ phổ biến hay không thì câu trả lời ngắn gọn là không.-->
<!--Bạn có thể sử dụng bất kỳ công cụ nào miễn là nó giúp tất cả thành viên trong nhóm có thể tiếp cận được ngôn ngữ phổ biến này. Các công cụ cộng tác và chia sẻ kiến ​​thức như hội nghị và quip thường được sử dụng.-->
<!--Xin lưu ý rằng đây không phải là công cụ cộng tác và chia sẻ kiến ​​thức duy nhất. Bất kỳ công cụ nào có sẵn trong tổ chức của bạn sẽ giúp các thành viên trong nhóm của chúng tôi có thể dễ dàng tiếp cận ngôn ngữ phổ biến này.-->

<!--Khi nhóm đã đạt đến mức độ trưởng thành khá cao đối với ngôn ngữ phổ biến của mình, họ nên bắt đầu sử dụng nó cho mọi thứ.-->
<!--Và sau đó ngôn ngữ này sẽ phát triển theo thời gian. Các chuyên gia tên miền nên sử dụng nó. Các đội giao hàng phải sử dụng nó cho công việc chung hàng ngày của họ.-->
<!--Và tất cả tài liệu nên sử dụng ngôn ngữ phổ biến nếu nhóm đang phát triển tài liệu và họ tạo một thuật ngữ mới hoặc tìm thấy một thuật ngữ mới, thì thuật ngữ đó sẽ được thêm vào ngôn ngữ phổ biến vào cuối ngày.-->
<!--Ngôn ngữ phổ biến phải đóng vai trò là nguồn thông tin chính xác cho tất cả mọi người sử dụng vào thời điểm ngôn ngữ phổ biến đó được sử dụng trong mã ứng dụng cũng như trong mã thử nghiệm.-->
<!--Cuối cùng nhưng không kém phần quan trọng, các nhóm phải sử dụng ngôn ngữ phổ biến trong tất cả các cuộc trò chuyện của mình.-->

![Alt text](image-1.png)

<!--Vì vậy, tại thời điểm này bạn có thể hỏi lợi ích của việc làm đó là gì?-->
<!--Mọi thứ trở nên nhất quán và dễ theo dõi hơn đối với cả chuyên gia tên miền cũng như chuyên gia ID. Một tác dụng phụ thú vị của ngôn ngữ phổ biến là nó giúp xác định các liên hệ chồng chéo.-->
<!--Và điều đó có nghĩa là chúng ta có thể sử dụng ngôn ngữ phổ biến để chia các mối liên hệ kinh doanh của mình thành các phần nhỏ hơn và theo các thiết kế khác nhau về miền. Những phần nhỏ hơn của bối cảnh này được gọi là bối cảnh liên kết. Thêm về điều này trong các bài giảng sau.-->

<!--Ngôn ngữ phổ biến phát triển trong một khoảng thời gian.-->
<!--Đây không phải là công việc chỉ làm một lần mà nó được tạo ra bởi sự cộng tác giữa chuyên gia tên miền và chuyên gia công nghệ.-->
<!--Ngôn ngữ phổ biến không yêu cầu bất kỳ công cụ đặc biệt nào mà bạn có thể sử dụng bất kỳ nền tảng cộng tác tri thức nào.-->

<!--Hướng dẫn 5/7-->

<!--! Mẫu chiến lược (strategic): Bối cảnh bị ràng buộc (Bounded Context)-->
<!--là một trong những mô hình chiến lược trong thiết kế hướng miền.-->

DDD đề xuất chia không gian vấn đề thành các bối cảnh bị ràng buộc

1. Các mô hình được phát triển độc lập trong mỗi BC
2. Mô hình áp dụng trong BC
3. Mỗi BC có một ngôn ngữ phổ biến

Bối cảnh kinh doanh chia miền thành các phần độc lập giải quyết sự phức tạp trong mô hình doanh nghiệp.
Kỹ thuật tạo lớp đối tượng gồm nhiều thuộc tính từ nhiều chuyên gia miền. Mỗi miền sẽ chỉ cần một vài thuộc tính để quản lý.

<!--Ví dụ: class users(......)-->

Dẫn đến sự phụ thuộc. Mất đi tính linh hoạt, xung đột và độ phức tạp của thiết kế hướng miền.
=> Bối cảnh bị ràng buộc (Bounded Context) xác định ranh giới chia miền thành các phần độc lập giải quyết sự phức tạp trong mô hình doanh nghiệp.

một số đặc điểm:

<!--mô hình miền độc lập-->
<!--mỗi liên hệ bị giới hạn phải được thể hiện bằng mô hình miền riêng của nó. Tức là không có sự chia sẻ về mô hình.-->

mỗi domain có mô hình riêng ... user ở domain1,user ở domain2
Các mô hình này được tạo ra và quản lý độc lập bởi các nhóm công nghệ được phân công cho từng đơn vị chức năng này.
Vì các mô hình độc lập nên nhóm này không cần phải có kiến ​​thức về nhóm khác.
các mô hình có thể phát triển độc lập giữa các đơn vị chức năng trong doanh nghiệp.

<!--Mô hình miền được xây dựng cho bối cảnh giới hạn chỉ được áp dụng trong phạm vi ranh giới của bối cảnh giới hạn đó.-->

<!--ngôn ngữ được sử dụng trong bối cảnh giới hạn không gặp phải bất kỳ thách thức ngôn ngữ. Nói cách khác, mỗi bối cảnh đều có ngôn ngữ phổ biến của riêng nó.-->

Đây là ngôn ngữ phổ biến. Vì vậy, nói cách khác, mỗi ngữ cảnh bị giới hạn có một ngôn ngữ phổ biến có một tập hợp các thuật ngữ có ý nghĩa trong ngữ cảnh bị ràng buộc.

Vì vậy, ví dụ: nhóm bán lẻ sẽ tạo ngôn ngữ phổ biến của riêng mình, trong khi nhóm thẻ tín dụng sẽ sử dụng ngôn ngữ phổ biến của riêng mình.

<!--! Khám phá các bối cảnh bị ràng buộc-->

<!--Bạn cần tận dụng các tài sản hiện có và bạn cần hợp tác với các chuyên gia trong lĩnh vực, hãy bắt đầu bằng cách xem xét cơ cấu tổ chức.-->

<!--Thông thường, các cấu trúc tổ chức có sẵn dưới dạng sơ đồ mô tả các khả năng kinh doanh hoặc lĩnh vực chức năng khác nhau trong tổ chức như một bước tiếp theo.-->

<!--tìm kiếm manh mối trong ngôn ngữ kinh doanh được các chuyên gia trong lĩnh vực sử dụng.-->

<!--Nếu tổ chức của bạn đã đầu tư vào các ứng dụng nguyên khối, mô-đun, được thiết kế tốt thì chúng cũng có thể đóng vai trò là điểm khởi đầu cho bài tập này.-->

<!--Nhìn chung, ý tưởng là thu thập manh mối từ các bài tập này và sau đó sử dụng những manh mối này để đánh dấu ranh giới cho bối cảnh được giới hạn nhằm mô tả từng bối cảnh này và cách sử dụng các manh mối này.-->

<!--Hầu hết các tổ chức đều giỏi ghi chép và duy trì cơ cấu tổ chức của họ.-->

<!--Các chức năng kinh doanh này là các khả năng kinh doanh có thể được coi là điểm khởi đầu cho các liên hệ bị giới hạn.-->

![Alt text](image-2.png)

<!--Đi sâu hơn vào từng hoạt động này với sự cộng tác của các chuyên gia kinh doanh sẽ giúp các chuyên gia hiểu được ranh giới bối cảnh trong lĩnh vực ngân hàng tiêu dùng.-->

<!--Bạn, với tư cách là chuyên gia CNTT, cần cộng tác với các chuyên gia kinh doanh để xác định các hoạt động chính phù hợp trong tổ chức của mình và sau đó tìm hiểu sâu hơn về từng hoạt động này.-->

<!--Và như bạn. Việc thực hiện các hoạt động này đảm bảo rằng bạn nắm bắt được ngôn ngữ kinh doanh được sử dụng cho từng hoạt động này, việc sử dụng luồng của các hoạt động chính này và manh mối ngôn ngữ sẽ giúp bạn xác định các mối liên hệ gắn kết từ góc độ kinh doanh, trường hợp sử dụng và quy trình.-->

<!--Nếu bạn làm việc cho một tổ chức đã đầu tư vào việc xây dựng các ứng dụng mô-đun nguyên khối, được thiết kế tốt thì bạn thật may mắn vì bạn có thể sử dụng các ứng dụng được thiết kế tốt này để xác định các liên hệ được liên kết.-->

<!--Nói tóm lại, không nên bỏ qua các ứng dụng nguyên khối hiện có và chúng có thể được sử dụng làm điểm khởi đầu để tạo các liên hệ được liên kết trong miền doanh nghiệp của bạn.-->

<!--Trong bài học này, tôi đã hướng dẫn bạn một loạt các bước mà bạn có thể thực hiện để khám phá các liên hệ được liên kết trong miền của mình.-->

<!--Đề xuất là tận dụng các tài sản sẵn có, chẳng hạn như cơ cấu tổ chức, các ứng dụng nguyên khối, được thiết kế tốt hiện có để xác định các liên hệ bị ràng buộc và những thứ khác mà bạn với tư cách là I.T. điều chuyên gia cần làm là hợp tác với các chuyên gia kinh doanh để hiểu trách nhiệm và hoạt động chính của họ khi bạn làm việc chặt chẽ với chuyên gia kinh doanh.-->

<!--Bạn cần chú ý đến ngôn ngữ kinh doanh và những manh mối ngôn ngữ sẽ giúp bạn phân định ranh giới của bối cảnh bị giới hạn.-->

Hướng dẫn 5/10

<!--// C:\Users\ionships_VVN\000000001.srt-->

<!--Bối cảnh liên kết, các mối quan hệ, không liên kết với các liên hệ là độc lập, các liên hệ được liên kết trên cơ thể không bị cô lập với các liên hệ được liên kết khác xung quanh chúng, các mô hình trong các liên hệ được liên kết cộng tác để đáp ứng các yêu cầu của hệ thống.-->

<!--các dịch vụ vi mô, không tự đáp ứng tất cả các yêu cầu của hệ thống.-->

<!--Các dịch vụ vi mô này cần tương tác với các dịch vụ vi mô khác. Những mối quan hệ này ngụ ý một số loại phụ thuộc giữa các liên hệ được liên kết hoặc các dịch vụ vi mô.-->
<!--Vì vậy, trong trường hợp này, bối cảnh phụ thuộc vào ranh giới.-->

Có nhiều loại mối quan hệ: 1-1 đối xứng, 1 - nhiều không đối xứng.

<!--Symmetric Relationship : Separate ways , Partnership, Shared Kernel-->
<!--Mối quan hệ đối xứng: Cách riêng biệt, Quan hệ đối tác, Hạt nhân chung-->

<!--Asymmetric Relationship: Customer-Supplier, Conformist, Anti Corruption Layer-->
<!--Mối quan hệ bất đối xứng: Khách hàng-Nhà cung cấp, Người tuân thủ, Lớp chống tham nhũng-->

<!--One-to-Many Relationship: Open Host Service, Published Language-->
<!--Mối quan hệ một-nhiều: Dịch vụ máy chủ mở, ngôn ngữ được xuất bản-->

<!--// C:\Users\ionships_VVN\000000002.srt-->
<!--Quản lý mối quan hệ giữa các liên hệ liên kết trong bài học này, Alcoa và Antiproton được gọi là quả bóng bùn lớn, bạn cũng sẽ tìm hiểu về những thách thức liên quan đến các liên hệ liên kết, sự phụ thuộc và bạn tìm hiểu về các liên hệ, bản đồ có thể giúp quản lý BONARD sự phụ thuộc vào bối cảnh, các liên hệ bị giới hạn không được quản lý, mối quan hệ dẫn đến một cục bùn lớn.-->

<!--Bối cảnh bị ràng buộc - Phụ thuộc-->

Trong quá trình phát triển, nếu không kiểm soát sửa lỗi hợp lí dẫn tới mô hình phát triển không tốt
khó bảo trì, và thường là kết quả của quá trình phát triển không kiểm soát.
không có một chiến lược kiến trúc tổng thể hoặc kế hoạch dài hạn.
![Alt text](image-3.png)

<!---->
<!--Bây giờ chúng tôi biết rằng các liên hệ ngoại quan không thể bị cô lập. Sẽ có những mối quan hệ phụ thuộc.-->
<!--Những mối quan hệ này cần được quản lý. Nếu không thì sẽ mất tính toàn vẹn và sẽ mất đi khả năng hoạt động độc lập của nhóm.-->
<!--mất đi những lợi ích mà bạn mong đợi nhận được từ kiến ​​trúc dịch vụ vi mô.-->
<!--Tác động tiêu cực đến tính toàn vẹn của mô hình-->
<!--Mất tính toàn vẹn của mô hình-->
<!--Sự phụ thuộc giữa bối cảnh bị ràng buộc cuối cùng được chuyển thành sự phụ thuộc giữa các dịch vụ vi mô.-->
<!--Vì vậy, tất cả các thay đổi sẽ yêu cầu một số hình thức hợp tác giữa các nhóm sở hữu các dịch vụ vi mô này.-->
<!--Và điều đó có nghĩa là các nhóm sẽ mất khả năng hoạt động độc lập và điều đó sẽ dẫn đến mất đi tính linh hoạt, điều này trái ngược với một trong những lý do khiến kiến ​​trúc dịch vụ vi mô được áp dụng.-->

<!--Vì vậy, đề xuất là quản lý các liên hệ, mối quan hệ được liên kết này bằng cách sử dụng các mẫu thiết kế hướng miền thích hợp.-->
<!--Các đội phải nỗ lực phải ghi lại mối quan hệ giữa các điểm tiếp xúc được liên kết bằng cách sử dụng Bản đồ bối cảnh (Context Maps)-->
<!--Bản đồ bối cảnh là sự thể hiện trực quan của các hệ thống, các liên hệ và mối quan hệ giữa chúng.-->

<!--Có nhiều lợi ích của việc sử dụng bản đồ:-->
<!--giúp các thành viên trong nhóm dễ dàng hiểu được bức tranh toàn cảnh hơn.-->
<!--giúp hiểu được sự phụ thuộc lẫn nhau giữa các liên hệ bị ràng buộc.-->
<!--giúp các nhóm đánh giá mức độ hợp tác cần thiết với các nhóm khác.-->
<!--giúp sàng lọc các liên hệ được giới hạn và các mô hình.-->

<!--xác định mối quan hệ giữa các liên hệ bị ràng buộc của mình.-->

<!--// C:\Users\ionships_VVN\000000003.srt-->
<!--! Mối quan hệ đối xứng-->
<!--! Separate Ways-->
<!--! Các cách riêng biệt-->

<!--các liên hệ được liên kết thực sự độc lập-->
<!--Điều đó có nghĩa là không có sự chia sẻ mô hình giữa hai địa chỉ liên hệ được liên kết này vì các nhóm độc lập của họ có thể tự động làm việc trên hai địa chỉ liên hệ được liên kết này.-->
<!--Nói cách khác, các nhóm này không phải cộng tác hay phối hợp cho bất kỳ nhiệm vụ nào.-->
<!--Không có mối quan hệ nào giữa các ranh giới liên hệ được gọi là các cách riêng biệt từ góc nhìn hiện thực hóa.-->
<!--Điều đó có nghĩa là chúng sẽ là tập hợp các ứng dụng hoặc dịch vụ độc lập cho từng điểm tiếp xúc được liên kết.-->

<!--! Partnership pattern-->
<!--! Mô hình hợp tác-->

<!--Sự phụ thuộc lẫn nhau này dẫn đến mức độ kết hợp cao giữa bối cảnh gắn kết và loại mối quan hệ này được gọi là Quan hệ đối tác và Thiết kế theo nhu cầu.-->
<!--Từ góc độ hiện thực hóa, mô hình hợp tác chuyển thành các dịch vụ có sự phụ thuộc lẫn nhau.-->
<!--Vì vậy, điều đó có nghĩa là các dịch vụ có thể được phát triển bởi các nhóm khác nhau, nhưng do sự phụ thuộc lẫn nhau giữa các dịch vụ nên các nhóm không thể hoạt động độc lập.-->
<!--Không chỉ vậy, mỗi nhóm tham gia vào loại mối quan hệ này sẽ cần phải tìm hiểu các mô hình kinh doanh và ngôn ngữ phổ biến đó cho các mối liên hệ gắn kết do nhóm kia quản lý.-->
<!--Cuối cùng, điều này có nghĩa là các nhóm trong mối quan hệ kiểu này sẽ cần phối hợp các thay đổi, triển khai và phát hành của họ, và điều đó sẽ làm hỏng mục đích áp dụng kiến ​​trúc dịch vụ vi mô.-->

<!--Bây giờ, câu hỏi hiển nhiên mà bạn có thể có vào thời điểm này là làm cách nào để giải quyết vấn đề này? Một cách để giải quyết vấn đề này là phân định ranh giới cho các mô hình dùng chung.-->
<!--Vì vậy, giả sử hai nhóm độc lập đang làm việc trên bối cảnh hỗn hợp và bối cảnh tự nguyện. B, họ có thể tạo ranh giới xung quanh các mô hình được chia sẻ giữa hai điểm tiếp xúc được liên kết.-->
<!--Ý tưởng là quản lý các mô hình chia sẻ này một cách độc lập với phần còn lại của bối cảnh liên kết. Vì vậy, điều đó có nghĩa là nếu cần thay đổi và thay đổi này không phải là một phần của mô hình được chia sẻ thì nhóm được chỉ định cho các liên hệ bị giới hạn có thể đưa ra quyết định độc lập.-->
<!--Tương tự, nếu có những thay đổi cần thiết bên ngoài các mô hình được chia sẻ và các liên hệ bị ràng buộc, hãy là nhóm được chỉ định cho các liên hệ liên kết.-->
<!--B có thể đưa ra những quyết định đó một cách độc lập. Nhưng bất cứ lúc nào, nếu có nhu cầu thay đổi mẫu dùng chung thì 2 đội sẽ phối hợp.-->

<!--! Shared Kernel-->
<!--! Hạt nhân dùng chung-->
<!--Việc chia sẻ mô hình giữa các liên hệ bị chặn được gọi là mẫu mục tiêu chung. Điều quan trọng cần ghi nhớ đối với Kernel được chia sẻ là các phần chồng chéo của các liên hệ thể hiện mô hình miền chung, các khái niệm được chia sẻ và ngôn ngữ kinh doanh được chia sẻ giữa hai liên hệ được liên kết.-->
<!--Thông thường, hạt nhân dùng chung được hiện thực hóa bằng Labrys dùng chung, chẳng hạn như Java, Java, Gói Python và Ruby Gems.-->

<!--Các nhóm có thể phát triển độc lập các dịch vụ sử dụng các thư viện dùng chung này. Các nhóm có thể sử dụng kernel dùng chung và Labrys dùng chung miễn là phạm vi chia sẻ.-->

<!--Giữa các tiếp điểm liên kết được giới hạn ở một tập hợp nhỏ các mô hình cho các tình huống liên quan đến việc chia sẻ quá nhiều mô hình giữa các tiếp điểm được liên kết, việc duy trì tính toàn vẹn của ranh giới của các tiếp điểm biên sẽ trở nên khó khăn.-->

<!--Và đó là lý do gợi ý chỉ sử dụng kernel dùng chung nếu chúng ta đang nói về một tập hợp nhỏ các khái niệm được chia sẻ giữa các liên hệ bị chặn.-->

<!--!Trong bài học này, tôi đã đề cập đến ba mô hình chiến lược. Cách đầu tiên là những cách riêng biệt trong đó không có mối quan hệ nào giữa các liên hệ bị chặn.-->
<!--!Kết quả là, các nhóm làm việc trên hai điểm tiếp xúc liên kết có thể làm việc thực sự độc lập. Tiếp theo là mô hình hợp tác trong đó có sự phụ thuộc lẫn nhau giữa các liên hệ bị ràng buộc.-->
<!--!Do đó, các đội phải phối hợp với nhau để thực hiện các thay đổi đối với các liên hệ giới hạn của riêng mình. Thứ ba là Kamna được chia sẻ, trong đó đề xuất rằng ranh giới của các khái niệm và mô hình được chia sẻ phải được phân định rõ ràng và chỉ những thay đổi đối với các mô hình chung này mới cần được các nhóm điều phối.-->
<!--!Nói cách khác, nếu nhóm đang thực hiện những thay đổi không liên quan đến các mô hình hoặc khái niệm được chia sẻ thì nhóm có thể thực hiện những thay đổi đó mà không cần ý kiến ​​đóng góp của nhóm khác.-->

<!--// C:\Users\ionships_VVN\000000004.srt-->
<!--các ký hiệu bản đồ ngữ cảnh.-->

<!--Mối quan hệ bất đối xứng-->

<!--Loại mối quan hệ này được mô tả bằng cách gán vai trò cho bối cảnh bị ràng buộc.-->

Bối cảnh A ràng buộc với bối cảnh B thì:
Bối cảnh A đóng vai trò là bối cảnh ranh giới hạ lưu (Downstream)
Bối cảnh B đóng vai trò là bối cảnh ranh giới thượng nguồn (Upstream)
Bối cảnh bị ràng buộc A có kiến thức về các mô hình trong Bối cảnh bị ràng buộc B
Bối cảnh B không có bất kỳ kiến ​​thức nào về mô hình trong bối cảnh bị chặn A

<!--D-U-->
<!--!Mô hình khách hàng-nhà cung cấp (Customer-Supplier Pattern)-->

Trong trường hợp Upstream đáp ứng một số nhu cầu cụ thể của Downstream
Từ góc độ hiện thực hóa, nhóm nhà cung cấp luôn tham khảo ý kiến ​​​​của nhóm khách hàng để đảm bảo rằng máy chủ của nhà cung cấp đáp ứng được nhu cầu dịch vụ khách hàng.

<!--!mẫu phù hợp (Conformist Pattern)-->
<!--mô hình tuân thủ-->

Trong trường hợp Upstream hiển thị các mô hình mà không liên quan đến bất kỳ yêu cầu hoặc nhu cầu của Downstream

<!--CF-U-->
<!--!Mẫu lớp chống tham nhũng (Anti Corruption Layer Pattern)-->

bối cảnh giới hạn xuôi dòng quyết định không tuân theo bối cảnh giới hạn ngược dòng.
quyết định tạo ra mô hình của riêng mình thay vì áp dụng các mô hình cho ngữ cảnh bị giới hạn.

<!--Trong trường hợp đó, các mô hình từ ngữ cảnh bị chặn sẽ được hiển thị trong ngữ cảnh bị chặn. Nó sẽ yêu cầu một số loại bản dịch để chuyển đổi các mô hình từ bối cảnh bị ràng buộc sang bối cảnh bị ràng buộc.-->

<!--Đề xuất là tách logic dịch thuật này thành một lớp riêng biệt. Cấp độ này của bản dịch được gọi là trực tiếp chống tham nhũng-->

<!--Ý tưởng đằng sau luật sư chống tham nhũng là bảo vệ bối cảnh ngoại quan khỏi tham nhũng.-->
<!--ACL-U-->

trong mỗi bối cảnh liên kết này, có mô hình riêng. Họ không có kiến ​​thức gì về mô hình của nhau.
ACL có kiến ​​thức cần thiết về cả hai mô hình của A và B và thực hiện việc chuyển đổi từ B sang mô hình của A là lớp chống tham nhũng cần phải có kiến ​​thức về cả mô hình hạ nguồn cũng như mô hình thượng nguồn.
Nhưng hạ lưu không có kiến ​​thức về bối cảnh giới hạn thượng nguồn, và đó là cách lớp chống tham nhũng bảo vệ hạ lưu khỏi những thay đổi ở thượng nguồn.

<!--!Trong bài học này, bạn đã tìm hiểu về mối quan hệ bất đối xứng giữa bối cảnh ranh giới và mối quan hệ bất đối xứng.-->
<!--!Bối cảnh ranh giới hạ nguồn phụ thuộc vào bối cảnh ranh giới thượng nguồn trong mẫu nhà cung cấp khách hàng.-->
<!--!Bối cảnh giới hạn ngược dòng điều chỉnh các mô hình theo nhu cầu của bối cảnh giới hạn xuôi dòng, trong khi ở mẫu tuân thủ, bối cảnh giới hạn ngược dòng không liên quan đến nhu cầu của bối cảnh giới hạn xuôi dòng.-->
<!--!Và do đó, bối cảnh ranh giới phía hạ nguồn phù hợp với các mô hình thượng nguồn. Để bảo vệ bối cảnh ranh giới hạ nguồn, các đội sẽ quyết định sử dụng lớp chống tham nhũng.-->
<!--!Lớp chống tham nhũng này có logic để dịch các mô hình từ định dạng ngược dòng sang định dạng xuôi dòng.-->
<!--!Formic, theo hướng đó xuôi dòng. Bối cảnh bị ràng buộc không có kiến ​​thức về bối cảnh mô hình ngược dòng và do đó không có sự phụ thuộc trực tiếp.-->

<!--// C:\Users\ionships_VVN\000000005.srt-->
<!--One to Many Relationship-->

Bối cảnh ranh giới cung cấp các dịch vụ chung được gọi là dịch vụ nguồn mở

<!--Mở dịch vụ máy chủ Open Host Service-->

mô tả dịch vụ chung này dưới dạng mẫu được đặt trước bối cảnh giới hạn ngược dòng cung cấp các dịch vụ chung, bối cảnh giới hạn ngược dòng hoặc nhà cung cấp dịch vụ được lưu trữ mở trong mối quan hệ này cung cấp một ngôn ngữ chung để tích hợp.
Đối tác đầu tiên, mẫu dịch vụ được lưu trữ mở, trong đó bối cảnh kết hợp ngược dòng cung cấp một tập hợp các dịch vụ chung hoặc khả năng chung cho bối cảnh giới hạn xuôi dòng.

<!--D-OHS-->
<!--Published Language-->
<!--Ngôn ngữ được xuất bản-->

Ngôn ngữ chung này được các nhóm làm việc trong bối cảnh giới hạn ở hạ lưu chấp nhận. Ngôn ngữ chung này được gọi là ngôn ngữ được xuất bản và mẫu này được gọi là mẫu ngôn ngữ được xuất bản.

<!--D-OHS|PL-->

Ngôn ngữ thứ hai là ngôn ngữ được xuất bản, đi đôi với dịch vụ lưu trữ mở. Trở lại ngược dòng, các liên hệ được giới hạn trên nhà cung cấp dịch vụ được lưu trữ mở sẽ hiển thị ngôn ngữ chung cho các dịch vụ chung và ngôn ngữ này được quản lý bởi nhóm chịu trách nhiệm về dịch vụ được lưu trữ mở, các liên hệ được giới hạn ở hạ nguồn ngoại trừ ngôn ngữ được xuất bản này.

<!--Hướng dẫn 6/6-->
<!--! mẫu chiến lược (Strategic patterns)-->
<!--!Phân rã các miền phức tạp (Decomposition of complex domains)-->

<!--các mẫu chiến thuật có thể được sử dụng để lập mô hình và hiện thực hóa các dịch vụ vi mô.-->
<!--Thiết kế hướng mô hình (model drivern design) cung cấp một khuôn khổ để hiện thực hóa mô hình hệ thống và sử dụng phương pháp thiết kế hướng miền, các mẫu chiến thuật là các khối xây dựng và thiết kế hướng mô hình.-->

<!--Entities ,Value Objects ,Aggregate được gọi là các đối tượng miền, các đối tượng miền này được sử dụng để mô hình hóa dữ liệu trong mô hình miền.-->
<!--Các nhà máy (factori) là để tạo ra miền phức tạp.-->
<!--Các reporitori được sử dụng để quản lý tính bền vững của các đối tượng miền.-->
<!--Các dịch vụ được sử dụng để mô hình hóa sự tương tác của các đối tượng miền với các đối tượng miền khác, với cơ sở hạ tầng và với các thành phần bên ngoài khác.-->

<!--Entities (thực thể)-->
<!--!Đối tượng thực thể-->
<!--!Đặc điểm của các thực thể-->

<!--!Logic kinh doanh-->
<!--Một thực thể đại diện cho một đối tượng kinh doanh có thể nhận dạng duy nhất, bao gồm các thuộc tính và hành vi miền được xác định rõ ràng.-->
<!--Các thực thể này và danh tính của chúng chỉ có ý nghĩa trong bối cảnh giới hạn tương ứng của chúng.-->
<!--Một thực thể có một tập hợp các thuộc tính được xác định bởi ngôn ngữ phổ biến cho ngữ cảnh bị chặn.-->
<!--Một thực thể có một hành vi, nghĩa là nó đóng gói logic nghiệp vụ. Và logic kinh doanh này được thể hiện qua cách thức hoạt động.-->

<!--Khi các hoạt động này được thực hiện đối với thực thể, nó sẽ dẫn đến sự thay đổi trạng thái của thực thể.-->
<!--Tương tự, thao tác này là sở hữu đối tượng vào cơ sở dữ liệu. Vì vậy, nhìn từ bề ngoài, có vẻ như thực thể này không bao gồm bất kỳ hoạt động kinh doanh nào.-->
<!--Trong trường hợp RDBMS, một bảng biểu thị một tập hợp các thực thể. Các quy tắc trong bảng biểu thị các thực thể được xác định duy nhất bằng cột khóa chính.-->
<!--Điều đầu tiên là các thực thể là các đối tượng kinh doanh chỉ có ý nghĩa trong một bối cảnh giới hạn.-->

<!--Nơi chúng được xác định là các thực thể được xác định duy nhất trong bối cảnh bị giới hạn. Tiếp theo là định nghĩa của thực thể bao gồm thuộc tính và hành vi.-->
<!--Hành vi này triển khai logic nghiệp vụ có thể thay đổi trạng thái của thực thể. Các thực thể được lưu trữ lâu dài.-->

<!--!Đối tượng giá trị (Value Objects)-->

<!--!Đặc trưng-->

<!--!Vòng đời-->

<!--Đối tượng giá trị, không giống như thực thể, các đối tượng không có nhận dạng khái niệm trong ngữ cảnh bị ràng buộc.-->

<!--Nói cách khác, giá trị, thuộc tính đối tượng và hành vi không ánh xạ trực tiếp tới các khái niệm cốt lõi trong bối cảnh bị chặn.-->

<!--bạn sẽ đặt logic xác thực cho địa chỉ email ở đâu?-->
<!--xác nhận kỹ thuật không liên quan đến bất kỳ khái niệm kinh doanh nào.-->
<!--tạo một đối tượng giá trị để xác thực địa chỉ email.-->
<!--Kết quả là, thực thể khách hàng sẽ sạch hơn và đơn giản hơn nhiều trong việc thực hiện.-->

<!--Nói cách khác, đối tượng giá trị được tạo trong bộ nhớ tiến trình và sau đó bị hủy sau khi nó đã phục vụ mục đích của nó.-->
<!--đối tượng giá trị không có danh tính duy nhất.-->

<!--Một điểm khác biệt quan trọng giữa các thực thể và đối tượng giá trị là đối tượng giá trị không tồn tại lâu dài trong cơ sở dữ liệu.-->

Đã đến lúc xem xét nhanh. Trong bài học này bạn đã học về các đối tượng giá trị. Các đối tượng giá trị không có nhận dạng khái niệm trong bối cảnh bị giới hạn.
Các đối tượng giá trị không được tồn tại trong cơ sở dữ liệu như một đối tượng độc lập. Nó được lưu trữ như một phần của đối tượng thực thể hoặc thậm chí nó không được lưu trữ trong cơ sở dữ liệu, một thực thể trong một ngữ cảnh bị chặn, có thể là một đối tượng giá trị trong một ngữ cảnh bị chặn khác và ngược lại.

<!--Hướng dẫn 7/4-->
<!--Hướng dẫn 7/5-->
<!--tổng hợp và mẫu nhà máy (Aggregates & Factories)-->
<!--!Tổng hợp là gì?-->

<!--!Các bộ phận của một tập hợp-->

<!--định nghĩa về tổng hợp:-->
<!--Đối tượng tổng hợp là một nhóm các thực thể và đối tượng giá trị được xem như một tổng thể thống nhất từ ​​góc độ dữ liệu và khái niệm miền.-->
<!---->

Hãy để tôi giải thích điều này bằng một minh họa.
Một tập hợp bao gồm một nhóm tổng hợp còn được gọi là thực thể gốc.
Thực thể gốc này có một danh tính duy nhất từ ​​phối cảnh miền.
Phần thứ hai của tập hợp là cụm, được hình thành bởi ranh giới của tập hợp.
Trong ranh giới này, có thể không có hoặc nhiều thực thể tổng hợp và đối tượng giá trị. Các đối tượng trong cụm này hoặc đối tượng trong ranh giới được gọi là đối tượng bên trong hoặc đối tượng con.
![Alt text](image-4.png)

<!--Aggregate phải cung cấp các giao diện để vận hành trên các đối tượng bên trong.-->
<!--Aggregate provides interfaces for operations on Inner objects-->

<!--đảm bảo rằng tất cả hành vi cần thiết để vận hành trên đối tượng bên trong được hiển thị dưới dạng các hàm của đối tượng gốc tổng hợp.-->

![Alt text](image-5.png)

<!--!Mẫu nhà xưởng (Factory Pattern)-->
<!--Mẫu thiết kế nhà máy là một mẫu phổ biến để xây dựng các tập hợp miền phức tạp. Cách thức hoạt động là bạn xác định một đối tượng có tất cả logic để tạo tổng hợp miền.-->

Nhà máy này hiển thị một chức năng có thể được gọi bằng mã và hiển thị chức năng để tạo các bộ tổng hợp có liên quan trong nhà máy, nhà máy đọc.
Dữ liệu tổng hợp từ bộ lưu trữ liên tục sẽ tạo tổng hợp và trả về cột.
Vì vậy đây là mẫu thiết kế rất phổ biến, không nhất thiết chỉ dành riêng cho các dịch vụ của Mikoto.

<!--Đã đến lúc xem xét nhanh. Tổng hợp có thể chứa các thực thể tổng hợp và đối tượng giá trị khác. Tổng hợp phải gói gọn hành vi để quản lý trong đối tượng bên trong.-->
<!--Tất cả các thay đổi đối với tổng hợp đều được lưu. Các đối tác nguyên tử và nhà máy thường được sử dụng để tạo các tập hợp miền phức tạp.-->

<!--Hướng dẫn 7.7-->
<!--Hướng dẫn 7.8-->

<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!--mẫu kho lưu trữ (Repository Pattern)-->

các đặc điểm của kho lưu trữ
một số tùy chọn hiện thực hóa cho kho lưu trữ

<!--Đối tượng kho lưu trữ hoạt động như một tập hợp các đối tượng tổng hợp trong bộ nhớ.-->

<!--Tất cả logic để tương tác với bộ lưu trữ dữ liệu được gói gọn bởi đối tượng kho lưu trữ.-->
<!--kho lưu trữ đóng vai trò là nơi chứa tập hợp các đối tượng tổng hợp.-->

<!--đối với mỗi tổng hợp được xác định trong mô hình miền, bạn có một và chỉ một kho lưu trữ.-->
<!--Các đối tượng kho lưu trữ được quản lý như một phần của lớp miền. Ngoài các chức năng thẻ điển hình, kho lưu trữ cũng có thể hiển thị các chức năng cấp cao hơn, chủ yếu dành cho truy vấn.-->

<!--Nhìn chung, lợi ích chính của việc sử dụng kho lưu trữ là nó giữ cho mô hình miền độc lập với lớp lưu trữ.-->

<!--Mô hình miền độc lập với mô hình lưu trữ. Vì vậy, ví dụ: nếu bạn đang sử dụng RDBMS thì mô hình miền không cần phải biết về cấu trúc bảng và cột.-->
<!--Nó giữ cho mô hình miền độc lập với công nghệ bạn có thể đang sử dụng và RDBMS không bằng nhau-->

<!--Kho lưu trữ giữ cho mô hình miền độc lập với cơ sở hạ tầng-->
<!--giúp kiểm tra và mô phỏng đơn vị.-->
<!--Phản hồi cơ sở dữ liệu tĩnh được sử dụng rộng rãi làm cơ chế xây dựng mô hình vì nó giúp tôi di chuyển nhanh hơn mà không phụ thuộc vào sự sẵn có của cơ sở dữ liệu thực.-->

<!--Việc hiện thực hóa kho lưu trữ yêu cầu nhà phát triển phải ánh xạ giữa đối tượng miền và cơ sở dữ liệu và ngược lại.-->

Trong bài học này, bạn đã tìm hiểu về các đối tượng kho lưu trữ mẫu kho lưu trữ làm cho mô hình miền độc lập với lớp cơ sở dữ liệu.
Các hoạt động cơ sở dữ liệu trên tổng hợp phải là nguyên tử, đối tượng kho lưu trữ và các lực lượng. Các đối tượng kho lưu trữ nguyên tử cũng có thể được sử dụng để thử nghiệm và mô phỏng đơn vị.
Có một số mối quan tâm chung liên quan đến các đối tượng kho lưu trữ, nhưng những mối quan tâm chung này liên quan đến chức năng truy vấn có thể được giải quyết bằng cách hiển thị các hàm truy vấn cấp cao trong đối tượng kho lưu trữ bằng cách sử dụng các giải pháp bộ nhớ đệm như Radice và Memcache cũng như bằng cách tạo và hiển thị các hàm truy vấn bên ngoài của đối tượng kho lưu trữ.

<!--hướng dẫn 7/11-->

<!--@ \07DomainDrivenDesignTacticalPatterns_VVN\000000012.srt-->
<!--Domain Services dịch vụ miền-->
<!--Domain Service Pattern-->
<!--Characteristics of Domain Services đặc điểm-->

<!--Một định nghĩa chính thức hơn về dịch vụ miền là đối tượng miền thực hiện chức năng hoặc khái niệm miền có thể không được mô hình hóa một cách tự nhiên như một hành vi trong bất kỳ dịch vụ miền, thực thể hoặc đối tượng giá trị nào như một phần của mô hình miền, vì có các loại dịch vụ khác nhau.-->

<!--Điều quan trọng là bạn phải hiểu các đặc điểm của dịch vụ tên miền.-->
<!--Dịch vụ miền luôn thực hiện hành vi kinh doanh cho miền.-->
<!--Dịch vụ miền không có trạng thái, dịch vụ miền có tính gắn kết cao.-->
<!--Dịch vụ miền có thể tương tác với các dịch vụ miền khác.-->
<!--Chúng ta hãy đi qua các chi tiết của từng một trong số này. Vì dịch vụ miền có hành vi kinh doanh nên đối tượng dịch vụ miền nhận thức được các đối tượng miền khác.-->

Một dịch vụ miền có thể tương tác với các dịch vụ miền khác.

Trước khi kết thúc bài học này, tôi muốn nhấn mạnh một điểm quan trọng.

Dịch vụ tên miền là bất khả tri về công nghệ. Có một quan niệm sai lầm phổ biến rằng dịch vụ của người bán hàng rong nên được coi là một hoạt động kinh doanh là không đúng.

Dịch vụ miền độc lập với công nghệ được sử dụng để gọi. Ví dụ: hoạt động dịch vụ miền, có thể chỉ là lệnh gọi hàm Java đơn giản hoặc có thể được thực hiện qua giao thức mạng như HTTP hoặc MQ.

Thông tin thêm về chủ đề này khi chúng ta tiến bộ trong suốt khóa học. Đã đến lúc bắt đầu với những điểm chính mà chúng ta đã đề cập trong bài học này.

Tôi đã nói về dịch vụ miền và bạn cần phải biết những đặc điểm của dịch vụ miền giúp phân biệt nó với các loại dịch vụ khác.
Đầu tiên là dịch vụ miền thực hiện hành vi miền không phù hợp một cách tự nhiên với các thực thể và đối tượng giá trị khác trong mô hình miền.
Các đặc điểm khác là dịch vụ miền không có trạng thái, dịch vụ miền có tính Cohasset cao và dịch vụ miền với các dịch vụ miền khác.

<!--@ \07DomainDrivenDesignTacticalPatterns_VVN\000000013.srt-->
<!--Dịch vụ ứng dụng (app sẻvice)-->

Chúng ta hãy xem lại định nghĩa về dịch vụ tên miền. Nó tuyên bố rằng dịch vụ miền là một đối tượng miền thực hiện chức năng miền.
Và vì dịch vụ danh mục khách hàng sẽ không triển khai bất kỳ chức năng miền nào nên chúng tôi không thể triển khai nó dưới dạng dịch vụ miền.
Và đây là nơi các dịch vụ ứng dụng xuất hiện. Đó là một định nghĩa chính thức hơn về một dịch vụ ứng dụng.
Nó là một đối tượng miền không triển khai bất kỳ chức năng miền nào mà phụ thuộc vào các đối tượng miền khác để hiển thị chức năng miền cấp cao cho bên ngoài của người tiêu dùng đối với mô hình.
Sự khác biệt chính giữa dịch vụ miền và dịch vụ ứng dụng là dịch vụ ứng dụng không triển khai bất kỳ loại logic nghiệp vụ hoặc chức năng miền nào.
Sự khác biệt lớn khác là dịch vụ ứng dụng được tiếp xúc với người tiêu dùng bên ngoài như ứng dụng Web, ứng dụng di động hoặc dịch vụ ứng dụng.

Chúng ta hãy đi qua các đặc điểm của một dịch vụ ứng dụng. Dịch vụ ứng dụng không có logic miền và đây là điểm khác biệt chính giữa dịch vụ ứng dụng và dịch vụ miền.
Các dịch vụ ứng dụng như dịch vụ miền đều không có trạng thái. Các dịch vụ ứng dụng có thể xác định giao diện bên ngoài, các dịch vụ ứng dụng được hiển thị hoặc một số loại giao thức mạng.

Chúng ta hãy đi qua các chi tiết của từng trong số này. Một dịch vụ ứng dụng không có logic miền. Nó phụ thuộc vào đối tượng miền khác cho logic miền.

Đây là điểm khác biệt chính giữa dịch vụ miền và dịch vụ ứng dụng. Dịch vụ ứng dụng điều phối việc thực thi logic miền.

Giống như dịch vụ miền và dịch vụ ứng dụng cũng không có trạng thái. Không có quản lý nhà nước được thực hiện trong dịch vụ ứng dụng.

Không có biến trạng thái hoặc sự tồn tại lâu dài của các đối tượng miền được triển khai trong dịch vụ ứng dụng. Dịch vụ ứng dụng phụ thuộc vào đối tượng miền để tồn tại lâu dài và dịch vụ ứng dụng hiển thị giao diện được thế giới bên ngoài sử dụng.

Nói cách khác, lược đồ yêu cầu và phản hồi cho dịch vụ ứng dụng không cần phải liên kết với bất kỳ đối tượng miền nào khác.

Dịch vụ ứng dụng hiển thị giao diện bên ngoài hoặc giao thức mạng trong mô hình miền. Dịch vụ ứng dụng có thể được coi như một đối tượng ranh giới bảo vệ tất cả các đối tượng trong mô hình miền.

Dịch vụ ứng dụng có thể được hiển thị dưới dạng API và API này được các thành phần bên ngoài sử dụng qua giao thức mạng.
Giao thức mạng này, có thể là SCDP, MQ hoặc thậm chí có thể là giao thức độc quyền. Định dạng dữ liệu giữa năng lực bên ngoài và API rất linh hoạt.
Nó có thể là Jason Ximo, CSFI hoặc bất kỳ định dạng nào khác. Tùy thuộc vào việc thực hiện dịch vụ ứng dụng.

Các thành phần bên ngoài có thể có hoặc không có kiến ​​thức về đối tượng miền hoặc cấu trúc của chúng. Tiếp theo, tôi sẽ thảo luận về mối quan hệ giữa dịch vụ ứng dụng và dịch vụ miền và dịch vụ ứng dụng có thể hiển thị dịch vụ miền với thành phần bên ngoài.

Dịch vụ miền để cung cấp giao diện cho các thành phần bên ngoài. Đã đến lúc đi vào những điểm chính trong bài học này bạn đã học về các ứng dụng, dịch vụ, ứng dụng, dịch vụ không triển khai bất kỳ hành vi miền nào.
Chúng cung cấp các dịch vụ cấp cao bằng cách phối hợp thực thi logic miền trong các đối tượng miền.
Các dịch vụ ứng dụng hiển thị giao diện cho các thành phần bên ngoài. Nghĩa là, các thành phần nằm ngoài mô hình miền thông qua giao thức mạng như HTP và NQ.

<!--@ \07DomainDrivenDesignTacticalPatterns_VVN\000000014.srt-->
<!--Dịch vụ cơ sở hạ tầng-->

là dịch vụ tương tác với tài nguyên bên ngoài để giải quyết một vấn đề mối quan tâm không thuộc phạm vi vấn đề chính.
Nó xác định một hợp đồng được các đối tượng miền sử dụng để tương tác với các dịch vụ bên ngoài. Từ khóa ở đây là nguồn lực bên ngoài.
VD:

<!--Logging system e.g., Fluentd, ElastiSearch-->
<!--Ví dụ: thông báo qua email hoặc SMS-->
<!--cơ sở dữ liệu bên ngoài hoặc thậm chí là hệ thống tệp-->
<!--Google Map.-->

Dịch vụ cơ sở hạ tầng không có logic miền.

Dịch vụ cơ sở hạ tầng tuân theo nguyên tắc trách nhiệm duy nhất

8
00:01:39,420--> 00:01:50,760

<!--Chúng ta hãy đi qua các chi tiết của từng một trong số này. Dịch vụ cơ sở hạ tầng không có logic miền vì nó cung cấp, như tên cho thấy, dịch vụ cơ sở hạ tầng chứ không phải dịch vụ kinh doanh.-->

9
00:01:50,970--> 00:02:08,000

<!--Nó không có bất kỳ sự phụ thuộc trực tiếp nào vào đối tượng miền và dịch vụ cơ sở hạ tầng được đối tượng miền và các dịch vụ sử dụng để tương tác với các tài nguyên bên ngoài và dịch vụ cơ sở hạ tầng tuân theo nguyên tắc trách nhiệm duy nhất.-->

10
00:02:08,040--> 00:02:18,640

<!--Ý tưởng là dịch vụ này cung cấp chức năng cho một và chỉ một thứ. Mục đích của họ là đơn giản hóa việc triển khai và làm cho dịch vụ trở nên dễ hiểu.-->

11
00:02:18,660--> 00:02:29,100

<!--Ví dụ: chúng tôi có ba dịch vụ này, mỗi dịch vụ chuyên cung cấp một chức năng cụ thể. Ví dụ: dịch vụ email chỉ để gửi email.-->

12
00:02:29,130--> 00:02:38,520

<!--Dịch vụ ghi nhật ký chỉ để ghi nhật ký tin nhắn và dịch vụ cơ sở dữ liệu là để tương tác với cơ sở dữ liệu và cơ sở hạ tầng.-->

13
00:02:38,520--> 00:02:52,140

<!--Dịch vụ xác định một hợp đồng tiêu chuẩn giữa mô hình và các tài nguyên bên ngoài. Hãy nghĩ về nó giống như một API, dành cho các đối tượng và dịch vụ mô hình sử dụng.-->

14
00:02:52,620--> 00:03:03,990

<!--Và nó cũng sẽ thực hiện bất kỳ loại chuyển đổi nào cần thiết trên dữ liệu. Bây giờ hãy xem cơ chế này làm cho miền độc lập hơn với tài nguyên bên ngoài như thế nào.-->
<!--Giả sử chúng ta phải triển khai một dịch vụ email. Dịch vụ e-mail này sẽ cung cấp chức năng tiêu chuẩn để gửi email.-->
<!--Ban đầu, dịch vụ e-mail được triển khai bằng cách sử dụng sendmail của Linux. Nhưng giả sử trong một khoảng thời gian, số lượng email được gửi đi từ ứng dụng tăng lên và do đó cần có một giải pháp mạnh mẽ hơn và Sendmail đã được thay thế bằng MailChimp.-->

Thay đổi này sẽ chỉ yêu cầu thay đổi trong dịch vụ email và sẽ không có tác động đến bất kỳ dịch vụ miền nào sử dụng dịch vụ email nội dung hiển thị theo hợp đồng tiêu chuẩn và do đó mô hình miền được cách ly khỏi các thay đổi tài nguyên bên ngoài.

Trong bài giảng này, bạn đã tìm hiểu về các dịch vụ cơ sở hạ tầng. Các dịch vụ cơ sở hạ tầng như dịch vụ ứng dụng không thực hiện bất kỳ hành vi miền nào.
Các dịch vụ cơ sở hạ tầng cung cấp các tài nguyên bên ngoài thông qua giao diện tiêu chuẩn hoặc hợp đồng tiêu chuẩn và cơ chế hợp đồng tiêu chuẩn này bảo vệ mô hình miền khỏi những thay đổi trong dịch vụ bên ngoài.

<!--Hướng dẫn 7/15-->
<!--Hướng dẫn 7/16-->

<!--có các mối quan hệ giữa các liên hệ được liên kết. các liên hệ được liên kết này được chuyển thành các dịch vụ vi mô và các mối quan hệ này được chuyển thành các tương tác giữa các dịch vụ vi mô.-->

<!--Các dịch vụ vi mô cũng tạo ra nhiều loại sự kiện khác nhau. Những sự kiện này được sử dụng bởi các dịch vụ vi mô khác cũng như các thành phần trong bối cảnh liên kết nơi sự kiện được tạo ra.-->

Bây giờ hãy nói về mối quan hệ giữa kiến ​​trúc điều khiển chẵn và các dịch vụ vi mô. Kiến trúc thậm chí được định hướng cũng là một mô hình kiến ​​trúc.

Thúc đẩy việc sản xuất, phát hiện, tiêu thụ và phản ứng với các sự kiện và dịch vụ vi mô là những nhà sản xuất và tiêu dùng tự nhiên.

Do đó, kiến ​​trúc điều khiển đồng đều thường được sử dụng để xây dựng các ứng dụng có dịch vụ vi mô.

Các sự kiện có bản chất không đồng bộ và việc thực hiện các tương tác dựa trên sự kiện đòi hỏi phải sử dụng một số công nghệ nhắn tin.

Có nhiều công nghệ nhắn tin có sẵn cho mục đích này. Trong phần này bạn sẽ thấy cách sử dụng Rabbitt.

MQ COFCO cũng rất phổ biến và bạn sẽ thấy cách sử dụng Kafka ở phần sau. Chúng ta hãy xem qua các mục tiêu học tập trong phần bạn sẽ tìm hiểu về các dịch vụ vi mô, các kiểu giao tiếp, kiến ​​trúc hướng sự kiện.

Bạn tìm hiểu về các loại sự kiện dịch vụ vi mô khác nhau. Tôi sẽ cung cấp cho bạn cái nhìn tổng quan về khái niệm AQAP liên quan đến việc triển khai cơ bản các sự kiện và bạn cũng sẽ thấy các sự kiện mô hình bán hàng đang hoạt động bằng cách sử dụng Java và Rabbit MQ.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000002.srt-->

Các mẫu giao tiếp cơ bản, đến cuối bài giảng này, bạn sẽ có thể giải thích các mẫu giao tiếp Đồng bộ và không đồng bộ phổ biến.

Bạn sẽ có thể mô tả sự khác biệt giữa một máy thu và nhiều máy thu. Và ở cuối bài học này, tôi cũng sẽ đưa ra một số ví dụ công nghệ để hiện thực hóa các mẫu mà tôi sẽ thảo luận trong bài giảng này.

Mẫu đầu tiên là mẫu giao tiếp đối tượng nguyên khối trong đó đối tượng gọi là các phương thức trên các đối tượng khác.

Vì vậy, trong ví dụ này, một ứng dụng ngân hàng đang gọi các phương thức trên các đối tượng khác và các phương thức đó đang dẫn đến các cuộc gọi, các hàm trên các đối tượng khác.

Bây giờ, tất cả những điều này đang diễn ra trong một không gian bộ nhớ chung của một quy trình chung. Đây là điển hình của một ứng dụng nguyên khối và đó là lý do tôi gọi nó là mẫu giao tiếp đối tượng nguyên khối.

Trong trường hợp các ứng dụng hoặc hệ thống phân tán, các thành phần nằm trong không gian xử lý riêng của chúng.

Nói cách khác, không có sự chia sẻ tài nguyên điện toán hoặc bộ nhớ giữa các thành phần. Các thành phần này giao tiếp với nhau bằng một loại giao thức mạng nào đó.

Giao thức truyền thông mạng này có thể có tính chất đồng bộ hoặc không đồng bộ? Theo tính đồng bộ, điều đó có nghĩa là người gọi vẫn bị chặn cho đến khi nhận được phản hồi từ thành phần khác.

Ví dụ về các giao thức truyền thông đồng bộ là SCDP và bất kỳ loại thủ tục từ xa độc quyền nào được gọi là cơ chế.

Bởi không đồng bộ, điều đó có nghĩa là người gọi không chờ phản hồi. Ví dụ về giao tiếp không đồng bộ là một số loại giao thức nhắn tin, chẳng hạn như M Cupie, viết tắt của giao thức tin nhắn nâng cao.

Nếu bạn muốn biết thêm về M cupie, chỉ cần truy cập và cupie dot org. Và đó cũng là một bài viết hay về AM Cupie trên Wikipedia.

Một điều quan trọng cần ghi nhớ là việc sử dụng các giao thức mạng đồng bộ và không đồng bộ không loại trừ lẫn nhau.

Điều đó có nghĩa là trong các hệ thống phân tán, có thể có một số giao tiếp sử dụng các giao thức mạng đồng bộ như HTP và có thể có các thành phần khác đang giao tiếp qua các giao thức không đồng bộ như M Cupie.

Việc sử dụng các giao thức Đồng bộ và không đồng bộ tùy thuộc vào trường hợp sử dụng và yêu cầu. Giao tiếp có thể là giữa hai điểm cuối.

Điều này được gọi là giao tiếp một-một, còn được gọi là giao tiếp một người nhận. Ví dụ phổ biến là HTP, trong đó giao tiếp giữa hai điểm cuối.

Đây là một ví dụ. Ứng dụng ngân hàng gọi API trên thành phần khách hàng qua HTP. Bây giờ lệnh gọi này sẽ độc lập với lệnh gọi DEPI bổ sung.

Ứng dụng ngân hàng sẽ tạo thành phần tài khoản. Nhưng giao thức không đồng bộ như SCDP, bạn sẽ luôn có giao tiếp 1-1, giao tiếp 1-1.

Parathion cũng có thể được thực hiện bằng cách sử dụng cơ chế nhắn tin không đồng bộ. Hãy để tôi giải thích cách thức hoạt động của nó.

Giả sử ứng dụng ngân hàng có API Invoker trong thành phần tài khoản và API này đang sử dụng giao thức nhắn tin.

Trong trường hợp đó, ứng dụng ngân hàng có thể đưa một tin nhắn vào hàng đợi. Thông báo này đại diện cho thông báo yêu cầu.

Thành phần tài khoản có thể đọc bộ xử lý tin nhắn này, tạo tin nhắn phản hồi và đưa nó vào hàng đợi.

Sau đó, ứng dụng ngân hàng có thể đọc tin nhắn dưới dạng phản hồi cho yêu cầu của nó. Vì vậy, kịch bản này trông giống như một mẫu phản hồi yêu cầu đồng bộ.

Nhưng giao thức cơ bản không đồng bộ theo kiểu giao tiếp một đến nhiều. Có nhiều thành phần quan tâm đến việc nhận tin nhắn từ người gửi.

Điều này thường đạt được bằng cách bật lên mẫu tin nhắn. Hãy để tôi giải thích điều này bằng một ví dụ. Giả sử có một thành phần tài khoản đảm nhiệm việc thiết lập tài khoản mới cho khách hàng của ngân hàng.

Và sau đó có những thành phần khác quan tâm đến việc nhận thông báo. Khi một tài khoản khách hàng mới được thiết lập để thực hiện mẫu này, một chủ đề sẽ được thiết lập trên hệ thống nhắn tin.

Thành phần tài khoản sẽ xuất bản một thông báo về chủ đề này mỗi khi tài khoản mới được tạo. Các thành phần khác này sẽ đăng ký chủ đề chung này và nhận tin nhắn khi nhận được tin nhắn.

Mỗi thành phần này. Sẽ thực hiện một nhiệm vụ cụ thể được giao cho nó. Vì vậy, ví dụ, thành phần e-mail sẽ gửi e-mail cho khách hàng.

Thành phần nhóm đặt hàng sẽ đặt mua thẻ ATM và bảng thông tin người thực hiện cập nhật sẽ cập nhật số lượng tài khoản trên bảng thông tin người thực hiện.

Tiếp theo, tôi sẽ đề cập đến một số công nghệ mẫu có thể được sử dụng để hiện thực hóa các kiểu giao tiếp này.

GDP là một cách phổ biến mà Microsoft sử dụng để hiển thị các ứng dụng. Có nhiều khung cho các ngôn ngữ khác nhau có thể được sử dụng để xây dựng các ứng dụng nhắn tin này.

Có 2 loại sản phẩm, sản phẩm tuân thủ MQ là MQ hoạt động và MQ Rabbitt. Và sau đó có những sản phẩm được biết là tuân thủ, chẳng hạn như Kafka, Amazon Skier's, Amazon S.A..

Xin lưu ý rằng đây chỉ là một số ví dụ. Trên thực tế, còn có nhiều sản phẩm và khuôn khổ khác có thể được sử dụng cho các kiểu giao tiếp khác nhau này.

Bạn sẽ thấy một số công nghệ này hoạt động trong các bài giảng sau của khóa học này. Đã đến lúc xem xét nhanh.

Trong bài học này, tôi đã đề cập đến các mẫu giao tiếp cơ bản. Các mẫu đồng bộ là những mẫu trong đó người gọi gửi yêu cầu và chờ phản hồi quay trở lại như một ví dụ thực sự về mẫu giao tiếp đồng bộ.

Trong trường hợp kiểu liên lạc không đồng bộ, người gọi sẽ gửi tin nhắn và không đợi phản hồi mà tiếp tục thực hiện quá trình xử lý.

Tức là nó không bị chặn. Các nền tảng nhắn tin như Kafka, Rabbit, MQ và Active Amcu thường được sử dụng để xây dựng các mẫu giao tiếp không đồng bộ.

Cửa sổ bật lên thường được sử dụng khi có nhiều người nhận tin nhắn. Trong bài giảng tiếp theo, bạn sẽ tìm hiểu cách các dịch vụ vi mô sử dụng các mẫu này.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000003.srt-->

Microsoft cho biết các tương tác trong bài giảng này, tôi sẽ đề cập đến các mô hình giao tiếp trong Microsoft Office giữa Microsoft ISS và giữa Dịch vụ của Microsoft và các dịch vụ bên ngoài, các dịch vụ vi mô và Giao tiếp của Crossover đề cập đến các lệnh gọi chức năng được thực hiện giữa các thành phần trong cùng một bối cảnh liên kết.

Ý tưởng là một văn phòng Microsoft được triển khai trong một đơn vị triển khai duy nhất. Điều đó có nghĩa là các thành phần trong thời gian chạy trong Microsoft được chia sẻ một không gian xử lý chung.

Tất cả các tương tác xảy ra bằng cách gọi hàm trực tiếp. Đôi khi, Microsoft cho biết, các nhà thiết kế quyết định thay thế các lệnh gọi hàm này bằng một số giao thức mạng, chẳng hạn như API qua HDB hoặc các tín hiệu và chủ đề nhắn tin.

Quyết định này được đưa ra nhằm đạt được mức độ tách rời cao và khả năng mở rộng trong tương lai. Nói cách khác, giả sử nếu bạn có một thành phần trong dịch vụ vi mô mà bạn dự kiến ​​sẽ chuyển ra khỏi Microsoft Office sau này thì bạn có thể triển khai các tương tác với thành phần đó bằng giao thức mạng.

Ý tưởng là khi dịch vụ này bị rút khỏi Microsoft Office, sẽ không có yêu cầu thay đổi mã trong các thành phần cổ áo.

Nhược điểm của việc thay thế các lệnh gọi hàm trực tiếp này bằng các giao thức mạng là sẽ có một số mức chi phí mạng mà bạn sẽ phải giải quyết.

Vì vậy, đó là cái giá bạn sẽ phải trả. Giao tiếp giữa các dịch vụ ở đây đề cập đến giao tiếp giữa các dịch vụ vi mô khác nhau hoặc giữa các địa chỉ liên hệ được liên kết khác nhau, bạn sẽ luôn sử dụng các giao thức mạng để thực hiện các loại giao tiếp này.

Hãy nhớ rằng việc sử dụng tính năng nhắn tin hoặc HTP sẽ tùy thuộc vào trường hợp sử dụng và các yêu cầu khác. Quyết định sẽ dựa trên việc giao tiếp được yêu cầu đồng bộ hay không đồng bộ hay bạn đang muốn phân phối tin nhắn đến nhiều người nhận hay chỉ có một người nhận tin nhắn.

Vì vậy, trong trường hợp Synchronoss, bạn sẽ luôn sử dụng giao thức mạng đồng bộ như Resto hoặc HTP.

Trong trường hợp có nhiều bộ thu, bạn sẽ luôn sử dụng kiểu mẫu bật lên. Tiếp theo, tương tác các dịch vụ bên ngoài của Alcoa.

Việc các dịch vụ vi mô giao tiếp với các dịch vụ bên ngoài là điều bình thường. Giao thức mạng và định dạng của tin nhắn được sử dụng bởi các dịch vụ bên ngoài này nằm ngoài tầm kiểm soát của Nhóm Phát triển Dịch vụ Vi mô.

Do đó, Nhóm phát triển dịch vụ vi mô cần tuân thủ các yêu cầu về giao diện và giao thức mạng của các dịch vụ bên ngoài này.

Ví dụ: có thể có một cổng thanh toán hiển thị giao diện của nó bằng HTP, một dịch vụ ghi nhật ký hiển thị giao diện của nó bằng cách nhắn tin và sau đó các cơ sở dữ liệu thường được sử dụng có giao thức mạng độc quyền dựa trên TCP IP của riêng chúng.

Từ góc độ dịch vụ vi mô, chi tiết về giao thức mạng và định dạng nhắn tin này sẽ được gói gọn trong các dịch vụ cơ sở hạ tầng.

Như đã thảo luận trước đó, các dịch vụ cơ sở hạ tầng này sẽ chịu trách nhiệm giữ phần còn lại của mã dịch vụ vi mô độc lập với Giao thức dịch vụ bên ngoài cũng như các định dạng tin nhắn.

Đối với Giao tiếp giữa các dịch vụ trong Dịch vụ vi mô, nhà phát triển dịch vụ vi mô cần quyết định cấu trúc của thông báo yêu cầu và phản hồi, đồng thời họ cũng cần quyết định về định dạng.

Thông thường, một dịch vụ vi mô hiển thị giao diện sẽ sử dụng các đối tượng mô hình để xác định cấu trúc của thông báo yêu cầu và phản hồi từ phối cảnh chuyển tiếp.

Jason là một hình thức phổ biến. Nhưng xin lưu ý rằng các định dạng khác, chẳng hạn như XML và CSFI cũng được sử dụng ở định dạng không phổ biến khác như định dạng bộ đệm giao thức.

Kết hợp với giao thức giao thức PC. Baphomet là một cơ chế tuần tự hóa có hiệu suất cao được phát triển bởi Google.

Nếu bạn muốn tìm hiểu thêm về nó, vui lòng xem liên kết tại đây. Hãy nhớ rằng bộ đệm giao thức và cơ chế giao tiếp dựa trên quyền riêng tư của bạn phù hợp với các giao diện dịch vụ vi mô yêu cầu hiệu suất và thông lượng cao.

Bây giờ là lúc dành cho câu đố, giả sử có hai bộ Microsoft, A và B, cần tương tác với nhau.

Hai dịch vụ vi mô này được quản lý bởi hai nhóm độc lập và mỗi nhóm này phát triển mô hình riêng cho A và B.

Kết quả là không có mối quan hệ nào giữa A và mô hình kinh doanh. Vì vậy, một câu hỏi khác dành cho bạn là nên sử dụng mô hình nào để liên lạc giữa A và B?

Câu trả lời là tùy thuộc vào cách bạn muốn quản lý sự phụ thuộc giữa A và B.

Việc quản lý phụ thuộc cho các dịch vụ vi mô này được thực hiện theo các ranh giới, bối cảnh, mô hình tích hợp được xác định rõ ràng.

Tôi đã đề cập đến các mô hình tích hợp này trong các bài giảng trước và nếu bạn quên nó, tôi khuyên bạn nên xem lại các video đó.

Tôi sẽ trình bày các mô hình tích hợp này trong một bản tóm tắt ngắn gọn. Tiếp theo, mẫu tích hợp ngữ cảnh liên kết đầu tiên để quản lý phần phụ thuộc là mẫu hạt nhân dùng chung.

Trong đó, một bộ quy tắc đạo đức và quy tắc chung dành cho các bác sĩ vi phẫu được chia sẻ giữa các vi mạch. Vì vậy, trước tiên trong chủ đề ví dụ này của Microsoft, nó chịu trách nhiệm tạo và quản lý hạt nhân dùng chung, được cả A và B sử dụng, mặc dù phần hạt nhân dùng chung trên cũng có thể được triển khai dưới dạng SDK hoặc thư viện, nhưng tốt hơn là nên sử dụng nó. sử dụng giao thức mạng như được mô tả trong hình minh họa này.

Phần thứ hai là mô hình nhà cung cấp khách hàng. Trong kiểu tích hợp này, nhà cung cấp hoặc nhà cung cấp giao diện chỉ định dạng giao diện và giao thức mạng theo nhu cầu của khách hàng.

Vì vậy, mặc dù nhà cung cấp có thể có mô hình khác cho một số thực thể thông thường, họ sẽ chịu trách nhiệm điều chỉnh định dạng của thông báo ngoài mô-đun của khách hàng.

Tiếp theo là mẫu tuân thủ, như tên gợi ý trong mẫu này. Thứ nhất, Microsoft tuân thủ mô hình được xác định trong một dịch vụ vi mô khác.

Vì vậy, ở đây trong ví dụ này, thời gian dành cho Microsoft là a đã quyết định áp dụng các mô hình do Dean xác định cho B của Microsoft, nhưng có một số thách thức nhất định với mô hình này và những thách thức mà bất cứ khi nào có sự thay đổi trong mô hình đối với Microsoft là B, chúng sẽ sẽ có tác động đến Microsoft A và nhóm Microsoft là A sẽ cần điều chỉnh để giảm thiểu tác động đó.

Nhóm của Microsoft có thể áp dụng mô hình lớp chống tham nhũng trong việc này. Họ có thể tạo một lớp tách biệt tất cả mã dịch từ các mô hình từ B sang nó và ngược lại.

Ưu điểm của việc sử dụng mẫu lớp chống tham nhũng là những thay đổi trong mô hình của B sẽ không ảnh hưởng đến việc triển khai cốt lõi của Microsoft Office và mọi thay đổi cần thiết sẽ được tách biệt với lớp chống tham nhũng.

Chúng ta hãy điểm qua những điểm chính từ bài học này để xây dựng các tương tác trong bối cảnh liên kết hoặc một hoặc dịch vụ là giao tiếp giữa các dịch vụ, bạn có thể sử dụng chức năng gọi là API và nhắn tin trong trường hợp các dịch vụ bên ngoài, Microsoft, điều này phụ thuộc vào giao diện dịch vụ bên ngoài và giao thức mạng.

Với tư cách là nhà thiết kế hoặc các dịch vụ vi mô, bạn sẽ sử dụng các dịch vụ cơ sở hạ tầng để ánh xạ các giao diện do dịch vụ bên ngoài cung cấp nhằm thực hiện giao tiếp giữa các dịch vụ vi mô.

Đó là, giao tiếp dịch vụ. Bạn sẽ luôn sử dụng các ứng dụng và nhắn tin. Điều quan trọng nhất cần ghi nhớ là bạn cần đưa ra quyết định về việc quản lý sự phụ thuộc giữa các dịch vụ vi mô bằng cách sử dụng các mẫu tích hợp ngữ cảnh giới hạn.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000004.srt-->

Kiến trúc được định hướng chẵn cung cấp nền tảng để thiết kế các tương tác dịch vụ vi mô trong bài giảng này, bạn tìm hiểu về các sự kiện, bạn tìm hiểu về kiến ​​trúc được định hướng chẵn và tôi sẽ so sánh những quả táo với kiến ​​trúc thậm chí có liên quan.

Tôi sẽ bắt đầu bài học này bằng cách thảo luận về một tình huống mua sắm trực tuyến phổ biến. Khách hàng thanh toán sản phẩm trong giỏ hàng.

Tại thời điểm đó, các hành động khác nhau được thực hiện. Một email được gửi đến khách hàng thông báo xác nhận đơn hàng.

Bộ phận vận chuyển xuất đơn hàng, đồng thời hệ thống kho hàng cập nhật số lượng sản phẩm có trong kho.

Vì vậy, việc khách hàng thanh toán này được nhiều hệ thống con trong hệ thống mua sắm trực tuyến quan tâm. Có một điều đáng quan tâm, đó là việc khách hàng trả phòng được coi là một sự kiện.

Và tất cả các hệ thống con quan tâm đến việc nhận thông báo về sự kiện này đều được gọi là sự kiện của người tiêu dùng xảy ra một cách tự nhiên trong mọi tình huống kinh doanh.

Hãy để tôi cung cấp cho bạn một định nghĩa chính thức hơn về các sự kiện. Sự kiện là dấu hiệu cho thấy điều gì đó có ý nghĩa đã xảy ra tại một thời điểm so với điều gì đó đã xảy ra trong quá khứ.

Có những người tiêu dùng muốn biết về các sự kiện nên muốn được thông báo.

Vì vậy, khi một sự kiện xảy ra, một hoặc nhiều người tiêu dùng sẽ được thông báo về sự kiện này. Khi nhận được sự kiện.

Quá trình xử lý Consumer Macario và xử lý sự kiện độc lập với người tạo sự kiện và những người tiêu dùng khác của sự kiện.

Và kiến ​​trúc điều khiển chẵn là một mô hình kiến ​​trúc phần mềm nhằm thúc đẩy việc thiết kế các hệ thống như một tập hợp các thành phần đồng lỏng lẻo đóng vai trò đồng đều như nhà sản xuất và thậm chí cả người tiêu dùng.

Trọng tâm của kiến ​​trúc hướng sự kiện là xương sống sự kiện, giờ đây xương sống của sự kiện này là một thành phần cơ sở hạ tầng.

Bạn có thể nghĩ về nó như một thành phần vật chất. Nó được gọi bằng nhiều tên, thậm chí Busse, thậm chí Broca, thậm chí cả sự kiện Serota, trung tâm sự kiện hòa giải.

Đây là một số thuật ngữ phổ biến được sử dụng cho thành phần này. Tên gọi phụ thuộc vào tính năng, chức năng của sản phẩm và nhà cung cấp tiếp thị các sản phẩm này.

Tôi khuyên bạn nên thực hiện nghiên cứu của riêng mình trên Google. Bạn sẽ tìm thấy rất nhiều thông tin. Điều quan trọng cần ghi nhớ là về mặt khái niệm chúng giống nhau.

Tất cả đều cung cấp một cách để định tuyến các sự kiện, từ nhà sản xuất đến người tiêu dùng. Các nhà sản xuất sự kiện sẽ thông báo cho người đứng đầu sự kiện về điều gì đó đáng quan tâm đang xảy ra.

Và họ thực hiện điều này bằng cơ chế đồng bộ được cung cấp bởi các sự kiện, đường trục và đường trục sự kiện nhận sự kiện.

Nó chỉ ra nơi thậm chí cần được định tuyến, tùy thuộc vào người tiêu dùng quan tâm đến sự kiện đó.

Vì vậy, ví dụ: sự kiện sẽ được triển khai cho những người tiêu dùng đã đăng ký tham gia sự kiện. Sự kiện tương tự.

Chúng tôi sẽ được chuyển đến những người tiêu dùng đã đăng ký. Và điều tương tự cũng xảy ra với các sự kiện khác.

Điều quan trọng cần ghi nhớ ở đây, từ góc độ bình đẳng của người tiêu dùng, là họ không rơi vào những sự kiện này.

Họ nhận được thông báo. Chúng ta hãy xem một ví dụ cụ thể về kiến ​​trúc điều khiển chẵn. Giả sử rằng Kafka đang được sử dụng để định tuyến đồng đều, hãy nhớ lại ví dụ về một ngân hàng khi tài khoản ngân hàng mới được tạo, có nhiều thành phần nhận được thông báo và tiến hành xử lý.

Vì vậy, trong kịch bản này, ba thành phần này sẽ đăng ký Kafka cho các sự kiện liên quan đến việc tạo tài khoản mới.

Khi một tài khoản mới được tạo trong thành phần tài khoản, nó sẽ kết nối với Kafka và xuất bản một thông báo tới chủ đề tài khoản mới.

Khi đó Kafka sẽ thông báo cho tất cả những người đăng ký này về sự kiện tài khoản mới. Bây giờ, nếu bạn đang nghĩ rằng kiểu nhắn tin này giống với kiểu nhắn tin phổ biến thì bạn đã đúng.

Bật lên. Mẫu tin nhắn thường được sử dụng để hiện thực hóa các kiến ​​trúc điều khiển chẵn. Tiếp theo, hãy nói về dữ liệu trong thông báo sự kiện, nội dung của thông báo, có thể là dữ liệu trạng thái hoặc siêu dữ liệu.

Trong trường hợp ví dụ về tài khoản ngân hàng mới, dữ liệu trạng thái sẽ là tất cả thông tin liên quan đến tài khoản mới.

Vì vậy, người tiêu dùng nhận được thông báo đại diện cho sự kiện sẽ nhận được tất cả dữ liệu trạng thái liên quan và họ có thể tiến hành xử lý bằng cách sử dụng dữ liệu trạng thái mà họ sẽ nhận được trong thông báo sự kiện.

Cũng có thể thiết kế cấu trúc sự kiện sao cho nó chỉ chứa siêu dữ liệu. Trong trường hợp ví dụ về tài khoản ngân hàng, nó có thể chỉ có số tài khoản của tài khoản mới.

Người tiêu dùng sẽ nhận được siêu dữ liệu này và một số người tiêu dùng có thể cần thông tin chi tiết về tài khoản có thể phải liên hệ với nhà sản xuất để lấy tất cả dữ liệu cần thiết cho quá trình xử lý của họ.

Bạn sẽ sử dụng cả dữ liệu trạng thái và siêu dữ liệu trong mình, thậm chí cả tin nhắn. Không có quy tắc cứng nhắc và nhanh chóng, nhưng có những cân nhắc nhất định.

Nếu kích thước phương thức quá lớn thì có thể có những thách thức liên quan đến độ trễ. Vì vậy, trong trường hợp đó, bạn có thể cân nhắc chỉ sử dụng siêu dữ liệu trong tin nhắn của mình.

Nếu người tiêu dùng đang dẫn đến nhiều cuộc trò chuyện trong ứng dụng của bạn vì họ đang liên hệ với nhà sản xuất để lấy dữ liệu trạng thái, thì có lẽ bạn nên xem qua dữ liệu trạng thái trong thông báo sự kiện.

Tiếp theo, tôi sẽ thảo luận về API so với kiến ​​trúc được điều khiển đồng đều. API là các lệnh được định hướng, trong khi các sự kiện là có thể quan sát được.

Chủ đề trung tâm trong kiến ​​trúc phụ thuộc vào EPA là bộ điều phối và bộ điều phối có thể được coi là một thành phần tập trung chứa logic nghiệp vụ và các quyết định sàn.

Khi người điều phối cần thực hiện điều gì đó, nó sẽ gọi một API, đối với phản hồi yêu cầu người khác, dường như sẽ thực hiện quá trình xử lý nghiệp vụ cần thiết.

Trong trường hợp của Edir, người điều phối được thay thế bằng nhà sản xuất chẵn và thậm chí cả người tiêu dùng. Những người này, thậm chí cả người tiêu dùng, là những người quan sát các sự kiện do nhà sản xuất sự kiện tạo ra.

Một điểm khác biệt lớn giữa hai kiến ​​trúc này là các nhà sản xuất và thậm chí cả người tiêu dùng đều có logic kinh doanh và chịu trách nhiệm đạt được kết quả mong muốn từ quy trình kinh doanh.

Nhà sản xuất chẵn không thực hiện lệnh gọi trực tiếp trên bất kỳ thành phần nào. Đúng hơn, nó chỉ đơn giản kích hoạt một sự kiện, một thông điệp được chuyển đến tất cả người tiêu dùng.

Hãy nhớ rằng ngay cả nhà sản xuất cũng có thể là người tiêu dùng và thậm chí người tiêu dùng cũng có thể là nhà sản xuất.

Chúng ta hãy nói về sự khác biệt giữa APA và kiến ​​​​trúc được điều khiển, trong trường hợp vượn, người gọi có kiến ​​thức về điểm cuối API, trong khi trong trường hợp nhà sản xuất thậm chí không biết bất kỳ API tiêu dùng nào là đồng bộ, nghĩa là người gọi có để chờ phản hồi trở lại.

Người gọi bị chặn, trong khi trong trường hợp có sự kiện, nhà sản xuất chỉ là sự kiện của Emmet và tiếp tục.

Bây giờ, nó thậm chí không phụ thuộc vào sự sẵn có của người tiêu dùng. Vì vậy, điều đó có nghĩa là nó có thể dẫn đến tính sẵn sàng cao hơn trong trường hợp người tiêu dùng không có mặt.

Nhà sản xuất tiếp tục và khi người tiêu dùng đến, họ sẽ nhận được, dữ liệu xuất hiện dựa trên mô hình phản hồi yêu cầu.

Trong khi đó, trong trường hợp sự kiện, thông báo bao gồm dữ liệu sự kiện, có thể là dữ liệu trạng thái hoặc siêu dữ liệu trong trường hợp API, ngay cả với kiến ​​trúc phân tán.

Có mức độ kết nối tương đối cao giữa trình gọi API và điểm cuối API, trong khi đó trong trường hợp xảy ra sự kiện, các nhà sản xuất chẵn và người tiêu dùng chẵn có khả năng tách rời cao và bản thân kiến ​​trúc có thể mở rộng.

Và lý do là bạn có thể thêm hoặc bớt người tiêu dùng mà không ảnh hưởng đến nhà sản xuất dưới bất kỳ hình thức nào. Thông thường với API, logic nghiệp vụ được tập trung hóa, trong khi đó trong trường hợp có sự kiện, logic nghiệp vụ có thể được trải rộng trên nhiều thành phần.

Và mỗi thành phần này, nhà sản xuất và người tiêu dùng, đều có quyền tự chủ đưa ra quyết định kinh doanh với các thành phần tương tự của họ.

Có thể dễ dàng hiểu được lỗ hổng vì logic nghiệp vụ được tập trung hóa, nhưng ngay cả kiến ​​trúc được điều khiển, việc tuân theo logic nghiệp vụ cũng tương đối khó.

Đã đến lúc làm một bài kiểm tra nhanh. Bạn sẽ sử dụng kiến ​​trúc nào cho các dịch vụ vi mô của mình? Câu trả lời là EDI được ưu tiên cho các dịch vụ vi mô, nhưng bạn có thể sử dụng cả ứng dụng và sự kiện trong các dịch vụ vi mô của mình và quyết định sẽ tùy thuộc vào trường hợp sử dụng cũng như các yêu cầu cụ thể của bạn.

Những điểm chính trong bài học này cho thấy một điều gì đó quan trọng đã xảy ra. Kiến trúc điều khiển chẵn là một mô hình kiến ​​trúc phần mềm dựa trên bản chất của kiến ​​trúc chẵn.

Edir sử dụng giao tiếp không đồng bộ giữa nhà sản xuất và người tiêu dùng. EDI có khả năng tách rời và mở rộng cao, logic kinh doanh và quy trình kinh doanh trong trường hợp của Edir được phân cấp.

Điều đó có nghĩa là tất cả các thành phần trong hệ thống đều có logic nghiệp vụ nhất định có thể được quản lý độc lập với các thành phần khác trong hệ thống.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000005.srt-->

Trong giờ giảng này, hãy trình diễn mô hình đăng ký công khai bằng cách sử dụng thỏ MQ. Tôi sẽ bắt đầu bài giảng này bằng cách thảo luận về khái niệm AQAP cơ bản.

Sau đó, chúng tôi sẽ tạo một phiên bản thỏ và tiêu diệt Broecker miễn phí trên AQAP dot com. Sau đó, chúng ta sẽ sử dụng rabbit mq UI để thiết lập các thành phần trên Rabbit MQ để thực hiện đăng ký công khai.

Xin lưu ý rằng bài giảng này sẽ không dạy cho bạn con thỏ MQ. Mục đích của tôi là cung cấp cho bạn cái nhìn tổng quan ở mức độ cao về các khái niệm thiết yếu.

Các khái niệm mà tôi đang trình bày trong bài giảng này được trình bày chi tiết tại liên kết này. Nếu bạn muốn tìm hiểu thêm về nó, MQ hoặc M Cupie, tôi thực sự khuyên bạn nên xem qua nội dung có sẵn tại liên kết này.

Sau khi xem bài giảng này, tôi sẽ bắt đầu bài giảng này với một số thuật ngữ cơ bản mà tôi đã trình bày trước đó.

Và nhà môi giới tin nhắn AM Cupie nhận được tin nhắn từ nhà xuất bản và họ đã viết những tin nhắn này cho người tiêu dùng.

Rabbitt Amcu là một triển khai của Giao thức Amcu, là giao thức mạng. Nói cách khác, nó cho phép nhà xuất bản và người tiêu dùng kết nối với nhà môi giới tin nhắn qua mạng.

Amcu có thể lập trình được. Điều đó có nghĩa là các nhà phát triển đưa ra quyết định định tuyến trong phần mềm trung gian nhắn tin trước đó như IBM.

Quản trị viên Amcu kiểm soát thiết lập định tuyến và các nhà phát triển có rất ít hoặc không kiểm soát được các quyết định định tuyến đó.

Tính linh hoạt trong việc đưa ra quyết định định tuyến này giúp các nhà phát triển có nhiều tự do hơn nhưng cũng làm tăng nguy cơ xung đột.

Tính linh hoạt trong việc kiểm soát định tuyến này đạt được nhờ một thành phần được gọi là trao đổi. Exchange có logic định tuyến.

Hãy tìm hiểu sâu hơn về cách Exchange Work Exchange hiển thị API cho người tiêu dùng và người tiêu dùng nhà xuất bản tạo hàng đợi tạm thời hoặc hàng đợi vĩnh viễn thông qua API của nhà môi giới hoặc bằng cách sử dụng giao diện người dùng của nhà môi giới.

Tên được đặt cho hàng đợi cố định, trong khi hàng đợi tạm thời được tạo bởi nhà môi giới. Sau đó, người tiêu dùng liên kết hàng đợi với các quy tắc ràng buộc với sàn giao dịch.

Khóa ràng buộc được cung cấp như một phần của quá trình ràng buộc này. Nhà xuất bản có thể xuất bản thông báo bằng cách sử dụng API do sàn giao dịch cung cấp.

Là một phần của API đã xuất bản, nhà xuất bản phải cung cấp dữ liệu thông báo chính định tuyến và siêu dữ liệu.

Sàn giao dịch sử dụng khóa liên kết, khóa định tuyến và siêu dữ liệu để đưa ra quyết định định tuyến.

Tin nhắn được xuất bản sẽ nằm trong hàng đợi của người tiêu dùng. Tùy thuộc vào logic định tuyến, nhiều người tiêu dùng có thể liên kết với một trao đổi duy nhất.

Tương tự, nhiều nhà xuất bản có thể xuất bản thông qua một cuộc trao đổi duy nhất. Có bốn loại trao đổi.

Mỗi loại trao đổi này cung cấp một logic định tuyến khác nhau. Loại đầu tiên là trao đổi trực tiếp và logic trong phương pháp này khá đơn giản.

Các tin nhắn nhận được từ nhà xuất bản đến hàng đợi có cùng khóa liên kết với khóa định tuyến do nhà xuất bản cung cấp.

Việc trao đổi trực tiếp chỉ tốt cho một lần xử lý. Nói cách khác, bạn có thể có nhiều hàng đợi được liên kết với cùng một khóa liên kết nhưng thông báo sẽ chỉ được thay đổi thành một trong các Q để bạn có thể phân phối khối lượng công việc cho nhiều nhân viên trên các hàng đợi khác nhau.

Và loại trao đổi trực tiếp sẽ sử dụng Round-Robin để phân phối tải trên nhiều hàng đợi với cùng một khóa liên kết.

Lần sau là lần trao đổi cuối cùng. Việc trao đổi fadeout bỏ qua định tuyến và khóa liên kết. Điều đó có nghĩa là khi nhà xuất bản xuất bản một tin nhắn đến sàn giao dịch cuối cùng, việc định tuyến sẽ bị bỏ qua và tin nhắn sẽ được phát đến tất cả các hàng đợi được liên kết với sàn giao dịch đó.

Loại tiếp theo là trao đổi sử dụng dữ liệu tiêu đề thư để định tuyến. Người tiêu dùng có thể liên kết hàng đợi với loại trao đổi này bằng cách chỉ định lộ trình phù hợp cho dữ liệu trong tiêu đề.

Tiếp theo là phần trao đổi chủ đề. Trao đổi chủ đề sử dụng khớp mẫu cho khóa định tuyến. Ý tưởng là người tiêu dùng phải chỉ định mẫu định tuyến trong khóa liên kết cho bị cáo.

Khi nhà xuất bản xuất bản một tin nhắn có khóa định tuyến. Khóa định tuyến được so sánh với khóa liên kết, đó là khóa.

Giữ mẫu cho tất cả các hàng đợi được liên kết với trao đổi, tin nhắn sẽ được gửi đến tất cả các hàng đợi mà mẫu định tuyến khớp với khóa định tuyến được chỉ định trong tin nhắn đã xuất bản.

Ví dụ về mẫu định tuyến là nơi khóa liên kết được đặt thành khóa định tuyến. Vì vậy, người tiêu dùng trong trường hợp này đang tìm kiếm sự kết hợp trực tiếp.

Bước đầu tiên, chúng ta cần tạo một phiên bản của Broca, vì vậy hãy truy cập cloud MQ dot com, nhấp vào đăng ký, làm theo hướng dẫn để tạo tài khoản trên cloud và cupie dot com.

Khi bạn đã tạo xong tài khoản, hãy nhấp vào đăng nhập. Và như bạn có thể thấy ở đây, tôi đã tạo một phiên bản của nhà môi giới để tạo tức thì mới.

Bạn có thể nhấp vào tạo phiên bản mới. Ở đây bạn cần phải cung cấp một tên. Hãy gọi cho nhà môi giới Acme Travel.

Đảm bảo rằng bạn đã chọn gói miễn phí. Như bạn có thể thấy, có những kế hoạch khác sẽ khiến bạn tốn rất nhiều tiền.

Vì vậy chỉ cần chọn Ba tầng rồi chọn khu vực. Tôi sẽ đi cùng chúng tôi bằng một cú nhấp chuột vào đánh giá. Và tại thời điểm này, bạn đã sẵn sàng tạo ngay lập tức việc tạo phiên bản có thể mất vài phút.

Để biết thông tin chi tiết về phiên bản này, hãy nhấp vào tên tức thì và nghe điều quan trọng tôi muốn cho bạn xem là MQ Eurail mà chúng tôi sẽ sử dụng trong bài giảng sau để tương tác với nhà môi giới từ mã Java của chúng tôi để thực hiện quản lý của nhà môi giới.

Bấm vào người quản lý Robert MQ. Và đây là năm mà chúng ta có thể sử dụng để thử nghiệm các sàn giao dịch. Nhấp vào các sàn giao dịch và đây là các sàn giao dịch khác nhau có sẵn cho bạn.

Chúng tôi sẽ không sử dụng các sàn giao dịch mặc định này. Chúng tôi sẽ tạo ra một sàn giao dịch mới. Vì vậy, hãy nhấp vào THÊM trao đổi mới, cung cấp tên. Tôi sẽ gọi nó là Akhmad hoặc kiểm tra chủ đề, chọn loại làm chủ đề và nhấp vào THÊM Exchange.

Tại thời điểm này, trao đổi chủ đề thử nghiệm của chúng tôi đã được tạo và như bạn có thể thấy ở đây, không có hàng đợi nào bị ràng buộc với nó.

Tiếp theo, chúng ta sẽ tạo một hàng đợi và liên kết với sàn giao dịch này. Vì vậy hãy nhấp vào Kyuss, nhấp vào thêm hàng đợi mới, đặt tên cho nó.

Hãy gọi nó là Q1 và Q2. Hãy thêm một hàng đợi khác sẽ gọi nó là Q2 tại hàng đợi. Và bây giờ chúng ta có hai hàng đợi này là bước tiếp theo.

Chúng ta phải quay lại trao đổi, mở achmad hoặc kiểm tra trao đổi chủ đề của mình. Và bây giờ chúng ta sẽ thêm các liên kết để thêm liên kết cho Q1 và chúng ta sẽ cung cấp khóa liên kết được chỉ định ở đây.

Tôi sẽ gọi nó là phím chấm kiểm tra và liên kết. Tại thời điểm này, chúng tôi có Q1 được liên kết với khóa ngày kiểm tra làm khóa liên kết.

Hãy làm tương tự cho Q2 đó là key là test phi tiêu và liên kết. Bây giờ cả hai hàng đợi của chúng tôi đều liên quan đến chủ đề kiểm tra Akhmadov.

Bây giờ, để kiểm tra hoạt động của trao đổi này, chúng tôi sẽ xuất bản một tin nhắn, nhấp vào xuất bản tin nhắn, cung cấp khóa định tuyến mà anh ấy đã dạy và sau đó cung cấp tải trọng.

Tôi sẽ gọi nó là Tin nhắn xuất bản thử nghiệm Haloed. Tin nhắn được xuất bản. Hãy quay lại tố cáo. Và như bạn có thể thấy ở đây, chúng tôi có một thông điệp trong mỗi câu hỏi này.

Vì vậy nếu muốn đọc tin nhắn chỉ cần vào CU, nhấn vào Get Message. Và đây là tải trọng thử nghiệm của chúng tôi.

Bây giờ, một thử nghiệm khác sẽ được thực hiện là chúng tôi sẽ thay đổi ràng buộc cho Q2. Vì vậy, hãy quay lại trao đổi, nhấp vào Achmad hoặc kiểm tra chủ đề của chúng tôi.

Q2 sẽ không bị ràng buộc. Hãy liên kết lại Q2 bằng một khóa liên kết khác. Vì vậy, hãy gọi bài kiểm tra quan trọng này ra.

Chìa khoá mới. Bây giờ chúng ta phải có Qs, Bonwit, các phím định tuyến khác nhau. Vì vậy, tại thời điểm này, nếu nhà xuất bản xuất bản một thông báo, bài kiểm tra không phải là chìa khóa, nó sẽ kết thúc ở Q1 chứ không phải ở Q2.

Và nếu nhà xuất bản xuất bản thông báo bằng Test Dot Newquay thì thông báo đó sẽ kết thúc ở Quý 2 chứ không phải ở Quý 1.

Hãy tiếp tục và thử kiểm tra khóa mới giống như khóa định tuyến. Tôi sẽ chỉ đưa vào một tải trọng cho biết rằng đây là khóa mới và xuất bản thông báo đã xuất bản.

Hãy quay lại tố cáo và kiểm tra xem chúng ta có bao nhiêu tin nhắn. Vì vậy, trong Q1, chúng tôi chỉ có một tin nhắn và trong Q2, chúng tôi có hai tin nhắn vì chúng tôi mong đợi một cú nhấp chuột vào hàng đợi và sau đó bạn sẽ nhận được tin nhắn trong tin nhắn đầu tiên.

Hãy đọc tin nhắn số hai, và đây là tin nhắn số hai, kiểm tra Dort Newquay. Và tin nhắn này là gửi tới Newquay.

Tôi khuyên bạn nên tự mình thử trao đổi và liên kết hàng đợi để hiểu rõ hơn về cách hoạt động của Rabbit Amcu.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000006.srt-->

Trong bài giảng này, bạn tìm hiểu về các loại sự kiện khác nhau trong thiết kế miền. Sau đó, chúng ta sẽ tìm hiểu sâu hơn về các sự kiện và miền miền, thậm chí cả các trình xử lý.

Sau đó, tôi sẽ nói về bản chất giao dịch của các sự kiện trong miền. Sự kiện là một phần không thể thiếu của mô hình được xác định cho bối cảnh ranh giới.

Trong ví dụ này ở đây, mỗi người trong số 100 người liên hệ sẽ có các sự kiện được xác định rõ ràng và vì các sự kiện là một phần của mô hình có thể áp dụng trong ngữ cảnh bị giới hạn nên định nghĩa chẵn luôn được quản lý bằng ngôn ngữ phổ biến cho ngữ cảnh ranh giới đó.

Với tư cách là một chuyên gia, bạn có trách nhiệm đảm bảo rằng bạn đang nắm bắt tất cả các sự kiện có liên quan trong bối cảnh bị giới hạn như một phần của mô hình và ngôn ngữ phổ biến.

Những sự kiện này được các thành phần mô hình đưa ra khi có một số loại thay đổi trạng thái. Hãy xem một ví dụ.

Các khoản vay cá nhân được triển khai dưới dạng dịch vụ vi mô sẽ có các dịch vụ ứng dụng, dịch vụ miền và tổng hợp, đồng thời mỗi thành phần này có thể đưa ra các sự kiện để chỉ ra một số loại thay đổi trạng thái.

Hãy nhớ rằng có thể có các nguồn khác ngay cả trong một dịch vụ vi mô, chẳng hạn như có thể có giám sát ứng dụng, nhưng giám sát ứng dụng không phát hiện các sự kiện liên quan đến bối cảnh bị giới hạn.

Đây là những sự kiện kỹ thuật và không phải là một phần của thiết kế hướng miền. Cuộc thảo luận của tôi trong khóa học này là về các sự kiện bị các thành phần bỏ qua trong ngữ cảnh bị chặn.

Các thành phần đang bỏ qua các sự kiện được gọi là nguồn sự kiện và thậm chí người tiêu dùng cũng là người tiêu dùng của các sự kiện đó.

Những người tiêu dùng này thậm chí có thể là một phần của cùng một vi mạch. Vì vậy, trong trường hợp đó, các sự kiện bị nguồn sự kiện bỏ qua được gọi là các sự kiện miền.

Các sự kiện bị nguồn sự kiện bỏ qua có thể được sử dụng bởi các dịch vụ MICROS khác. Vì vậy, điều đó có nghĩa là một sự kiện được xác định trong một ngữ cảnh bị chặn sẽ được sử dụng trong một ngữ cảnh bị chặn khác.

Trong những trường hợp như vậy, sự kiện này được gọi là sự kiện tích hợp. Ngay cả người tiêu dùng cũng có thể là một phần của dịch vụ bên ngoài.

Tôi sẽ coi dịch vụ bên ngoài là API dịch vụ cũ hoặc bất kỳ dịch vụ nào khác không được triển khai dưới dạng dịch vụ vi mô trong những trường hợp như vậy.

Ngoài ra, sự kiện này được gọi là sự tích hợp. Thậm chí hãy nhớ rằng về mặt ngữ nghĩa không có sự khác biệt giữa các sự kiện miền và sự kiện tích hợp.

Người tiêu dùng chỉ là người quyết định liệu sự kiện sẽ được coi là miền hay thậm chí là tích hợp.

Hãy cùng tìm hiểu sâu hơn về miền và các sự kiện tích hợp. Tôi sẽ bắt đầu với định nghĩa chính thức về miền.

Ngay cả một sự kiện miền cũng là một thông báo thông báo cho các bộ phận khác trong cùng bối cảnh giới hạn rằng điều gì đó quan trọng đã xảy ra.

Đây là phần quan trọng trong cùng một bối cảnh giới hạn. Bây giờ, khi một sự kiện miền được kích hoạt, nó sẽ biểu thị sự thay đổi trạng thái trong ngữ cảnh bị giới hạn và người tiêu dùng của sự kiện sẽ nhận được thông báo sự kiện và thực thi một số logic nghiệp vụ trong cùng một ngữ cảnh bị giới hạn.

Vì vậy, điều quan trọng ở đây là hãy nhớ rằng sự kiện miền được kích hoạt trong bối cảnh bị giới hạn và nó được sử dụng trong cùng bối cảnh bị giới hạn đó.

Lý do tại sao các sự kiện đã trở thành một phần không thể thiếu trong thiết kế hướng miền là vì các sự kiện diễn ra một cách tự nhiên.

Đó là những người thợ làm thịt có khái niệm về sự kiện. Hãy nghĩ đến trường hợp khách hàng của cửa hàng mua sắm trực tuyến thêm hàng hóa vào quầy và sau đó thanh toán khi khách hàng thanh toán.

Đó là dấu hiệu của sự thay đổi trạng thái, tức là một sự kiện mà khách hàng đã kiểm tra. Điều này thậm chí sẽ dẫn đến quá trình xử lý khác và là một phần của quá trình xử lý đơn hàng, đơn hàng sẽ được chuyển đi, đây một lần nữa là dấu hiệu cho thấy sự thay đổi trạng thái.

Và kết quả là, nó là một quyền tác giả sự kiện. Các thành phần khác có thể phản ứng với sự kiện mới này. Ví dụ: một email có thể được gửi đến khách hàng để thông báo cho khách hàng rằng đơn hàng đang được chuyển đi.

Vì vậy các sự kiện xảy ra một cách tự nhiên ở mọi lĩnh vực. Một cách nhanh chóng để xác định các sự kiện trong một miền là tìm kiếm các tuyên bố như thời điểm điều này xảy ra, sau đó thực hiện.

Phần này thể hiện sự kiện và phần này thể hiện phản ứng đối với sự kiện đó. Đó là logic kinh doanh.

Xin lưu ý rằng phản ứng này còn được gọi là. Tác dụng phụ là bây giờ, tôi chắc chắn rằng bạn hiểu rằng ngôn ngữ đóng một vai trò rất quan trọng trong thiết kế Theo nhu cầu, vì vậy bạn phải hết sức cẩn thận khi đặt tên cho các sự kiện của mình.

Luôn sử dụng thì quá khứ, vì sự kiện thậm chí đã xảy ra. Dưới đây là một số phương pháp hay nhất để đặt tên cho sự kiện.

Bạn phải sử dụng ngôn ngữ phổ biến để không cần phải dịch giữa doanh nghiệp và ví dụ của nhóm CNTT.

Những sự kiện này có phải là một phần của miền bán lẻ không, thậm chí không được thêm dưới dạng hậu tố cho tên chẵn. Đây là một thực tế phổ biến mà tất cả chúng ta đều đã sử dụng với tư cách là nhà phát triển.

Tương tự, không thêm thao tác làm hậu tố. Vì vậy, tạo ra ở đây là hoạt động và gợi ý là sử dụng ngôn ngữ kinh doanh.

Vì vậy, người dùng đã đăng ký được ưu tiên hơn tên miền do người dùng tạo. Even Handler đề cập đến việc triển khai logic của người tiêu dùng chẵn.

Trong trường hợp miền, ngay cả trình xử lý cũng là một phần của cơ sở mã dịch vụ vi mô giống như nhà sản xuất chẵn.

Những trình xử lý này đăng ký các sự kiện quan tâm và có thể không có hoặc nhiều trình xử lý cho mỗi sự kiện.

Giống như các sự kiện, trình xử lý sự kiện phải được đặt tên phù hợp bằng cách sử dụng ngôn ngữ phổ biến như được đề xuất như một phương pháp hay nhất.

Bạn có thể đặt tên cho trình xử lý giống với sự kiện mà trình xử lý đó đang xử lý. Ví dụ: Order Shib sẽ là tên của đối tượng sẽ xử lý thứ tự các sự kiện.

Không thêm trình xử lý hoặc trình nhận làm hậu tố. Vì vậy, đây là một cái tên xấu. Thay vì tên này, bạn nên đi theo thứ tự.

Hãy xem ví dụ về khoản vay cá nhân, dịch vụ vi mô, tên miền, thậm chí nguồn và trình xử lý sự kiện tên miền đều trong cùng một quy trình.

Giả sử có một đơn xin vay tổng hợp. Tổng hợp đơn đăng ký khoản vay này được gọi khi khách hàng tạo đơn đăng ký vay trực tuyến khi gửi đơn đăng ký trực tuyến.

Việc tổng hợp đơn xin vay sẽ tạo ra đơn xin vay và kho lưu trữ liên tục. Đó là dấu hiệu của một sự kiện.

Hãy gọi đây là ứng dụng chẵn đã nhận được. Bây giờ, có thể có một trình xử lý trong cùng một dịch vụ vi mô này quan tâm đến việc phản hồi các sự kiện nhận được của ứng dụng.

Khi sự kiện này bị bỏ qua, trình xử lý sẽ nhận nó và gọi một thao tác để xem xét khoản vay. Tổng hợp việc xem xét khoản vay này.

Aggregate quản lý quá trình xem xét đơn xin vay. Là một phần của quá trình xử lý này, người xử lý cũng có thể bắt đầu quá trình xem xét đơn đăng ký bằng cách thông báo cho nhân viên cho vay.

Nhân viên cho vay có thể từ chối hoặc phê duyệt đơn xin vay, điều này có thể dẫn đến các sự kiện mới như đơn được phê duyệt.

Sau đó, người xử lý ứng dụng được phê duyệt sẽ gọi một thao tác trên tổng hợp tài khoản, thao tác này sẽ chịu trách nhiệm thiết lập tài khoản cho vay mới và bộ lưu trữ liên tục.

Một quan niệm sai lầm phổ biến về việc hiện thực hóa sự kiện là các sự kiện phải được quản lý bằng thông báo, nhưng điều đó không đúng với các sự kiện miền.

Các sự kiện miền có thể được thừa nhận và sử dụng một cách đồng bộ, chẳng hạn như bằng cách gọi hàm trực tiếp.

Hãy nhớ rằng nhà sản xuất sự kiện miền và trình xử lý đều ở trong cùng một quy trình. Nhưng bạn cũng có thể sử dụng cơ chế không đồng bộ như gửi tin nhắn bộ nhớ hoặc thậm chí là tin nhắn bên ngoài.

Broca. Các thay đổi trạng thái và sự chạy đua của các sự kiện cần phải xảy ra, về mặt nguyên tử trong trường hợp các cuộc gọi Đồng bộ hóa, việc triển khai các cơ chế như vậy sẽ dễ dàng hơn, trong khi với không đồng bộ, bạn sẽ cần sử dụng các mẫu thích hợp.

Hãy để tôi giải thích điều này bằng một ví dụ. Trong dịch vụ vi mô cho vay cá nhân, tổng hợp đơn xin vay có trách nhiệm quản lý trạng thái của đơn xin vay.

Vì vậy khi khách hàng đăng ký vay, tổng hợp hồ sơ vay sẽ lưu trạng thái hồ sơ vay mới vào cơ sở dữ liệu.

Bây giờ, giả sử tổng hợp không thể đưa ra ứng dụng sự kiện nhận được trong kịch bản thì các bước tiếp theo sẽ không thực thi.

Tại sao? Bởi vì người xử lý sẽ không bao giờ nhận được thông báo để bắt đầu quá trình xem xét khoản vay. Một tình huống thất bại khác là khi khách hàng đăng ký khoản vay và đơn xin vay.

Tổng hợp không thể lưu ứng dụng vào cơ sở dữ liệu, nhưng nó đã nâng cấp ứng dụng nhận được. Ngay cả trong trường hợp này, người xử lý sẽ nhận được thông báo nhưng sẽ không tìm thấy đơn xin vay trong cơ sở dữ liệu.

Kịch bản thứ hai này có thể được giải quyết bằng cách kiểm tra xem tất cả các hoạt động trước khi phát sinh sự kiện có thành công hay không, sau đó chỉ phát sinh sự kiện nếu các hoạt động trước đó thành công.

Hãy để tôi giải thích cách bạn có thể giải quyết tình huống số một. Xin lưu ý rằng tôi sẽ giải thích một trong nhiều mẫu có sẵn để xây dựng hành vi giao dịch cho các sự kiện miền.

Vì vậy, trong ví dụ này, tổng hợp đơn xin vay sẽ không xảy ra ngay khi nhận được đơn.

Nó sẽ lưu ngay cả vào bộ lưu trữ, bộ lưu trữ, có thể chỉ trong bộ nhớ lưu trữ. Sau đó, tổng hợp đơn xin vay có thể cố gắng lưu ứng dụng vào cơ sở dữ liệu.

Nếu có lỗi thì sự kiện sẽ không bị xóa. Nếu việc bán cơ sở dữ liệu thành công thì sự kiện sẽ bị xóa và người xử lý sẽ được thông báo.

Vì vậy, theo cách này, sự thay đổi trạng thái và việc khơi dậy sự kiện sẽ diễn ra một cách nguyên tử. Chúng ta hãy điểm qua những điểm chính từ bài giảng này.

Có hai loại sự kiện miền và sự kiện tích hợp. Các sự kiện miền được bỏ qua và xử lý trong cùng bối cảnh giới hạn, trong khi các sự kiện tích hợp được xử lý bên ngoài bối cảnh giới hạn.

Các sự kiện miền có thể được xử lý đồng bộ cũng như không đồng bộ. Nên sử dụng các quy ước đặt tên phù hợp để đặt tên cho các sự kiện và trình xử lý sự kiện.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000007.srt-->

Trong bài giảng này, chúng ta sẽ đi sâu hơn vào lớp tĩnh, Broecker, mẫu chẵn. Đầu tiên, tôi sẽ hướng dẫn bạn qua các lớp trong khung mẫu gãy mà tôi đã tập hợp lại.

Sau đó, tôi sẽ chỉ cho bạn sơ đồ trình tự để đăng ký và tăng số chẵn như một phần của bài giảng này.

Tôi cũng sẽ hướng dẫn bạn mã và bạn sẽ thấy mẫu này hoạt động trong lớp tĩnh thậm chí đã phá vỡ một mẫu, một lớp X duy nhất khi sự kiện bị phá vỡ.

Lớp này hiển thị các hàm tĩnh để quản lý sự kiện. Có một chức năng để nâng cao các sự kiện.

Có chức năng xử lý đăng ký và hủy đăng ký. Tất cả các cuộc gọi đều là cuộc gọi chức năng trực tiếp.

Do đó tất cả chúng đều đồng bộ. Và vì tất cả các lệnh gọi đều đang được xử lý, các lệnh gọi hàm trực tiếp nên mẫu này chỉ có thể được áp dụng cho các sự kiện miền.

Nó không thể được sử dụng để tích hợp ngay cả trước khi tiếp tục bài giảng này. Hãy chắc chắn rằng bạn đã kiểm tra chi nhánh sự kiện.

Tất cả các mô hình đều có sẵn dưới dạng UML utils. Ngay cả các lớp triển khai cũng không có trong mô hình, không được sử dụng hoặc thậm chí không được đóng gói và các lớp nhiệm vụ đang được thử nghiệm, thậm chí không tĩnh.

Gói Broca. Khung thống nhất mà tôi đã tập hợp lại sẽ có bốn lớp. Lớp đầu tiên là lớp tĩnh hiển thị ba chức năng cần thiết để quản lý đồng đều.

Đối với mỗi sự kiện, sẽ có một tập hợp các trình xử lý sẽ được quản lý trong lớp trình điều phối chẵn.

Lớp người gửi hàng thậm chí này sẽ chịu trách nhiệm gửi sự kiện đến những người xử lý đã đăng ký cho sự kiện đó.

Tất cả các trình xử lý sự kiện phải triển khai trình xử lý sự kiện giao diện. Giao diện này có một hàm xử lý lấy sự kiện làm đối số.

Tất cả các sự kiện phải mở rộng lớp trừu tượng sự kiện và bạn sẽ thấy rằng có một thuộc tính cho tên tên.

Đây là những gì xác định cụ thể loại sự kiện cụ thể. Thậm chí các lớp có thể giới thiệu các thuộc tính bổ sung để đáp ứng nhu cầu của các sự kiện cụ thể.

Vui lòng xem sơ đồ lớp đầy đủ có sẵn trong dự án trong thư mục này. Tiếp theo, tôi sẽ hướng dẫn bạn sơ đồ trình tự để đăng ký trình xử lý sự kiện.

Thành phần đầu tiên trong chuỗi sẽ là thành phần lãi suất, là thành phần kiểm soát. Sau đó, chúng ta có bus sự kiện xử lý sự kiện và một tập hợp các hoạt động gửi đi đều.

Đây là những thành phần chính trong trình tự đăng ký. Thành phần công nghiệp sẽ tạo một phiên bản của trình xử lý sự kiện.

Sau đó, nó sẽ gọi hàm đăng ký trên bus sự kiện với nhóm sự kiện và trình xử lý chẳng hạn.

Ngay cả xe buýt cũng sẽ tìm người điều phối tên sự kiện nhận được trong chức năng đăng ký. Hai điều có thể xảy ra.

Xe buýt sự kiện cuối cùng thậm chí sẽ gửi một bộ sưu tập cho sự kiện hoặc nó sẽ không tìm thấy. Hãy xem kịch bản đầu tiên và tìm thấy bộ điều phối sự kiện.

Nếu người điều phối sự kiện là điện thoại thì ngay cả xe buýt cũng sẽ gọi chức năng đăng ký trên sự kiện. Bộ điều phối thậm chí cả bộ điều phối sẽ trả về một boolean true cho bus sự kiện và bus sự kiện sẽ trả về true cho lãi suất tại thành phần.

Và tại thời điểm này, trình xử lý đã được đăng ký với sự kiện. Nhưng nếu bộ điều phối không được tuân theo thì điều đầu tiên mà xe buýt thực hiện là tạo một bộ điều phối cho tên sự kiện đó, sau đó đăng ký bộ điều phối cho tên sự kiện, dẫn đến lệnh gọi đến bộ điều phối sự kiện để đăng ký bộ xử lý.

Bộ điều phối trả về Boolean True, sau đó bus sự kiện sẽ quay trở lại thành phần được ủy thác. Vì vậy, tại thời điểm này, trình xử lý đã được đăng ký.

Chúng ta hãy xem nhanh hàm đăng ký lớp bus chẵn trong hàm register. Điều đầu tiên là kiểm tra bộ sưu tập bộ điều phối sự kiện để xem liệu có bộ điều phối cho tên chẵn đã cho hay không.

Nếu bộ điều phối không tồn tại trong bộ sưu tập tạo một bộ điều phối rồi gọi bộ điều phối sự kiện, hãy đăng ký một hàm trong bộ điều phối sự kiện, hãy đăng ký một hàm.

Chúng tôi chỉ đơn giản là kiểm tra xem trình xử lý đã tồn tại chưa. Nếu nó tồn tại, chỉ cần trả về false vì bạn không muốn cùng một trình xử lý được đăng ký hai lần.

Nếu không, nó có thể dẫn đến trùng lặp và sau đó thêm trình xử lý vào bộ sưu tập. Như bạn có thể thấy, việc triển khai này khá đơn giản.

Tiếp theo, tôi sẽ hướng dẫn bạn qua trình tự nhận trong đó tuyến tổng hợp sẽ đóng vai trò là nguồn của sự kiện.

Lộ trình tổng hợp sẽ tương tác với cả ông chủ để nâng cao sự kiện. Sau đó, ông chủ sự kiện sẽ tương tác với người điều phối chẵn, sau đó người điều phối này sẽ tương tác với người xử lý sự kiện.

Vì vậy, điều đầu tiên xảy ra là tuyến đường tổng hợp đó sẽ. Tất cả chức năng đua xe trên xe buýt, thậm chí cả xe buýt, đều sẽ tìm người điều phối tên buổi tối, không thể xảy ra hai chuyện.

Người điều phối sẽ được theo dõi hoặc nó sẽ không được tìm thấy. Nếu không tìm thấy bộ điều phối cho sự kiện thì xe buýt chỉ trả về sai, điều này cho biết không có hành động nào được thực hiện vì không có trình xử lý.

Ngược lại, bus sự kiện sẽ gọi hàm điều phối trên phiên bản bộ điều phối chẵn. Sau đó, bộ điều phối chẵn sẽ gọi hàm xử lý trên tất cả các trình xử lý.

Sau đó, nó trả về true cho cả ông chủ cho biết rằng sự kiện đã được xử lý. Việc trả lại xe buýt đồng đều đúng với tuyến đường tổng hợp.

Xin lưu ý rằng tất cả các lệnh gọi hàm này đều đồng bộ. Trong lớp xe buýt chẵn. Bạn sẽ tìm thấy hàm đua và bạn sẽ tìm thấy ba bước mà tôi đã thảo luận trong sơ đồ trình tự.

Trước tiên, chúng tôi cố gắng tìm người điều phối cho sự kiện đang diễn ra. Nếu không tìm thấy người điều phối thì không có hành động nào được thực hiện.

Ngược lại, hàm điều phối sẽ được gọi trên phiên bản bộ điều phối chẵn và lớp bộ điều phối chẵn.

Chức năng điều phối kiểm tra. Nếu kích thước của bộ sưu tập trình xử lý bằng 0, trả về sai vì không có trình xử lý nào xử lý sự kiện.

Nếu không, hãy lặp đến các phiên bản trình xử lý và gọi trình xử lý ngay cả trên mỗi trình xử lý. Tôi đã đưa ra một trường hợp thử nghiệm để xem ông chủ và hành động đồng đều.

Tất cả các lớp kiểm tra đều có sẵn trong bài kiểm tra. Ngay cả gói tĩnh đã bị hỏng. Lớp kiểm thử chính có mã trường hợp kiểm thử.

Một số hành động là lớp xấu và một số hành động xảy ra là lớp xử lý. Hãy để tôi hướng dẫn nhanh mã cho bạn và cho bạn thấy rằng ngay cả ông chủ cũng đang hành động, vì mục đích thử nghiệm này, hãy giả sử rằng gốc tổng hợp là nguồn gốc của sự kiện.

Và đây là tên của sự kiện sẽ được lớp này đưa ra khi một số hành động được thực hiện ở đây, bạn sẽ thấy rằng chúng ta chỉ đơn giản in ra thông báo và sau đó đưa ra sự kiện chứ không phải để nêu lên sự kiện.

Chúng ta đang chuyển một thể hiện của hành động some. Hành động some thực sự là một lớp sự kiện mở rộng phần tóm tắt.

Như bạn có thể thấy, không có gì đặc biệt trong lớp học này. Trong lớp kiểm tra chính. Những gì chúng ta đang làm trong hàm main là tạo một trình xử lý và sau đó đăng ký trình xử lý đó với ông chủ chẵn và với tên chẵn từ tuyến tổng hợp.

Chúng ta hãy xem nhanh trình xử lý sự kiện. Vì vậy, một số hành động đã xảy ra. Đó có phải là một trình xử lý không và nó chỉ đơn giản là đưa ra một thông báo cho biết trình xử lý đã được thực thi.

Vì vậy, hãy quay lại bài kiểm tra chính ở đây. Và do đó, để thực hiện thử nghiệm, chúng tôi sẽ tạo một lộ trình tổng hợp mới và sau đó thực hiện một số hành động trên đó, điều này sẽ dẫn đến việc nâng cao sự kiện.

Vì vậy, hãy tiếp tục và kiểm tra điều này. Phải. Nhấp vào Bài đăng chính và chạy thử nghiệm chính. Và đây là kết quả của chúng tôi.

Tuyến tổng hợp đã thực hiện hành động thành công và sau đó trình xử lý được thực thi do sự kiện.

Con gái ông chủ đang ở trong lộ trình tổng hợp. Đề nghị bạn đi bộ đến tòa án và tự mình thử.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000008.srt-->

Giống như bao miền khác, Acme sales cũng có các sự kiện trong bài giảng này. Tôi sẽ xem xét một số sự kiện nhất định trong mô hình miền bán hàng và chúng tôi cũng sẽ nghiên cứu lập mô hình các sự kiện này cũng như trình xử lý các sự kiện này như một phần của quá trình khám phá.

Chúng tôi đã phỏng vấn John. Và điều John nói là tôi biết có nhiều yêu cầu về quy định và tuân thủ, nhưng vì tôi không phải là chuyên gia nên hãy tham gia cùng hoặc và từ nhóm pháp lý.

Vì vậy chúng tôi đã mời hoặc tham gia cuộc họp và đây là những gì oint đã nói với chúng tôi. Chúng tôi đang ở trong một ngành công nghiệp được quản lý. Chúng tôi cần đảm bảo rằng chúng tôi tuân thủ tất cả các quy định, mặc dù có nhiều quy định, nhưng liên quan cụ thể đến việc thanh toán, điều bắt buộc là khi nhận được khoản thanh toán của khách hàng, khoản thanh toán đó phải được duy trì và yêu cầu thanh toán tối thiểu là bảy năm.

Vậy là có một thuật ngữ mới xuất hiện ở đây, lệnh thanh toán. Vì vậy, với tư cách là một chuyên gia CNTT, hãy đảm bảo bạn thêm thuật ngữ này vào ngôn ngữ phổ biến.

Tại thời điểm này. John đã đề cập rằng sau khi chúng tôi nhận được tin nhắn đã nhận thanh toán, việc đặt chỗ sẽ bắt đầu.

Cuối cùng, việc đặt chỗ đã được thực hiện thành công. Chúng tôi đánh dấu việc đặt phòng là đã được xác nhận. Đã đến lúc làm một bài kiểm tra, xem qua bản ghi và xác định một sự kiện cũng như tác dụng phụ.

Nếu bạn cần thêm thời gian, vui lòng chuyển video. Trong bài giảng trước, tôi đã đề cập rằng bạn cần tìm kiếm những câu phát biểu giống như khi một điều gì đó đã xảy ra.

Vì vậy, nếu bạn nhìn vào bản ghi này, bạn có thể dễ dàng thấy rằng khi nhận được khoản thanh toán của khách hàng thì việc đặt chỗ sẽ diễn ra.

Vì vậy, đây là sự kiện và đây là hành động hoặc tác dụng phụ tiếp theo. Hãy suy nghĩ về cách chúng ta sẽ mô hình hóa những yêu cầu mới này.

Tất cả thông tin thanh toán phải được lưu giữ trong bảy năm khi đề cập đến việc kiểm tra thanh toán. Không có lệnh thanh toán nào là bản ghi tất cả các khoản thanh toán do khách hàng thực hiện, vì đó là một thực thể cũng sẽ cần một kho lưu trữ.

Thực thể lệnh thanh toán này có thể hiển thị khoản thanh toán trong quy trình hoạt động và thực hiện việc xử lý khoản thanh toán.

Chúng tôi sẽ gọi chức năng này. Bất cứ khi nào chức năng này được gọi và thanh toán thành công, một thực thể mới sẽ được tạo và thêm vào bộ sưu tập thanh toán bằng kho lưu trữ thanh toán.

Và các khoản thanh toán thành công cũng sẽ dẫn đến việc tăng số tiền nhận được. Ngay cả khi sự kiện này được nêu ra, nó sẽ được xử lý bằng cách xử lý khoản thanh toán đã nhận để bắt đầu quá trình đặt trước.

Và sau khi tất cả các lượt đặt trước thành công, nó sẽ thay đổi trạng thái xác nhận đặt chỗ để xác nhận rằng đó là sơ đồ lớp mô tả tất cả các lớp mới được giới thiệu trong mô hình nhằm đáp ứng các yêu cầu mới mà chúng tôi đã khám phá.

Mô hình này có sẵn trong tệp mô hình này. Như bạn có thể thấy ở đây, tôi đã giới thiệu khoản thanh toán nhận được ngay cả trong gói thanh toán và khoản thanh toán nhận được này thậm chí còn bị bỏ qua trong quá trình kiểm tra thanh toán lớp này.

Trình xử lý nằm trong gói đặt chỗ và nó mở rộng lớp xử lý sự kiện. Tất cả mã Java cho các lớp này đều có sẵn trong dự án.

Nếu bạn quan tâm, bạn có thể truy cập mã vào lúc này. Tiếp theo, tôi sẽ hướng dẫn bạn về miền thanh toán nhận được, theo trình tự chẵn.

Mô hình này có sẵn trong tập tin này. Đại lý bán hàng tiếp nhận thông tin thẻ tín dụng từ khách hàng.

Họ nhập thông tin thẻ tín dụng này vào một loại ứng dụng nào đó mà tôi gọi là giao diện bán hàng.

Sau đó, giao diện hoặc ứng dụng bán hàng sẽ thực hiện quá trình thanh toán trên lệnh thanh toán. Lệnh thanh toán sử dụng Dịch vụ cơ sở hạ tầng cổng thanh toán để thực hiện xử lý thanh toán thực tế.

Dịch vụ Cổng thanh toán này đã được thảo luận trong một trong những bài giảng trước đó. Dịch vụ Cổng thanh toán tương tác với dịch vụ thanh toán bên ngoài.

Xác nhận thanh toán được Cổng thanh toán nhận, sau đó được chuyển sang kiểm tra thanh toán, kiểm tra thanh toán khi nhận thanh toán, xác nhận quyền truy cập vào bộ lưu trữ liên tục và sau đó đưa ra sự kiện nhận thanh toán.

Tiếp theo, hãy xem sơ đồ hoạt động của trình xử lý thanh toán đã nhận. Mô hình được mô tả ở đây có sẵn trong tập tin này.

Người xử lý thanh toán nhận được sự kiện đã nhận thanh toán và bắt đầu các đặt phòng khác nhau, chẳng hạn như Đặt phòng khách sạn, Đặt vé máy bay và đặt thuê xe, là một phần của gói kỳ nghỉ.

Điều này sẽ dẫn đến việc thực hiện các dịch vụ cơ sở hạ tầng cho các đặt phòng này. Ý tưởng là các dịch vụ bên ngoài sẽ được gọi và sẽ nhận được xác nhận.

Đối với mỗi lần đặt trước này, người xử lý sẽ đảm bảo rằng tất cả các lần đặt trước đều thành công.

Nếu bất kỳ lượt đặt chỗ nào không thành công thì lượt đặt chỗ đó sẽ được đánh dấu là không thành công. Nếu tất cả các đặt phòng thành công thì trạng thái xác nhận đặt phòng sẽ được chuyển thành xác nhận đặt phòng.

Trong bài học này, tôi đã chỉ cho bạn cách sử dụng chiến thuật này. Mẫu lớp Braco để xây dựng trình xử lý cho sự kiện miền.

Hãy nhớ rằng đây là một mẫu rất đơn giản. Trên thực tế, bạn có thể sử dụng các thư viện và khung của bên thứ ba và thực hiện xử lý đồng đều theo cách không đồng bộ.

Hãy thực hiện nghiên cứu của riêng bạn và chia sẻ những phát hiện của bạn. Trong bài giảng tiếp theo, bạn sẽ thấy việc triển khai thử nghiệm các yêu cầu mới này.

Nếu bạn không quan tâm đến việc xem qua mã và xem nó hoạt động như thế nào, bạn có thể bỏ qua bài giảng tiếp theo.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000009.srt-->

Mục đích đằng sau bài học này là trình bày cách thức thanh toán nhận được, thậm chí là xử lý trong bài giảng này.

Tôi sẽ hướng dẫn bạn mã kiểm tra và sau đó chúng ta sẽ xem quá trình thực thi của trình xử lý khoản thanh toán nhận được đang hoạt động như thế nào để chứng minh việc gửi và xử lý khoản thanh toán nhận được.

Thậm chí tôi còn tập hợp bài kiểm tra thứ tự thanh toán lớp này làm bước tiếp theo. Tôi sẽ hướng dẫn bạn mã trong lớp học này và chúng ta cũng sẽ thấy khoản thanh toán đã nhận được, thậm chí cả quá trình xử lý đang diễn ra.

Xin lưu ý rằng để triển khai quá trình xử lý khoản thanh toán nhận được, tôi đang sử dụng mẫu Class Brocco chiến thuật này đã được thảo luận trong bài giảng trước đó trong chức năng chính như bước đầu tiên trong việc tạo đối tượng repo xác nhận đặt phòng.

Đây là đối tượng repo giả mà chúng tôi sử dụng trong các thử nghiệm trước đó và bước thứ hai trong việc tạo một phiên bản của trình xử lý nhận được khoản thanh toán chuyển vào kho lưu trữ xác nhận đặt chỗ và sau đó đăng ký trình xử lý cho khoản thanh toán đã nhận.

Ngay cả ở bước số ba, tôi vẫn nhận được xác nhận đặt chỗ hiện có với số tham chiếu từ chín đến tám.

Hãy nhớ lại rằng dữ liệu xác nhận đặt phòng này là một phần của kho lưu trữ xác nhận đặt phòng giả mạo. Nếu bạn muốn xem chi tiết về nó, chỉ cần xem đối tượng repo xác nhận đặt phòng trong gói repo ghi chú giả là bước tiếp theo, tạo quy trình cổng thanh toán.

Đây là quá trình triển khai thử nghiệm cổng thanh toán. Tiếp theo, chúng tôi đang tạo ba lệnh thanh toán giả.

Điều này một lần nữa có sẵn trong các gói repo giả mạo. Và như bạn sẽ thấy, cách triển khai này rất giống với các kho lưu trữ giả mạo khác.

Khi bạn đã tạo repo yêu cầu thanh toán, chúng tôi sẽ tạo thực thể kiểm tra thanh toán. Thực thể kiểm toán thanh toán này có sẵn trong gói thanh toán.

Nó cho thấy một chức năng thanh toán quá trình. Chúng tôi đang chuyển một số dữ liệu giả mạo và sau đó chúng tôi chỉ in xác nhận đặt phòng.

Ý tưởng là chúng ta sẽ so sánh trạng thái xác nhận đặt phòng trước và sau khi xử lý để xem trạng thái đã thay đổi hay chưa.

Vì vậy, hãy tiếp tục và thực hiện lớp này. Phải, bấm, chạy. Và đây là kết quả. Như bạn có thể thấy ở đây, số tham chiếu đặt chỗ là chín hai mươi tám.

Và những người mới bắt đầu lúc đầu đang chờ thanh toán. Việc xử lý thanh toán được thực hiện trong quá trình kiểm tra thanh toán và sau đó người xử lý đã bị sa thải do bỏ sót khoản thanh toán đã nhận.

Ngay cả người xử lý sau đó cũng cập nhật tham chiếu đặt chỗ từ chín đến tám và trạng thái đã được thay đổi để phù hợp.

Đề xuất của tôi dành cho bạn là bạn nên tự mình xem mã này, kiểm tra mã và các lớp liên quan và cho tôi biết nếu bạn có bất kỳ câu hỏi nào.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000010.srt-->

Trong bài giảng về tích hợp, thậm chí, sự nghiệp của Alpha, so sánh các sự kiện tích hợp và miền, sau đó chúng ta sẽ thảo luận về tích hợp, thậm chí xử lý từ góc độ dịch vụ vi mô của người tiêu dùng.

Vào cuối bài học này, chúng tôi sẽ nâng cao mô hình cho bối cảnh giới hạn quản lý khoản vay đã được thảo luận trong bài giảng trước đó.

Bây giờ, bạn đã biết rằng các sự kiện miền được nêu ra và sử dụng trong cùng một bối cảnh giới hạn của dịch vụ vi mô.

Mặt khác, các sự kiện tích hợp được sử dụng bởi các dịch vụ vi mô khác bên ngoài bối cảnh bom con nguồn.

Và những sự kiện tích hợp này cũng có thể được sử dụng bởi các dịch vụ bên ngoài. Một định nghĩa chính thức hơn về sự tích hợp thậm chí là nó là một thông báo thông báo cho các thành phần bên ngoài bối cảnh giới hạn nguồn rằng điều gì đó quan trọng đã xảy ra và sự tích hợp thậm chí không dẫn đến bất kỳ loại thay đổi nào trong bối cảnh giới hạn nguồn.

Hãy cùng điểm qua những khác biệt giữa miền và các sự kiện tích hợp. Cái đầu tiên là một cái hiển nhiên, tên miền.

Bạn được nêu lên và sử dụng trong cùng một bối cảnh bị giới hạn hoặc một dịch vụ vi mô, trong khi các sự kiện tích hợp được nêu ra trong một bối cảnh bị giới hạn nhưng có thể được sử dụng trong một bối cảnh bị giới hạn khác hoặc bởi một sự kiện miền dịch vụ bên ngoài dẫn đến những thay đổi trạng thái trong bối cảnh bị giới hạn nguồn, trong khi không có thay đổi trạng thái nào xảy ra trong bối cảnh giới hạn nguồn.

Do phản ứng với các sự kiện tích hợp, các sự kiện miền được triển khai bằng cách gọi hàm trực tiếp và các sự kiện tích hợp phải được sử dụng qua giao thức mạng.

Nói cách khác, trong trường hợp các sự kiện tích hợp, nếu bạn sử dụng lệnh gọi hàm trực tiếp thì hãy đoán xem điều gì sẽ xảy ra?

Bạn đang tạo một ứng dụng nguyên khối. Trong trường hợp các sự kiện miền, việc tiêu thụ sự kiện có thể đồng bộ, như với các lệnh gọi hàm trực tiếp.

Nhưng trong trường hợp các sự kiện tích hợp, các cơ chế không đồng bộ được ưu tiên hơn. Cả sự kiện miền và sự kiện tích hợp đều là một phần của mô hình bối cảnh được mã hóa nguồn.

Trong trường hợp có sự kiện tích hợp, người liên hệ bị giới hạn của người tiêu dùng phải quyết định về mẫu tích hợp mà nó sẽ sử dụng để tiêu thụ các sự kiện.

Thêm về điều này trong một vài phút. Mặc dù về mặt kỹ thuật có thể sử dụng cơ chế Đồng bộ hóa cho các sự kiện tích hợp, giao tiếp nhưng các giao thức mạng không đồng bộ được ưu tiên vì những lý do rõ ràng.

Điều đầu tiên là bạn có thể đạt được mức độ tách rời cao bằng các cơ chế không đồng bộ. Khả năng mở rộng trong tương lai dễ dàng hơn.

Ví dụ: bạn có thể thêm người tiêu dùng mới mà không ảnh hưởng đến nguồn sự kiện hoặc dịch vụ vi mô đang thực hiện các sự kiện tích hợp.

Nó giúp việc thiết lập mối quan hệ một-nhiều giữa các liên hệ bị chặn hoặc các dịch vụ vi mô trở nên dễ dàng hơn.

Công nghệ nhắn tin được sử dụng phổ biến. Đây là một số công cụ nhắn tin rất phổ biến để xây dựng các dịch vụ vi mô.

Sự kiện tên miền cũng có thể được xuất bản dưới dạng sự kiện tích hợp. Nói cách khác, đối với cùng một sự kiện, có thể có người tiêu dùng trong bối cảnh bị ràng buộc cũng như bên ngoài bối cảnh bị ràng buộc.

Cả hai sự kiện đều là một phần của mô hình cho bối cảnh dài hơn. Về mặt ngữ nghĩa, hai sự kiện đều giống nhau.

Sự khác biệt nằm ở cách những sự kiện này được xuất bản và tiêu thụ. Nhưng nếu người thiết kế dịch vụ vi mô đã quyết định sử dụng cùng một cơ chế không đồng bộ cho cả hai loại sự kiện thì cơ chế xuất bản và kích hoạt sẽ giống nhau đối với các sự kiện miền và tích hợp.

Bây giờ chúng ta hãy xem xét các sự kiện tích hợp từ góc độ của người tiêu dùng, người tiêu dùng hoặc sự tích hợp, thậm chí có thể là một người theo chủ nghĩa tuân thủ.

Vì vậy, trong trường hợp này, trong đó A là loại sự kiện và B là người tiêu dùng đồng đều là những người tuân thủ, điều đó có nghĩa là nhóm chịu trách nhiệm về B của Microsoft sẽ cần phải có kiến ​​thức về các mô hình được sử dụng trong bối cảnh liên kết.

Nói cách khác, Microsoft chính là nó. Và bất cứ khi nào có sự thay đổi về cấu trúc đồng đều hoặc cấu trúc mô hình, nhóm Microsoft B sẽ phải điều chỉnh để giảm thiểu tác động của những thay đổi đó.

Nhóm của Microsoft là V có thể sử dụng lớp chống tham nhũng. Trong trường hợp này, tất cả những thay đổi trong sự kiện bắt nguồn từ Microsoft, nó sẽ bị cô lập với.

Chống tham nhũng, do đó giữ cho nền tảng đạo đức và quy tắc của Microsoft độc lập với mô hình của Microsoft là a.

Hãy xem lại ví dụ về khoản vay cá nhân, quản lý tài khoản, dịch vụ vi mô của chúng tôi. Giả sử có hai yêu cầu mới.

Yêu cầu đầu tiên không phải là bối cảnh giới hạn tuân thủ được triển khai vì một dịch vụ vi mô cần được thông báo khi nhận được đơn đăng ký mới và khách hàng cần được thông báo qua email khi tài khoản vay được thiết lập.

Bây giờ, để đáp ứng hai yêu cầu này, chúng tôi sẽ cần triển khai tích hợp ngay cả đối với yêu cầu đầu tiên trong đó chúng tôi cần thông báo việc tuân thủ.

Chúng tôi có thể xuất bản miền ngay cả khi ứng dụng được nhận dưới dạng tích hợp. Ngay cả dịch vụ vi mô để tuân thủ cũng sẽ có thể nhận được sự đồng đều và thực hiện quá trình xử lý phù hợp trong bối cảnh giới hạn của nó.

Đối với thông báo của khách hàng, chúng tôi có thể thiết lập tổng hợp tài khoản để xuất bản một sự kiện mới và sự kiện mới này thậm chí có thể là một tài khoản được thiết lập.

Một dịch vụ thông báo có thể đăng ký sự kiện mới này và khi nhận được tài khoản cho vay được thiết lập, nó thậm chí có thể gửi email cho khách hàng.

Vì vậy, trong miền hiện có, thậm chí được xuất bản dưới dạng sự kiện tích hợp và với sự kiện tích hợp mới, sẽ có thể nâng cao mô hình dịch vụ quản lý tài khoản cho vay của chúng tôi để đáp ứng hai yêu cầu mới.

Chúng ta hãy điểm qua những điểm chính từ bài học này. Các sự kiện trên miền có thể được xuất bản dưới dạng sự kiện tích hợp.

Ưu tiên các sự kiện tích hợp được xuất bản không đồng bộ. Công nghệ nhắn tin thường được sử dụng để xuất bản và đăng ký các sự kiện hội nhập.

Các dịch vụ vi mô tiêu dùng dành cho các sự kiện tích hợp có thể sử dụng Atheel hoặc lớp chống tham nhũng để tách biệt kiến ​​thức về bối cảnh giới hạn nguồn trước đó.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000011.srt-->

Trong bài học này, chúng tôi sẽ mở rộng mô hình bán hàng Acme bằng cách giới thiệu một sự kiện tích hợp mới và thêm dịch vụ cơ sở hạ tầng tin nhắn.

Trong lần tương tác gần đây nhất với John và Ian từ bộ phận pháp lý, chúng tôi được biết rằng sau khi khách hàng thanh toán thành công, trạng thái đặt chỗ sẽ thay đổi thành tuân thủ.

Vậy câu hỏi đặt ra là điều gì sẽ xảy ra tiếp theo? Mục tiêu của chúng ta trong bài học này là hiểu các hành động được thực hiện sau khi việc đặt chỗ được xác nhận.

Vì vậy, chúng tôi đã hỏi John câu hỏi này và đây là những gì John nói với chúng tôi. Khi đặt phòng được xác nhận, chúng tôi làm hai việc.

Đầu tiên là chúng tôi gửi email cho khách hàng kèm theo thông tin xác nhận đặt phòng, đồng thời chúng tôi cũng cập nhật báo cáo hàng ngày và hàng tuần cho các bộ phận khác nhau của achmad.

Bạn có thấy điều gì thú vị ở đây không? Có một sự kiện khi việc đặt chỗ được xác nhận, vì vậy có vẻ như chúng tôi vừa phát hiện ra một sự kiện đặt chỗ mới được xác nhận yêu cầu không có ai có vẻ khá đơn giản.

Hãy hỏi John về yêu cầu số hai. Vì vậy, John đang nói với chúng tôi rằng việc tạo báo cáo là một công việc mệt mỏi vì mọi bộ phận đều muốn những báo cáo này phải có một định dạng nhất định.

Nhưng một số dữ liệu nhất định, chúng tôi luôn cố gắng bắt kịp. Đôi khi chúng tôi bị các bộ phận khác đổ lỗi cho những sai sót trong các bộ phận đó, chủ yếu là do không gửi báo cáo đúng hạn hoặc thiếu hoặc dữ liệu sai trong báo cáo.

Dưới đây là một số báo cáo ví dụ. Chúng tôi cần cung cấp báo cáo đặt phòng hàng ngày. Sau đó, có một báo cáo doanh thu cần thiết hàng ngày.

Báo cáo dự báo được thực hiện hàng tuần. Tất cả điều này yêu cầu chúng tôi phải xem xét dữ liệu chúng tôi đã thu thập cho tất cả các lượt đặt chỗ.

Và đôi khi các bộ phận này yêu cầu dữ liệu đặc biệt yêu cầu chúng tôi phải tìm hiểu kỹ tất cả dữ liệu mà chúng tôi đang thu thập từ các đề xuất và lượt đặt chỗ này.

Đó là một công việc mệt mỏi. Hy vọng có cách tốt hơn để giải quyết tất cả những điều này. Với tư cách là chuyên gia CNTT, trách nhiệm của chúng tôi là đơn giản hóa quy trình này và giúp cuộc sống của John dễ dàng hơn.

Hãy bắt tay vào làm việc ngay bây giờ. Bạn sẽ đáp ứng những yêu cầu này như thế nào khi sử dụng mô hình này làm điểm khởi đầu?

Hãy nhớ lại rằng chúng tôi đã nghĩ ra mô hình này trong cuộc trò chuyện gần đây nhất với John và vui lòng chuyển video, viết suy nghĩ của bạn ra một tờ giấy và tiếp theo tôi sẽ chia sẻ suy nghĩ của mình về giải pháp.

Chúng tôi có thể giải quyết những yêu cầu này bằng cách giới thiệu một tiện ích tích hợp mới, thậm chí cả việc đặt chỗ đã được xác nhận trong kho lưu trữ xác nhận đặt chỗ.

Mỗi khi một lượt đặt chỗ được xác nhận, một lượt đặt chỗ đã được xác nhận thậm chí sẽ được hủy bỏ. Và tối nay sẽ được nhận bởi nhiều người đăng ký khác nhau, chẳng hạn như các dịch vụ Metro khác và dịch vụ thông báo về việc nhận sự kiện dưới dạng tin nhắn.

Dịch vụ thông báo sẽ gửi email và các dịch vụ khác có thể thực hiện quá trình xử lý cần thiết để tạo báo cáo và sử dụng dữ liệu cho bất kỳ mục đích nào họ cần.

Dữ liệu mang lại lợi ích cho phương pháp này là tất cả các sự kiện này sẽ được kích hoạt trong thời gian thực.

Vì vậy, các dịch vụ khác này sẽ có tất cả dữ liệu hiện tại mà họ cần để xử lý. Tiếp theo, tôi sẽ hướng dẫn bạn đến sơ đồ thành phần này từ góc độ sự kiện, ghi chú này và lớp lưu giữ được mô tả ở đây là dành cho dịch vụ vi mô bán hàng.

Giả sử rằng đường trục nhắn tin được xây dựng trên Rabbit MQ và người đăng ký là các dịch vụ bên ngoài và các dịch vụ vi mô khác.

Như bạn có thể thấy ở đây, chúng tôi có dịch vụ thông báo ở đây cũng như đã thảo luận trong bài giảng trước đó mà phụ huynh đã yêu cầu sau khi nhận được bản cập nhật xác nhận thanh toán thành công, thực thể yêu cầu thanh toán sẽ được lưu trữ liên tục và sau đó tăng miền nhận được khoản thanh toán.

Ngay cả khoản thanh toán này đã nhận được. Sự kiện chính được sử dụng bởi khoản thanh toán Hannelore nhận được và trạng thái xác nhận đặt phòng sau khi đặt chỗ được cập nhật để phù hợp nhằm đáp ứng yêu cầu mới.

Bây giờ, sau khi trạng thái xác nhận đặt phòng được cập nhật, tổng hợp xác nhận đặt phòng sẽ đưa ra xác nhận đặt phòng.

Thậm chí điều này sẽ dẫn đến việc xuất bản một thông báo tới một chủ đề được hiển thị ở đây. Vì các thành phần này đã đăng ký chủ đề nên tất cả chúng sẽ nhận được sự kiện dưới dạng tin nhắn và sau đó mỗi thành phần này có thể xử lý tin nhắn theo nhu cầu của chúng.

Cách tốt nhất là chúng tôi cần đảm bảo rằng mô hình của chúng tôi không bị ràng buộc với bất kỳ công nghệ cụ thể nào. Do đó, chúng tôi sẽ xác định một dịch vụ cơ sở hạ tầng sẽ cách ly mô hình khỏi công nghệ nhắn tin cơ bản.

Dịch vụ cơ sở hạ tầng này sẽ được triển khai như một dịch vụ nhắn tin giao diện. Giao diện dịch vụ nhắn tin này sẽ hiển thị các chức năng cho các thành phần đạo đức khác nhau tương tác với công nghệ nhắn tin cơ bản.

Chức năng đăng ký sẽ yêu cầu một phiên bản của trình xử lý tin nhắn. Trình xử lý tin nhắn sẽ có một hàm xử lý duy nhất sẽ được thực thi khi người đăng ký nhận được tin nhắn.

Tất cả các chức năng trong dịch vụ nhắn tin sẽ đưa ra một ngoại lệ với ngoại lệ thông báo tên. Giao diện dịch vụ nhắn tin này sẽ được triển khai bởi các lớp cụ thể cho các công nghệ nhắn tin cụ thể.

Ví dụ: tôi đã tạo một bản triển khai dịch vụ nhắn tin cho Robert MQ. Mục đích của dịch vụ ở đây là triển khai dịch vụ nhắn tin và mã trong dịch vụ sử dụng ứng dụng Rabbit NQ.

Tôi cũng đã tổng hợp mục đích của lớp kiểm tra dịch vụ mà chúng ta sẽ sử dụng sau này để kiểm tra dịch vụ FOB này.

Bây giờ bạn đã hiểu giải pháp tổng thể và dịch vụ cơ sở hạ tầng nhắn tin, hãy tổng hợp mọi thứ lại với nhau để hiểu sự kiện xác nhận đặt chỗ sẽ diễn ra như thế nào.

Sơ đồ tuần tự mà tôi sắp thảo luận có sẵn trong tệp này. Vì đối tượng repo xác nhận đặt phòng sẽ tương tác với dịch vụ nhắn tin nên chúng ta sẽ thiết lập dịch vụ nhắn tin trên đối tượng báo cáo xác nhận đặt phòng.

Tổng hợp xác nhận đặt phòng sẽ thực hiện cập nhật trạng thái trên repo xác nhận đặt phòng để cập nhật trạng thái xác nhận đặt phòng.

Tại thời điểm này, báo cáo xác nhận đặt chỗ sẽ cập nhật trạng thái xác nhận đặt chỗ trong bộ lưu trữ liên tục và nếu điều đó thành công, nó sẽ công bố việc đặt chỗ đã được xác nhận ngay cả thông qua Dịch vụ cơ sở hạ tầng nhắn tin.

Dịch vụ cơ sở hạ tầng nhắn tin sau đó sẽ xuất bản việc đặt chỗ đã được xác nhận ngay cả đối với cơ sở hạ tầng cơ bản.

Trong trường hợp của chúng tôi, nó có MQ thỏ, sau đó nhà môi giới Rabbit và Q sẽ phân phối sự kiện dưới dạng tin nhắn cho tất cả những người đăng ký chẵn và thậm chí cả những người đăng ký sau đó sẽ thực hiện quá trình xử lý mong muốn của họ bằng cách sử dụng dữ liệu trong sự kiện.

Đã đến lúc xem lại những điểm chính trong bài giảng này. Điều đầu tiên là kho lưu trữ là một nơi tốt để nêu ra các sự kiện và lý do cho điều đó là do việc cập nhật tổng hợp và việc nâng cao sự kiện cần phải được thực hiện theo kiểu nguyên tử.

Vì vậy, thậm chí sẽ chỉ được nâng lên nếu đối tượng lưu trữ thành công trong quá trình triển khai repro. Bạn sẽ tìm hiểu thêm về nó trong một bài giảng sau.

Điểm mấu chốt thứ hai là mô hình không được có bất kỳ chi tiết nào về công nghệ nhắn tin cơ bản hoặc bất kỳ công nghệ nào.

Vì vậy, để bảo vệ mô hình khỏi bị hiểu biết về các công nghệ cơ sở hạ tầng cơ bản này, bạn phải sử dụng các dịch vụ cơ sở hạ tầng.

Vì vậy chúng tôi đã tạo ra dịch vụ cơ sở hạ tầng tin nhắn. Trong bài giảng tiếp theo, bạn sẽ thấy hoạt động của sự kiện xác nhận đặt chỗ đang diễn ra.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000012.srt-->

Trong bài học này, bạn sẽ tìm hiểu về cách triển khai các sự kiện tích hợp, cụ thể là việc đặt chỗ đã được xác nhận ngay cả bằng cách hướng dẫn mã và hai bài giảng trong bài giảng này.

Tôi sẽ đề cập đến việc thiết lập sàn giao dịch và Q trên Rabbitt MQ, sau đó tôi sẽ cung cấp cho bạn hướng dẫn chi tiết về dịch vụ cơ sở hạ tầng nhắn tin và sẽ kiểm tra dịch vụ cơ sở hạ tầng so với sàn giao dịch và Q được thiết lập trên MQ.

Cách chia đoạn mã đi qua hoạt động thành ba phần. Trong phần một, chúng ta sẽ thiết lập trao đổi và chủ đề trên Rabbitt MQ Broca, sau đó chúng ta sẽ thử nghiệm một phần để thử nghiệm dịch vụ nhắn tin cơ sở hạ tầng.

Sau đó, trong phần ba, tôi sẽ hướng dẫn bạn mã để triển khai sự kiện xác nhận đặt chỗ và cũng sẽ kiểm tra mã đó.

Trong bài giảng này tôi sẽ chỉ trình bày phần một và phần hai và trong bài giảng tiếp theo tôi sẽ trình bày phần ba.

Trong Phần một sẽ thực hiện bốn bước. Và bước số một, chúng ta sẽ thiết lập một cuộc trao đổi với tên Achmad hoặc chủ đề nhân viên bán hàng.

Và cuộc trao đổi này sẽ theo chủ đề ở bước hai sẽ thiết lập một Q với tên email hoặc thông báo ở bước ba, Q mới của Bindi với khóa định tuyến achmad hoặc doanh số bán hàng hoặc đặt chỗ đã được xác nhận.

Và trong bước bốn sẽ kiểm tra thiết lập này bằng cách xuất bản thông báo lên sàn giao dịch. Thông báo này sẽ kết thúc trong hàng thông báo e-mail.

Bước đầu tiên, đăng nhập vào cổng MQ trên đám mây, tôi đã có Acme travel ngay lập tức, nhấp vào trình quản lý Rabbit Amcu, đi tới các sàn giao dịch và điều đầu tiên bạn cần làm là tạo một sàn giao dịch.

Chúng tôi sẽ đặt tên cho chủ đề trao đổi Acme Auto Sales. Hãy chắc chắn rằng bạn thay đổi tiêu đề thành Papic và thêm trao đổi hoặc trao đổi được tạo.

Bây giờ đây là phần lọc tiếp theo của Exchange mà bạn nhấn vào Qs cho biết tên của hàng đợi như email thông báo và chỉ cần nhấn vào lúc gợi ý.

Nhấp vào Quay lại trao đổi và tất cả những gì chúng tôi cần để liên kết là xếp hàng đến Akhmad hoặc bán hàng hoặc trao đổi chủ đề hoặc nhấp vào trao đổi.

Vì vậy chúng ta cần cung cấp tên của email thông báo hàng đợi. Hàng đợi định tuyến sẽ là Achmad hoặc xác nhận đặt chỗ bắt đầu bán hàng và chỉ cần nhấn liên kết.

Tại thời điểm này, sàn giao dịch của chúng tôi có một hàng đợi bị ràng buộc bởi qinawi định tuyến này sẵn sàng kiểm tra.

Chỉ cần cuộn xuống, cung cấp khóa định tuyến achmad tất cả các đơn đặt hàng bắt đầu bán hàng đã xác nhận đây là bản thử nghiệm và xuất bản một tin nhắn được xuất bản.

Hãy quay lại email hoặc thông báo của Cuno. Và như bạn có thể thấy ở đây, có một tin nhắn. Hãy cuộn xuống và chúng ta sẽ nhận được một tin nhắn trên đó.

Và đây là thông điệp của chúng tôi. Vì vậy, Sarah đã làm việc ổn vào thời điểm này. Hãy đến Pakta trước khi tiếp tục.

Vui lòng đảm bảo rằng bạn đã thiết lập đúng MQ Purell trong thử nghiệm dịch vụ phụ của quán rượu. Nếu không làm như vậy sẽ dẫn đến Conexion thất bại.

Vì vậy, hãy sao chép MQ Purell từ trang chi tiết và dán nó vào phần kiểm tra dịch vụ bật lên. MQ b gạch dưới bạn là một biến trong phần hai sẽ kiểm tra dịch vụ cơ sở hạ tầng nhắn tin ở bước một sẽ đẩy thông báo email Q và bước hai sẽ thiết lập lớp kiểm tra bật lên để xuất bản một tin nhắn và sau đó sẽ chạy lớp.

Sau đó chúng ta sẽ chạy lớp này. Nó sẽ xuất bản một thông báo tới sàn giao dịch và thông báo đó sẽ xuất hiện trong thông báo qua email.

Giữ nguyên bước ba sẽ phục vụ mục đích của lớp kiểm tra là đăng ký nhận tin nhắn và sau đó lớp sẽ chạy.

Điều này sẽ tạo ra một đăng ký cho chủ đề và chúng tôi sẽ sử dụng giao diện người dùng để xuất bản một thông báo tới sàn giao dịch achmad hoặc bán chủ đề bằng khóa định tuyến achmad hoặc doanh số bán hàng không xác nhận đặt chỗ.

Và điều này sẽ dẫn đến việc người đăng ký của chúng tôi nhận được một tin nhắn và người đăng ký của chúng tôi sẽ chỉ in tin nhắn đó ra bảng điều khiển vì bước đầu tiên sẽ chuyển các tin nhắn từ email Q hoặc thông báo.

Vì vậy, hãy nhấp vào tín hiệu, nhấp vào email hoặc thông báo, cuộn xuống và nhấp vào nút để thanh lọc. Và như bạn có thể thấy bây giờ, không có tin nhắn nào trong hàng đợi. Bước tiếp theo là tôi sẽ hướng dẫn bạn qua lớp cơ sở hạ tầng dịch vụ nhắn tin và cách triển khai cụ thể, chọn hành vi gói, không phải bán hàng, không phải tiện ích đạo đức hay thậm chí là nhắn tin.

Đây là giao diện dịch vụ nhắn tin của chúng tôi. Bạn sẽ tìm thấy các hàm đơn giản ở đây và bạn sẽ quan sát thấy rằng tất cả các hàm này đang đưa ra ngoại lệ nhắn tin được xác định ở đây.

Hàm đăng ký ở đây yêu cầu một phiên bản của trình xử lý tin nhắn và đây là trình xử lý tin nhắn, chỉ có một hàm trong đó.

Vì vậy, các giao diện và lớp này là định nghĩa dịch vụ cơ sở hạ tầng của chúng tôi. Việc triển khai thực tế cho Rabbit MQ có sẵn trong gói Kondor Acme Dot Dot, Rabbit MQ và dịch vụ nhắn tin được triển khai bởi các lớp dịch vụ.

Như bạn có thể thấy ở đây, việc triển khai lớp này đang sử dụng ứng dụng Rabbit MQ. Không, tôi sẽ không hướng dẫn bạn.

Tất cả API đều được sử dụng trong quá trình triển khai này, nhưng bạn sẽ thấy rằng tôi đã đưa liên kết đến các ứng dụng mà tôi đã sử dụng.

Nếu bạn muốn tìm hiểu sâu hơn về Rabbit MPU, tôi khuyên bạn nên xem hướng dẫn API này và sau đó khi bạn xem mã trong lớp này, hãy tìm các liên kết mà tôi đã đưa vào nhận xét để kiểm tra việc triển khai của dịch vụ nhắn tin của chúng tôi.

Chúng tôi sẽ sử dụng lớp thử nghiệm dịch vụ phụ trong lớp này. Bạn sẽ thấy rằng tất cả đã được thiết lập để thực thi để kiểm tra chức năng công cộng, chỉ phát hiện ra các phần nổi bật của dịch vụ chứ không xuất bản và nhận xét bài kiểm tra người đăng ký.

Và bây giờ chúng tôi có thể thử nghiệm dịch vụ để kiểm tra một cách đơn giản. Bấm và chạy. Vì vậy, điều này sẽ xuất bản một thông điệp cho chủ đề này, Achmad.

Không bán hàng, không xác nhận đặt phòng. Chúng ta hãy tiếp tục kiểm tra Q Và đúng như dự đoán, chúng ta sẽ thấy một thông báo ở đây để kiểm tra nội dung của tin nhắn.

Chỉ cần cuộn xuống, nhận được tin nhắn. Và đây là nội dung tin nhắn chạy thử nghiệm đăng ký.

Quay trở lại chức năng chính, chỉ huy mục đích dịch vụ, không xuất bản và Unkovic dòng này tại thời điểm này chúng tôi đã sẵn sàng kiểm tra ngay trước đó, chỉ cần dừng kiểm tra trước đó một lần nữa.

Chạy cho bài kiểm tra này. Bạn sẽ thấy rằng trong thử nghiệm này, chúng tôi đã đăng ký chủ đề xác nhận đặt phòng Achmad hoặc bắt đầu bán hàng.

Vì vậy, điều đó có nghĩa là nếu tôi xuất bản một thông báo tới sàn giao dịch Achmad bán chủ đề đó, thì người đăng ký của chúng tôi sẽ có thể nhận được nó.

Và như bạn có thể thấy ở đây, hiện tại có hai người đăng ký. Một là thuê bao tĩnh mà chúng tôi đã tạo và thuê bao này là thuê bao dành cho mã đang chạy trong bảng điều khiển.

Hãy tiếp tục và xuất bản một tin nhắn. Chúng tôi cần cung cấp khóa định tuyến bán hàng achmad, hãy bắt đầu đặt chỗ.

Và tôi sẽ chỉ nói từ tin nhắn đã xuất bản của bạn, tin nhắn đã xuất bản, hãy quay lại bảng điều khiển và đây là tin nhắn của chúng tôi.

Hãy thử một lần nữa. Tôi sẽ chỉ đặt tin nhắn được xuất bản thử nghiệm thứ hai và đây là thử nghiệm thứ hai của chúng tôi. Và lúc này, chúng ta cũng sẽ thấy tin nhắn trong thông báo qua email.

<!--@ \08EventsDrivenArchitectureDomainEvents_VVN\000000013.srt-->

Đây là phần hai của hướng dẫn mã về các sự kiện tích hợp trong bài học này. Tôi sẽ hướng dẫn bạn cách triển khai kho lưu trữ để xác nhận đăng ký.

Sau đó, tôi sẽ hướng dẫn bạn mã mà chúng tôi sẽ sử dụng để kiểm tra sự kiện tích hợp. Và cuối cùng, chúng ta sẽ thấy sự kiện xác nhận đặt chỗ đang diễn ra.

Xin nhắc nhanh, mã mà tôi đang hướng dẫn bạn trong bài giảng này có sẵn ở nhánh cổng.

Nhớ lại bài giảng trước rằng repo xác nhận đặt phòng là cái làm tăng việc xác nhận đặt phòng.

Mặc dù vậy, để nâng cao sự kiện, tôi đã điều chỉnh lại repo xác nhận đặt phòng giả mạo bằng cách thêm hai chức năng mới vào chức năng đầu tiên là thiết lập dịch vụ nhắn tin.

Đây là chức năng sẽ được sử dụng để thiết lập phiên bản của dịch vụ nhắn tin trên đối tượng giả mạo người xác nhận đặt phòng.

Và chức năng thứ hai là chức năng trạng thái cập nhật, sẽ được gọi từ tổng hợp xác nhận đặt chỗ để cập nhật trạng thái của xác nhận đặt chỗ theo đức tin kho xác nhận đặt chỗ lớp và bạn sẽ tìm thấy chức năng dịch vụ nhắn tin lên có một phiên bản của tin nhắn service làm đối số và nó trên dịch vụ nhắn tin biến thể hiện trong hàm bước cập nhật.

Nếu trạng thái đang được cập nhật để phù hợp thì siêu dữ liệu sự kiện sẽ được tạo. Siêu dữ liệu này chỉ có tham chiếu khách hàng và tham chiếu đặt chỗ, sau đó dịch vụ nhắn tin sẽ xuất bản dữ liệu dưới dạng sự kiện.

Vì vậy, trong thiết lập này, chúng tôi không gửi tất cả dữ liệu trong tải trọng nhưng chúng tôi có thể làm điều đó rất tốt bằng cách thay thế mã này tại đây.

Khi người đàn áp, sự kiện xảy ra, nó sẽ in ra thông báo này trên bảng điều khiển. Hãy để tôi giải thích cách chúng tôi sẽ thực hiện bài kiểm tra.

Chúng tôi sẽ sử dụng bài kiểm tra thứ tự thanh toán lớp mà chúng tôi đã sử dụng cho bài kiểm tra trước đó. Trước đó, chúng tôi đã chạy thử nghiệm với tính năng nhắn tin bị tắt.

Bây giờ chúng ta sẽ kích hoạt dịch vụ nhắn tin theo thứ tự thanh toán. Lớp kiểm tra sẽ tạo một phiên bản của dịch vụ bật lên.

Sau đó, chúng tôi sẽ bắt đầu phiên bản dịch vụ bật lên trên kho lưu trữ xác nhận đặt phòng giả. Sau đó, chúng ta sẽ chạy lớp kiểm tra lệnh thanh toán và sau đó chúng ta sẽ thấy việc đặt chỗ đã được xác nhận, thậm chí được xuất bản để lấy nó trong email hoặc thông báo.

Q Bước đầu tiên, chúng tôi cần đảm bảo rằng chúng tôi có thiết lập kết hợp phù hợp và lớp thanh toán hoặc thử nghiệm.

Vì vậy, vui lòng tiếp tục, sao chép M Kupwara từ trang chi tiết và dán nó vào hàng kiểm tra đơn đặt hàng thanh toán trong biến Amcu gạch dưới Eurail mở lớp tài sản kiểm tra thanh toán đang được thử nghiệm mô hình bán hàng Kamelot Ackmann.

Ngay cả trong quá trình kiểm tra và đây là lớp kiểm tra lệnh thanh toán của chúng tôi được gọi đến chức năng chính và bạn sẽ thấy lệnh gọi tới thông báo thiết lập trên dòng này.

Đây là một chức năng địa phương. Chúng ta hãy xem nhanh chức năng này và chức năng này. Bạn sẽ thấy rằng tôi đang tạo phiên bản lớp dịch vụ bật lên, gửi các thuộc tính cho Amcu P, sau đó khởi động dịch vụ nhắn tin.

Nếu bạn chưa nói Eurail hoặc nếu có bất kỳ vấn đề kết nối nào thì lúc này sẽ có ngoại lệ và quá trình kiểm tra sẽ dừng lại.

Nếu không, dịch vụ nhắn tin sẽ được đặt trên đối tượng repo xác nhận đặt phòng. Bây giờ chúng ta đã sẵn sàng chạy thử nghiệm, nhưng trước đó, hãy đẩy hàng đợi, đi tới Qs được gửi qua email hoặc thông báo, cuộn xuống và lọc thư.

Không, chúng tôi không có tin nhắn nào trong hàng đợi. Hãy tiếp tục và chạy thử nghiệm. Chạy thử nghiệm đúng. Bấm và chạy.

Sau đó, bạn sẽ chạy thử nghiệm này. Nó sẽ thực hiện nhiều hoạt động thông qua các kho lưu trữ giả mạo.

Thử nghiệm này tương tự như thử nghiệm trước đó, ngoại trừ việc lần này kho lưu trữ giả mạo đang phát sinh một sự kiện.

Đây là thông báo đến từ việc triển khai kho lưu trữ giả mạo để xác nhận đặt chỗ.

Như bạn có thể thấy ở đây, một sự kiện đã được nêu ra. Hãy kiểm tra Q và trong Q, như mong đợi, chúng ta thấy một thông báo và nếu nhận được thông báo, chúng ta sẽ thấy nội dung thông báo cho sự kiện.
