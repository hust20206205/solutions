<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\01 Course Ouline\001 Author introductions and Course outline.en.srt -->

1

00:00:00,240 --> 00:00:03,520

Domain driven design and micro services for architects.



2

00:00:03,540 --> 00:00:05,670

Thank you for joining my calls.



3

00:00:06,090 --> 00:00:10,980

My name is Rajeev Sakya and I will be your instructor for this course.



4

00:00:11,120 --> 00:00:17,690

I've put the content on this course based on my experiences working as a consultant for over a decade,



5

00:00:18,090 --> 00:00:22,910

I've helped multiple organizations in building micro services applications.



6

00:00:23,550 --> 00:00:31,620

My focus in this quote is on the architects, architects and Microsoft's applications play a very important



7

00:00:31,620 --> 00:00:33,610

role now since we are on the roll.



8

00:00:33,630 --> 00:00:36,060

Let's talk about architectural software.



9

00:00:36,060 --> 00:00:43,980

Architect makes high level design choices based on their experiences, knowledge and understanding of



10

00:00:43,980 --> 00:00:48,380

the software models, standard tools and techniques in the schools.



11

00:00:48,720 --> 00:00:55,980

I'll help you with building knowledge and understanding of micro services as a micro services architect



12

00:00:55,980 --> 00:01:00,780

and I.T. professional must have knowledge of all aspects of micro services.



13

00:01:01,020 --> 00:01:07,620

They need to focus on the business value of micro services, not just the technology aspects of micro



14

00:01:07,620 --> 00:01:08,970

services architecture.



15

00:01:08,970 --> 00:01:14,430

As a micro services expert, they're responsible for guiding the I.T. and business leaders.



16

00:01:14,700 --> 00:01:19,380

They're responsible for mentoring the micro services development teams.



17

00:01:19,380 --> 00:01:25,470

Overall, an architect is responsible for the delivery of targeted business benefits of micro services.



18

00:01:25,710 --> 00:01:31,350

An architect does not need to be hands on on every technology related to micro services.



19

00:01:31,650 --> 00:01:38,320

It is good to be hands on, but it is not required for an architect to be hands on since you are here.



20

00:01:38,670 --> 00:01:46,530

I'm guessing that either you are an existing architect or trying to become an architect for micro services



21

00:01:46,530 --> 00:01:47,410

initiatives.



22

00:01:47,520 --> 00:01:54,770

This course will help you build a solid foundation and Demand-Driven Design and micro services architecture.



23

00:01:55,350 --> 00:02:01,020

At the end of this course, you will be in a position to guide the micro services teams through the



24

00:02:01,020 --> 00:02:04,830

process of building micro services applications.



25

00:02:05,580 --> 00:02:07,740

Discourse is divided into two parts.



26

00:02:07,740 --> 00:02:10,260

In part one, the focus will be on business.



27

00:02:10,530 --> 00:02:12,600

You will learn the domain driven design.



28

00:02:12,750 --> 00:02:20,130

You will learn how to apply the domain to one design strategic patterns such as ubiquitous language,



29

00:02:20,130 --> 00:02:22,680

bounded contacts and other patterns.



30

00:02:22,950 --> 00:02:25,650

In part to the focus is on technology.



31

00:02:25,950 --> 00:02:32,760

You will learn to apply the various technical patterns to your micro services components, and by the



32

00:02:32,760 --> 00:02:39,540

end of this part you will be in a position to make appropriate design choices for your micro services.



33

00:02:39,780 --> 00:02:42,110

There are three types of lessons in this course.



34

00:02:42,120 --> 00:02:44,610

The first type are the concepts that examples.



35

00:02:44,970 --> 00:02:47,250

The second type are the exercises.



36

00:02:47,250 --> 00:02:48,960

In the lessons on exercises.



37

00:02:48,960 --> 00:02:56,220

You will be given a micro services modeling or design problem and then I'll walk you through the solution



38

00:02:56,220 --> 00:02:56,940

to the problem.



39

00:02:57,090 --> 00:03:00,540

Then there are hands on lessons and the hands on lessons.



40

00:03:00,750 --> 00:03:06,900

I'll provide you a walkthrough of UML design and implementation of micro services components.



41

00:03:07,080 --> 00:03:13,080

If interested, you can set up the court on your own machine and try it out locally.



42

00:03:13,200 --> 00:03:15,300

Quizzes are part of the lessons.



43

00:03:15,300 --> 00:03:22,050

I'll prompt you to respond to my questions and then I'll discuss the solution to those quizzes in a



44

00:03:22,050 --> 00:03:22,890

later lecture.



45

00:03:22,890 --> 00:03:29,340

In this section, you will learn how to set up the sample code locally on your machine.



46

00:03:29,550 --> 00:03:37,590

You'll also learn about to UML, which is the modelling tool I'm using for creating the UML models for



47

00:03:37,590 --> 00:03:39,090

the sample micro services.



48

00:03:39,750 --> 00:03:41,370

Now, a couple of quick tips.



49

00:03:41,370 --> 00:03:47,790

You have full control on the playback speed of the video to control the speed of the video, click on



50

00:03:47,790 --> 00:03:51,330

the button under the video and then select the speed.



51

00:03:51,540 --> 00:03:57,480

Try out a couple of these speeds to see what works best for you as you will start going through the



52

00:03:57,480 --> 00:04:03,630

course, you will have questions the first place where you should look for answers in the Q&amp;A forum.



53

00:04:03,840 --> 00:04:08,820

Under the video, you will find the Q&amp;A tab in the search box and the Q&amp;A forum.



54

00:04:08,820 --> 00:04:15,240

You can provide some towns related to the question that you have and you will see the responses to questions



55

00:04:15,240 --> 00:04:16,560

similar to your question.



56

00:04:16,650 --> 00:04:22,650

If you are unable to find a satisfactory response to your question, then click on the ask a new question



57

00:04:22,650 --> 00:04:25,080

and provide as many details as possible.



58

00:04:25,710 --> 00:04:29,430

Last but not least, your feedback is extremely important for me.



59

00:04:29,580 --> 00:04:34,030

Please do not hesitate to share your thoughts on how I can improve this course.



60

00:04:34,080 --> 00:04:34,680

Once again.



61

00:04:35,010 --> 00:04:37,440

Thank you for joining my you in the class.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\01 Course Ouline\002 Development tools and setup.en.srt -->

1

00:00:00,330 --> 00:00:06,360

Development environment set up, please follow the instructions that I'll provide you in this lesson



2

00:00:06,600 --> 00:00:13,440

so that by the end of this lesson, you have the environment set up that you will use in this course,



3

00:00:13,440 --> 00:00:16,680

we will be setting up intelligence as the IDY.



4

00:00:16,740 --> 00:00:23,580

I'll provide you an overview of how the code for this cause is organized and repositories and branches.



5

00:00:23,580 --> 00:00:31,170

And you learn about the plant you animal extension that we will be using for creating UML diagrams.



6

00:00:31,800 --> 00:00:38,420

You need an integrated development environment to walk to the code and the UML in this code.



7

00:00:38,610 --> 00:00:45,390

I'm using the intelligence community addition as the IDY, but other IDs are fine too.



8

00:00:45,840 --> 00:00:50,940

If you already have the intelligent setup on your machine, you may skip the next step.



9

00:00:50,940 --> 00:00:56,130

Otherwise, please go ahead and open the download link for intelligent.



10

00:00:56,280 --> 00:00:58,290

Select the appropriate platform.



11

00:00:58,680 --> 00:01:01,860

It is available for Windows, Mac and Linux.



12

00:01:02,010 --> 00:01:05,310

Click on the download button for the community edition.



13

00:01:05,730 --> 00:01:12,330

Once the download is completed, double click on the downloaded file and follow the instruction to set



14

00:01:12,330 --> 00:01:17,460

up intelligence on your machine to set up the project locally on your machine.



15

00:01:17,460 --> 00:01:25,500

Launched the intelligent Idy and then we will use the Getaround version control option to fetch the



16

00:01:25,530 --> 00:01:27,990

course repository to your local machine.



17

00:01:28,650 --> 00:01:34,770

Important thing to keep in mind is that the code and UML model for this course are available in multiple



18

00:01:35,100 --> 00:01:36,480

GitHub repositories.



19

00:01:36,480 --> 00:01:41,850

Each of these repositories will be set up in a separate, intelligent project.



20

00:01:41,850 --> 00:01:47,280

In the next step will set up our first project with the sealed repository.



21

00:01:47,820 --> 00:01:55,530

Open up the link GitHub dot com slash iCloud fan click on repositories just type sales dash one.



22

00:01:55,530 --> 00:01:58,430

And this is the repository that we are going to clone.



23

00:01:58,500 --> 00:02:05,550

Click on code and click on this button to copy the link to the Great Repository as a next step, launch



24

00:02:05,550 --> 00:02:12,120

intelligent and click on Get from version control, paste the link and hit clone.



25

00:02:12,150 --> 00:02:17,940

At this point, Intelligent is cloning the repository and setting up the project for you.



26

00:02:18,070 --> 00:02:21,300

Give it a few minutes and you will have your workspace ready.



27

00:02:21,780 --> 00:02:26,550

The code in these repositories is organized in multiple branches.



28

00:02:26,730 --> 00:02:33,210

In the beginning of the Hands-On lectures, I will provide you the instructions for switching to a particular



29

00:02:33,330 --> 00:02:37,860

repository and a specific branch within that repository.



30

00:02:38,070 --> 00:02:46,420

The human diagrams are available under the subdirectories within the folder program after intelligence



31

00:02:46,420 --> 00:02:48,990

has cloned the code from the repository.



32

00:02:48,990 --> 00:02:55,590

If you see a blank screen, just click on View Tool Windows and click on Project.



33

00:02:56,100 --> 00:03:02,880

This will show you the Project Explorer to check out various branches in this repository, click on



34

00:03:02,880 --> 00:03:06,180

View Tool Windows and click on GET.



35

00:03:06,420 --> 00:03:08,610

And these are the various repositories.



36

00:03:08,640 --> 00:03:14,220

Now, at this time, the Master Branch is checked out to check out a different branch.



37

00:03:14,220 --> 00:03:15,750

Just select the branch.



38

00:03:15,750 --> 00:03:22,380

Right, click on it and select check out when you check out for the first time internally will take



39

00:03:22,380 --> 00:03:25,830

a couple of minutes to download the branch and to build a code.



40

00:03:25,830 --> 00:03:33,390

Each branch has read me file this read me file provides all the instructions which are covered in the



41

00:03:33,390 --> 00:03:34,020

videos.



42

00:03:34,050 --> 00:03:37,380

It also tells you which branch you are on.



43

00:03:37,560 --> 00:03:45,510

The Java source is available under the SRT folder and here you will see all of the Java classes.



44

00:03:45,690 --> 00:03:53,670

Since the course uses UML for modeling the micro services, we need a tool for drawing these UML diagrams.



45

00:03:53,880 --> 00:03:57,930

I decided to use client UML for that plan to.



46

00:03:57,930 --> 00:04:03,510

UML is used to draw UML diagrams using a human readable text description.



47

00:04:03,660 --> 00:04:10,830

So what that means is it is not a drawing tool like visual or draw IO.



48

00:04:11,820 --> 00:04:17,310

The designer has to provide the design details in the form of text, file and plant.



49

00:04:17,320 --> 00:04:21,810

UML uses that file to create the model diagram.



50

00:04:22,500 --> 00:04:29,220

Since Plant UML is not a modelling tool, it does not enforce any modeling rules.



51

00:04:29,220 --> 00:04:35,160

So if you are making a mistake in the model, that mistake will not be caught by the plant.



52

00:04:35,160 --> 00:04:35,940

You too.



53

00:04:36,330 --> 00:04:40,640

We will be using the plant UML extension for Intelligent.



54

00:04:41,010 --> 00:04:48,630

So what I would suggest to you at this point is open up your ontology, click on file settings and then



55

00:04:48,630 --> 00:04:51,990

click on plugins and type plant UML.



56

00:04:52,410 --> 00:04:54,900

This is the plugin that we need to install.



57

00:04:55,080 --> 00:04:59,760

So click on install and install the plugin in your intelligent.



58

00:05:00,830 --> 00:05:07,520

I only have the plant here plugin installed in my intelligent environment after you have successfully



59

00:05:07,520 --> 00:05:14,330

installed, you should verify if the installation was successful to do that, click on Installed and



60

00:05:14,330 --> 00:05:20,520

you should see plant integration extension in the installed plug ins list.



61

00:05:20,750 --> 00:05:22,610

Now, let me show you how this works.



62

00:05:22,760 --> 00:05:29,660

Click on the UML folder and click on the file that is available under the German folder.



63

00:05:29,930 --> 00:05:33,690

This is a test file that was generated by applying to UML.



64

00:05:33,890 --> 00:05:36,800

And as you can see here, this is a class diagram.



65

00:05:37,040 --> 00:05:42,020

I won't go through the details in this file, but if you are interested in learning more about plant



66

00:05:42,020 --> 00:05:45,080

UML, please check out Plant Yamal dot com.



67

00:05:45,500 --> 00:05:52,650

And if you would like to try out creating some other files here, just click on New Plant YAML file.



68

00:05:52,700 --> 00:05:55,130

Pick up the diagram type, for example.



69

00:05:55,130 --> 00:06:01,240

I can say test sequence dot p UML, which is extension for plant human.



70

00:06:01,400 --> 00:06:06,790

And as you can see here, this is a sequence diagram created by Plant UML.



71

00:06:07,010 --> 00:06:15,680

If the plant UML extension is not showing you the UML diagrams, then most probably the reason is that



72

00:06:15,680 --> 00:06:22,340

the graph is library on which the plant Yamal depends has not been installed to install.



73

00:06:22,340 --> 00:06:23,450

The graph is library.



74

00:06:23,720 --> 00:06:30,800

Follow the instructions available at this link after installing the graph is library restart intelligent



75

00:06:31,010 --> 00:06:32,840

and that should solve the problem.



76

00:06:33,470 --> 00:06:39,290

The project in the scores are set up to use Gradle as the build automation tool.



77

00:06:39,530 --> 00:06:44,510

Each branch has the dependencies defined in the buildout gradle file.



78

00:06:44,750 --> 00:06:51,080

If you would like to learn more about Gradle, please visit griddled or or at this point you should



79

00:06:51,080 --> 00:06:54,680

have the development environment set up on your machine.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\01CourseOuline_VVN\000000001.srt -->

Tóm tắt nội dung của file srt thành các   gạch đầu dòng:

1
00:00:00,240 --> 00:00:10,980
Thiết kế hướng miền và các dịch vụ vi mô dành cho kiến ​​trúc sư.  Cảm ơn bạn đã tham gia cuộc gọi của tôi.  Tên tôi là Rajeev Sakya và tôi sẽ là người hướng dẫn bạn khóa học này.

2
00:00:11,120 --> 00:00:22,910
Tôi đưa nội dung vào khóa học này dựa trên kinh nghiệm làm cố vấn trong hơn một thập kỷ, tôi đã giúp nhiều tổ chức xây dựng các ứng dụng dịch vụ vi mô.

3
00:00:23,550 --> 00:00:33,610
Trọng tâm của tôi trong trích dẫn này là các kiến ​​trúc sư, các kiến ​​trúc sư và các ứng dụng của Microsoft hiện đóng một vai trò rất quan trọng kể từ khi chúng tôi bắt đầu triển khai.

4
00:00:33,630 --> 00:00:48,380
Hãy nói về phần mềm kiến ​​trúc.  Kiến trúc sư đưa ra các lựa chọn thiết kế cấp cao dựa trên kinh nghiệm, kiến ​​thức và hiểu biết của họ về các mô hình phần mềm, công cụ và kỹ thuật tiêu chuẩn trong trường học.

5
00:00:48,720 --> 00:01:00,780
Tôi sẽ giúp bạn xây dựng kiến ​​thức và hiểu biết về các dịch vụ vi mô với tư cách là kiến ​​trúc sư dịch vụ vi mô và CNTT.  chuyên gia phải có kiến ​​thức về tất cả các khía cạnh của dịch vụ vi mô.

6
00:01:01,020 --> 00:01:08,970
Họ cần tập trung vào giá trị kinh doanh của các dịch vụ vi mô, chứ không chỉ các khía cạnh công nghệ của kiến ​​trúc dịch vụ vi mô.

7
00:01:08,970 --> 00:01:19,380
Với tư cách là chuyên gia về dịch vụ vi mô, họ chịu trách nhiệm hướng dẫn hệ thống CNTT.  và lãnh đạo doanh nghiệp.  Họ chịu trách nhiệm cố vấn cho các nhóm phát triển dịch vụ vi mô.

8
00:01:19,380 --> 00:01:25,470
Nhìn chung, kiến ​​trúc sư chịu trách nhiệm cung cấp các lợi ích kinh doanh có mục tiêu của các dịch vụ vi mô.

9
00:01:25,710 --> 00:01:38,320
Một kiến ​​trúc sư không cần phải nắm vững mọi công nghệ liên quan đến các dịch vụ vi mô.  Bắt tay vào làm thì tốt, nhưng kiến ​​trúc sư không bắt buộc phải bắt tay vào vì bạn đã ở đây.

10
00:01:38,670 --> 00:01:47,410
Tôi đoán rằng bạn là một kiến ​​trúc sư hiện tại hoặc đang cố gắng trở thành kiến ​​trúc sư cho các sáng kiến ​​​​dịch vụ vi mô.

11
00:01:47,520 --> 00:01:54,770
Khóa học này sẽ giúp bạn xây dựng một nền tảng vững chắc và kiến ​​trúc Thiết kế theo nhu cầu và các dịch vụ vi mô.

12
00:01:55,350 --> 00:02:04,830
Khi kết thúc khóa học này, bạn sẽ có thể hướng dẫn các nhóm dịch vụ vi mô trong quá trình xây dựng các ứng dụng dịch vụ vi mô.

13
00:02:05,580 --> 00:02:12,600
Bài thuyết trình được chia thành hai phần.  Trong phần một, trọng tâm sẽ là kinh doanh.  Bạn sẽ học thiết kế hướng miền.

14
00:02:12,750 --> 00:02:22,680
Bạn sẽ học cách áp dụng miền cho một mẫu chiến lược thiết kế chẳng hạn như ngôn ngữ phổ biến, địa chỉ liên hệ bị giới hạn và các mẫu khác.

15
00:02:22,950 --> 00:02:39,540
Một phần trọng tâm là về công nghệ.  Bạn sẽ học cách áp dụng các mẫu kỹ thuật khác nhau cho các thành phần dịch vụ vi mô của mình và khi kết thúc phần này, bạn sẽ có thể đưa ra các lựa chọn thiết kế phù hợp cho các dịch vụ vi mô của mình.

16
00:02:39,780 --> 00:02:47,250
Có ba loại bài học trong khóa học này.  Loại đầu tiên là các khái niệm có ví dụ.  Loại thứ hai là các bài tập.

17
00:02:47,250 --> 00:02:56,940
Trong các bài học về bài tập.  Bạn sẽ được giao một vấn đề về thiết kế hoặc lập mô hình dịch vụ vi mô và sau đó tôi sẽ hướng dẫn bạn giải pháp cho vấn đề đó.

18
00:02:57,090 --> 00:03:06,900
Sau đó là các bài học thực hành và các bài học thực hành.  Tôi sẽ cung cấp cho bạn hướng dẫn chi tiết về thiết kế UML và triển khai các thành phần dịch vụ vi mô.

19
00:03:07,080 --> 00:03:15,300
Nếu quan tâm, bạn có thể thiết lập sân trên máy của riêng mình và dùng thử tại địa phương.  Câu đố là một phần của bài học.

20
00:03:15,300 --> 00:03:22,890
Tôi sẽ nhắc bạn trả lời các câu hỏi của tôi và sau đó tôi sẽ thảo luận về giải pháp cho những câu hỏi đó trong bài giảng sau.

21
00:03:22,890 --> 00:03:39,090
Trong phần này, bạn sẽ tìm hiểu cách thiết lập mã mẫu cục bộ trên máy của mình.  Bạn cũng sẽ tìm hiểu về UML, đây là công cụ tạo mô hình mà tôi đang sử dụng để tạo mô hình UML cho các dịch vụ vi mô mẫu.

22
00:03:39,750 --> 00:03:51,330
Bây giờ, một vài lời khuyên nhanh chóng.  Bạn có toàn quyền kiểm soát tốc độ phát lại của video để kiểm soát tốc độ của video, nhấp vào nút bên dưới video rồi chọn tốc độ.

23
00:03:51,540 --> 00:04:03,630
Hãy thử một vài tốc độ trong số này để xem tốc độ nào phù hợp nhất với bạn khi bạn bắt đầu tham gia khóa học, bạn sẽ có câu hỏi đầu tiên mà bạn nên tìm kiếm câu trả lời trong diễn đàn Hỏi & Đáp.

24
00:04:03,840 --> 00:04:16,560
Trong video, bạn sẽ tìm thấy tab Hỏi đáp trong hộp tìm kiếm và diễn đàn Hỏi đáp.  Bạn có thể cung cấp một số thị trấn liên quan đến câu hỏi mà bạn có và bạn sẽ thấy câu trả lời cho những câu hỏi tương tự với câu hỏi của bạn.

25
00:04:16,650 --> 00:04:25,080
Nếu bạn không thể tìm thấy câu trả lời thỏa đáng cho câu hỏi của mình, hãy nhấp vào đặt câu hỏi mới và cung cấp càng nhiều chi tiết càng tốt.

26
00:04:25,710 --> 00:04:34,030
Cuối cùng nhưng không kém phần quan trọng, phản hồi của bạn cực kỳ quan trọng đối với tôi. Xin vui lòng chia sẻ suy nghĩ của bạn về cách tôi có thể cải thiện khóa học này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\01CourseOuline_VVN\000000002.srt -->

1
00:00:00,330 --> 00:00:16,680
Đã thiết lập môi trường phát triển, vui lòng làm theo hướng dẫn mà tôi sẽ cung cấp cho bạn trong bài học này để đến cuối bài học này, bạn đã thiết lập xong môi trường mà bạn sẽ sử dụng trong khóa học này, chúng ta sẽ thiết lập trí thông minh với tư cách là IDY.

2
00:00:16,740 --> 00:00:23,580
Tôi sẽ cung cấp cho bạn cái nhìn tổng quan về cách tổ chức mã cho mục đích này cũng như các kho lưu trữ và các nhánh.

3
00:00:23,580 --> 00:00:38,420
Và bạn tìm hiểu về tiện ích mở rộng động vật thực vật mà chúng ta sẽ sử dụng để tạo sơ đồ UML.  Bạn cần một môi trường phát triển tích hợp để tiếp cận mã và UML trong mã này.

4
00:00:38,610 --> 00:00:50,940
Tôi đang sử dụng phần bổ sung của cộng đồng tình báo làm IDY, nhưng các ID khác cũng ổn.  Nếu bạn đã cài đặt thông minh trên máy của mình, bạn có thể bỏ qua bước tiếp theo.

5
00:00:50,940 --> 00:00:58,290
Nếu không thì hãy tiếp tục và mở liên kết tải xuống cho thông minh.  Chọn nền tảng thích hợp.

6
00:00:58,680 --> 00:01:17,460
Nó có sẵn cho Windows, Mac và Linux.  Nhấp vào nút tải xuống cho phiên bản cộng đồng.  Sau khi quá trình tải xuống hoàn tất, hãy nhấp đúp vào tệp đã tải xuống và làm theo hướng dẫn để thiết lập thông minh trên máy của bạn nhằm thiết lập dự án cục bộ trên máy của bạn.

7
00:01:17,460 --> 00:01:27,990
Ra mắt Idy thông minh và sau đó chúng tôi sẽ sử dụng tùy chọn kiểm soát phiên bản Getaround để tìm nạp kho lưu trữ khóa học về máy cục bộ của bạn.

8
00:01:28,650 --> 00:01:36,480
Điều quan trọng cần lưu ý là mã và mô hình UML cho khóa học này có sẵn trong nhiều kho GitHub.

9
00:01:36,480 --> 00:01:47,280
Mỗi kho lưu trữ này sẽ được thiết lập trong một dự án thông minh, riêng biệt.  Trong bước tiếp theo sẽ thiết lập dự án đầu tiên của chúng ta với kho lưu trữ kín.

10
00:01:47,820 --> 00:01:58,430
Mở liên kết GitHub dot com gạch chéo iCloud fan nhấp vào kho chỉ cần gõ một dấu gạch ngang bán hàng.  Và đây là kho lưu trữ mà chúng ta sẽ sao chép.

11
00:01:58,500 --> 00:02:12,120
Nhấp vào mã và nhấp vào nút này để sao chép liên kết đến Great Repository trong bước tiếp theo, khởi chạy thông minh và nhấp vào Nhận từ kiểm soát phiên bản, dán liên kết và nhấn bản sao.

12
00:02:12,150 --> 00:02:21,300
Tại thời điểm này, Thông minh đang sao chép kho lưu trữ và thiết lập dự án cho bạn.  Hãy chờ vài phút và bạn sẽ có không gian làm việc sẵn sàng.

13
00:02:21,780 --> 00:02:37,860
Mã trong các kho lưu trữ này được tổ chức thành nhiều nhánh.  Khi bắt đầu bài giảng Thực hành, tôi sẽ cung cấp cho bạn hướng dẫn để chuyển sang một kho lưu trữ cụ thể và một nhánh cụ thể trong kho lưu trữ đó.

14
00:02:38,070 --> 00:02:48,990
Sơ đồ con người có sẵn trong các thư mục con trong chương trình thư mục sau khi trí thông minh đã sao chép mã từ kho lưu trữ.

15
00:02:48,990 --> 00:03:06,180
Nếu bạn thấy một màn hình trống, chỉ cần nhấp vào View Tool Windows và nhấp vào Project.  Thao tác này sẽ hiển thị cho bạn Project Explorer để kiểm tra các nhánh khác nhau trong kho lưu trữ này, nhấp vào Xem công cụ Windows và nhấp vào NHẬN.

16
00:03:06,420 --> 00:03:14,220
Và đây là những kho lưu trữ khác nhau.  Bây giờ, tại thời điểm này, Chi nhánh chính được kiểm tra để kiểm tra một chi nhánh khác.

17
00:03:14,220 --> 00:03:25,830
Chỉ cần chọn chi nhánh.  Đúng, nhấp vào nó và chọn thanh toán khi bạn thanh toán nội bộ lần đầu tiên. Bạn sẽ mất vài phút để tải xuống chi nhánh và tạo mã.

18
00:03:25,830 --> 00:03:34,020
Mỗi chi nhánh đều có tệp đọc cho tôi, tệp đọc cho tôi này cung cấp tất cả các hướng dẫn có trong video.

19
00:03:34,050 --> 00:03:45,510
Nó cũng cho bạn biết bạn đang ở chi nhánh nào.  Nguồn Java có sẵn trong thư mục SRT và tại đây bạn sẽ thấy tất cả các lớp Java.

20
00:03:45,690 --> 00:03:53,670
Vì khóa học sử dụng UML để mô hình hóa các dịch vụ vi mô nên chúng ta cần một công cụ để vẽ các sơ đồ UML này.

21
00:03:53,880 --> 00:04:03,510
Tôi quyết định sử dụng UML khách cho kế hoạch đó.  UML được sử dụng để vẽ sơ đồ UML bằng cách sử dụng mô tả văn bản mà con người có thể đọc được.

22
00:04:03,660 --> 00:04:17,310
Vậy điều đó có nghĩa là nó không phải là một công cụ vẽ như visual hay draw IO.  Người thiết kế phải cung cấp các chi tiết thiết kế dưới dạng văn bản, tập tin và cây trồng.

23
00:04:17,320 --> 00:04:29,220
UML sử dụng tệp đó để tạo sơ đồ mô hình.  Vì Plant UML không phải là một công cụ lập mô hình nên nó không thực thi bất kỳ quy tắc lập mô hình nào.

24
00:04:29,220 --> 00:04:40,640
Vì vậy, nếu bạn mắc lỗi trong mô hình, lỗi đó sẽ không được cây phát hiện.  Bạn cũng vậy.  Chúng tôi sẽ sử dụng phần mở rộng UML thực vật cho Thông minh.

25
00:04:41,010 --> 00:04:51,990
Vì vậy, những gì tôi muốn đề xuất với bạn tại thời điểm này là mở bản thể luận của bạn, nhấp vào cài đặt tệp, sau đó nhấp vào plugin và nhập UML thực vật.

26
00:04:52,410 --> 00:04:59,760
Đây là plugin mà chúng ta cần cài đặt.  Vì vậy hãy nhấp vào cài đặt và cài đặt plugin trong tệp thông minh của bạn.

27
00:05:00,830 --> 00:05:20,520
Tôi chỉ cài đặt plugin plant here trong môi trường thông minh của mình sau khi bạn cài đặt thành công, bạn nên xác minh xem quá trình cài đặt có thành công hay không, nhấp vào Đã cài đặt và bạn sẽ thấy tiện ích mở rộng tích hợp plant trong danh sách plug-in đã cài đặt.

28
00:05:20,750 --> 00:05:29,660
Bây giờ, hãy để tôi chỉ cho bạn cách nó hoạt động.  Bấm vào thư mục UML và bấm vào tệp có sẵn trong thư mục tiếng Đức.

29
00:05:29,930 --> 00:05:36,800
Đây là tệp thử nghiệm được tạo bằng cách áp dụng vào UML.  Và như bạn có thể thấy ở đây, đây là sơ đồ lớp học.

30
00:05:37,040 --> 00:05:45,080
Tôi sẽ không xem chi tiết trong tệp này, nhưng nếu bạn muốn tìm hiểu thêm về UML thực vật, vui lòng xem Plant Yamal dot com.

31
00:05:45,500 --> 00:05:55,130
Và nếu bạn muốn thử tạo một số tệp khác tại đây, chỉ cần nhấp vào tệp New Plant YAML.  Chọn loại sơ đồ chẳng hạn.

32
00:05:55,130 --> 00:06:06,790
Tôi có thể nói chuỗi thử nghiệm dot p UML, là phần mở rộng dành cho người thực vật.  Và như bạn có thể thấy ở đây, đây là sơ đồ trình tự được tạo bởi Plant UML.

33
00:06:07,010 --> 00:06:22,340
Nếu tiện ích mở rộng UML của nhà máy không hiển thị cho bạn các sơ đồ UML thì rất có thể lý do là biểu đồ là thư viện mà nhà máy Yamal phụ thuộc chưa được cài đặt để cài đặt.

34
00:06:22,340 --> 00:06:32,840
Biểu đồ là thư viện.  Thực hiện theo các hướng dẫn có sẵn tại liên kết này sau khi cài đặt biểu đồ là thư viện khởi động lại thông minh và điều đó sẽ giải quyết được vấn đề.

35
00:06:33,470 --> 00:06:44,510
Dự án trong điểm số được thiết lập để sử dụng Gradle làm công cụ tự động hóa bản dựng.  Mỗi nhánh có các phần phụ thuộc được xác định trong tệp gradle xây dựng.

36
00:06:44,750 --> 00:06:54,680
Nếu bạn muốn tìm hiểu thêm về Gradle, vui lòng truy cập Griddled hoặc hoặc tại thời điểm này, bạn nên thiết lập môi trường phát triển trên máy của mình.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02 Microservices Architecture\001 Microservices Architecture.en.srt -->

1

00:00:00,480 --> 00:00:06,160

Microsoft says architecture saw this lesson by discussing the monolithic architecture.



2

00:00:06,600 --> 00:00:12,750

Then I'll discuss the characteristics of Microsoft's architecture, followed by the high level tasks



3

00:00:12,960 --> 00:00:17,310

needed for the realisation of a micro services application.



4

00:00:18,030 --> 00:00:22,170

Monolithic architecture is a traditional way of building applications.



5

00:00:22,320 --> 00:00:28,770

A well-designed, monolithic application is composed of multiple modules, which are implemented by



6

00:00:28,770 --> 00:00:32,940

way of one or more large code bases or common programming.



7

00:00:32,940 --> 00:00:39,480

Language is generally used for building all of the components in a monolithic application, and there



8

00:00:39,480 --> 00:00:45,060

is tight coupling between the components that make up the monolithic application the teams form.



9

00:00:45,060 --> 00:00:52,170

Monolithic applications are generally composed of multiple smaller teams, which are organized by technology



10

00:00:52,380 --> 00:00:53,250

and business.



11

00:00:53,500 --> 00:00:59,970

For example, they may be a database specialist team, they may be an infrastructure team.



12

00:01:00,470 --> 00:01:07,710

There may be analysts specializing in different business capabilities for making changes to such applications.



13

00:01:08,160 --> 00:01:14,630

All of the teams need to get together and coordinate the release of new versions of the application.



14

00:01:14,790 --> 00:01:19,650

Generally, monolithic application spans across multiple business functions.



15

00:01:19,950 --> 00:01:27,630

For example, a banking application may support multiple banking products as part of the same application.



16

00:01:28,690 --> 00:01:35,440

Now, let's talk about micro services, architecture, micro services, architecture arranges an application



17

00:01:35,440 --> 00:01:42,550

as a collection of loosely coupled services in a micro services architecture services are finding and



18

00:01:42,550 --> 00:01:44,500

the protocols are lightweight.



19

00:01:44,860 --> 00:01:47,500

This is the definition from Wikipedia.



20

00:01:47,890 --> 00:01:52,600

A service in a micro services architecture is referred to as a micro service.



21

00:01:53,350 --> 00:01:59,110

These services are self-contained units built to realize a specific business capability.



22

00:01:59,410 --> 00:02:06,700

So in case of a retail business, these services may be built around orders, shipping and marketing



23

00:02:06,700 --> 00:02:08,660

capabilities of the retail business.



24

00:02:09,130 --> 00:02:14,950

In the case of a bank, these services may be organized around the products that a bank deals with,



25

00:02:15,280 --> 00:02:18,190

such as retail accounts, credit cards and loans.



26

00:02:18,910 --> 00:02:26,380

One important point to keep in mind here is that a business capability may be realized by way of one



27

00:02:26,380 --> 00:02:27,850

or more micro services.



28

00:02:27,910 --> 00:02:29,020

Here's an example.



29

00:02:29,020 --> 00:02:35,770

Let's say there is a product manufacturer that sells their product directly to the customer and also



30

00:02:36,040 --> 00:02:38,020

by way of a partner network.



31

00:02:38,170 --> 00:02:45,250

And let's say the business processes for the two sales channel are independent.



32

00:02:45,280 --> 00:02:51,490

In that case, the orders business capability may be implemented as to micro services, one for the



33

00:02:51,490 --> 00:02:59,650

customer orders and another for the partner orders, all interactions between the micro services are



34

00:02:59,650 --> 00:03:03,530

by way of well-defined interfaces or contracts.



35

00:03:03,970 --> 00:03:06,610

Let's revisit our retail example.



36

00:03:06,830 --> 00:03:13,510

The Shipping Microsoft Service may expose an interface called Ship Order and the orders micro service



37

00:03:13,810 --> 00:03:19,300

may expose an interface object status on receiving the orders.



38

00:03:19,570 --> 00:03:27,100

The orders micro servers will invoke the chip order interface exposed by the Shipping Micro Service



39

00:03:27,370 --> 00:03:33,940

and the Shipping Micro Service will invoke the update status on the orders micro service to update the



40

00:03:33,940 --> 00:03:35,900

status of the order.



41

00:03:36,160 --> 00:03:42,010

I won't go into the technical details of these interactions here as I'll be covering it in a later lecture.



42

00:03:42,310 --> 00:03:49,210

The important point to keep in mind is that these contracts are well-defined interfaces and other micro



43

00:03:49,210 --> 00:03:50,980

services are aware of it.



44

00:03:51,490 --> 00:03:58,990

To build a micro services application, the micro services architecture team needs to first demarcate



45

00:03:58,990 --> 00:04:00,770

the business capability boundaries.



46

00:04:00,790 --> 00:04:07,390

Recall that each micro service related to a specific business capability, each of the business capability



47

00:04:07,570 --> 00:04:10,420

is then mapped to one or more micro services.



48

00:04:10,480 --> 00:04:16,230

This is where domain driven design helps in identifying the business capability boundaries.



49

00:04:16,270 --> 00:04:22,500

These business capability boundaries are referred to as boundary context and domain driven design.



50

00:04:22,540 --> 00:04:26,540

Each of the micro service is then assigned to a small I.T. team.



51

00:04:26,830 --> 00:04:34,360

This team is responsible for building and operating the micro service each team to find the contract



52

00:04:34,360 --> 00:04:37,900

for their micro service by coordinating with other teams.



53

00:04:38,690 --> 00:04:45,250

The team for the micro service then works closely with the domain experts to develop the domain model



54

00:04:45,370 --> 00:04:46,690

for their micro service.



55

00:04:46,690 --> 00:04:52,060

And then comes the technical design and development of the micro service.



56

00:04:52,330 --> 00:04:55,600

This is where the team makes technical decisions.



57

00:04:55,870 --> 00:05:02,050

Strategic domain driven design patterns are used for developing the domain model and the technical domain



58

00:05:02,050 --> 00:05:07,090

driven design patterns are used for building the micro services.



59

00:05:07,480 --> 00:05:12,910

If you're new to the main driven design nowadays because you will be learning everything about domain



60

00:05:12,930 --> 00:05:19,840

driven design in this course, I learned this lesson, but the response to a question what is the business



61

00:05:19,840 --> 00:05:22,240

benefit of micro services architecture?



62

00:05:22,360 --> 00:05:27,400

And the response is that it helps the business change at a faster pace.



63

00:05:27,730 --> 00:05:30,700

Now you may ask, why do businesses need to change?



64

00:05:30,970 --> 00:05:34,100

And that is the topic for the next lecture.



65

00:05:34,120 --> 00:05:38,320

So join me next lecture to learn why businesses need to change.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02 Microservices Architecture\002 Business & Digital Transformation.en.srt -->

1

00:00:00,420 --> 00:00:03,730

Business transformation and micro services architecture.



2

00:00:03,750 --> 00:00:09,400

I'll start this lesson by defining the terms, business transformation and digital transformation.



3

00:00:09,750 --> 00:00:15,360

By the end of this lesson, you should be able to describe the reasons why businesses need to transform



4

00:00:15,630 --> 00:00:20,760

and how Maiko services architecture enables a business to transform.



5

00:00:21,690 --> 00:00:28,650

Business transformation is an umbrella term that is used for referring to fundamental changes in how



6

00:00:28,650 --> 00:00:31,260

an organization conducts its business.



7

00:00:31,760 --> 00:00:32,790

Here's an example.



8

00:00:33,240 --> 00:00:41,610

Microsoft used to sell their software as a packaged product in the form of CDs and floppy disk long



9

00:00:41,610 --> 00:00:42,180

time back.



10

00:00:42,660 --> 00:00:50,640

But over a period of time with the evolution of Internet and cloud technologies, today they sell their



11

00:00:50,640 --> 00:00:56,200

software by way of a subscription model instead of charging the customer a one time fee.



12

00:00:56,340 --> 00:01:00,810

Microsoft charges its customer on a monthly or yearly basis.



13

00:01:00,840 --> 00:01:02,650

Another example is Amazon.



14

00:01:02,730 --> 00:01:08,730

Amazon started out as an online bookstore, but over a period of time they have all this bookstore into



15

00:01:08,730 --> 00:01:12,800

a marketplace where other vendors could also sell their products.



16

00:01:12,810 --> 00:01:19,050

So instead of depending on the core business of selling their own books, they started to make money



17

00:01:19,320 --> 00:01:24,330

out of this marketplace they created for outside vendors as well.



18

00:01:24,480 --> 00:01:26,600

Next example is Apple.



19

00:01:26,940 --> 00:01:34,860

Apple used to sell computers, but over the last two decades it has gone from computers to iPods, iPhones,



20

00:01:34,860 --> 00:01:39,360

iPads, music store and a number of other products as well.



21

00:01:39,540 --> 00:01:43,380

They're no more dependent on their core product, which was computers.



22

00:01:44,250 --> 00:01:47,760

Now, you may be wondering why do businesses need to transform?



23

00:01:47,850 --> 00:01:49,220

There are many reasons for it.



24

00:01:49,260 --> 00:01:51,240

I'll go some of the common ones.



25

00:01:51,250 --> 00:01:53,490

First one is the environmental changes.



26

00:01:53,520 --> 00:02:00,310

New regulations like GDP may force the organization to change how they conduct their business.



27

00:02:00,330 --> 00:02:06,780

Next one is the competitive pressure tank of an organization that is dealing with a competitor that



28

00:02:06,780 --> 00:02:10,570

is rolling out innovative products at a very rapid pace.



29

00:02:10,840 --> 00:02:13,690

Now, what is the choice for this organization?



30

00:02:14,100 --> 00:02:15,140

They have to transform.



31

00:02:15,540 --> 00:02:17,510

They have to think of new products.



32

00:02:17,520 --> 00:02:21,300

They have to think about speed at which they can roll out these new products.



33

00:02:21,310 --> 00:02:24,130

In effect, the organization need to transform.



34

00:02:24,300 --> 00:02:26,430

Next one is the new opportunities.



35

00:02:26,430 --> 00:02:34,710

In early 90s, when Internet started to become popular, businesses had a new opportunity to use Internet



36

00:02:34,860 --> 00:02:37,080

for selling their products and services.



37

00:02:37,110 --> 00:02:44,070

Organizations had to transform themselves to integrate their businesses with this new technology, and



38

00:02:44,070 --> 00:02:47,000

that required serious transformation initiatives.



39

00:02:47,550 --> 00:02:54,630

Next reason is one of the biggest reasons why the organizations need to transform customer demands and



40

00:02:54,630 --> 00:03:00,720

expectations are continuously changing in order to maintain and expand their customer base.



41

00:03:00,750 --> 00:03:06,930

Organizations need to adjust their business to meet their customers demands and expectations.



42

00:03:06,930 --> 00:03:12,480

Businesses that ignore their customers expectations tend to lose out to the competitors.



43

00:03:13,170 --> 00:03:15,560

Now let's talk about digital transformation.



44

00:03:15,570 --> 00:03:22,890

Digital transformation is the process of using digital technologies to meet the needs of transformed



45

00:03:22,890 --> 00:03:27,840

business processes and to create innovative customer engagement mechanisms.



46

00:03:28,170 --> 00:03:35,670

The relationship between digital transformation and business transformation is that the digital transformation



47

00:03:35,670 --> 00:03:39,090

supports the business transformation initiatives.



48

00:03:39,270 --> 00:03:41,100

Let's go over some examples.



49

00:03:41,550 --> 00:03:45,840

Target is a retail store in US till 2011.



50

00:03:45,960 --> 00:03:50,430

Their website and fulfillment was outsourced to Amazon.



51

00:03:50,580 --> 00:03:54,920

In 2011, Target decided to transform their business.



52

00:03:54,930 --> 00:04:01,500

They invested heavily in digital technologies to integrate their supply chain inventories across the



53

00:04:01,500 --> 00:04:08,820

partner network stores and their warehouses, and that enabled them to create new customer experiences.



54

00:04:08,830 --> 00:04:15,720

Customers could place orders online and pick up the merchandise at the stores within a few minutes of



55

00:04:15,720 --> 00:04:16,770

placing the order.



56

00:04:17,010 --> 00:04:24,570

At this time, Target is continuously able to create new customer experiences because of a strong foundation.



57

00:04:24,570 --> 00:04:27,600

They created the new digital technologies.



58

00:04:28,230 --> 00:04:35,910

Capital One used to be a traditional physical bank, but today it is truly a digital bank, which has



59

00:04:35,910 --> 00:04:38,070

no data centers of their own.



60

00:04:38,340 --> 00:04:42,900

They depend on AWG cloud for all of their technology needs.



61

00:04:42,900 --> 00:04:51,000

They use different services in the cloud to support their ever changing operating model and for creating



62

00:04:51,150 --> 00:04:53,430

innovative customer experiences.



63

00:04:53,670 --> 00:04:59,940

Amazon.com uses multiple digital technologies to support their business transformation.



64

00:05:00,270 --> 00:05:08,850

Technologies like Emelle API Analytics are commonly used, and this helps them in changing their business



65

00:05:08,850 --> 00:05:10,590

model at a very rapid pace.



66

00:05:10,620 --> 00:05:14,900

This helps them in creating new products in a very short period of time.



67

00:05:15,090 --> 00:05:22,050

Overall, use of these digital technologies has enabled Amazon.com to become a leader in the retail



68

00:05:22,050 --> 00:05:22,540

sector.



69

00:05:23,610 --> 00:05:30,180

So what happens to businesses that do not transform the short answer to this question is that businesses



70

00:05:30,180 --> 00:05:33,180

that do not transform fail to survive.



71

00:05:33,420 --> 00:05:34,810

Let me give you an example.



72

00:05:35,400 --> 00:05:42,750

In 1997, Netflix started offering an innovative DVD subscription model to its customers.



73

00:05:42,900 --> 00:05:50,700

Customers could receive a DVD in mail, watch the movies and return it to Netflix in exchange for newer



74

00:05:50,700 --> 00:05:51,310

DVD.



75

00:05:51,360 --> 00:05:58,350

In 2007, Netflix started their streaming service using newer digital platforms and technologies.



76

00:05:58,350 --> 00:06:03,430

Customers could watch movies on their mobile phones, game consoles and TVs.



77

00:06:03,480 --> 00:06:09,360

On the other hand, Blockbuster ignored all of these newer digital technologies.



78

00:06:09,390 --> 00:06:11,720

They failed to transform their business in time.



79

00:06:11,880 --> 00:06:13,110

And guess what?



80

00:06:13,150 --> 00:06:17,790

Early 2021, the last blockbuster store was closed down at this time.



81

00:06:17,940 --> 00:06:20,250

Blockbuster is no more in business.



82

00:06:20,890 --> 00:06:27,130

One important point to keep in mind is that transformation is not a one time initiative or task.



83

00:06:27,540 --> 00:06:35,580

Businesses need to change on a continuous basis, and this requires rapid changes to their systems and



84

00:06:35,580 --> 00:06:36,600

applications.



85

00:06:36,810 --> 00:06:42,590

Organizations must keep up with the pace of new and evolving technologies.



86

00:06:42,900 --> 00:06:47,280

A prime example of continuous transformation is Amazon.



87

00:06:47,520 --> 00:06:54,660

Amazon is keeping pace with newer digital technologies and offering new products and services to their



88

00:06:54,660 --> 00:06:57,000

customers as well as their partners.



89

00:06:57,900 --> 00:07:05,430

A common challenge that businesses face in their transformation journey is that the old ways of building



90

00:07:05,430 --> 00:07:10,650

software hinders or makes it difficult for organizations to transform.



91

00:07:10,920 --> 00:07:17,310

It is slow to build software using the older technologies and architectural paradigms.



92

00:07:17,490 --> 00:07:24,420

Older technologies and old ways of building applications made it difficult for these applications to



93

00:07:24,420 --> 00:07:27,290

integrate with newer digital technologies.



94

00:07:27,720 --> 00:07:31,710

And this is where micro services architecture can help.



95

00:07:32,190 --> 00:07:39,990

Microsoft's architecture addresses these challenges and helps the organizations move at a faster pace



96

00:07:40,230 --> 00:07:43,390

to achieve their transformational objectives.



97

00:07:44,910 --> 00:07:50,930

An obvious question you may want to ask at this point is how does a micro services architecture help



98

00:07:50,940 --> 00:07:55,890

with transformation while transformation is all about rapid changes?



99

00:07:56,310 --> 00:08:03,600

And in the case of micro services, architecture changes are isolated to a set of micro services.



100

00:08:03,630 --> 00:08:05,940

I'll explain it with an example of a bank.



101

00:08:06,270 --> 00:08:13,020

Let's say a bank has adopted micro services architecture, and what that means is that they will create



102

00:08:13,410 --> 00:08:14,880

multiple micro services.



103

00:08:14,880 --> 00:08:18,990

Each micro servers will realize one business capability.



104

00:08:19,500 --> 00:08:22,140

Here I'm showing three such micro services.



105

00:08:22,290 --> 00:08:23,190

The retail accounts.



106

00:08:23,190 --> 00:08:29,340

Micro service takes care of the business functionality needed for the retail banking product, such



107

00:08:29,340 --> 00:08:31,320

as checking account and saving account.



108

00:08:31,470 --> 00:08:33,130

The credit cards Microsoft.



109

00:08:33,130 --> 00:08:38,230

This is for the realization of the credit card products offered by the bank.



110

00:08:38,370 --> 00:08:44,170

Let's say the bank decides to transform their credit cards business strategy.



111

00:08:44,220 --> 00:08:50,580

So what that means is that there will be a need to change only the credit cards, micro services.



112

00:08:50,730 --> 00:08:57,150

And since there is no dependency between the credit cards, micro service and other micro services,



113

00:08:57,300 --> 00:09:04,530

the pace at which these changes can be made and released is going to be much more faster compared to



114

00:09:04,830 --> 00:09:12,240

a monolithic architecture where there are interdependencies between multiple modules realizing the different



115

00:09:12,360 --> 00:09:13,770

business functionalities.



116

00:09:13,770 --> 00:09:19,240

In the next lecture, you will learn the business benefits of micro services architecture.



117

00:09:19,800 --> 00:09:22,310

Time to go over the key points from this lesson.



118

00:09:22,920 --> 00:09:25,890

Organizations need to continuously transform.



119

00:09:26,280 --> 00:09:32,590

This transformation requires the I.T. systems to change at a very rapid pace.



120

00:09:33,000 --> 00:09:40,130

There is a need for rapid adoption of new digital technologies, and speed to market is the key.



121

00:09:40,440 --> 00:09:47,910

Microsoft's architecture helps the organizations meet these requirements from I.T. perspective.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02 Microservices Architecture\003 A Business Perspective of Microservices.en.srt -->

1

00:00:00,330 --> 00:00:06,630

Microsoft says architecture a business perspective, I'll start this lesson by discussing how teams



2

00:00:06,630 --> 00:00:13,410

are organized for building Microsoft says applications you learn about the relationship between business



3

00:00:13,410 --> 00:00:16,190

capabilities and Microsoft services.



4

00:00:16,650 --> 00:00:23,840

By the end of this lesson, you should be able to explain the business benefits of Microsoft's architecture



5

00:00:24,450 --> 00:00:30,780

once the micro services have been identified in a Microsoft application, each of the micro services



6

00:00:30,930 --> 00:00:33,290

is assigned to a small team.



7

00:00:33,510 --> 00:00:36,660

These small I.T. teams build and operate.



8

00:00:36,900 --> 00:00:37,890

The Microsoft is.



9

00:00:38,040 --> 00:00:44,340

The members in these teams build different skills to the table, and these teams are supported by the



10

00:00:44,340 --> 00:00:45,570

domain experts.



11

00:00:46,110 --> 00:00:52,350

One common question that comes up at this point is what should be the size of the Microsoft search team?



12

00:00:52,380 --> 00:00:58,410

And to answer this question, I will quote Jeff Bezos idea of stupid team.



13

00:00:58,680 --> 00:01:07,080

Early 2000s, when Amazon was building Amazon.com website for Microsoft's architecture, Jeff Bezos



14

00:01:07,290 --> 00:01:14,790

and his leadership team decided that the size of the micro services team will be kept around eight members.



15

00:01:15,300 --> 00:01:16,530

And this is a quote.



16

00:01:16,920 --> 00:01:22,050

We tried to create teams that are no larger than can be fed by two pajares.



17

00:01:22,530 --> 00:01:25,390

We call that the dupatta team rule.



18

00:01:25,950 --> 00:01:31,830

The idea is that there is better collaboration among smaller teams, which lead to frequent software



19

00:01:31,830 --> 00:01:39,490

releases, which in turn helps the organization respond faster to changes in business overall.



20

00:01:39,540 --> 00:01:46,310

This will lead to the technology becoming a competitive edge for an organization and for short.



21

00:01:46,320 --> 00:01:49,130

This model has worked out very well for Amazon.



22

00:01:49,710 --> 00:01:51,210

Now it's time for a quiz.



23

00:01:51,450 --> 00:01:57,930

In the earlier lecture, you learned that the micro services are self-contained units built to realize



24

00:01:57,930 --> 00:01:59,880

a specific business capability.



25

00:02:00,240 --> 00:02:07,440

My question to you is, what are the benefits of organizing micro services around business capabilities?



26

00:02:07,920 --> 00:02:14,010

Please post the video, Jordan, your thoughts on a piece of paper and join me to learn the benefits



27

00:02:14,010 --> 00:02:15,390

of this approach.



28

00:02:16,560 --> 00:02:23,970

The first benefit of organizing micro services around business capabilities is that each service can



29

00:02:23,970 --> 00:02:25,380

evolve independently.



30

00:02:25,800 --> 00:02:28,370

Let me explain it to you with an example.



31

00:02:28,770 --> 00:02:35,610

Consider a bank that offers three types of products to its customers retail accounts, credit cards



32

00:02:35,790 --> 00:02:37,880

and loans and mortgages account.



33

00:02:38,670 --> 00:02:46,230

Let's say a single monolithic application provides all of the business functionality needed for managing



34

00:02:46,230 --> 00:02:47,010

these products.



35

00:02:47,310 --> 00:02:53,460

Now, let's say there's a change in business environment that requires some changes in loan and mortgage



36

00:02:53,730 --> 00:02:56,910

products not to make a change to loan and mortgage.



37

00:02:57,240 --> 00:03:03,750

The monolithic application will need to undergo a change which will require coordination among all the



38

00:03:03,750 --> 00:03:10,620

teams managing the modules for the different products, such as retail accounts, credit cards and loan



39

00:03:10,620 --> 00:03:12,160

and mortgages overall.



40

00:03:12,540 --> 00:03:15,220

What does this mean from the business perspective?



41

00:03:15,540 --> 00:03:23,880

It means that this coordination between the various teams will slow down the process of making changes



42

00:03:23,880 --> 00:03:26,460

to different parts of the application.



43

00:03:26,550 --> 00:03:32,010

From the business perspective, the bank will be slow to release new products in the market.



44

00:03:32,130 --> 00:03:35,100

This problem is addressed with micro services.



45

00:03:35,790 --> 00:03:39,120

This monolithic architecture, when replaced with micro services.



46

00:03:39,120 --> 00:03:45,420

Architecture will look something like this, where in each of the capability will be realized in an



47

00:03:45,420 --> 00:03:47,170

independent micro service.



48

00:03:47,220 --> 00:03:53,910

So what that means is that changes can be performed on each of these services independently and that



49

00:03:53,910 --> 00:04:01,990

translate into a business benefit within foster responses can be achieved to changes in business environment.



50

00:04:02,070 --> 00:04:08,580

For example, if there is a regulatory change in loans and mortgage services, there would be no change



51

00:04:08,580 --> 00:04:11,390

required in the credit card or retail accounts.



52

00:04:11,640 --> 00:04:18,150

The team working on the Loans and Mortgage Micro Service will be able to deliver the changes independently.



53

00:04:19,050 --> 00:04:25,420

Micro Services architecture allows the business to make radical changes to how it operates.



54

00:04:25,560 --> 00:04:32,070

Consider this example wherein the bank has decided to fully transform loans and mortgage products.



55

00:04:32,340 --> 00:04:38,280

In that case, they can easily replace the loans and mortgage micro service with a new micro service



56

00:04:38,280 --> 00:04:42,410

that implements the transformed business operating model.



57

00:04:42,420 --> 00:04:49,200

As long as this new micro service is maintaining the same contract as the old micro service, there



58

00:04:49,200 --> 00:04:52,210

will be no change required in other micro services.



59

00:04:52,500 --> 00:04:57,950

The next benefit is that it makes it easier for the I.T. teams to understand the business.



60

00:04:58,530 --> 00:04:59,850

So in the case of.



61

00:04:59,990 --> 00:05:06,200

Banking, the team working on the retail accounts will need to have a deep understanding of retail accounts,



62

00:05:06,200 --> 00:05:11,960

but they may not need to delve deep into the business processes around credit cards, for example.



63

00:05:12,020 --> 00:05:17,320

Overall, it means that the I.T. teams don't need to dive deep into all business capabilities.



64

00:05:17,660 --> 00:05:22,640

They can focus on the business capability that they are building in their micro service.



65

00:05:23,060 --> 00:05:30,710

With micro services built around the business capability, the I.T. teams are able to achieve higher



66

00:05:30,740 --> 00:05:33,690

alignment with the business priorities.



67

00:05:33,710 --> 00:05:42,080

For example, if the retail accounts business is not undergoing frequent changes, the team working



68

00:05:42,080 --> 00:05:47,600

on the retail accounts might or service may decide to release their medical service every two weeks.



69

00:05:47,610 --> 00:05:53,930

But let's say the loan and mortgages business is undergoing some kind of a serious transformation,



70

00:05:53,930 --> 00:05:59,890

in which case the loan and mortgage team may decide to release their micro service every day.



71

00:06:00,560 --> 00:06:07,820

And what this boils down to is that since each of the micro services team is operating independently,



72

00:06:08,180 --> 00:06:12,890

they do not spend time on managing the conflicting business priorities.



73

00:06:12,900 --> 00:06:18,000

And this, in effect, will lead to faster speed to value for the business.



74

00:06:18,530 --> 00:06:24,350

Now, if I were to summarize the discussion, the way I'll put it is that businesses need to stay competitive



75

00:06:24,530 --> 00:06:26,810

by way of rapid transformations.



76

00:06:26,810 --> 00:06:34,040

And this rapid transformations require support from the I.T. teams to deliver value to the market at



77

00:06:34,040 --> 00:06:35,060

a faster pace.



78

00:06:35,150 --> 00:06:42,980

Micro services architecture is an enabler or a catalyst for continuous business transformation, as



79

00:06:42,980 --> 00:06:47,270

it helps the I.T. teams to move at the same speed as the business.



80

00:06:48,790 --> 00:06:54,880

One important thing to keep in mind is that to get the most benefit from the micro services architecture,



81

00:06:55,180 --> 00:07:02,550

it is critical for the micro services teams to carve out an appropriate business code for each of the



82

00:07:02,590 --> 00:07:03,550

micro servers.



83

00:07:03,700 --> 00:07:10,510

If it is not done correctly, it will lead to teams being interdependent, and that will lead to loss



84

00:07:10,510 --> 00:07:13,860

of advantages of micro services architecture.



85

00:07:14,260 --> 00:07:17,550

And this is where Demand-Driven design comes into picture.



86

00:07:17,710 --> 00:07:24,690

The domain driven design bounded context is a representation of the business scope for the micro service.



87

00:07:24,910 --> 00:07:27,100

I won't be covering Demand-Driven Design here.



88

00:07:27,250 --> 00:07:31,570

You learn all about domain driven design in later sections.



89

00:07:32,560 --> 00:07:38,200

Time to go over the key points from this lesson, smaller teams translate to faster speed to market.



90

00:07:38,230 --> 00:07:44,380

Micro services are organized around business capabilities, and the benefit of this approach is that



91

00:07:44,710 --> 00:07:48,790

it enables the I.T. teams to operate independently.



92

00:07:48,970 --> 00:07:55,690

One important point to keep in mind is that micro services architecture team must carve out appropriate



93

00:07:55,690 --> 00:08:00,730

business scope for each of the micro services to stay independent.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02 Microservices Architecture\004 A Technical Perspective of Microservices.en.srt -->

1

00:00:00,180 --> 00:00:06,150

In the last lesson, I talked about Microsoft architecture from a business perspective, in this lesson,



2

00:00:06,360 --> 00:00:10,800

I talk about Microsoft architecture from the technology perspective.



3

00:00:11,100 --> 00:00:17,490

At the end of this lecture, you should be able to describe the pros and cons of Microsoft architecture.



4

00:00:18,420 --> 00:00:26,340

Microsoft's architecture suggests creation of loosely coupled set of services for building applications.



5

00:00:27,030 --> 00:00:34,160

These services interact with each other over a network by way of lightweight protocol such as HTP.



6

00:00:34,590 --> 00:00:41,100

Each of these services have an independent code base, and what that means is that they can be independently



7

00:00:41,100 --> 00:00:41,760

deployed.



8

00:00:42,060 --> 00:00:49,380

Teams owning these services are empowered to make decisions, and what that means is there is no centralized



9

00:00:49,380 --> 00:00:50,100

governance.



10

00:00:50,250 --> 00:00:55,860

Teams can make their own decisions on what works best for the services they own.



11

00:00:56,220 --> 00:01:00,510

Each of the services have a well-defined scope from the business perspective.



12

00:01:01,050 --> 00:01:06,390

Now, you are already aware of what loose coupling means, but let's talk about it in the context of



13

00:01:06,390 --> 00:01:07,410

micro services.



14

00:01:07,530 --> 00:01:12,510

Loose coupling means there is minimal dependency between the micro services.



15

00:01:12,780 --> 00:01:17,010

A consumer micro service invokes an interface on the provider.



16

00:01:17,010 --> 00:01:18,360

Microsoft is the consumer.



17

00:01:18,360 --> 00:01:25,080

Microsoft has knowledge only about the external interfaces exposed by the provider.



18

00:01:25,080 --> 00:01:26,520

Microsoft is the consumer.



19

00:01:26,520 --> 00:01:32,700

Microsoft has no knowledge of the internal implementation of the provider.



20

00:01:32,700 --> 00:01:38,580

Microsoft is all interactions between the micro services are over the network protocol.



21

00:01:38,760 --> 00:01:43,410

As a result, there is no code level dependencies between micro services.



22

00:01:44,040 --> 00:01:49,110

Micro services exposed their external interfaces as APIs.



23

00:01:49,110 --> 00:01:57,330

These apps are commonly implemented as restful services or graphical APIs, which are made available



24

00:01:57,630 --> 00:02:01,470

to other micro services or the protocol.



25

00:02:02,130 --> 00:02:09,660

Apart from SCDP, asynchronous messaging mechanism is also used for building the interactions between



26

00:02:09,660 --> 00:02:10,710

micro services.



27

00:02:10,720 --> 00:02:17,760

It is common for the micro services to interact with other micro services using requestor apply pattern



28

00:02:17,910 --> 00:02:21,900

as well as the published Subscribe Messaging Pattern COFCO.



29

00:02:21,900 --> 00:02:23,340

Robert McEuen active.



30

00:02:23,520 --> 00:02:29,460

Q Are some of the commonly used technologies for building these messaging based interactions?



31

00:02:29,760 --> 00:02:34,110

Next, we'll discuss the advantages of micro services architecture.



32

00:02:34,440 --> 00:02:36,630

Compared to monolithic applications.



33

00:02:36,750 --> 00:02:43,950

It is easier to manage changes in a micro services application and there is a change in one service.



34

00:02:44,340 --> 00:02:51,150

There is no impact on other services within the application, since the core base is for each of the



35

00:02:51,150 --> 00:02:58,710

micro services as independent, little or no coordination is needed between the teams and the regression



36

00:02:58,710 --> 00:03:03,180

testing needs to be carried out only for the micro service that is getting changed.



37

00:03:03,240 --> 00:03:09,780

Although micro services need not be tested, deployment for each of the micro services may be carried



38

00:03:09,780 --> 00:03:11,010

out independently.



39

00:03:11,100 --> 00:03:18,450

Each team decides on the frequency of deployments depending on the requirements and other constraints.



40

00:03:18,450 --> 00:03:24,960

In other words, teams do not follow a common deployment plan, which is very common in case of monolithic



41

00:03:24,960 --> 00:03:25,830

applications.



42

00:03:25,920 --> 00:03:32,080

And this independent deployments lead to higher productivity and faster delivery of software.



43

00:03:32,580 --> 00:03:35,310

Now let's talk about polyglot micro services.



44

00:03:35,460 --> 00:03:42,750

The idea behind polyglot micro services is that the team owning the micro servers may decide on the



45

00:03:42,750 --> 00:03:45,150

technology stack for their service.



46

00:03:45,510 --> 00:03:52,530

For example, team for the orders Microsoft Office may use Norges, whereas the team for shipping service



47

00:03:52,650 --> 00:03:54,390

may use spring framework.



48

00:03:54,630 --> 00:04:02,130

Now, experts caution against the use of multiple languages as this may lead to challenges.



49

00:04:02,940 --> 00:04:08,470

One of the biggest differentiator of micro services architecture is the fact that there is failure,



50

00:04:08,520 --> 00:04:09,390

isolation.



51

00:04:09,420 --> 00:04:16,800

What that means is that failure and one service will not bring down the entire system, which is a common



52

00:04:16,800 --> 00:04:22,220

scenario in case of a failure of a component in a monolithic application.



53

00:04:22,410 --> 00:04:23,550

Consider the scenario.



54

00:04:23,880 --> 00:04:30,790

Ordos microsurgeons passes on the orders to the shipping micros and let's say the shipping service went



55

00:04:30,790 --> 00:04:31,110

down.



56

00:04:31,350 --> 00:04:39,390

In that case, the orders micro servers will continue to process the orders without impacting the user



57

00:04:39,390 --> 00:04:40,080

experience.



58

00:04:40,380 --> 00:04:45,420

These orders may be held in a messaging broker and vendor shipping.



59

00:04:45,420 --> 00:04:50,280

Microsoft comes up a process all of the orders handling the message.



60

00:04:50,280 --> 00:04:58,740

Broca Another benefit of micro services is that each of the servers may be scaled independently in this



61

00:04:58,740 --> 00:04:59,520

example.



62

00:05:00,020 --> 00:05:08,300

Let's say during the Black Friday event, there is a heavy load on the orders in that scenario, additional



63

00:05:08,300 --> 00:05:15,800

instances of the orders microcircuits may be created for handling the extra load, but they may not



64

00:05:15,800 --> 00:05:19,250

be a need to scale the shipping micros service.



65

00:05:19,680 --> 00:05:22,760

Micro services also have some disadvantages.



66

00:05:22,910 --> 00:05:27,710

So let's go over some of the disadvantages of micro services architecture.



67

00:05:28,130 --> 00:05:34,820

Since Microsoft is interact with each other over a network protocol, an application built with micro



68

00:05:34,820 --> 00:05:41,600

services, architecture may exacerbate poor performance compared to the same application implemented



69

00:05:41,600 --> 00:05:49,220

with a monolithic architecture in a micro services application, each micro service manages its own



70

00:05:49,220 --> 00:05:49,910

database.



71

00:05:50,300 --> 00:05:54,040

This leads to complexity in managing data integrity.



72

00:05:54,260 --> 00:06:00,590

And the reason for that is that in the case of monolithic applications, you may use a common database



73

00:06:00,590 --> 00:06:06,050

and you may use local transactions to manage the data integrity.



74

00:06:06,380 --> 00:06:12,740

In the case of a distributed architecture like a micro services architecture, traditional transactional



75

00:06:12,740 --> 00:06:14,440

mechanisms may not work.



76

00:06:14,450 --> 00:06:17,180

And this leads to higher complexity.



77

00:06:17,900 --> 00:06:22,460

At runtime, micro services are launched as independent processes.



78

00:06:22,490 --> 00:06:25,600

These independent processes need to be monitored.



79

00:06:25,760 --> 00:06:32,210

If you have an architecture where you would need tens or hundreds of instances of the same micro servers,



80

00:06:32,570 --> 00:06:39,080

it may become challenging to monitor these micro services and to debug the micro services in case of



81

00:06:39,080 --> 00:06:39,650

issues.



82

00:06:39,980 --> 00:06:47,750

The images that you see here are the micro services maps for Amazon.com and Netflix and other common



83

00:06:47,750 --> 00:06:56,030

concern for micro services is that since micro services exposes interfaces in the form of APIs that



84

00:06:56,030 --> 00:07:04,910

lead to an expanded attack surface for micro services based application to address some of these disadvantages,



85

00:07:04,940 --> 00:07:12,860

organizations planning to adopt micro services need to invest in new technologies in terms of infrastructure



86

00:07:13,100 --> 00:07:17,460

tools, and then they also need to invest in skills development.



87

00:07:17,630 --> 00:07:24,980

So what this means is that organizations may need to make upfront investments for an application that



88

00:07:24,980 --> 00:07:27,610

will be built with Microsoft, says architecture.



89

00:07:28,400 --> 00:07:33,720

In this lesson, I discussed the micro services architecture from technology perspective.



90

00:07:33,770 --> 00:07:37,370

Let's go over the pros of micro services architecture.



91

00:07:37,850 --> 00:07:43,490

Change management becomes easier and deployment's can be carried out independently.



92

00:07:43,610 --> 00:07:48,260

And what this means is that features can be released much faster.



93

00:07:48,530 --> 00:07:55,550

Speed to market is increased, failures are isolated and services may be scaled independently.



94

00:07:56,000 --> 00:08:03,140

And what this means is that it leads to a better quality of experience for the consumers or the application.



95

00:08:03,140 --> 00:08:06,800

From the Korn's perspective, support network performance is a concern.



96

00:08:06,950 --> 00:08:12,120

And then there are challenges related to monitoring data management and security.



97

00:08:12,800 --> 00:08:20,060

Some of these challenges may be addressed by way of investment and tools, infrastructure and skills



98

00:08:20,060 --> 00:08:20,720

development.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02 Microservices Architecture\005 Adoption of Microservices Architecture.en.srt -->

1

00:00:00,180 --> 00:00:06,090

Adopting and building micro services in this lesson are discussed what an organization needs in order



2

00:00:06,090 --> 00:00:08,460

to adopt micro services architecture.



3

00:00:08,760 --> 00:00:15,090

I'll share my thoughts on how a technologist can put together a business case for gaining support for



4

00:00:15,090 --> 00:00:18,240

the adoption of micro services in their organization.



5

00:00:18,540 --> 00:00:23,580

And then I'll introduce you to two new Tomas Brownfield and Greenfield Micro Services project.



6

00:00:24,180 --> 00:00:25,740

Adoption of Micro Services.



7

00:00:25,770 --> 00:00:32,850

Architecture requires an organization to acquire resources with new technology skills.



8

00:00:33,060 --> 00:00:40,950

They need to invest in technologies such as cloud containers and a number of tools for building and



9

00:00:40,950 --> 00:00:45,960

operating micro services organization need to change their processes.



10

00:00:45,990 --> 00:00:49,260

For example, the need to build their practices.



11

00:00:49,350 --> 00:00:56,300

All the ways of managing I.T. resources and applications does not work for Microsoft, says applications.



12

00:00:56,310 --> 00:00:58,860

And the next one is the toughest to handle.



13

00:00:59,370 --> 00:01:02,220

An organization may need to change its culture.



14

00:01:02,550 --> 00:01:07,160

For example, foster decision making and this cannot happen overnight.



15

00:01:07,290 --> 00:01:14,280

Successful adoption of Microsoft's architecture requires commitment from the business and the I.T. leaders.



16

00:01:14,850 --> 00:01:23,310

The role of an architect is to guide and educate the business and I.T. teams in terms of cost and benefit



17

00:01:23,550 --> 00:01:26,280

of adoption of Microsoft's architecture.



18

00:01:26,430 --> 00:01:32,370

It is important for the architect to not just talk about the technical benefits of micro services,



19

00:01:32,370 --> 00:01:39,480

but spend time in building a business case for Microsoft's adoption for their specific organization.



20

00:01:39,720 --> 00:01:47,700

The idea is that it'll be easier for the architect to get the support from the I.T. and business leaders



21

00:01:47,700 --> 00:01:51,630

if there are business benefits of adopting micro services.



22

00:01:51,660 --> 00:01:58,560

Let's drill a little deeper into how a business case can be created for adoption of micro services architecture.



23

00:01:59,340 --> 00:02:04,440

To build a business case, one has to think of the business impact and not the technology.



24

00:02:04,590 --> 00:02:09,150

So as an architect, think about the specific business for your organization.



25

00:02:09,240 --> 00:02:12,990

Is it going to improve the customer experience at a rapid pace?



26

00:02:13,230 --> 00:02:16,820

Is it going to lower the cost of I.T. operations?



27

00:02:16,830 --> 00:02:19,130

Maybe it is going to generate new revenue streams.



28

00:02:19,140 --> 00:02:22,650

Maybe it will give your organization a competitive advantage.



29

00:02:22,830 --> 00:02:28,620

Now, the specific business advantage will depend on your organization's business.



30

00:02:28,620 --> 00:02:35,700

So you as an architect must understand your organization's business to be able to map the benefits of



31

00:02:35,880 --> 00:02:39,630

micro services architecture to your organization.



32

00:02:40,470 --> 00:02:44,510

Let me give you an example of technical versus business benefit.



33

00:02:45,180 --> 00:02:51,360

An architect focused on the technology side of micro services would describe the benefit like this.



34

00:02:51,480 --> 00:02:53,250

With micro services architecture.



35

00:02:53,250 --> 00:02:59,160

We can release our software every six weeks rather than every three months like we do today.



36

00:02:59,400 --> 00:03:04,980

An architect thinking about the business benefit may describe the benefit like this.



37

00:03:05,550 --> 00:03:12,510

It can help business cut down the product development process to six weeks, which is roughly 50 percent



38

00:03:12,510 --> 00:03:14,750

faster than our competitor.



39

00:03:14,880 --> 00:03:20,820

Read these two statements and think about which one would appeal more to the business stakeholders.



40

00:03:20,850 --> 00:03:22,650

Obviously it is the second one.



41

00:03:23,250 --> 00:03:24,750

It is another example.



42

00:03:25,110 --> 00:03:31,140

A technology focused architect may say our model applications are difficult to change.



43

00:03:31,590 --> 00:03:34,770

Hence adopting new technologies has been slow.



44

00:03:34,770 --> 00:03:39,900

We need to invest in micro services, architecture technologies to be able to move faster.



45

00:03:40,760 --> 00:03:48,650

And a business focused architect may say something like this adoption of new digital technologies can



46

00:03:48,650 --> 00:03:55,070

help the business achieve the goal of increasing the lifetime value of our customer as micro services.



47

00:03:55,070 --> 00:04:01,490

Architecture provides a foundation for faster adoption of these new digital technologies.



48

00:04:01,790 --> 00:04:08,750

Again, the idea is to resonate with the business and the I.T. leaders, but projecting the business



49

00:04:08,750 --> 00:04:15,110

benefits of micro services rather than just describing the technical benefits of micro services.



50

00:04:15,800 --> 00:04:22,160

An important point to keep in mind here is that I'm not suggesting that you create a 50 pages long formal



51

00:04:22,160 --> 00:04:23,450

business case document.



52

00:04:23,660 --> 00:04:30,740

Five to seven slides are fine, too, as long as you are able to convey the right message to your I.T.



53

00:04:30,740 --> 00:04:32,020

and business stakeholders.



54

00:04:32,210 --> 00:04:36,380

Here is how I like to do the business case for Microsoft's architecture.



55

00:04:36,530 --> 00:04:42,080

The first thing I like to see in my business case is a clear messaging around the business value.



56

00:04:42,080 --> 00:04:42,880

If possible.



57

00:04:42,980 --> 00:04:44,170

You need to quantify.



58

00:04:44,330 --> 00:04:51,150

You need to use the right numbers to be able to create an impactful statement from business value perspective.



59

00:04:51,170 --> 00:04:58,760

Put together a roadmap on how you expect the organization to adopt micro services important to indicate



60

00:04:58,970 --> 00:05:00,050

the time to value.



61

00:05:00,380 --> 00:05:05,630

Would it take you three months to deliver value or would it take you 18 months to get there?



62

00:05:06,140 --> 00:05:12,530

It is important for you to convey it clearly, to set the right expectations and then ask describe what



63

00:05:12,530 --> 00:05:13,920

you need to be successful.



64

00:05:14,120 --> 00:05:17,710

You are looking to get a commitment from your I.T. and business leadership.



65

00:05:17,990 --> 00:05:22,010

They can't commit to you unless they understand what they are getting into.



66

00:05:22,250 --> 00:05:28,880

And depending on where you are in your micro services architecture journey to APAC, demonstrating the



67

00:05:28,880 --> 00:05:32,240

value with something live is always helpful.



68

00:05:32,720 --> 00:05:39,020

Now, this is just an example of how you can do a business case, but be creative, think about what



69

00:05:39,020 --> 00:05:43,880

works for your organization, and then put together your business case, because that will have a higher



70

00:05:43,880 --> 00:05:48,050

chance of success than using a generic form that I have provided to you.



71

00:05:48,470 --> 00:05:50,930

There are two types of micro services projects.



72

00:05:51,050 --> 00:05:56,780

The Brownfield Micro Services Project is the one in which there is an existing monolithic application



73

00:05:57,170 --> 00:06:00,080

that need to be converted to micro services.



74

00:06:00,440 --> 00:06:06,650

And then there are Greenfield Micro Services Project wherein a new application need to be built ground



75

00:06:06,650 --> 00:06:07,040

up.



76

00:06:07,490 --> 00:06:14,750

A brownfield project team has to deal with legacy technologies and it that there are two options available



77

00:06:14,750 --> 00:06:16,510

to the Brownfield Project teams.



78

00:06:16,670 --> 00:06:23,630

The first option is to refactor the application that is, convert monolithic application to micro services.



79

00:06:24,000 --> 00:06:30,620

This conversion process can be carried out by way of a Big Bang approach wherein all of the micro services



80

00:06:30,920 --> 00:06:32,330

are built in parallel.



81

00:06:32,420 --> 00:06:39,560

Or the project team can take an incremental or evolutionary approach with a build micro services by



82

00:06:39,560 --> 00:06:43,310

peeling off parts of the existing monolithic application.



83

00:06:43,460 --> 00:06:49,040

The other option is to completely rebuild the brownfield application from ground up.



84

00:06:49,310 --> 00:06:54,280

The Greenfield Project team has two options for building the application.



85

00:06:54,290 --> 00:07:00,440

The first one is they can build an application as a micro service application from the get go.



86

00:07:00,710 --> 00:07:04,580

A couple of considerations that the Green Field Project team needs to keep in mind.



87

00:07:04,940 --> 00:07:11,210

Plus, one is the need to ensure that there are tools and technologies available to them for building



88

00:07:11,210 --> 00:07:12,380

these micro services.



89

00:07:12,380 --> 00:07:15,320

And the organization readiness also plays an important role.



90

00:07:15,480 --> 00:07:20,960

For example, does the organization have matured, develops practices and processes?



91

00:07:21,300 --> 00:07:28,430

This option is suggested for teams that are experienced with micro services and are looking for organizations



92

00:07:28,430 --> 00:07:30,860

that have already adopted micro services.



93

00:07:31,040 --> 00:07:33,680

The second option is to use the model.



94

00:07:33,680 --> 00:07:35,420

IT first approach the model.



95

00:07:35,420 --> 00:07:41,280

Its first approach suggests that the Greenfield application team create a well-designed, monolithic



96

00:07:41,330 --> 00:07:49,070

application, gain some experience with the application, and then peel off parts of the Mollenard application



97

00:07:49,370 --> 00:07:52,010

to create appropriate micro services.



98

00:07:52,040 --> 00:07:54,710

You can read more about this approach at this link.



99

00:07:55,370 --> 00:07:57,830

Time to go over the key points from this lesson.



100

00:07:58,100 --> 00:08:04,670

As an idea architect working on micro services applications, you must think about the specific business



101

00:08:04,670 --> 00:08:08,320

benefit of micro services to your organization.



102

00:08:08,600 --> 00:08:13,400

There are two types of micro services projects in a Brownfield Micro Services project.



103

00:08:13,400 --> 00:08:17,960

An existing MIGNOLET application needs to be converted to micro services.



104

00:08:17,960 --> 00:08:20,350

There are two options for these kind of projects.



105

00:08:20,450 --> 00:08:27,380

First one is to refactor the existing application to micro services application, and the second one



106

00:08:27,740 --> 00:08:33,850

is to retire the brownfield application and create a micro services application from ground up.



107

00:08:33,860 --> 00:08:38,900

The second type of micro services project is the Greenfield Project, in which the project team does



108

00:08:38,900 --> 00:08:40,100

not have any kind of.



109

00:08:40,340 --> 00:08:41,860

Legacy debt to deal with.



110

00:08:42,010 --> 00:08:47,700

There are two options for the greenfield projects Greenfield projects may be implemented with Microsoft's



111

00:08:47,710 --> 00:08:54,550

architecture from ground up or the Greenfield Project team may the model first approach wherein the



112

00:08:54,550 --> 00:08:58,690

first create a monolithic application and then convert it to micro services.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02MicroservicesArchitecture_VVN\000000001.srt -->

1
00:00:00,480 --> 00:00:17,310
Microsoft cho biết kiến ​​trúc đã nhìn thấy bài học này bằng cách thảo luận về kiến ​​trúc nguyên khối.  Sau đó, tôi sẽ thảo luận về các đặc điểm của kiến ​​trúc Microsoft, tiếp theo là các nhiệm vụ cấp cao cần thiết để hiện thực hóa một ứng dụng dịch vụ vi mô.

2
00:00:18,030 --> 00:00:32,940
Kiến trúc nguyên khối là một cách xây dựng ứng dụng truyền thống.  Một ứng dụng nguyên khối, được thiết kế tốt bao gồm nhiều mô-đun, được triển khai bằng một hoặc nhiều cơ sở mã lớn hoặc lập trình chung.

3
00:00:32,940 --> 00:00:45,060
Ngôn ngữ thường được sử dụng để xây dựng tất cả các thành phần trong một ứng dụng nguyên khối và có sự liên kết chặt chẽ giữa các thành phần tạo nên ứng dụng nguyên khối mà các nhóm hình thành.

4
00:00:45,060 --> 00:00:53,250
Các ứng dụng nguyên khối thường bao gồm nhiều nhóm nhỏ hơn, được tổ chức theo công nghệ và kinh doanh.

5
00:00:53,500 --> 00:01:07,710
Ví dụ: họ có thể là nhóm chuyên gia cơ sở dữ liệu, họ có thể là nhóm cơ sở hạ tầng.  Có thể có các nhà phân tích chuyên về các khả năng kinh doanh khác nhau để thực hiện các thay đổi đối với các ứng dụng đó.

6
00:01:08,160 --> 00:01:14,630
Tất cả các nhóm cần phải tập hợp lại và điều phối việc phát hành các phiên bản mới của ứng dụng.

7
00:01:14,790 --> 00:01:27,630
Nói chung, ứng dụng nguyên khối trải rộng trên nhiều chức năng kinh doanh.  Ví dụ: một ứng dụng ngân hàng có thể hỗ trợ nhiều sản phẩm ngân hàng như một phần của cùng một ứng dụng.

8
00:01:28,690 --> 00:01:44,500
Bây giờ, hãy nói về các dịch vụ vi mô, kiến ​​trúc, dịch vụ vi mô, kiến ​​trúc sắp xếp một ứng dụng như một tập hợp các dịch vụ được liên kết lỏng lẻo trong kiến ​​trúc dịch vụ vi mô mà các dịch vụ đang tìm kiếm và các giao thức rất nhẹ.

9
00:01:44,860 --> 00:01:52,600
Đây là định nghĩa từ Wikipedia.  Một dịch vụ trong kiến ​​trúc dịch vụ vi mô được gọi là dịch vụ vi mô.

10
00:01:53,350 --> 00:02:08,660
Các dịch vụ này là các đơn vị khép kín được xây dựng để hiện thực hóa khả năng kinh doanh cụ thể.  Vì vậy, trong trường hợp doanh nghiệp bán lẻ, các dịch vụ này có thể được xây dựng dựa trên đơn đặt hàng, khả năng vận chuyển và tiếp thị của doanh nghiệp bán lẻ.

11
00:02:09,130 --> 00:02:18,190
Trong trường hợp ngân hàng, các dịch vụ này có thể được tổ chức xung quanh các sản phẩm mà ngân hàng giao dịch, chẳng hạn như tài khoản bán lẻ, thẻ tín dụng và khoản vay.

12
00:02:18,910 --> 00:02:27,850
Một điểm quan trọng cần ghi nhớ ở đây là khả năng kinh doanh có thể được hiện thực hóa bằng một hoặc nhiều dịch vụ vi mô.

13
00:02:27,910 --> 00:02:38,020
Đây là một ví dụ.  Giả sử có một nhà sản xuất sản phẩm bán sản phẩm của họ trực tiếp cho khách hàng và thông qua mạng lưới đối tác.

14
00:02:38,170 --> 00:03:03,530
Và giả sử quy trình kinh doanh của hai kênh bán hàng là độc lập.  Trong trường hợp đó, khả năng kinh doanh của đơn đặt hàng có thể được triển khai đối với các dịch vụ vi mô, một cho đơn đặt hàng của khách hàng và một cho đơn đặt hàng của đối tác, tất cả các tương tác giữa các dịch vụ vi mô đều thông qua các giao diện hoặc hợp đồng được xác định rõ ràng.

15
00:03:03,970 --> 00:03:19,300
Hãy xem lại ví dụ bán lẻ của chúng tôi.  Dịch vụ Vận chuyển của Microsoft có thể hiển thị một giao diện có tên là Đơn đặt hàng và dịch vụ vi mô của đơn đặt hàng có thể hiển thị trạng thái đối tượng giao diện khi nhận đơn đặt hàng.

16
00:03:19,570 --> 00:03:35,900
Các máy chủ vi mô của đơn đặt hàng sẽ gọi giao diện đặt hàng chip do Dịch vụ vi mô vận chuyển cung cấp và Dịch vụ vi mô vận chuyển sẽ gọi trạng thái cập nhật trên dịch vụ vi mô của đơn đặt hàng để cập nhật trạng thái của đơn đặt hàng.

17
00:03:36,160 --> 00:03:42,010
Tôi sẽ không đi sâu vào chi tiết kỹ thuật của những tương tác này ở đây vì tôi sẽ đề cập đến nó trong bài giảng sau.

18
00:03:42,310 --> 00:03:50,980
Điểm quan trọng cần ghi nhớ là các hợp đồng này là những giao diện được xác định rõ ràng và các dịch vụ vi mô khác đều biết về điều đó.

19
00:03:51,490 --> 00:04:00,770
Để xây dựng một ứng dụng dịch vụ vi mô, trước tiên nhóm kiến ​​trúc dịch vụ vi mô cần phân định ranh giới khả năng kinh doanh.

20
00:04:00,790 --> 00:04:10,420
Hãy nhớ lại rằng mỗi dịch vụ vi mô liên quan đến một khả năng kinh doanh cụ thể, sau đó mỗi khả năng kinh doanh sẽ được ánh xạ tới một hoặc nhiều dịch vụ vi mô.

21
00:04:10,480 --> 00:04:22,500
Đây là nơi thiết kế hướng miền giúp xác định ranh giới khả năng kinh doanh.  Những ranh giới khả năng kinh doanh này được gọi là bối cảnh ranh giới và thiết kế hướng miền.

22
00:04:22,540 --> 00:04:37,900
Sau đó, mỗi dịch vụ vi mô sẽ được chỉ định cho một bộ phận CNTT nhỏ.  đội.  Nhóm này chịu trách nhiệm xây dựng và vận hành dịch vụ vi mô mà mỗi nhóm tìm kiếm hợp đồng cho dịch vụ vi mô của mình bằng cách phối hợp với các nhóm khác.

23
00:04:38,690 --> 00:04:46,690
Sau đó, nhóm dịch vụ vi mô sẽ hợp tác chặt chẽ với các chuyên gia miền để phát triển mô hình miền cho dịch vụ vi mô của họ.

24
00:04:46,690 --> 00:04:55,600
Sau đó là thiết kế kỹ thuật và phát triển dịch vụ vi mô.  Đây là nơi nhóm đưa ra quyết định kỹ thuật.

25
00:04:55,870 --> 00:05:07,090
Các mẫu thiết kế hướng miền chiến lược được sử dụng để phát triển mô hình miền và các mẫu thiết kế hướng miền kỹ thuật được sử dụng để xây dựng các dịch vụ vi mô.

26
00:05:07,480 --> 00:05:22,240
Nếu hiện nay bạn chưa quen với thiết kế hướng chính vì bạn sẽ học mọi thứ về thiết kế hướng miền trong khóa học này, thì tôi đã học bài học này, nhưng câu trả lời cho câu hỏi lợi ích kinh doanh của kiến ​​trúc dịch vụ vi mô là gì?

27
00:05:22,360 --> 00:05:30,700
Và câu trả lời là nó giúp doanh nghiệp thay đổi với tốc độ nhanh hơn.  Bây giờ bạn có thể hỏi, tại sao doanh nghiệp cần thay đổi?

28
00:05:30,970 --> 00:05:38,320
Và đó chính là chủ đề của bài giảng tiếp theo.  Vậy hãy cùng tôi tham gia bài giảng tiếp theo để tìm hiểu lý do tại sao doanh nghiệp cần thay đổi.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02MicroservicesArchitecture_VVN\000000002.srt -->

1
00:00:00,420 --> 00:00:09,400
Chuyển đổi kinh doanh và kiến ​​trúc dịch vụ vi mô.  Tôi sẽ bắt đầu bài học này bằng cách xác định các thuật ngữ, chuyển đổi kinh doanh và chuyển đổi kỹ thuật số.

2
00:00:09,750 --> 00:00:20,760
Đến cuối bài học này, bạn sẽ có thể mô tả lý do tại sao doanh nghiệp cần chuyển đổi và cách kiến ​​trúc dịch vụ Maiko hỗ trợ doanh nghiệp chuyển đổi.

3
00:00:21,690 --> 00:00:31,260
Chuyển đổi kinh doanh là một thuật ngữ chung được sử dụng để đề cập đến những thay đổi cơ bản trong cách một tổ chức tiến hành hoạt động kinh doanh của mình.

4
00:00:31,760 --> 00:00:42,180
Đây là một ví dụ.  Microsoft đã từng bán phần mềm của họ dưới dạng sản phẩm đóng gói dưới dạng đĩa CD và đĩa mềm từ lâu.

5
00:00:42,660 --> 00:00:56,200
Nhưng theo thời gian với sự phát triển của Internet và công nghệ đám mây, ngày nay họ bán phần mềm của mình theo mô hình đăng ký thay vì tính phí một lần cho khách hàng.

6
00:00:56,340 --> 00:01:12,800
Microsoft tính phí khách hàng hàng tháng hoặc hàng năm.  Một ví dụ khác là Amazon.  Amazon khởi đầu là một hiệu sách trực tuyến, nhưng theo thời gian, họ đã biến toàn bộ hiệu sách này thành một thị trường nơi các nhà cung cấp khác cũng có thể bán sản phẩm của họ.

7
00:01:12,810 --> 00:01:24,330
Vì vậy, thay vì phụ thuộc vào hoạt động kinh doanh cốt lõi là bán sách của riêng mình, họ bắt đầu kiếm tiền từ thị trường mà họ đã tạo ra cho các nhà cung cấp bên ngoài.

8
00:01:24,480 --> 00:01:39,360
Ví dụ tiếp theo là Apple.  Apple từng bán máy tính, nhưng trong hai thập kỷ qua, hãng đã chuyển từ máy tính sang iPod, iPhone, iPad, kho nhạc và một số sản phẩm khác.

9
00:01:39,540 --> 00:01:47,760
Họ không còn phụ thuộc vào sản phẩm cốt lõi của mình là máy tính nữa.  Bây giờ, có thể bạn đang thắc mắc tại sao doanh nghiệp cần chuyển đổi?

10
00:01:47,850 --> 00:01:53,490
Có rất nhiều lý do cho nó.  Tôi sẽ đi một số trong những cái phổ biến.  Đầu tiên là những thay đổi về môi trường.

11
00:01:53,520 --> 00:02:10,570
Các quy định mới như GDP có thể buộc tổ chức phải thay đổi cách họ tiến hành kinh doanh.  Tiếp theo là bể áp lực cạnh tranh của một tổ chức đang giao dịch với một đối thủ cạnh tranh đang tung ra các sản phẩm đổi mới với tốc độ rất nhanh.

12
00:02:10,840 --> 00:02:17,510
Bây giờ, sự lựa chọn cho tổ chức này là gì?  Họ phải biến đổi.  Họ phải nghĩ ra sản phẩm mới.

13
00:02:17,520 --> 00:02:24,130
Họ phải suy nghĩ về tốc độ có thể tung ra những sản phẩm mới này.  Trên thực tế, tổ chức cần phải chuyển đổi.

14
00:02:24,300 --> 00:02:37,080
Tiếp theo là những cơ hội mới.  Đầu những năm 90, khi Internet bắt đầu trở nên phổ biến, các doanh nghiệp có cơ hội mới sử dụng Internet để bán sản phẩm và dịch vụ của mình.

15
00:02:37,110 --> 00:02:47,000
Các tổ chức đã phải tự chuyển đổi để tích hợp hoạt động kinh doanh của mình với công nghệ mới này và điều đó đòi hỏi phải có những sáng kiến ​​chuyển đổi nghiêm túc.

16
00:02:47,550 --> 00:03:00,720
Lý do tiếp theo là một trong những lý do lớn nhất khiến tổ chức cần chuyển đổi nhu cầu và mong đợi của khách hàng liên tục thay đổi để duy trì và mở rộng cơ sở khách hàng của mình.

17
00:03:00,750 --> 00:03:12,480
Các tổ chức cần điều chỉnh hoạt động kinh doanh của mình để đáp ứng nhu cầu và mong đợi của khách hàng.  Các doanh nghiệp bỏ qua kỳ vọng của khách hàng có xu hướng thua đối thủ cạnh tranh.

18
00:03:13,170 --> 00:03:27,840
Bây giờ hãy nói về chuyển đổi kỹ thuật số.  Chuyển đổi kỹ thuật số là quá trình sử dụng công nghệ kỹ thuật số để đáp ứng nhu cầu của các quy trình kinh doanh được chuyển đổi và tạo ra các cơ chế tương tác khách hàng sáng tạo.

19
00:03:28,170 --> 00:03:39,090
Mối quan hệ giữa chuyển đổi số và chuyển đổi kinh doanh là chuyển đổi số hỗ trợ các sáng kiến ​​chuyển đổi kinh doanh.

20
00:03:39,270 --> 00:03:50,430
Chúng ta hãy xem qua một số ví dụ.  Target là một cửa hàng bán lẻ ở Mỹ cho đến năm 2011. Trang web và khâu xử lý đơn hàng của họ được gia công cho Amazon.

21
00:03:50,580 --> 00:04:08,820
Năm 2011, Target quyết định chuyển đổi hoạt động kinh doanh của họ.  Họ đã đầu tư rất nhiều vào công nghệ kỹ thuật số để tích hợp hàng tồn kho trong chuỗi cung ứng của mình trên khắp các cửa hàng trong mạng lưới đối tác và kho hàng của họ, đồng thời điều đó cho phép họ tạo ra những trải nghiệm mới cho khách hàng.

22
00:04:08,830 --> 00:04:16,770
Khách hàng có thể đặt hàng trực tuyến và nhận hàng tại cửa hàng trong vòng vài phút sau khi đặt hàng.

23
00:04:17,010 --> 00:04:24,570
Tại thời điểm này, Target liên tục có thể tạo ra những trải nghiệm mới cho khách hàng nhờ nền tảng vững chắc.

24
00:04:24,570 --> 00:04:38,070
Họ đã tạo ra các công nghệ kỹ thuật số mới.  Capital One từng là một ngân hàng vật lý truyền thống, nhưng ngày nay nó thực sự là một ngân hàng kỹ thuật số, không có trung tâm dữ liệu riêng.

25
00:04:38,340 --> 00:04:53,430
Họ phụ thuộc vào đám mây AWG cho tất cả các nhu cầu công nghệ của mình.  Họ sử dụng các dịch vụ khác nhau trên đám mây để hỗ trợ mô hình hoạt động luôn thay đổi của mình và tạo ra những trải nghiệm sáng tạo cho khách hàng.

26
00:04:53,670 --> 00:05:10,590
Amazon.com sử dụng nhiều công nghệ kỹ thuật số để hỗ trợ quá trình chuyển đổi hoạt động kinh doanh của họ.  Các công nghệ như Emelle API Analytics thường được sử dụng và điều này giúp họ thay đổi mô hình kinh doanh với tốc độ rất nhanh.

27
00:05:10,620 --> 00:05:22,540
Điều này giúp họ tạo ra sản phẩm mới trong một khoảng thời gian rất ngắn.  Nhìn chung, việc sử dụng các công nghệ kỹ thuật số này đã giúp Amazon.com trở thành công ty dẫn đầu trong lĩnh vực bán lẻ.

28
00:05:23,610 --> 00:05:33,180
Vì vậy, điều xảy ra với những doanh nghiệp không chuyển đổi, câu trả lời ngắn gọn cho câu hỏi này là những doanh nghiệp không chuyển đổi sẽ không thể tồn tại.

29
00:05:33,420 --> 00:05:42,750
Tôi sẽ cho bạn một ví dụ.  Năm 1997, Netflix bắt đầu cung cấp mô hình đăng ký DVD cải tiến cho khách hàng của mình.

30
00:05:42,900 --> 00:05:51,310
Khách hàng có thể nhận DVD qua thư, xem phim và trả lại cho Netflix để đổi lấy DVD mới hơn.

31
00:05:51,360 --> 00:06:03,430
Năm 2007, Netflix bắt đầu dịch vụ phát trực tuyến bằng cách sử dụng các nền tảng và công nghệ kỹ thuật số mới hơn.  Khách hàng có thể xem phim trên điện thoại di động, máy chơi game và TV.

32
00:06:03,480 --> 00:06:11,720
Mặt khác, Blockbuster đã bỏ qua tất cả những công nghệ kỹ thuật số mới hơn này.  Họ đã thất bại trong việc chuyển đổi hoạt động kinh doanh của mình kịp thời.

33
00:06:11,880 --> 00:06:20,250
Và đoán xem?  Đầu năm 2021, cửa hàng bom tấn cuối cùng đã đóng cửa vào thời điểm này.  Bom tấn không còn trong kinh doanh nữa.

34
00:06:20,890 --> 00:06:36,600
Một điểm quan trọng cần ghi nhớ là chuyển đổi không phải là sáng kiến ​​hay nhiệm vụ chỉ diễn ra một lần.  Các doanh nghiệp cần thay đổi liên tục và điều này đòi hỏi những thay đổi nhanh chóng đối với hệ thống và ứng dụng của họ.

35
00:06:36,810 --> 00:06:47,280
Các tổ chức phải theo kịp tốc độ của các công nghệ mới và đang phát triển.  Một ví dụ điển hình về sự chuyển đổi liên tục là Amazon.

36
00:06:47,520 --> 00:06:57,000
Amazon đang bắt kịp các công nghệ kỹ thuật số mới hơn và cung cấp các sản phẩm và dịch vụ mới cho khách hàng cũng như đối tác của họ.

37
00:06:57,900 --> 00:07:10,650
Một thách thức chung mà các doanh nghiệp phải đối mặt trong hành trình chuyển đổi là cách xây dựng phần mềm cũ cản trở hoặc gây khó khăn cho các tổ chức trong việc chuyển đổi.

38
00:07:10,920 --> 00:07:27,290
Việc xây dựng phần mềm bằng cách sử dụng các công nghệ và mô hình kiến ​​trúc cũ sẽ chậm hơn.  Các công nghệ cũ hơn và cách xây dựng ứng dụng cũ khiến các ứng dụng này khó tích hợp với các công nghệ kỹ thuật số mới hơn.

39
00:07:27,720 --> 00:07:43,390
Và đây là lúc kiến ​​trúc dịch vụ vi mô có thể trợ giúp.  Kiến trúc của Microsoft giải quyết những thách thức này và giúp các tổ chức phát triển với tốc độ nhanh hơn để đạt được các mục tiêu chuyển đổi của mình.

40
00:07:44,910 --> 00:07:55,890
Một câu hỏi hiển nhiên mà bạn có thể muốn hỏi vào thời điểm này là làm thế nào kiến ​​trúc dịch vụ vi mô giúp chuyển đổi trong khi chuyển đổi chỉ là những thay đổi nhanh chóng?

41
00:07:56,310 --> 00:08:05,940
Và trong trường hợp dịch vụ vi mô, các thay đổi về kiến ​​trúc được tách biệt thành một tập hợp các dịch vụ vi mô.  Tôi sẽ giải thích nó bằng một ví dụ về ngân hàng.

42
00:08:06,270 --> 00:08:14,880
Giả sử một ngân hàng đã áp dụng kiến ​​trúc dịch vụ vi mô và điều đó có nghĩa là họ sẽ tạo ra nhiều dịch vụ vi mô.

43
00:08:14,880 --> 00:08:22,140
Mỗi máy chủ vi mô sẽ nhận ra một khả năng kinh doanh.  Ở đây tôi đang hiển thị ba dịch vụ vi mô như vậy.

44
00:08:22,290 --> 00:08:31,320
Các tài khoản bán lẻ.  Dịch vụ vi mô đảm nhiệm chức năng kinh doanh cần thiết cho sản phẩm ngân hàng bán lẻ, chẳng hạn như tài khoản séc và tài khoản tiết kiệm.

45
00:08:31,470 --> 00:08:38,230
Thẻ tín dụng Microsoft.  Điều này nhằm mục đích hiện thực hóa các sản phẩm thẻ tín dụng do ngân hàng cung cấp.

46
00:08:38,370 --> 00:08:50,580
Giả sử ngân hàng quyết định chuyển đổi chiến lược kinh doanh thẻ tín dụng của họ.  Vì vậy, điều đó có nghĩa là sẽ chỉ cần thay đổi thẻ tín dụng, các dịch vụ vi mô.

47
00:08:50,730 --> 00:09:13,770
Và vì không có sự phụ thuộc giữa thẻ tín dụng, dịch vụ vi mô và các dịch vụ vi mô khác nên tốc độ thực hiện và phát hành những thay đổi này sẽ nhanh hơn nhiều so với kiến ​​trúc nguyên khối nơi có sự phụ thuộc lẫn nhau giữa nhiều mô-đun thực hiện  chức năng kinh doanh khác nhau.

48
00:09:13,770 --> 00:09:22,310
Trong bài giảng tiếp theo, bạn sẽ tìm hiểu các lợi ích kinh doanh của kiến ​​trúc dịch vụ vi mô.  Đã đến lúc ôn lại những điểm chính của bài học này.

49
00:09:22,920 --> 00:09:32,590
Các tổ chức cần phải liên tục chuyển đổi.  Sự chuyển đổi này đòi hỏi I.T.  hệ thống thay đổi với tốc độ rất nhanh.

50
00:09:33,000 --> 00:09:47,910
Cần phải áp dụng nhanh chóng các công nghệ kỹ thuật số mới và tốc độ đưa ra thị trường là chìa khóa. Kiến trúc của Microsoft giúp các tổ chức đáp ứng các yêu cầu này từ bộ phận CNTT.  luật xa gần.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02MicroservicesArchitecture_VVN\000000003.srt -->

1
00:00:00,330 --> 00:00:16,190
Microsoft nói kiến ​​trúc là một góc độ kinh doanh. Tôi sẽ bắt đầu bài học này bằng cách thảo luận cách tổ chức các nhóm để xây dựng các ứng dụng Microsoft nói mà bạn tìm hiểu về mối quan hệ giữa khả năng kinh doanh và các dịch vụ của Microsoft.

2
00:00:16,650 --> 00:00:33,290
Đến cuối bài học này, bạn sẽ có thể giải thích các lợi ích kinh doanh của kiến ​​trúc Microsoft khi các dịch vụ vi mô đã được xác định trong ứng dụng Microsoft, mỗi dịch vụ vi mô được gán cho một nhóm nhỏ.

3
00:00:33,510 --> 00:00:45,570
Những I.T nhỏ này.  đội xây dựng và vận hành.  Microsoft là vậy.  Các thành viên trong các nhóm này xây dựng các kỹ năng khác nhau trên bàn và các nhóm này được hỗ trợ bởi các chuyên gia tên miền.

4
00:00:46,110 --> 00:00:52,350
Một câu hỏi phổ biến được đặt ra vào thời điểm này là quy mô của nhóm tìm kiếm Microsoft sẽ như thế nào?

5
00:00:52,380 --> 00:01:14,790
Và để trả lời câu hỏi này, tôi sẽ trích dẫn ý tưởng của Jeff Bezos về đội ngũ ngu ngốc.  Đầu những năm 2000, khi Amazon đang xây dựng trang web Amazon.com cho kiến ​​trúc của Microsoft, Jeff Bezos và đội ngũ lãnh đạo của ông đã quyết định rằng quy mô của nhóm dịch vụ vi mô sẽ được giữ ở mức tám thành viên.

6
00:01:15,300 --> 00:01:25,390
Và đây là một trích dẫn.  Chúng tôi đã cố gắng tạo ra những đội không lớn hơn mức có thể cho hai người ăn.  Chúng tôi gọi đó là quy tắc nhóm dupatta.

7
00:01:25,950 --> 00:01:39,490
Ý tưởng là có sự hợp tác tốt hơn giữa các nhóm nhỏ hơn, dẫn đến việc phát hành phần mềm thường xuyên, từ đó giúp tổ chức phản ứng nhanh hơn với những thay đổi trong hoạt động kinh doanh nói chung.

8
00:01:39,540 --> 00:01:49,130
Điều này sẽ dẫn đến việc công nghệ trở thành một lợi thế cạnh tranh cho một tổ chức và nói tóm lại.  Mô hình này đã mang lại hiệu quả rất tốt cho Amazon.

9
00:01:49,710 --> 00:01:59,880
Bây giờ là lúc cho một bài kiểm tra.  Trong bài giảng trước, bạn đã biết rằng dịch vụ vi mô là các đơn vị độc lập được xây dựng để hiện thực hóa một khả năng kinh doanh cụ thể.

10
00:02:00,240 --> 00:02:07,440
Câu hỏi của tôi dành cho bạn là lợi ích của việc tổ chức các dịch vụ vi mô xung quanh khả năng kinh doanh là gì?

11
00:02:07,920 --> 00:02:15,390
Jordan, hãy đăng video suy nghĩ của bạn lên một tờ giấy và cùng tôi tìm hiểu những lợi ích của phương pháp này.

12
00:02:16,560 --> 00:02:25,380
Lợi ích đầu tiên của việc tổ chức các dịch vụ vi mô xoay quanh khả năng kinh doanh là mỗi dịch vụ có thể phát triển độc lập.

13
00:02:25,800 --> 00:02:37,880
Hãy để tôi giải thích cho bạn bằng một ví dụ.  Hãy xem xét một ngân hàng cung cấp ba loại sản phẩm cho khách hàng của mình là tài khoản bán lẻ, thẻ tín dụng và tài khoản cho vay và thế chấp.

14
00:02:38,670 --> 00:02:47,010
Giả sử một ứng dụng nguyên khối duy nhất cung cấp tất cả chức năng kinh doanh cần thiết để quản lý các sản phẩm này.

15
00:02:47,310 --> 00:02:56,910
Bây giờ, giả sử có một sự thay đổi trong môi trường kinh doanh đòi hỏi một số thay đổi trong các sản phẩm cho vay và thế chấp để không tạo ra sự thay đổi đối với khoản cho vay và thế chấp.

16
00:02:57,240 --> 00:03:12,160
Ứng dụng nguyên khối sẽ cần phải trải qua một sự thay đổi đòi hỏi sự phối hợp giữa tất cả các nhóm quản lý các mô-đun cho các sản phẩm khác nhau, chẳng hạn như tài khoản bán lẻ, thẻ tín dụng, khoản vay và thế chấp nói chung.

17
00:03:12,540 --> 00:03:26,460
Điều này có ý nghĩa gì từ góc độ kinh doanh?  Điều đó có nghĩa là sự phối hợp giữa các nhóm khác nhau sẽ làm chậm quá trình thực hiện thay đổi đối với các phần khác nhau của ứng dụng.

18
00:03:26,550 --> 00:03:35,100
Ở góc độ kinh doanh, ngân hàng sẽ chậm tung sản phẩm mới ra thị trường.  Vấn đề này được giải quyết với các dịch vụ vi mô.

19
00:03:35,790 --> 00:03:47,170
Kiến trúc nguyên khối này khi được thay thế bằng các dịch vụ vi mô.  Kiến trúc sẽ trông giống như thế này, trong đó mỗi khả năng sẽ được hiện thực hóa trong một dịch vụ vi mô độc lập.

20
00:03:47,220 --> 00:04:01,990
Vì vậy, điều đó có nghĩa là những thay đổi có thể được thực hiện một cách độc lập trên từng dịch vụ này và điều đó chuyển thành lợi ích kinh doanh trong phạm vi phản ứng thúc đẩy có thể đạt được trước những thay đổi trong môi trường kinh doanh.

21
00:04:02,070 --> 00:04:11,390
Ví dụ: nếu có thay đổi về quy định đối với các khoản vay và dịch vụ thế chấp thì sẽ không có thay đổi nào được yêu cầu đối với thẻ tín dụng hoặc tài khoản bán lẻ.

22
00:04:11,640 --> 00:04:18,150
Nhóm làm việc về Dịch vụ vi mô cho vay và thế chấp sẽ có thể thực hiện các thay đổi một cách độc lập.

23
00:04:19,050 --> 00:04:32,070
Kiến trúc Micro Services cho phép doanh nghiệp thực hiện những thay đổi căn bản về cách thức hoạt động.  Hãy xem xét ví dụ này trong đó ngân hàng đã quyết định chuyển đổi hoàn toàn các sản phẩm cho vay và thế chấp.

24
00:04:32,340 --> 00:04:42,410
Trong trường hợp đó, họ có thể dễ dàng thay thế các khoản vay và dịch vụ thế chấp vi mô bằng một dịch vụ vi mô mới thực hiện mô hình hoạt động kinh doanh đã chuyển đổi.

25
00:04:42,420 --> 00:04:52,210
Miễn là dịch vụ vi mô mới này vẫn duy trì hợp đồng giống như dịch vụ vi mô cũ thì sẽ không có thay đổi nào được yêu cầu đối với các dịch vụ vi mô khác.

26
00:04:52,500 --> 00:04:59,850
Lợi ích tiếp theo là nó giúp I.T.  nhóm để hiểu về doanh nghiệp.  Vì vậy, trong trường hợp.

27
00:04:59,990 --> 00:05:11,960
Ngân hàng, nhóm làm việc về tài khoản bán lẻ sẽ cần phải có hiểu biết sâu sắc về tài khoản bán lẻ, nhưng họ có thể không cần đi sâu vào các quy trình kinh doanh xung quanh thẻ tín dụng chẳng hạn.

28
00:05:12,020 --> 00:05:22,640
Nhìn chung, điều đó có nghĩa là I.T.  các nhóm không cần phải đi sâu vào mọi khả năng kinh doanh.  Họ có thể tập trung vào năng lực kinh doanh mà họ đang xây dựng trong dịch vụ vi mô của mình.

29
00:05:23,060 --> 00:05:33,690
Với các dịch vụ vi mô được xây dựng xung quanh khả năng kinh doanh, I.T.  các nhóm có thể đạt được sự liên kết cao hơn với các ưu tiên kinh doanh.

30
00:05:33,710 --> 00:05:47,600
Ví dụ: nếu hoạt động kinh doanh tài khoản bán lẻ không trải qua những thay đổi thường xuyên, nhóm làm việc về tài khoản bán lẻ có thể hoặc dịch vụ có thể quyết định cung cấp dịch vụ y tế của họ hai tuần một lần.

31
00:05:47,610 --> 00:05:59,890
Nhưng giả sử hoạt động kinh doanh cho vay và thế chấp đang trải qua một sự chuyển đổi nghiêm trọng nào đó, trong trường hợp đó, nhóm cho vay và thế chấp có thể quyết định phát hành dịch vụ vi mô của họ mỗi ngày.

32
00:06:00,560 --> 00:06:12,890
Và điều này tóm lại là vì mỗi nhóm dịch vụ vi mô hoạt động độc lập nên họ không dành thời gian để quản lý các ưu tiên kinh doanh xung đột nhau.

33
00:06:12,900 --> 00:06:26,810
Và trên thực tế, điều này sẽ dẫn đến tốc độ định giá doanh nghiệp nhanh hơn.  Bây giờ, nếu tôi tóm tắt cuộc thảo luận, cách tôi sẽ trình bày là các doanh nghiệp cần duy trì khả năng cạnh tranh bằng cách chuyển đổi nhanh chóng.

34
00:06:26,810 --> 00:06:35,060
Và sự chuyển đổi nhanh chóng này cần có sự hỗ trợ từ bộ phận CNTT.  các nhóm để cung cấp giá trị cho thị trường với tốc độ nhanh hơn.

35
00:06:35,150 --> 00:06:47,270
Kiến trúc dịch vụ vi mô là yếu tố hỗ trợ hoặc chất xúc tác cho quá trình chuyển đổi kinh doanh liên tục vì nó giúp CNTT phát triển.  các nhóm di chuyển với tốc độ tương tự như doanh nghiệp.

36
00:06:48,790 --> 00:07:03,550
Một điều quan trọng cần lưu ý là để tận dụng tối đa kiến ​​trúc dịch vụ vi mô, điều quan trọng đối với nhóm dịch vụ vi mô là phải tạo ra mã nghiệp vụ phù hợp cho từng máy chủ vi mô.

37
00:07:03,700 --> 00:07:13,860
Nếu không thực hiện đúng sẽ dẫn đến tình trạng các nhóm phụ thuộc lẫn nhau và điều đó sẽ dẫn đến mất đi lợi thế của kiến ​​trúc dịch vụ vi mô.

38
00:07:14,260 --> 00:07:24,690
Và đây là lúc thiết kế Theo nhu cầu xuất hiện.  Bối cảnh giới hạn của thiết kế hướng miền là sự thể hiện phạm vi kinh doanh của dịch vụ vi mô.

39
00:07:24,910 --> 00:07:31,570
Tôi sẽ không đề cập đến Thiết kế theo nhu cầu ở đây.  Bạn sẽ tìm hiểu tất cả về thiết kế hướng miền trong các phần sau.

40
00:07:32,560 --> 00:07:48,790
Đã đến lúc ôn lại những điểm chính trong bài học này, các nhóm nhỏ hơn sẽ có tốc độ tiếp cận thị trường nhanh hơn.  Các dịch vụ vi mô được tổ chức xoay quanh khả năng kinh doanh và lợi ích của phương pháp này là nó cho phép I.T.  các đội hoạt động độc lập.

41
00:07:48,970 --> 00:08:00,730
Một điểm quan trọng cần lưu ý là nhóm kiến ​​trúc dịch vụ vi mô phải tạo ra phạm vi kinh doanh phù hợp cho từng dịch vụ vi mô để duy trì tính độc lập.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02MicroservicesArchitecture_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:10,800
Trong bài học trước tôi đã nói về kiến ​​trúc Microsoft từ góc độ kinh doanh, trong bài học này tôi nói về kiến ​​trúc Microsoft từ góc độ công nghệ.

2
00:00:11,100 --> 00:00:17,490
Vào cuối bài giảng này, bạn sẽ có thể mô tả những ưu và nhược điểm của kiến ​​trúc Microsoft.

3
00:00:18,420 --> 00:00:26,340
Kiến trúc của Microsoft gợi ý việc tạo ra một tập hợp các dịch vụ được kết nối lỏng lẻo để xây dựng các ứng dụng.

4
00:00:27,030 --> 00:00:41,760
Các dịch vụ này tương tác với nhau qua mạng bằng giao thức nhẹ như HTP.  Mỗi dịch vụ này đều có cơ sở mã độc lập và điều đó có nghĩa là chúng có thể được triển khai độc lập.

5
00:00:42,060 --> 00:00:50,100
Các nhóm sở hữu các dịch vụ này được trao quyền đưa ra quyết định và điều đó có nghĩa là không có sự quản trị tập trung.

6
00:00:50,250 --> 00:01:00,510
Các nhóm có thể tự đưa ra quyết định về những gì phù hợp nhất với dịch vụ mà họ sở hữu.  Mỗi dịch vụ đều có phạm vi được xác định rõ ràng từ góc độ kinh doanh.

7
00:01:01,050 --> 00:01:07,410
Bây giờ, bạn đã biết khớp nối lỏng lẻo nghĩa là gì, nhưng hãy nói về nó trong bối cảnh các dịch vụ vi mô.

8
00:01:07,530 --> 00:01:17,010
Sự ghép nối lỏng lẻo có nghĩa là có sự phụ thuộc tối thiểu giữa các dịch vụ vi mô.  Một dịch vụ vi mô tiêu dùng gọi ra một giao diện trên nhà cung cấp.

9
00:01:17,010 --> 00:01:25,080
Microsoft là người tiêu dùng.  Microsoft chỉ có kiến ​​thức về các giao diện bên ngoài do nhà cung cấp cung cấp.

10
00:01:25,080 --> 00:01:32,700
Microsoft là người tiêu dùng.  Microsoft không biết gì về việc triển khai nội bộ của nhà cung cấp.

11
00:01:32,700 --> 00:01:43,410
Microsoft là tất cả các tương tác giữa các dịch vụ vi mô đều qua giao thức mạng.  Kết quả là không có sự phụ thuộc cấp độ mã giữa các dịch vụ vi mô.

12
00:01:44,040 --> 00:02:01,470
Các dịch vụ vi mô hiển thị giao diện bên ngoài của chúng dưới dạng API.  Các ứng dụng này thường được triển khai dưới dạng dịch vụ tĩnh hoặc API đồ họa, được cung cấp cho các dịch vụ vi mô hoặc giao thức khác.

13
00:02:02,130 --> 00:02:10,710
Ngoài SCDP, cơ chế nhắn tin không đồng bộ cũng được sử dụng để xây dựng sự tương tác giữa các dịch vụ vi mô.

14
00:02:10,720 --> 00:02:21,900
Thông thường, các dịch vụ vi mô sẽ tương tác với các dịch vụ vi mô khác bằng cách sử dụng mẫu áp dụng của người yêu cầu cũng như Mẫu tin nhắn đăng ký COFCO đã xuất bản.

15
00:02:21,900 --> 00:02:29,460
Robert McEuen hoạt động.  Hỏi Có một số công nghệ thường được sử dụng để xây dựng các tương tác dựa trên tin nhắn này không?

16
00:02:29,760 --> 00:02:36,630
Tiếp theo, chúng ta sẽ thảo luận về những ưu điểm của kiến ​​trúc dịch vụ vi mô.  So với các ứng dụng nguyên khối.

17
00:02:36,750 --> 00:02:43,950
Việc quản lý các thay đổi trong ứng dụng dịch vụ vi mô sẽ dễ dàng hơn và chỉ có một thay đổi trong một dịch vụ.

18
00:02:44,340 --> 00:03:03,180
Không có tác động nào đến các dịch vụ khác trong ứng dụng, vì cơ sở cốt lõi là đối với mỗi dịch vụ vi mô là độc lập, cần ít hoặc không cần phối hợp giữa các nhóm và việc kiểm tra hồi quy chỉ cần được thực hiện cho dịch vụ vi mô đó.  bị thay đổi.

19
00:03:03,240 --> 00:03:11,010
Mặc dù các dịch vụ vi mô không cần phải thử nghiệm nhưng việc triển khai từng dịch vụ vi mô có thể được thực hiện độc lập.

20
00:03:11,100 --> 00:03:18,450
Mỗi nhóm quyết định tần suất triển khai tùy thuộc vào yêu cầu và các ràng buộc khác.

21
00:03:18,450 --> 00:03:25,830
Nói cách khác, các nhóm không tuân theo kế hoạch triển khai chung, điều này rất phổ biến trong trường hợp ứng dụng nguyên khối.

22
00:03:25,920 --> 00:03:35,310
Và việc triển khai độc lập này sẽ mang lại năng suất cao hơn và phân phối phần mềm nhanh hơn.  Bây giờ hãy nói về các dịch vụ vi mô đa ngôn ngữ.

23
00:03:35,460 --> 00:03:45,150
Ý tưởng đằng sau các dịch vụ vi mô đa ngôn ngữ là nhóm sở hữu các máy chủ vi mô có thể quyết định về nền tảng công nghệ cho dịch vụ của họ.

24
00:03:45,510 --> 00:03:54,390
Ví dụ: nhóm đặt hàng Microsoft Office có thể sử dụng Norges, trong khi nhóm phụ trách dịch vụ vận chuyển có thể sử dụng Spring Framework.

25
00:03:54,630 --> 00:04:09,390
Hiện nay, các chuyên gia cảnh báo việc sử dụng nhiều ngôn ngữ vì điều này có thể dẫn đến nhiều thách thức.  Một trong những điểm khác biệt lớn nhất của kiến ​​trúc dịch vụ vi mô là có sự lỗi, bị cô lập.

26
00:04:09,420 --> 00:04:22,220
Điều đó có nghĩa là lỗi và một dịch vụ sẽ không làm toàn bộ hệ thống bị hỏng, đây là tình huống phổ biến trong trường hợp một thành phần trong ứng dụng nguyên khối bị lỗi.

27
00:04:22,410 --> 00:04:31,110
Hãy xem xét kịch bản.  Các bác sĩ phẫu thuật vi mô Ordos chuyển đơn đặt hàng đến vi mô vận chuyển và giả sử dịch vụ vận chuyển không hoạt động.

28
00:04:31,350 --> 00:04:40,080
Trong trường hợp đó, các máy chủ vi mô của đơn đặt hàng sẽ tiếp tục xử lý các đơn đặt hàng mà không ảnh hưởng đến trải nghiệm người dùng.

29
00:04:40,380 --> 00:04:50,280
Các đơn đặt hàng này có thể được giữ trong một nhà môi giới nhắn tin và vận chuyển của nhà cung cấp.  Microsoft đưa ra một quy trình tất cả các lệnh xử lý tin nhắn.

30
00:04:50,280 --> 00:04:59,520
Broca Một lợi ích khác của dịch vụ vi mô là mỗi máy chủ có thể được mở rộng quy mô độc lập trong ví dụ này.

31
00:05:00,020 --> 00:05:19,250
Giả sử trong sự kiện Thứ Sáu Đen, các đơn đặt hàng trong trường hợp đó có tải trọng lớn, các phiên bản bổ sung của vi mạch đơn đặt hàng có thể được tạo để xử lý tải bổ sung, nhưng chúng có thể không cần thiết phải mở rộng quy mô dịch vụ vận chuyển vi mô.

32
00:05:19,680 --> 00:05:27,710
Dịch vụ vi mô cũng có một số nhược điểm.  Vì vậy, hãy điểm qua một số nhược điểm của kiến ​​trúc dịch vụ vi mô.

33
00:05:28,130 --> 00:05:49,910
Vì Microsoft tương tác với nhau qua giao thức mạng nên một ứng dụng được xây dựng bằng kiến ​​trúc, dịch vụ vi mô có thể làm trầm trọng thêm hiệu suất kém so với cùng một ứng dụng được triển khai với kiến ​​trúc nguyên khối trong ứng dụng dịch vụ vi mô, nên mỗi dịch vụ vi mô sẽ quản lý cơ sở dữ liệu riêng của mình.

34
00:05:50,300 --> 00:06:06,050
Điều này dẫn đến sự phức tạp trong việc quản lý tính toàn vẹn dữ liệu.  Và lý do cho điều đó là trong trường hợp ứng dụng nguyên khối, bạn có thể sử dụng cơ sở dữ liệu chung và bạn có thể sử dụng các giao dịch cục bộ để quản lý tính toàn vẹn của dữ liệu.

35
00:06:06,380 --> 00:06:14,440
Trong trường hợp kiến ​​trúc phân tán như kiến ​​trúc dịch vụ vi mô, các cơ chế giao dịch truyền thống có thể không hoạt động.

36
00:06:14,450 --> 00:06:22,460
Và điều này dẫn đến độ phức tạp cao hơn.  Trong thời gian chạy, các dịch vụ vi mô được khởi chạy dưới dạng các quy trình độc lập.

37
00:06:22,490 --> 00:06:39,650
Những quá trình độc lập này cần được giám sát.  Nếu bạn có một kiến ​​trúc cần hàng chục hoặc hàng trăm phiên bản của cùng một máy chủ vi mô, thì việc giám sát các dịch vụ vi mô này và gỡ lỗi các dịch vụ vi mô trong trường hợp xảy ra sự cố có thể trở nên khó khăn.

38
00:06:39,980 --> 00:07:17,460
Những hình ảnh mà bạn thấy ở đây là bản đồ dịch vụ vi mô cho Amazon.com và Netflix và mối quan tâm chung khác đối với các dịch vụ vi mô là vì các dịch vụ vi mô hiển thị giao diện dưới dạng API dẫn đến bề mặt tấn công mở rộng cho ứng dụng dựa trên dịch vụ vi mô để giải quyết  Một số nhược điểm này, các tổ chức có kế hoạch áp dụng các dịch vụ vi mô cần đầu tư vào công nghệ mới về các công cụ cơ sở hạ tầng, sau đó họ cũng cần đầu tư vào phát triển kỹ năng.

39
00:07:17,630 --> 00:07:27,610
Vì vậy, điều này có nghĩa là các tổ chức có thể cần phải đầu tư trước cho một ứng dụng sẽ được xây dựng với Microsoft, kiến ​​trúc cho biết.

40
00:07:28,400 --> 00:07:37,370
Trong bài học này, tôi đã thảo luận về kiến ​​trúc dịch vụ vi mô từ góc độ công nghệ.  Hãy cùng điểm qua những ưu điểm của kiến ​​trúc dịch vụ vi mô.

41
00:07:37,850 --> 00:07:48,260
Việc quản lý thay đổi trở nên dễ dàng hơn và việc triển khai có thể được thực hiện độc lập.  Và điều này có nghĩa là các tính năng có thể được phát hành nhanh hơn nhiều.

42
00:07:48,530 --> 00:08:03,140
Tốc độ tiếp cận thị trường được tăng lên, các lỗi bị cô lập và các dịch vụ có thể được mở rộng quy mô một cách độc lập.  Và điều này có nghĩa là nó mang lại chất lượng trải nghiệm tốt hơn cho người tiêu dùng hoặc ứng dụng.

43
00:08:03,140 --> 00:08:12,120
Từ quan điểm của Korn, hiệu suất mạng hỗ trợ là một vấn đề cần quan tâm.  Và sau đó là những thách thức liên quan đến việc giám sát quản lý và bảo mật dữ liệu.

44
00:08:12,800 --> 00:08:20,720
Một số thách thức này có thể được giải quyết bằng cách đầu tư và phát triển công cụ, cơ sở hạ tầng và kỹ năng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\02MicroservicesArchitecture_VVN\000000005.srt -->

1
00:00:00,180 --> 00:00:08,460
Việc áp dụng và xây dựng các dịch vụ vi mô trong bài học này sẽ thảo luận những gì một tổ chức cần để áp dụng kiến ​​trúc dịch vụ vi mô.

2
00:00:08,760 --> 00:00:18,240
Tôi sẽ chia sẻ suy nghĩ của mình về cách một nhà công nghệ có thể đưa ra một trường hợp kinh doanh để đạt được sự hỗ trợ cho việc áp dụng các dịch vụ vi mô trong tổ chức của họ.

3
00:00:18,540 --> 00:00:25,740
Và sau đó tôi sẽ giới thiệu với các bạn hai dự án mới của Tomas Brownfield và Greenfield Micro Services.  Việc áp dụng các dịch vụ vi mô.

4
00:00:25,770 --> 00:00:45,960
Kiến trúc đòi hỏi một tổ chức phải có được các nguồn lực với các kỹ năng công nghệ mới.  Họ cần đầu tư vào các công nghệ như bộ chứa đám mây và một số công cụ để xây dựng và vận hành các dịch vụ vi mô mà tổ chức cần thay đổi quy trình của mình.

5
00:00:45,990 --> 00:00:56,300
Ví dụ, sự cần thiết phải xây dựng thực tiễn của họ.  Tất cả các cách quản lý I.T.  các tài nguyên và ứng dụng không hoạt động đối với Microsoft, các ứng dụng cho biết.

6
00:00:56,310 --> 00:01:07,160
Và vấn đề tiếp theo là khó giải quyết nhất.  Một tổ chức có thể cần phải thay đổi văn hóa của mình.  Ví dụ, thúc đẩy việc ra quyết định và điều này không thể xảy ra trong một sớm một chiều.

7
00:01:07,290 --> 00:01:14,280
Việc áp dụng thành công kiến ​​trúc của Microsoft đòi hỏi sự cam kết từ doanh nghiệp và đội ngũ CNTT.  các nhà lãnh đạo.

8
00:01:14,850 --> 00:01:26,280
Vai trò của kiến ​​trúc sư là hướng dẫn và đào tạo doanh nghiệp và CNTT.  các nhóm về chi phí và lợi ích của việc áp dụng kiến ​​trúc của Microsoft.

9
00:01:26,430 --> 00:01:39,480
Điều quan trọng đối với kiến ​​trúc sư là không chỉ nói về lợi ích kỹ thuật của các dịch vụ vi mô mà còn phải dành thời gian xây dựng một trường hợp kinh doanh để Microsoft áp dụng cho tổ chức cụ thể của họ.

10
00:01:39,720 --> 00:01:51,630
Ý tưởng là kiến ​​trúc sư sẽ dễ dàng nhận được sự hỗ trợ từ CNTT hơn.  và lãnh đạo doanh nghiệp nếu có lợi ích kinh doanh khi áp dụng các dịch vụ vi mô.

11
00:01:51,660 --> 00:01:58,560
Hãy tìm hiểu sâu hơn một chút về cách có thể tạo ra một đề án kinh doanh để áp dụng kiến ​​trúc dịch vụ vi mô.

12
00:01:59,340 --> 00:02:09,150
Để xây dựng một đề án kinh doanh, người ta phải nghĩ đến tác động kinh doanh chứ không phải công nghệ.  Vì vậy, với tư cách là một kiến ​​trúc sư, hãy nghĩ về hoạt động kinh doanh cụ thể cho tổ chức của bạn.

13
00:02:09,240 --> 00:02:16,820
Liệu nó có cải thiện trải nghiệm của khách hàng với tốc độ nhanh chóng không?  Liệu nó có làm giảm chi phí của I.T.  hoạt động?

14
00:02:16,830 --> 00:02:22,650
Có thể nó sẽ tạo ra nguồn doanh thu mới.  Có thể nó sẽ mang lại cho tổ chức của bạn một lợi thế cạnh tranh.

15
00:02:22,830 --> 00:02:39,630
Bây giờ, lợi thế kinh doanh cụ thể sẽ phụ thuộc vào hoạt động kinh doanh của tổ chức bạn.  Vì vậy, với tư cách là kiến ​​trúc sư, bạn phải hiểu hoạt động kinh doanh của tổ chức để có thể vạch ra các lợi ích của kiến ​​trúc dịch vụ vi mô cho tổ chức của mình.

16
00:02:40,470 --> 00:02:51,360
Hãy để tôi cho bạn một ví dụ về lợi ích kỹ thuật và lợi ích kinh doanh.  Một kiến ​​trúc sư tập trung vào khía cạnh công nghệ của các dịch vụ vi mô sẽ mô tả lợi ích như thế này.

17
00:02:51,480 --> 00:02:59,160
Với kiến ​​trúc dịch vụ vi mô.  Chúng tôi có thể phát hành phần mềm sáu tuần một lần thay vì ba tháng một lần như hiện nay.

18
00:02:59,400 --> 00:03:14,750
Một kiến ​​trúc sư nghĩ về lợi ích kinh doanh có thể mô tả lợi ích như thế này.  Nó có thể giúp doanh nghiệp cắt giảm quá trình phát triển sản phẩm xuống còn sáu tuần, nhanh hơn khoảng 50% so với đối thủ cạnh tranh của chúng tôi.

19
00:03:14,880 --> 00:03:22,650
Đọc hai tuyên bố này và suy nghĩ xem tuyên bố nào sẽ thu hút các bên liên quan trong kinh doanh hơn.  Rõ ràng đó là cái thứ hai.

20
00:03:23,250 --> 00:03:31,140
Đó là một ví dụ khác.  Một kiến ​​trúc sư tập trung vào công nghệ có thể nói rằng các ứng dụng mô hình của chúng tôi rất khó thay đổi.

21
00:03:31,590 --> 00:03:39,900
Do đó việc áp dụng công nghệ mới còn chậm.  Chúng ta cần đầu tư vào các dịch vụ vi mô, công nghệ kiến ​​trúc để có thể phát triển nhanh hơn.

22
00:03:40,760 --> 00:03:55,070
Và một kiến ​​trúc sư tập trung vào kinh doanh có thể nói điều gì đó giống như việc áp dụng công nghệ kỹ thuật số mới này có thể giúp doanh nghiệp đạt được mục tiêu tăng giá trị trọn đời của khách hàng dưới dạng dịch vụ vi mô.

23
00:03:55,070 --> 00:04:15,110
Kiến trúc cung cấp nền tảng để áp dụng nhanh hơn các công nghệ kỹ thuật số mới này.  Một lần nữa, ý tưởng là tạo ra tiếng vang với doanh nghiệp và CNTT.  dẫn đầu, nhưng dự đoán lợi ích kinh doanh của các dịch vụ vi mô thay vì chỉ mô tả lợi ích kỹ thuật của các dịch vụ vi mô.

24
00:04:15,800 --> 00:04:23,450
Một điểm quan trọng cần ghi nhớ ở đây là tôi không khuyên bạn nên tạo một tài liệu đề án kinh doanh chính thức dài 50 trang.

25
00:04:23,660 --> 00:04:30,740
Năm đến bảy slide cũng được, miễn là bạn có thể truyền tải đúng thông điệp đến bộ phận CNTT của mình.

26
00:04:30,740 --> 00:04:42,080
và các bên liên quan trong kinh doanh.  Đây là cách tôi muốn thực hiện đề án kinh doanh cho kiến ​​trúc của Microsoft.  Điều đầu tiên tôi muốn thấy trong trường hợp kinh doanh của mình là thông điệp rõ ràng xung quanh giá trị doanh nghiệp.

27
00:04:42,080 --> 00:04:51,150
Nếu có thể.  Bạn cần phải định lượng.  Bạn cần sử dụng những con số phù hợp để có thể tạo ra một tuyên bố có tác động từ góc độ giá trị doanh nghiệp.

28
00:04:51,170 --> 00:05:00,050
Lập một lộ trình về cách bạn mong đợi tổ chức áp dụng các dịch vụ vi mô quan trọng để chỉ ra thời điểm đánh giá.

29
00:05:00,380 --> 00:05:13,920
Bạn sẽ mất ba tháng để mang lại giá trị hay bạn sẽ mất 18 tháng để đạt được điều đó?  Điều quan trọng là bạn phải truyền đạt nó một cách rõ ràng, đặt ra những kỳ vọng đúng đắn và sau đó yêu cầu mô tả những gì bạn cần để thành công.

30
00:05:14,120 --> 00:05:22,010
Bạn đang mong muốn nhận được sự cam kết từ đội ngũ CNTT của mình.  và lãnh đạo doanh nghiệp.  Họ không thể cam kết với bạn trừ khi họ hiểu những gì họ đang làm.

31
00:05:22,250 --> 00:05:32,240
Và tùy thuộc vào vị trí của bạn trong hành trình kiến ​​trúc dịch vụ vi mô đến APAC, việc thể hiện giá trị bằng nội dung nào đó trực tiếp luôn hữu ích.

32
00:05:32,720 --> 00:05:48,050
Bây giờ, đây chỉ là một ví dụ về cách bạn có thể thực hiện một đề án kinh doanh, nhưng hãy sáng tạo, suy nghĩ về những gì hiệu quả cho tổ chức của bạn và sau đó tổng hợp các đề án kinh doanh của bạn lại, vì điều đó sẽ có cơ hội thành công cao hơn so với việc sử dụng một biểu mẫu chung chung  mà tôi đã cung cấp cho bạn.

33
00:05:48,470 --> 00:06:00,080
Có hai loại dự án dịch vụ vi mô.  Dự án Dịch vụ vi mô Brownfield là dự án trong đó có một ứng dụng nguyên khối hiện có cần được chuyển đổi thành các dịch vụ vi mô.

34
00:06:00,440 --> 00:06:07,040
Và sau đó là Dự án Dịch vụ Vi mô Greenfield, trong đó một ứng dụng mới cần được xây dựng nền tảng.

35
00:06:07,490 --> 00:06:16,510
Nhóm dự án brownfield phải xử lý các công nghệ cũ và có hai lựa chọn dành cho nhóm Dự án Brownfield.

36
00:06:16,670 --> 00:06:23,630
Tùy chọn đầu tiên là cấu trúc lại ứng dụng, nghĩa là chuyển đổi ứng dụng nguyên khối sang các dịch vụ vi mô.

37
00:06:24,000 --> 00:06:32,330
Quá trình chuyển đổi này có thể được thực hiện theo cách tiếp cận Big Bang trong đó tất cả các dịch vụ vi mô được xây dựng song song.

38
00:06:32,420 --> 00:06:43,310
Hoặc nhóm dự án có thể thực hiện phương pháp tiếp cận tăng dần hoặc cải tiến bằng cách xây dựng các dịch vụ vi mô bằng cách loại bỏ các phần của ứng dụng nguyên khối hiện có.

39
00:06:43,460 --> 00:06:54,280
Tùy chọn khác là xây dựng lại hoàn toàn ứng dụng brownfield từ đầu.  Nhóm Dự án Greenfield có hai lựa chọn để xây dựng ứng dụng.

40
00:06:54,290 --> 00:07:04,580
Đầu tiên là họ có thể xây dựng một ứng dụng dưới dạng một ứng dụng dịch vụ vi mô ngay từ đầu.  Một số điểm cần cân nhắc mà nhóm Dự án Cánh đồng Xanh cần lưu ý.

41
00:07:04,940 --> 00:07:12,380
Thêm vào đó, một là cần phải đảm bảo rằng họ có sẵn các công cụ và công nghệ để xây dựng các dịch vụ vi mô này.

42
00:07:12,380 --> 00:07:20,960
Và sự sẵn sàng của tổ chức cũng đóng một vai trò quan trọng.  Ví dụ, tổ chức có trưởng thành, phát triển các thông lệ và quy trình không?

43
00:07:21,300 --> 00:07:30,860
Tùy chọn này được đề xuất cho các nhóm có kinh nghiệm với các dịch vụ vi mô và đang tìm kiếm các tổ chức đã áp dụng các dịch vụ vi mô.

44
00:07:31,040 --> 00:07:52,010
Tùy chọn thứ hai là sử dụng mô hình.  CNTT lần đầu tiên tiếp cận mô hình.  Cách tiếp cận đầu tiên của nó gợi ý rằng nhóm ứng dụng Greenfield tạo ra một ứng dụng nguyên khối, được thiết kế tốt, tích lũy một số kinh nghiệm với ứng dụng đó, sau đó tách các phần của ứng dụng Mollenard để tạo ra các dịch vụ vi mô phù hợp.

45
00:07:52,040 --> 00:07:57,830
Bạn có thể đọc thêm về phương pháp này tại liên kết này.  Đã đến lúc ôn lại những điểm chính của bài học này.

46
00:07:58,100 --> 00:08:08,320
Với tư cách là một kiến ​​trúc sư ý tưởng làm việc trên các ứng dụng dịch vụ vi mô, bạn phải nghĩ về lợi ích kinh doanh cụ thể của các dịch vụ vi mô đối với tổ chức của mình.

47
00:08:08,600 --> 00:08:17,960
Có hai loại dự án dịch vụ vi mô trong dự án Dịch vụ vi mô Brownfield.  Một ứng dụng MIGNOLET hiện có cần được chuyển đổi sang các dịch vụ vi mô.

48
00:08:17,960 --> 00:08:33,850
Có hai lựa chọn cho loại dự án này.  Đầu tiên là cấu trúc lại ứng dụng hiện có thành ứng dụng dịch vụ vi mô và thứ hai là gỡ bỏ ứng dụng brownfield và tạo ứng dụng dịch vụ vi mô ngay từ đầu.

49
00:08:33,860 --> 00:08:40,100
Loại dự án dịch vụ vi mô thứ hai là Dự án Greenfield, trong đó nhóm dự án không có bất kỳ loại dự án nào.

50
00:08:40,340 --> 00:08:58,690
Nợ kế thừa cần giải quyết.  Có hai lựa chọn cho các dự án greenfield Các dự án Greenfield có thể được triển khai với kiến ​​trúc của Microsoft ngay từ đầu hoặc nhóm Dự án Greenfield có thể áp dụng phương pháp tiếp cận mô hình đầu tiên, trong đó việc đầu tiên là tạo một ứng dụng nguyên khối rồi chuyển đổi nó thành các dịch vụ vi mô.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03 Introduction to Domain Driven Design\001 Domain, Sub-Domain and Domain Experts.en.srt -->

1

00:00:00,150 --> 00:00:05,520

Understanding the domain by the end of this lesson, you should be able to explain what is a domain



2

00:00:05,880 --> 00:00:10,050

and what is the role of a domain expert in this lesson.



3

00:00:10,290 --> 00:00:18,310

I'll also introduce you to my travels, which is a fictitious company used as a case study in this course.



4

00:00:18,720 --> 00:00:20,280

Let's start with the English language.



5

00:00:20,280 --> 00:00:26,700

Definition of domain or domain is defined as a sphere of knowledge, influence or activity.



6

00:00:26,760 --> 00:00:31,380

Here are the examples of domains from the fields of engineering and sciences.



7

00:00:31,410 --> 00:00:34,710

A chemist has a thorough understanding of chemicals.



8

00:00:34,920 --> 00:00:41,580

The activities they carry out consist of experimenting with different chemicals in the field of space



9

00:00:41,580 --> 00:00:42,280

sciences.



10

00:00:42,330 --> 00:00:49,350

Scientists have the knowledge of how the space walks and activities may consist of understanding the



11

00:00:49,350 --> 00:00:56,160

effect of zero gravity on human body, and that may influence the design of the space stations.



12

00:00:56,180 --> 00:01:02,640

So if you think about the business perspective of domain or domain, represent a field or industry in



13

00:01:02,640 --> 00:01:04,610

which the business operates.



14

00:01:04,950 --> 00:01:10,800

For example, Banking Chase and Bank of America operate in the banking industry.



15

00:01:11,040 --> 00:01:15,830

Oil and gas Shell and BP operate in the oil and gas industry.



16

00:01:15,840 --> 00:01:20,370

And then there is retail and many other industries that you can think of.



17

00:01:20,730 --> 00:01:23,490

Now let's look at the domain from the software perspective.



18

00:01:23,730 --> 00:01:30,600

Domain may be thought of as the representation of the problem space for that software, for example,



19

00:01:30,600 --> 00:01:34,920

e commerce, social media, media, streaming and resource planning.



20

00:01:35,220 --> 00:01:39,270

These are all examples of domains for the software systems.



21

00:01:39,600 --> 00:01:42,780

The domain is made up of multiple subdomains.



22

00:01:42,810 --> 00:01:49,520

For example, in the case of banking, they may be a retail and a merchant account subdomain.



23

00:01:49,530 --> 00:01:54,750

Each of these different type of accounts have different rules and regulation, different type of products



24

00:01:54,750 --> 00:01:57,930

and different type of customers who buy these products.



25

00:01:57,940 --> 00:02:04,560

The knowledge needed to process the loans is very different from the knowledge needed to process the



26

00:02:04,560 --> 00:02:08,900

information in the merchant account for large and complex domains.



27

00:02:08,910 --> 00:02:14,220

It is virtually impossible for a domain expert to know everything about the domain.



28

00:02:14,220 --> 00:02:21,300

As a result, there are multiple subject matter experts or domain experts within a domain mostly aligned



29

00:02:21,300 --> 00:02:23,840

with the subdomains in the bigger domain.



30

00:02:23,880 --> 00:02:29,430

For example, in the case of banking, they may be retained accounts expert or much of the court's expert



31

00:02:29,430 --> 00:02:31,230

and a loan account expert.



32

00:02:31,230 --> 00:02:35,700

Each of these type of accounts have different regulatory and compliance requirements, so there may



33

00:02:35,700 --> 00:02:42,330

be an expert who understands the regulations and the compliance requirements for each of these account



34

00:02:42,330 --> 00:02:42,840

types.



35

00:02:43,140 --> 00:02:50,850

Technodrome operate in the travel and leisure industry and Travel has travel advisors who are experts



36

00:02:50,850 --> 00:02:52,320

in the travel industry.



37

00:02:52,530 --> 00:02:58,410

They understand the needs and wants of the customers, and they use their knowledge to influence the



38

00:02:58,410 --> 00:03:00,390

decisions made by the customers.



39

00:03:00,570 --> 00:03:06,900

From the activities perspective, they plan their customers vacation to ensure that the planned vacation



40

00:03:06,900 --> 00:03:13,290

is well within the customer's budget and the customer should get the best experience possible on their



41

00:03:13,290 --> 00:03:13,890

vacation.



42

00:03:14,040 --> 00:03:20,670

Like other large industries, travel industry also has multiple subdomains and multiple experts within



43

00:03:20,670 --> 00:03:24,130

these subdomains, you have already seen the role of a travel advisor.



44

00:03:24,170 --> 00:03:29,640

Then there are other experts that Achmea has to hire, such as department contract expert.



45

00:03:29,670 --> 00:03:35,640

This expert understand how to manage the contracts with other entities in the travel industry, for



46

00:03:35,640 --> 00:03:38,280

example, airlines or cruise ships or hotels.



47

00:03:38,280 --> 00:03:45,120

And then there may be accounting, customer support and multiple other export needed for smooth operations



48

00:03:45,120 --> 00:03:46,350

of ACMC travel.



49

00:03:46,530 --> 00:03:48,300

Time for a quick exercise.



50

00:03:48,300 --> 00:03:49,590

Answer these questions.



51

00:03:49,590 --> 00:03:51,660

The first question is what do you mean?



52

00:03:51,660 --> 00:03:56,040

Do you operate and think about the business domain, not the technology.



53

00:03:56,040 --> 00:04:01,860

Doing chances are high that you are a technologist, but that is your expertise, not your domain.



54

00:04:01,920 --> 00:04:07,500

So for example, I used to work for an insurance company, so at that time the domain that I operated



55

00:04:07,500 --> 00:04:08,630

in was insurance.



56

00:04:08,670 --> 00:04:10,720

Second question I would like you to think about this.



57

00:04:10,770 --> 00:04:14,620

What are the subdomains within the domain that you operate in?



58

00:04:14,640 --> 00:04:20,250

For example, when I was working in the insurance company, the subdomains were life insurance group,



59

00:04:20,250 --> 00:04:22,200

insurance, commercial insurance.



60

00:04:22,200 --> 00:04:27,000

Third question I would like you to answer is a list of the domain experts that you work with.



61

00:04:27,000 --> 00:04:32,850

During my time at the insurance company, I remember working with actuaries who create risk models.



62

00:04:33,180 --> 00:04:36,720

I used to work with regulatory and compliance experts.



63

00:04:36,840 --> 00:04:42,510

We used to explain to me the regulatory and the compliance requirements from the insurance industry's



64

00:04:42,510 --> 00:04:43,200

perspective.



65

00:04:43,200 --> 00:04:46,200

So go ahead, pause the video, try to answer these questions.



66

00:04:46,500 --> 00:04:52,560

Hopefully you enjoyed the last exercise and it's time for a quick review before I end this lesson.



67

00:04:52,950 --> 00:04:57,810

Domain is defined as a sphere of knowledge, influence or activity.



68

00:04:57,810 --> 00:04:59,790

You can think of banking, oil and.



69

00:04:59,870 --> 00:05:06,860

Gas and retail as business domains, domains are made up of multiple subdomains, it is not possible



70

00:05:06,860 --> 00:05:13,570

for a single expert to have a total knowledge of all the subdomains in a complex or large domain.



71

00:05:13,610 --> 00:05:18,640

As a result, multiple domain experts are needed to support business functions.



72

00:05:18,680 --> 00:05:25,040

Mostly, these domain experts are aligned with the subdomains within the larger domain.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03 Introduction to Domain Driven Design\002 Conceptual models, Architecture and Design.en.srt -->

1

00:00:00,210 --> 00:00:05,900

Architecture and design, in this lesson, you learn about conceptual models and architectural models,



2

00:00:06,150 --> 00:00:10,500

you'll also learn about the differences between architecture and design.



3

00:00:10,890 --> 00:00:17,130

Conceptual models are defined as a representation of a system made from composition of concepts.



4

00:00:17,580 --> 00:00:19,370

The key word here is concepts.



5

00:00:19,650 --> 00:00:25,000

In other words, the focus is not on the physical parameters of the system.



6

00:00:25,200 --> 00:00:29,130

For example, take a look at this model for a hybrid car.



7

00:00:29,280 --> 00:00:36,420

The designer of this car has put together the critical concept for this system or car that is a battery



8

00:00:36,420 --> 00:00:40,770

and an electric motor as a fuel storage tank and a gas engine.



9

00:00:40,980 --> 00:00:45,360

The focus here is on the critical concepts that make up the system.



10

00:00:45,390 --> 00:00:51,570

The model is not very detailed, but it does contain some physical parameters that are applicable to



11

00:00:51,570 --> 00:00:57,000

the concepts put together in this system, such as the combined horsepower of the car will be two hundred



12

00:00:57,000 --> 00:00:57,680

and eight.



13

00:00:57,690 --> 00:01:03,750

The capacity of the fuel tank is 14 GERLIN and the capacity of the battery is 70 kilowatt hour.



14

00:01:03,780 --> 00:01:09,370

Now, this information is not sufficient for the engineers in the factories to be able to build a car.



15

00:01:09,390 --> 00:01:12,030

So then what is the point of this conceptual model?



16

00:01:12,240 --> 00:01:15,850

There are multiple benefits of starting with conceptual models.



17

00:01:15,990 --> 00:01:20,760

The first one is that it enhances the understanding of the designers.



18

00:01:20,970 --> 00:01:24,440

As the designers put together the concept and think through it.



19

00:01:24,450 --> 00:01:29,270

They may find flaws in the design or they may find opportunities for improvement.



20

00:01:29,280 --> 00:01:33,810

And at the end of the day, a good conceptual model will lead to a better product.



21

00:01:33,840 --> 00:01:40,280

Second one is that it makes it easy to convey the ideas behind the concept to the stakeholders.



22

00:01:40,560 --> 00:01:46,550

So think about the designer of this car going to the investors and showing this model.



23

00:01:46,560 --> 00:01:52,580

It'll be easy for them to explain how these concepts can be put together to build the end product.



24

00:01:52,760 --> 00:01:59,250

Towards the conceptual models provide a point of reference to create detailed specifications.



25

00:01:59,280 --> 00:02:04,830

This model contains some information about the physical aspects of the end product.



26

00:02:04,860 --> 00:02:10,530

This information, combined with the models layout, can act as the starting point for the designers



27

00:02:10,530 --> 00:02:13,440

of the electric motor and the gas engine.



28

00:02:13,450 --> 00:02:18,360

In other words, the electrical engineer will be able to use this information to put together a more



29

00:02:18,360 --> 00:02:20,610

detailed design for the electric motor.



30

00:02:20,610 --> 00:02:25,860

And the same is true for the mechanical engineer who will put together the detailed design for the gas



31

00:02:25,860 --> 00:02:26,230

engine.



32

00:02:26,250 --> 00:02:32,430

The fourth one is that conceptual models provide documentation for future reference, like the designer



33

00:02:32,430 --> 00:02:38,680

of the car, the designer of the software products also start with the conceptual models.



34

00:02:39,060 --> 00:02:45,480

The first thing to do is identify the core concepts that need to be put together to design the final



35

00:02:45,480 --> 00:02:45,980

product.



36

00:02:46,080 --> 00:02:51,810

They come up with the common terminology for the domain concept used in the model.



37

00:02:51,810 --> 00:02:54,880

They identify the different parts of the system.



38

00:02:54,900 --> 00:03:01,280

So if you think about the banking domain, the designer will put together the columns such as Account



39

00:03:01,290 --> 00:03:07,060

Transaction Ledger and clearly document what each of these items mean.



40

00:03:07,200 --> 00:03:12,890

Also, they will identify the different parts of the overall product or the system.



41

00:03:13,260 --> 00:03:19,050

Next, the designer identifies and documents the relationship between the various domain concepts,



42

00:03:19,350 --> 00:03:25,350

and they also identify the critical or the foundational parameters for these concepts, as well as the



43

00:03:25,350 --> 00:03:27,180

relationships in the banking domain.



44

00:03:27,300 --> 00:03:31,350

Think of the relationship between accounts, transactions and ledger.



45

00:03:31,470 --> 00:03:38,100

All of this information is then used for creating the architectural model, which is the visualization



46

00:03:38,100 --> 00:03:40,910

of the system represented by the model.



47

00:03:41,070 --> 00:03:48,600

A more formal definition of the architectural model or architecture is that it is a structured representation



48

00:03:48,600 --> 00:03:52,380

of a solution that meets the requirements and the problems face.



49

00:03:52,410 --> 00:04:00,150

It is a high level abstraction of parts of the end solution that presents a view or a perspective on



50

00:04:00,150 --> 00:04:06,810

how the requirements will be met, and it assists in answering the questions posed by different stakeholders.



51

00:04:06,840 --> 00:04:11,910

A common question that comes up at this point is what is the difference between architectural model



52

00:04:11,910 --> 00:04:13,610

or architecture and design?



53

00:04:13,770 --> 00:04:17,310

The difference is in the level of detail and focus.



54

00:04:17,350 --> 00:04:19,230

Architecture is mostly high level.



55

00:04:19,350 --> 00:04:26,340

It provides a skeleton for the end product and the focus has more long term concepts depicted in the



56

00:04:26,340 --> 00:04:32,820

architecture may not change as frequently, or they may not even change at all for the lifetime of the



57

00:04:32,820 --> 00:04:37,920

product, whereas the design is relatively detailed and the focus is on the implementation.



58

00:04:38,100 --> 00:04:43,970

Have deliberately used the term relative and the reason is because even designs can be high level.



59

00:04:43,980 --> 00:04:49,590

But they are relatively detailed compared to the conventional or traditional architectural models.



60

00:04:49,800 --> 00:04:54,750

As an exercise, let's carry out the architecture and design for a rideshares system.



61

00:04:54,780 --> 00:04:58,380

Think about these commonly used ritcher applications.



62

00:04:58,560 --> 00:04:59,910

Let's start with the architect.



63

00:05:00,150 --> 00:05:06,240

Moral fust, the users of the system will be the drivers and the customers of the ride share platform,



64

00:05:06,610 --> 00:05:12,910

they'll use their mobile phones for requesting the rights and for accepting the rights to the system



65

00:05:13,060 --> 00:05:15,240

will be the right request processor.



66

00:05:15,370 --> 00:05:21,670

This right request processor will receive requests from the drivers and customers, and it should be



67

00:05:21,670 --> 00:05:27,610

able to handle 5000 rides for our all of the capabilities built into the right request.



68

00:05:27,610 --> 00:05:30,780

Processor will be exposed by way of an API earlier.



69

00:05:30,970 --> 00:05:34,960

This area should be able to handle 500 calls per second.



70

00:05:34,990 --> 00:05:41,090

The drivers and the customers of the system will be tracked by way of some kind of a streaming mechanism.



71

00:05:41,230 --> 00:05:48,190

It is expected that 10000 messages per second will be received by the streaming mechanism and these



72

00:05:48,190 --> 00:05:51,560

messages will have the location of the drivers and the customers.



73

00:05:51,580 --> 00:05:57,550

These streams will be consumed by the driver and customer trackers, and this component should be able



74

00:05:57,550 --> 00:06:01,450

to handle 100000 active users at any time.



75

00:06:01,660 --> 00:06:08,110

The right request processor will manage all of the data in multiple databases, and collectively the



76

00:06:08,110 --> 00:06:13,260

size of the data will increase by roughly two terabytes per year.



77

00:06:13,390 --> 00:06:20,290

Apart from these core components, the right request processor will use other components for geospatial



78

00:06:20,290 --> 00:06:23,070

services as well as for notifications.



79

00:06:23,110 --> 00:06:27,690

So this is a very high level architecture of a Raksha system.



80

00:06:27,700 --> 00:06:29,860

Next will carry out a quick exercise.



81

00:06:29,890 --> 00:06:34,130

Think of yourself as the designer for the rideshares system.



82

00:06:34,540 --> 00:06:40,450

Now you are provided this architectural diagram in which there are some requirements and the layout



83

00:06:40,600 --> 00:06:43,150

of various components that make up the system.



84

00:06:43,180 --> 00:06:45,950

As you can see, there are no implementation details in it.



85

00:06:46,030 --> 00:06:53,320

Your task is to decide what technologies you will use for implementing the component in each of these



86

00:06:53,320 --> 00:06:53,880

boxes.



87

00:06:53,890 --> 00:06:58,580

The technology that you select must meet all the requirements for the system.



88

00:06:58,600 --> 00:07:01,540

Keep in mind, there is no right or wrong answer.



89

00:07:01,550 --> 00:07:03,510

You are the best judge as the designer.



90

00:07:03,550 --> 00:07:06,440

So go ahead post the video and take a stab at it.



91

00:07:06,640 --> 00:07:12,160

Next, I'll walk you through a design that can be thought of as the starting point for the detailed



92

00:07:12,160 --> 00:07:14,170

design for each of these components.



93

00:07:14,410 --> 00:07:21,070

As the designer of the system, I have decided to implement the user application on Android and iOS



94

00:07:21,190 --> 00:07:25,350

since 10000 messages need to be handled in the location streams.



95

00:07:25,630 --> 00:07:27,580

I've decided to go with COFCO.



96

00:07:27,590 --> 00:07:34,600

I consider Jabat Amcu and active AMCU, but those messaging platforms will not be able to handle the



97

00:07:34,600 --> 00:07:38,970

kind of load that's expected and that is the reason I decided to go with Kafka.



98

00:07:39,160 --> 00:07:47,080

The AP earlier should be able to handle 500 calls per second and I also think we will need good AIPA



99

00:07:47,080 --> 00:07:48,430

management capabilities.



100

00:07:48,610 --> 00:07:52,350

So I've decided to go with APJ, the driver and customer.



101

00:07:52,360 --> 00:08:02,360

Krako needs to keep track of 100000 active users and I will go with Mongo DB and not just based implementation.



102

00:08:02,410 --> 00:08:10,060

Did I request Processer has to handle 5000 rides per hour and I think it'll be easy to take care of



103

00:08:10,060 --> 00:08:18,010

these 5000 rides for our using the spring and the ride request processor will need the data layer,



104

00:08:18,190 --> 00:08:24,610

which I have decided to implement by using Mongo DB and my sequel for the notification system will use



105

00:08:24,610 --> 00:08:29,680

Tullio and for geospatial services will use Google Maps APIs.



106

00:08:29,950 --> 00:08:35,080

So this is an architectural model overlayed but some implementation details.



107

00:08:35,230 --> 00:08:41,830

Hence this is the first level of design for the rideshares system as a next step, the design of the



108

00:08:41,830 --> 00:08:42,340

system.



109

00:08:42,460 --> 00:08:45,880

Macario detailed design for each of the components.



110

00:08:46,200 --> 00:08:49,060

There are three key concepts that you have learned in this lecture.



111

00:08:49,120 --> 00:08:54,640

The first one is the conceptual models, which is a set of concepts and their relationships.



112

00:08:54,940 --> 00:09:01,750

Architectural models are a structured representation of a solution that meets the requirements from



113

00:09:01,750 --> 00:09:02,710

the problem space.



114

00:09:02,710 --> 00:09:08,440

The architectural more does not have any implementation details, whereas the design is a structured



115

00:09:08,440 --> 00:09:13,630

representation of a solution that has some level of implementation details in it.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03 Introduction to Domain Driven Design\003 Modeling techniques & Architectural Styles.en.srt -->

1

00:00:00,180 --> 00:00:07,080

Modelling techniques and architectural styles in this lesson are discussed the commonly used modeling



2

00:00:07,080 --> 00:00:10,860

techniques and architectural styles for software development.



3

00:00:11,190 --> 00:00:14,620

At the end of this lesson, I touch on Demand-Driven Design.



4

00:00:14,910 --> 00:00:19,430

There are multiple ways for creating architectural models for software system.



5

00:00:19,440 --> 00:00:22,520

When I'm creating a model, I follow three guiding principles.



6

00:00:22,530 --> 00:00:28,010

I think about the purpose of the model and who are the audience for the model that I'm creating.



7

00:00:28,020 --> 00:00:31,440

I think about the perspective and the viewpoints of the audience.



8

00:00:31,470 --> 00:00:36,870

The idea is to think about their interests and their concerns, build a model that I'm creating, address



9

00:00:36,870 --> 00:00:39,300

their concerns and answer their questions.



10

00:00:39,310 --> 00:00:41,360

And the third one is level of detail.



11

00:00:41,490 --> 00:00:46,920

How detailed should my model be so that it provides most value to the target audience?



12

00:00:47,070 --> 00:00:50,180

There are many techniques for creating architectural models.



13

00:00:50,340 --> 00:00:53,190

I will touch on two popular techniques.



14

00:00:53,190 --> 00:01:00,120

The four plus one architectural view model and unified modeling language, or UML discourse does not



15

00:01:00,120 --> 00:01:03,270

require you to be an expert in either of these.



16

00:01:03,540 --> 00:01:10,140

But it is highly recommended that if you have not worked with UML in the past, please go to some quick



17

00:01:10,140 --> 00:01:12,750

tutorials which you can easily find on Google.



18

00:01:13,080 --> 00:01:19,620

The four plus one architectural view model describes the architecture from the viewpoint of multiple



19

00:01:19,620 --> 00:01:20,560

stakeholders.



20

00:01:20,580 --> 00:01:27,090

Central to this technique is the idea of scenarios or use cases, or think of these as requirements.



21

00:01:27,270 --> 00:01:34,140

These scenarios are used as guide for creating the multiple views, and these scenarios are also used



22

00:01:34,380 --> 00:01:36,540

for validating the architecture.



23

00:01:36,690 --> 00:01:44,830

Logical view focuses on the functionality or the capabilities exposed by the system to the end user.



24

00:01:45,120 --> 00:01:51,780

The process view, as the name suggests, explains the processes in the system and how these processes



25

00:01:51,780 --> 00:01:53,420

interact with each other.



26

00:01:53,580 --> 00:02:00,990

The development view illustrates a system from a programmers perspective and is concerned with software



27

00:02:00,990 --> 00:02:01,710

management.



28

00:02:01,890 --> 00:02:04,830

This view is also known as the implementation view.



29

00:02:04,990 --> 00:02:12,480

The last one is the physical view that depicts the system from the point of view of the engineers.



30

00:02:12,630 --> 00:02:19,110

It is concerned with the apology of software components on the physical layer as well as the physical



31

00:02:19,110 --> 00:02:21,720

connections between these components.



32

00:02:22,080 --> 00:02:25,670

You must be wondering why this technique is named as four plus one.



33

00:02:25,680 --> 00:02:29,820

The reason is there are four views and plus one is for the scenarios.



34

00:02:30,180 --> 00:02:34,180

A large software project involves multiple stakeholders.



35

00:02:34,200 --> 00:02:38,730

There may be tens or even hundreds of stakeholders involved in the project.



36

00:02:38,820 --> 00:02:42,840

These stakeholders have a different set of interest and concerns.



37

00:02:42,840 --> 00:02:47,130

Think about the business executive who is sponsoring the project.



38

00:02:47,160 --> 00:02:54,000

Their interest is in understanding the value that the system will provide to the end user and how that



39

00:02:54,000 --> 00:02:58,770

end user value will translate into the value for the business.



40

00:02:58,770 --> 00:03:04,890

For the business experts who understand the business, it is important that the system implements the



41

00:03:04,890 --> 00:03:08,490

right set of processes and these processes are accurate.



42

00:03:08,490 --> 00:03:12,090

As a result, their interest will be in the process views.



43

00:03:12,210 --> 00:03:16,260

Developers are concerned with the implementation of the system.



44

00:03:16,260 --> 00:03:21,260

They are concerned about the deployment and the management of the software.



45

00:03:21,270 --> 00:03:24,330

As a result, their interest is in development view.



46

00:03:24,390 --> 00:03:26,970

The network engineers are not concerned about.



47

00:03:26,970 --> 00:03:30,210

The development for you are the logical view of the process view.



48

00:03:30,510 --> 00:03:36,780

They would like to understand how the various servers that are host to applications or the components



49

00:03:37,020 --> 00:03:39,270

will talk to each other over the network.



50

00:03:39,270 --> 00:03:45,960

And last but not least, we have the architect who is responsible for creating all of these views and



51

00:03:45,960 --> 00:03:51,660

ensuring that these views are providing the most value to each of these stakeholders.



52

00:03:51,750 --> 00:03:56,430

Now, keep in mind that I have depicted just a small set of stakeholders.



53

00:03:56,550 --> 00:04:01,410

There may be many more stakeholders playing different roles and the software initiative.



54

00:04:01,440 --> 00:04:09,150

Now it's time for a quick exercise list out the stakeholders in your organization and think about which



55

00:04:09,150 --> 00:04:12,330

views will be most appropriate for them.



56

00:04:12,330 --> 00:04:18,930

So we'll have positive video and tried out the unified modeling language, or UML was created by the



57

00:04:18,930 --> 00:04:20,490

Object Management Group.



58

00:04:20,490 --> 00:04:28,020

It provides a standard set of diagrams for architectural modeling and these diagrams are created by



59

00:04:28,020 --> 00:04:30,660

using a standard set of notations.



60

00:04:30,690 --> 00:04:38,250

The subject of UML is quite vast and it'll take a course on its own to explain all of the aspects of



61

00:04:38,250 --> 00:04:38,660

UML.



62

00:04:38,820 --> 00:04:46,410

So my suggestion is that you please go to the basic UML notation and diagrams on your own before proceeding



63

00:04:46,410 --> 00:04:46,920

forward.



64

00:04:47,070 --> 00:04:54,090

The latest version of UML consists of fourteen standard diagrams and these fourteen standard diagrams



65

00:04:54,090 --> 00:04:59,910

maybe use for creating the various views in the four plus one architectural.



66

00:05:00,090 --> 00:05:05,320

View model, I like to use the use case diagram for depicting the scenarios for logical views.



67

00:05:05,370 --> 00:05:09,500

I like to use the straight diagram and the class diagram for process for you.



68

00:05:09,540 --> 00:05:13,890

You may use the sequence diagram and activity diagram for development for you.



69

00:05:13,980 --> 00:05:16,770

You may use the component diagram and package diagram.



70

00:05:16,950 --> 00:05:22,970

And for the physical view deployment diagram works out the best next hour to discuss architectural styles.



71

00:05:23,010 --> 00:05:27,420

Now, before going straight to the software architectural styles, I would like you to think about the



72

00:05:27,420 --> 00:05:29,600

different bridge types that you have seen.



73

00:05:29,760 --> 00:05:32,630

There are multiple ways in which bridges are designed.



74

00:05:32,640 --> 00:05:39,810

Each of these bridge designs follow a set of common principles and depending on the needs, the requirements



75

00:05:39,810 --> 00:05:46,070

and the condition, the bridge designer can model the bridge using one of these architectural styles.



76

00:05:46,080 --> 00:05:50,520

The idea of the software architectural style is similar software.



77

00:05:50,520 --> 00:05:58,140

Architectural style may be thought of as reusable architectural pattern, which may be used as a solution



78

00:05:58,140 --> 00:05:59,760

to a commonly occurring problem.



79

00:06:00,120 --> 00:06:05,820

There are multiple architectural styles and these architectural styles are categorized based on the



80

00:06:05,820 --> 00:06:07,170

key focus area.



81

00:06:07,200 --> 00:06:13,800

The service oriented architecture and the message architecture falls in the category of architectural



82

00:06:13,800 --> 00:06:20,490

style that focuses on the communication between the components, the architecture and the object oriented.



83

00:06:20,490 --> 00:06:28,170

Architecture and design are the common styles used when the architect is focusing on the structure of



84

00:06:28,170 --> 00:06:34,830

the system, the client server and the three-tier architectural styles falls in the category of deployment



85

00:06:34,830 --> 00:06:41,280

wherein the focus is on the deployment of the various components that make up this system.



86

00:06:41,430 --> 00:06:47,580

The database centric design and the dinner floor diagrams as tiles use with the architect is focusing



87

00:06:47,580 --> 00:06:50,670

on the core data within the business domain.



88

00:06:51,000 --> 00:06:56,400

And the last architectural style that I'll touch on is the domain reference design, where the focus



89

00:06:56,550 --> 00:07:00,320

is on the business domain rather than the technology.



90

00:07:00,690 --> 00:07:06,870

My intent for this lesson was just to give you a high level view of what is domain driven design and



91

00:07:06,870 --> 00:07:09,990

how is it different from other architectural styles.



92

00:07:10,020 --> 00:07:15,600

You will be learning everything about domain driven design in this course at this point, let's review



93

00:07:15,600 --> 00:07:17,400

the key learnings from this lesson.



94

00:07:17,610 --> 00:07:21,570

Architects create models using different modeling techniques.



95

00:07:21,600 --> 00:07:28,920

I touched on two such techniques the four plus one architectural view model and unified modeling language.



96

00:07:28,920 --> 00:07:33,330

These two be combined to create very effective architectural models.



97

00:07:33,480 --> 00:07:35,880

There are multiple architectural styles.



98

00:07:36,000 --> 00:07:42,630

Each of these styles follow a set of common principles and they focus on certain specific aspect of



99

00:07:42,630 --> 00:07:43,470

the system.



100

00:07:43,470 --> 00:07:48,060

Architects maddog any of these styles depending on their needs and preferences.



101

00:07:48,060 --> 00:07:53,880

Domain driven design is an architectural style in which the focus is on the business domain.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03 Introduction to Domain Driven Design\004 Domain Models.en.srt -->

1

00:00:00,180 --> 00:00:07,380

Domain models in this lecture, I'll talk about what is domain model and then I'll discuss the elements



2

00:00:07,530 --> 00:00:08,820

of a domain model.



3

00:00:09,480 --> 00:00:13,440

I'll start this lesson with the question why do businesses invest in software?



4

00:00:13,650 --> 00:00:20,850

Think about your past experiences with software development and think about the reasons why your employer



5

00:00:21,000 --> 00:00:25,600

spent hundreds of thousands or even millions of dollars in building software.



6

00:00:25,650 --> 00:00:27,720

There's no right or wrong answer here.



7

00:00:27,750 --> 00:00:31,520

So go ahead, pause the video and give it a thought for a few seconds.



8

00:00:31,860 --> 00:00:37,980

One common response to this question is that businesses invest in software to fulfill some needs.



9

00:00:38,190 --> 00:00:39,920

The key word here is need.



10

00:00:40,230 --> 00:00:48,630

And when I look back at my experience as a software developer and architect, I can think of many such



11

00:00:48,630 --> 00:00:51,170

needs a reduction in manual labor.



12

00:00:51,480 --> 00:00:59,070

So I worked on a process automation system and built some machine learning models to help the business



13

00:00:59,070 --> 00:01:00,760

reduce the manual labor.



14

00:01:00,780 --> 00:01:05,790

Another one that comes to my mind is the need for increasing the efficiency dividend.



15

00:01:05,850 --> 00:01:12,190

I worked in a team that built workflow engine and created multiple productivity tools in one initiative.



16

00:01:12,210 --> 00:01:18,180

I was given the task to help the business gain competitive edge by building a customer loyalty system



17

00:01:18,180 --> 00:01:20,020

and a business intelligence platform.



18

00:01:20,040 --> 00:01:24,150

Now, I'm pretty sure you must have come up with your own list of such needs.



19

00:01:24,420 --> 00:01:29,000

Now, these are the needs or the desired end goals to be met by the software.



20

00:01:29,340 --> 00:01:34,860

But then what is the reason behind these need to think about the reasons behind these needs?



21

00:01:35,040 --> 00:01:41,160

I came up with these business problems when my employer said that they want to reduce manual labor.



22

00:01:41,310 --> 00:01:47,560

They were actually looking to reduce the size of the workforce to save on payroll expenses.



23

00:01:48,030 --> 00:01:54,690

The end goal of increasing the efficiency was driven by the fact that the customers were complaining



24

00:01:54,690 --> 00:01:58,890

about the long response times for fulfilling the orders.



25

00:01:59,130 --> 00:02:05,580

And from the competitive edge perspective, I realized that my employer was concerned about competitors



26

00:02:05,850 --> 00:02:12,580

pulling over their customers by offering them better discounts or by offering them loyalty programs.



27

00:02:12,630 --> 00:02:17,720

So the reason businesses invest in software is to solve some business problems.



28

00:02:17,730 --> 00:02:23,640

And these are some of the business problems that I have dealt with as a software developer.



29

00:02:24,000 --> 00:02:29,640

Business problems may be defined as current or long term challenges and issues faced by the business



30

00:02:29,880 --> 00:02:33,360

that may prevent the business from achieving its goals.



31

00:02:33,840 --> 00:02:36,460

These goals may be short term or they may be long term.



32

00:02:36,630 --> 00:02:42,770

It is important for the architects to understand the business problem and understand the business problem.



33

00:02:42,840 --> 00:02:49,170

The architect must understand the domain fast, and for that the architects create domain models.



34

00:02:49,530 --> 00:02:56,850

A domain model is defined as organized and structured knowledge of the domain that is relevant for solving



35

00:02:56,850 --> 00:02:57,900

a business problem.



36

00:02:58,200 --> 00:03:01,770

The key words here are organized and structured knowledge.



37

00:03:02,550 --> 00:03:05,190

The domain model consists of multiple parts.



38

00:03:05,610 --> 00:03:12,700

Key concepts are the foundational concepts related to the domain, for example, in the banking domain.



39

00:03:12,720 --> 00:03:18,840

The key concepts may include the calculation of simple interest and calculation of component trust.



40

00:03:18,900 --> 00:03:21,330

Next one is the domain vocabulary.



41

00:03:21,360 --> 00:03:27,930

The domain vocabulary consist of common terms and their definitions used by the stakeholders when they



42

00:03:27,930 --> 00:03:32,400

are discussing the problems faced within that domain for the banking domain.



43

00:03:32,610 --> 00:03:38,670

The domain vocabulary will consist of a list of items such as transaction, credit, transaction posting,



44

00:03:38,670 --> 00:03:40,660

etc. with their meanings.



45

00:03:40,710 --> 00:03:48,420

This is to ensure that all stakeholders have a common understanding of all the terms used in that domain.



46

00:03:48,720 --> 00:03:55,080

Think of the domain entities as domain objects that have a unique identity.



47

00:03:55,200 --> 00:04:02,100

The attribute in the domain object may change over the lifetime of the object, but the identity is



48

00:04:02,100 --> 00:04:03,730

retained in the banking domain.



49

00:04:03,930 --> 00:04:10,040

The examples are saving account and checking account, which are uniquely identified by the account.



50

00:04:10,050 --> 00:04:15,660

No transaction is another entity which is uniquely identified by a transaction ID.



51

00:04:15,840 --> 00:04:23,280

In the real world, the domain entities have relationship with other domain entities and the domain



52

00:04:23,280 --> 00:04:27,200

model captures these relationships in the banking domain.



53

00:04:27,300 --> 00:04:31,560

The account entity has the transaction entities.



54

00:04:31,590 --> 00:04:36,310

This is the depiction of a very simple relation within a banking domain.



55

00:04:36,750 --> 00:04:44,130

Businesses use defined processes for carrying out the operations and these processes are documented



56

00:04:44,160 --> 00:04:48,270

within the domain model by way of workflows and activities.



57

00:04:48,540 --> 00:04:54,930

The examples for the banking domain are the process for opening a saving account and the loan approval



58

00:04:54,930 --> 00:04:55,530

process.



59

00:04:56,100 --> 00:04:59,880

The important thing to keep in mind is that the domain model.



60

00:05:00,200 --> 00:05:07,070

Captures structured knowledge that is used for solving a business problem, it doesn't have to be restricted



61

00:05:07,370 --> 00:05:10,140

to just the elements that I have discussed.



62

00:05:10,160 --> 00:05:17,090

In fact, the domain model may contain additional knowledge by way of visual depictions or diagrams



63

00:05:17,090 --> 00:05:18,850

and textual documentation.



64

00:05:18,950 --> 00:05:25,430

You, as the creator of domain models, are in control of what should go in the domain model to make



65

00:05:25,430 --> 00:05:27,350

it as effective as possible.



66

00:05:27,770 --> 00:05:34,580

There is no special tools for creating domain models for visualizations, which is typical in your email.



67

00:05:34,940 --> 00:05:40,470

You may use any tool that supports human modeling or textual documentation.



68

00:05:40,640 --> 00:05:47,510

I have seen teams using dogs as well as wikis and other information management tools.



69

00:05:47,540 --> 00:05:53,330

At the end of the day, stakeholders working on the domain models may decide on the tools that will



70

00:05:53,330 --> 00:05:54,790

work out best for them.



71

00:05:55,010 --> 00:05:58,110

Time to review the key points from this lesson domain.



72

00:05:58,110 --> 00:06:02,250

Morang is organized and structured knowledge about the domain.



73

00:06:02,780 --> 00:06:09,230

The purpose of the domain model is to help with creating solutions to business problems.



74

00:06:09,380 --> 00:06:11,450

Within that domain are discussed.



75

00:06:11,450 --> 00:06:18,890

The five elements that make up the domain model, domain, vocabulary, domain entities, relationship



76

00:06:18,890 --> 00:06:23,500

between the entities, workflows and activities and the key concepts.



77

00:06:23,870 --> 00:06:25,430

These are the five elements.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03 Introduction to Domain Driven Design\005 Modeling techniques & Architectural Styles.en.srt -->

1

00:00:00,180 --> 00:00:06,600

Enterprise domain models, in this lesson, you learn about enterprise domain models that are also known



2

00:00:06,600 --> 00:00:12,990

as aggregate or unified domain models, by the end of this lecture, you should be able to explain the



3

00:00:12,990 --> 00:00:14,600

term knowledge crunching.



4

00:00:14,970 --> 00:00:21,030

You should be able to explain what an enterprise domain model is and you should be able to discuss the



5

00:00:21,030 --> 00:00:24,270

challenges that domain driven design addresses.



6

00:00:24,690 --> 00:00:26,820

I'll start this lesson with a question.



7

00:00:27,210 --> 00:00:33,150

Who in your organization really understands your organization's business processes suggest that you



8

00:00:33,150 --> 00:00:35,700

pause the video for a few seconds and think through it.



9

00:00:35,910 --> 00:00:41,820

Now, if you work for a small organization in a small scale industry, it is very much possible for



10

00:00:41,820 --> 00:00:44,190

you to find one or two experts.



11

00:00:44,200 --> 00:00:52,410

But if you work in a complex industry like banking, then it may be difficult for you to find one expert



12

00:00:52,620 --> 00:00:56,120

who knows everything about that domain or the industry.



13

00:00:56,160 --> 00:01:03,180

Banking is a complex domain and you will find that there are multiple experts who specialize in certain



14

00:01:03,180 --> 00:01:05,240

aspects of the banking product.



15

00:01:05,610 --> 00:01:11,640

For example, the merchant account expert maybe able to provide you all of the information you need



16

00:01:11,760 --> 00:01:14,220

for the merchant account services of the bank.



17

00:01:14,580 --> 00:01:19,390

But they may not be able to talk about the processing of the loans, for example.



18

00:01:19,740 --> 00:01:24,990

Similarly, in the Akhmatova's example, we have multiple experts that I have discussed earlier.



19

00:01:25,320 --> 00:01:31,230

The travel advisor is an expert in creating travel packages for the customer, but they may not be able



20

00:01:31,230 --> 00:01:38,130

to provide information on how Achmat travels, carry out accounting or how to create partner contracts.



21

00:01:38,310 --> 00:01:42,800

For those things, you need to go to the other experts not to get the domain knowledge.



22

00:01:43,170 --> 00:01:50,220

The teams must work with these domain experts as this knowledge is mostly not documented anywhere,



23

00:01:50,460 --> 00:01:54,000

but is in the heads of these domain experts.



24

00:01:55,050 --> 00:02:02,460

RECALDE domain knowledge is organized and structured knowledge about the domain and these domain models



25

00:02:02,580 --> 00:02:09,270

are created by way of a process referred to as knowledge crunching simply for the team receiving the



26

00:02:09,270 --> 00:02:17,460

knowledge from the domain expert or expert analyzes the received information and knowledge and create



27

00:02:17,670 --> 00:02:18,690

the domain models.



28

00:02:19,110 --> 00:02:25,410

Typically, the knowledge crunching process is spearheaded by the technology team that works very closely



29

00:02:25,710 --> 00:02:31,660

with the domain experts to create that structure, domain knowledge or the domain models.



30

00:02:32,130 --> 00:02:37,110

It is common for the technology team to be led by an experienced technologist.



31

00:02:37,110 --> 00:02:40,820

For the sake of this discussion, I'll call this person ideally.



32

00:02:40,890 --> 00:02:48,330

Ideally, the ideal lead should have some prior experience with domain modeling exercise, and it is



33

00:02:48,330 --> 00:02:52,920

not required for the ideal to be expert in specific technologies.



34

00:02:52,950 --> 00:02:58,410

In my experience, successful I.T. leads have a breadth of knowledge and multiple technologies, and



35

00:02:58,410 --> 00:03:01,310

they are also open to learning business related topics.



36

00:03:01,770 --> 00:03:07,020

The technology team may be composed of team members with different skill sets and roles.



37

00:03:07,200 --> 00:03:15,150

In late 1990s and early 2000, I worked on multiple consulting engagements in which I was part of the



38

00:03:15,150 --> 00:03:22,290

teams who gathered knowledge from multiple experts in an organization to create an enterprise domain



39

00:03:22,290 --> 00:03:22,710

model.



40

00:03:22,890 --> 00:03:29,700

This enterprise domain model captured all of the knowledge from across the enterprise in one set of



41

00:03:29,820 --> 00:03:30,510

models.



42

00:03:30,540 --> 00:03:37,830

The idea was that these models could be used by the software development teams to build robust, well-documented



43

00:03:37,830 --> 00:03:38,580

systems.



44

00:03:38,730 --> 00:03:44,410

These enterprise models were also referred to as the unified models or aggregate models.



45

00:03:44,430 --> 00:03:47,130

The idea behind all of these are the same.



46

00:03:47,400 --> 00:03:51,980

The intended software development process looked something like this.



47

00:03:51,990 --> 00:03:58,890

The software development teams will focus on specific areas within the enterprise domain model and then



48

00:03:58,890 --> 00:04:03,630

carry out the technical design code and then build the final product.



49

00:04:03,690 --> 00:04:10,150

In theory, this sounds good, but in reality this process is marred with multiple challenges.



50

00:04:10,620 --> 00:04:13,820

The first challenge is the creation of the model itself.



51

00:04:13,830 --> 00:04:20,970

Enterprise models are inherently complex due to the scope and size and the fact that multiple experts



52

00:04:21,120 --> 00:04:23,940

need to be engaged in order to create such models.



53

00:04:24,210 --> 00:04:31,380

The second one is that it's hard to keep models up to date as there is no single owner for the model



54

00:04:31,560 --> 00:04:36,660

and it falls on the IGT to manage the model as well as the software product.



55

00:04:36,720 --> 00:04:43,890

Unfortunately, after a while, due to product delivery priorities, models start to fall behind the



56

00:04:43,890 --> 00:04:47,300

actual implementation and loses its value.



57

00:04:47,520 --> 00:04:50,640

And the third one is that there are linguistic challenges.



58

00:04:50,640 --> 00:04:57,900

When you try to merge together knowledge about multiple domains into one single model, it is very common



59

00:04:58,170 --> 00:04:59,580

to see the same business.



60

00:05:00,160 --> 00:05:07,420

Have different meanings in different subdomains within the organization, and these linguistic challenges



61

00:05:07,600 --> 00:05:13,460

can cause big confusions for the software development teams as well as the domain experts.



62

00:05:13,570 --> 00:05:20,920

One important point to note is that these challenges are not only applicable to enterprise level domain



63

00:05:20,920 --> 00:05:26,830

models, but to any domain model that has to deal with complex domains.



64

00:05:26,890 --> 00:05:33,460

The good news is that domain driven design approach provides principles and patterns to address the



65

00:05:33,460 --> 00:05:34,120

challenges.



66

00:05:34,120 --> 00:05:40,030

Faced with developing complex domain models, starting with the next lecture, we'll delve deeper into



67

00:05:40,210 --> 00:05:42,740

how the domain driven design approach works.



68

00:05:42,760 --> 00:05:45,300

Let's go over the key learnings from this lesson.



69

00:05:45,640 --> 00:05:52,780

Knowledge crunching refers to the process of creating the domain model from the knowledge gathered from



70

00:05:52,780 --> 00:05:54,320

the domain experts.



71

00:05:54,790 --> 00:06:02,440

There are multiple challenges with creating models for complex domains, and these challenges are addressed



72

00:06:02,440 --> 00:06:04,630

by domain driven design approach.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03IntroductiontoDomainDrivenDesign_VVN\000000001.srt -->

1
00:00:00,150 --> 00:00:10,050
Hiểu được miền khi kết thúc bài học này, bạn sẽ có thể giải thích miền là gì và vai trò của chuyên gia về miền trong bài học này là gì.

2
00:00:10,290 --> 00:00:18,310
Tôi cũng sẽ giới thiệu với bạn về những chuyến đi của tôi, một công ty hư cấu được sử dụng làm ví dụ điển hình trong khóa học này.

3
00:00:18,720 --> 00:00:26,700
Hãy bắt đầu với ngôn ngữ tiếng Anh.  Định nghĩa về miền hoặc miền được định nghĩa là một phạm vi kiến ​​thức, ảnh hưởng hoặc hoạt động.

4
00:00:26,760 --> 00:00:34,710
Dưới đây là ví dụ về các miền thuộc lĩnh vực kỹ thuật và khoa học.  Một nhà hóa học có sự hiểu biết thấu đáo về hóa chất.

5
00:00:34,920 --> 00:00:42,280
Các hoạt động họ thực hiện bao gồm thử nghiệm các loại hóa chất khác nhau trong lĩnh vực khoa học vũ trụ.

6
00:00:42,330 --> 00:00:56,160
Các nhà khoa học có kiến ​​thức về cách đi lại trong không gian và các hoạt động có thể bao gồm hiểu biết về tác động của tình trạng không trọng lực lên cơ thể con người và điều đó có thể ảnh hưởng đến thiết kế của các trạm vũ trụ.

7
00:00:56,180 --> 00:01:04,610
Vì vậy, nếu bạn nghĩ về góc độ kinh doanh của tên miền hoặc tên miền, hãy đại diện cho một lĩnh vực hoặc ngành mà doanh nghiệp hoạt động.

8
00:01:04,950 --> 00:01:15,830
Ví dụ: Banking Chase và Bank of America hoạt động trong ngành ngân hàng.  Oil and gas Shell và BP hoạt động trong lĩnh vực dầu khí.

9
00:01:15,840 --> 00:01:23,490
Và sau đó là bán lẻ và nhiều ngành khác mà bạn có thể nghĩ tới.  Bây giờ chúng ta hãy nhìn vào miền từ góc độ phần mềm.

10
00:01:23,730 --> 00:01:34,920
Tên miền có thể được coi là đại diện cho không gian vấn đề cho phần mềm đó, ví dụ: thương mại điện tử, phương tiện truyền thông xã hội, phương tiện truyền thông, phát trực tuyến và lập kế hoạch tài nguyên.

11
00:01:35,220 --> 00:01:42,780
Đây là tất cả các ví dụ về miền cho hệ thống phần mềm.  Tên miền được tạo thành từ nhiều tên miền phụ.

12
00:01:42,810 --> 00:01:57,930
Ví dụ: trong trường hợp ngân hàng, chúng có thể là tên miền phụ tài khoản bán lẻ và tài khoản người bán.  Mỗi loại tài khoản khác nhau này có các quy tắc và quy định khác nhau, loại sản phẩm khác nhau và loại khách hàng mua sản phẩm này khác nhau.

13
00:01:57,940 --> 00:02:08,900
Kiến thức cần thiết để xử lý các khoản vay rất khác với kiến ​​thức cần thiết để xử lý thông tin trong tài khoản người bán đối với các miền lớn và phức tạp.

14
00:02:08,910 --> 00:02:23,840
Hầu như không thể có một chuyên gia về miền biết mọi thứ về miền đó.  Kết quả là có nhiều chuyên gia về chủ đề hoặc chuyên gia tên miền trong một tên miền hầu hết được liên kết với các tên miền phụ trong tên miền lớn hơn.

15
00:02:23,880 --> 00:02:31,230
Ví dụ, trong trường hợp ngân hàng, họ có thể là chuyên gia về tài khoản được giữ lại hoặc phần lớn là chuyên gia của tòa án và chuyên gia về tài khoản cho vay.

16
00:02:31,230 --> 00:02:42,840
Mỗi loại tài khoản này có các yêu cầu tuân thủ và quy định khác nhau, do đó có thể có một chuyên gia hiểu rõ các quy định và yêu cầu tuân thủ đối với từng loại tài khoản này.

17
00:02:43,140 --> 00:02:52,320
Technodrome hoạt động trong ngành du lịch và giải trí và Travel có các cố vấn du lịch là những chuyên gia trong ngành du lịch.

18
00:02:52,530 --> 00:03:00,390
Họ hiểu nhu cầu và mong muốn của khách hàng và họ sử dụng kiến ​​thức của mình để tác động đến các quyết định của khách hàng.

19
00:03:00,570 --> 00:03:13,890
Từ góc độ hoạt động, họ lên kế hoạch cho kỳ nghỉ của khách hàng để đảm bảo rằng kỳ nghỉ đã lên kế hoạch nằm trong ngân sách của khách hàng và khách hàng sẽ có được trải nghiệm tốt nhất có thể trong kỳ nghỉ của họ.

20
00:03:14,040 --> 00:03:24,130
Giống như các ngành lớn khác, ngành du lịch cũng có nhiều miền phụ và nhiều chuyên gia trong các miền phụ này, bạn đã thấy vai trò của một cố vấn du lịch.

21
00:03:24,170 --> 00:03:38,280
Sau đó, có những chuyên gia khác mà Achmea phải thuê, chẳng hạn như chuyên gia hợp đồng của bộ phận.  Chuyên gia này hiểu cách quản lý các hợp đồng với các đơn vị khác trong ngành du lịch, ví dụ như các hãng hàng không, tàu du lịch hoặc khách sạn.

22
00:03:38,280 --> 00:03:46,350
Và sau đó có thể có kế toán, hỗ trợ khách hàng và nhiều hoạt động xuất khẩu khác cần thiết để hoạt động du lịch của ACMC được suôn sẻ.

23
00:03:46,530 --> 00:03:56,040
Đã đến lúc tập thể dục nhanh.  Trả lời những câu hỏi này.  Câu hỏi đầu tiên là ý bạn là gì?  Bạn hoạt động và nghĩ về lĩnh vực kinh doanh chứ không phải công nghệ.

24
00:03:56,040 --> 00:04:08,630
Rất có thể bạn là một nhà công nghệ, nhưng đó là chuyên môn của bạn chứ không phải lĩnh vực của bạn.  Ví dụ như tôi từng làm cho một công ty bảo hiểm nên lúc đó lĩnh vực tôi hoạt động là bảo hiểm.

25
00:04:08,670 --> 00:04:14,620
Câu hỏi thứ hai tôi muốn bạn suy nghĩ về điều này.  Các miền phụ trong miền mà bạn hoạt động là gì?

26
00:04:14,640 --> 00:04:22,200
Ví dụ, khi tôi làm việc ở công ty bảo hiểm, các miền phụ là nhóm bảo hiểm nhân thọ, bảo hiểm, bảo hiểm thương mại.

27
00:04:22,200 --> 00:04:32,850
Câu hỏi thứ ba tôi muốn bạn trả lời là danh sách các chuyên gia tên miền mà bạn làm việc cùng.  Trong thời gian làm việc tại công ty bảo hiểm, tôi nhớ mình đã làm việc với các chuyên gia tính toán, những người tạo ra các mô hình rủi ro.

28
00:04:33,180 --> 00:04:43,200
Tôi đã từng làm việc với các chuyên gia về quy định và tuân thủ.  Chúng tôi thường giải thích cho tôi các yêu cầu về quy định và tuân thủ theo quan điểm của ngành bảo hiểm.

29
00:04:43,200 --> 00:04:52,560
Vì vậy, hãy tạm dừng video và cố gắng trả lời những câu hỏi này.  Hy vọng rằng bạn thích bài tập cuối cùng và đã đến lúc ôn lại nhanh trước khi tôi kết thúc bài học này.

30
00:04:52,950 --> 00:04:59,790
Tên miền được định nghĩa là một phạm vi kiến ​​thức, ảnh hưởng hoặc hoạt động.  Bạn có thể nghĩ đến ngân hàng, dầu mỏ và.

31
00:04:59,870 --> 00:05:13,570
Khí đốt và bán lẻ là các miền kinh doanh, các miền được tạo thành từ nhiều miền phụ, không thể một chuyên gia duy nhất có thể có kiến ​​thức tổng thể về tất cả các miền phụ trong một miền phức tạp hoặc lớn.

32
00:05:13,610 --> 00:05:25,040
Do đó, cần có nhiều chuyên gia về lĩnh vực để hỗ trợ các chức năng kinh doanh.  Hầu hết, các chuyên gia tên miền này được liên kết với các tên miền phụ trong tên miền lớn hơn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03IntroductiontoDomainDrivenDesign_VVN\000000002.srt -->

1
00:00:00,210 --> 00:00:10,500
Kiến trúc và thiết kế, trong bài học này, bạn tìm hiểu về mô hình khái niệm và mô hình kiến ​​trúc, bạn cũng sẽ tìm hiểu về sự khác biệt giữa kiến ​​trúc và thiết kế.

2
00:00:10,890 --> 00:00:19,370
Các mô hình khái niệm được định nghĩa là sự biểu diễn của một hệ thống được tạo thành từ sự kết hợp của các khái niệm.  Từ khóa ở đây là các khái niệm.

3
00:00:19,650 --> 00:00:29,130
Nói cách khác, trọng tâm không phải là các thông số vật lý của hệ thống.  Ví dụ, hãy xem mô hình xe hybrid này.

4
00:00:29,280 --> 00:00:40,770
Người thiết kế chiếc xe này đã đưa ra khái niệm quan trọng cho hệ thống hoặc chiếc xe này đó là pin và động cơ điện làm bình chứa nhiên liệu và động cơ xăng.

5
00:00:40,980 --> 00:00:57,680
Trọng tâm ở đây là các khái niệm quan trọng tạo nên hệ thống.  Mô hình này không chi tiết lắm nhưng nó chứa một số thông số vật lý có thể áp dụng cho các khái niệm được đưa vào hệ thống này, chẳng hạn như tổng mã lực của chiếc xe sẽ là 208.

6
00:00:57,690 --> 00:01:09,370
Dung tích bình xăng là 14 GERLIN và dung lượng pin là 70 kilowatt giờ.  Hiện tại, thông tin này không đủ để các kỹ sư trong nhà máy có thể chế tạo ô tô.

7
00:01:09,390 --> 00:01:15,850
Vậy mục đích của mô hình khái niệm này là gì?  Có nhiều lợi ích khi bắt đầu với các mô hình khái niệm.

8
00:01:15,990 --> 00:01:24,440
Đầu tiên là nó nâng cao sự hiểu biết của các nhà thiết kế.  Khi các nhà thiết kế tập hợp ý tưởng và suy nghĩ kỹ về nó.

9
00:01:24,450 --> 00:01:33,810
Họ có thể tìm thấy những sai sót trong thiết kế hoặc họ có thể tìm thấy cơ hội cải tiến.  Và cuối cùng, một mô hình ý tưởng tốt sẽ tạo ra một sản phẩm tốt hơn.

10
00:01:33,840 --> 00:01:46,550
Thứ hai là nó giúp dễ dàng truyền đạt các ý tưởng đằng sau khái niệm này tới các bên liên quan.  Vì vậy, hãy nghĩ đến việc người thiết kế chiếc xe này đến gặp các nhà đầu tư và giới thiệu mẫu xe này.

11
00:01:46,560 --> 00:01:59,250
Họ sẽ dễ dàng giải thích cách kết hợp các khái niệm này lại với nhau để tạo ra sản phẩm cuối cùng.  Hướng tới các mô hình khái niệm cung cấp một điểm tham chiếu để tạo ra các thông số kỹ thuật chi tiết.

12
00:01:59,280 --> 00:02:13,440
Mô hình này chứa một số thông tin về các khía cạnh vật lý của sản phẩm cuối cùng.  Thông tin này, kết hợp với cách bố trí mô hình, có thể đóng vai trò là điểm khởi đầu cho các nhà thiết kế động cơ điện và động cơ xăng.

13
00:02:13,450 --> 00:02:20,610
Nói cách khác, kỹ sư điện sẽ có thể sử dụng thông tin này để đưa ra thiết kế chi tiết hơn cho động cơ điện.

14
00:02:20,610 --> 00:02:26,230
Và điều này cũng đúng với kỹ sư cơ khí, người sẽ tập hợp thiết kế chi tiết cho động cơ xăng.

15
00:02:26,250 --> 00:02:38,680
Thứ tư là các mô hình khái niệm cung cấp tài liệu để tham khảo trong tương lai, giống như người thiết kế ô tô, người thiết kế sản phẩm phần mềm cũng bắt đầu bằng các mô hình khái niệm.

16
00:02:39,060 --> 00:02:45,980
Điều đầu tiên cần làm là xác định các khái niệm cốt lõi cần được kết hợp với nhau để thiết kế sản phẩm cuối cùng.

17
00:02:46,080 --> 00:02:54,880
Họ đưa ra thuật ngữ chung cho khái niệm miền được sử dụng trong mô hình.  Họ xác định các phần khác nhau của hệ thống.

18
00:02:54,900 --> 00:03:07,060
Vì vậy, nếu bạn nghĩ về lĩnh vực ngân hàng, người thiết kế sẽ tập hợp các cột như Sổ cái giao dịch tài khoản và ghi lại rõ ràng ý nghĩa của từng mục này.

19
00:03:07,200 --> 00:03:27,180
Ngoài ra, họ sẽ xác định các phần khác nhau của sản phẩm tổng thể hoặc hệ thống.  Tiếp theo, người thiết kế xác định và ghi lại mối quan hệ giữa các khái niệm lĩnh vực khác nhau, đồng thời họ cũng xác định các tham số quan trọng hoặc cơ bản cho các khái niệm này cũng như các mối quan hệ trong lĩnh vực ngân hàng.

20
00:03:27,300 --> 00:03:40,910
Hãy nghĩ về mối quan hệ giữa tài khoản, giao dịch và sổ cái.  Sau đó, tất cả thông tin này được sử dụng để tạo mô hình kiến ​​trúc, là sự trực quan hóa của hệ thống được mô hình đại diện.

21
00:03:41,070 --> 00:03:52,380
Một định nghĩa chính thức hơn về mô hình kiến ​​trúc hay kiến ​​trúc là nó là sự biểu diễn có cấu trúc của một giải pháp đáp ứng các yêu cầu và các vấn đề gặp phải.

22
00:03:52,410 --> 00:04:06,810
Nó là sự trừu tượng hóa ở mức độ cao về các phần của giải pháp cuối cùng, thể hiện quan điểm hoặc quan điểm về cách đáp ứng các yêu cầu và hỗ trợ trả lời các câu hỏi do các bên liên quan khác nhau đặt ra.

23
00:04:06,840 --> 00:04:13,610
Một câu hỏi phổ biến được đặt ra vào thời điểm này là sự khác biệt giữa mô hình kiến ​​trúc hay kiến ​​trúc và thiết kế là gì?

24
00:04:13,770 --> 00:04:37,920
Sự khác biệt là ở mức độ chi tiết và trọng tâm.  Kiến trúc chủ yếu là cấp cao.  Nó cung cấp bộ khung cho sản phẩm cuối cùng và trọng tâm là các khái niệm dài hạn hơn được mô tả trong kiến ​​trúc có thể không thay đổi thường xuyên hoặc thậm chí chúng có thể không thay đổi chút nào trong suốt vòng đời của sản phẩm, trong khi thiết kế tương đối chi tiết và trọng tâm.  đang trong quá trình triển khai.

25
00:04:38,100 --> 00:04:49,590
Đã cố tình sử dụng thuật ngữ tương đối và lý do là vì ngay cả những thiết kế cũng có thể ở mức độ cao.  Nhưng chúng tương đối chi tiết so với các mô hình kiến ​​trúc thông thường hoặc truyền thống.

26
00:04:49,800 --> 00:04:58,380
Như một bài tập, chúng ta hãy thực hiện kiến ​​trúc và thiết kế cho một hệ thống chia sẻ xe.  Hãy suy nghĩ về những ứng dụng richcher thường được sử dụng này.

27
00:04:58,560 --> 00:05:15,240
Hãy bắt đầu với kiến ​​trúc sư.  Về mặt đạo đức, người dùng hệ thống sẽ là người lái xe và khách hàng của nền tảng chia sẻ chuyến đi, họ sẽ sử dụng điện thoại di động của mình để yêu cầu các quyền và việc chấp nhận các quyền đối với hệ thống sẽ là người xử lý yêu cầu phù hợp.

28
00:05:15,370 --> 00:05:27,610
Bộ xử lý yêu cầu phù hợp này sẽ nhận được yêu cầu từ tài xế và khách hàng, đồng thời có thể xử lý 5000 chuyến đi cho tất cả các khả năng được tích hợp theo yêu cầu phù hợp của chúng tôi.

29
00:05:27,610 --> 00:05:34,960
Bộ xử lý sẽ được hiển thị thông qua API trước đó.  Khu vực này có thể xử lý 500 cuộc gọi mỗi giây.

30
00:05:34,990 --> 00:05:41,090
Trình điều khiển và khách hàng của hệ thống sẽ được theo dõi thông qua một loại cơ chế phát trực tuyến nào đó.

31
00:05:41,230 --> 00:05:51,560
Dự kiến, cơ chế phát trực tuyến sẽ nhận được 10000 tin nhắn mỗi giây và những tin nhắn này sẽ có vị trí của tài xế và khách hàng.

32
00:05:51,580 --> 00:06:01,450
Các luồng này sẽ được sử dụng bởi trình theo dõi trình điều khiển và khách hàng và thành phần này sẽ có thể xử lý 100000 người dùng đang hoạt động bất kỳ lúc nào.

33
00:06:01,660 --> 00:06:13,260
Bộ xử lý yêu cầu phù hợp sẽ quản lý tất cả dữ liệu trong nhiều cơ sở dữ liệu và tổng kích thước của dữ liệu sẽ tăng khoảng hai terabyte mỗi năm.

34
00:06:13,390 --> 00:06:23,070
Ngoài các thành phần cốt lõi này, bộ xử lý yêu cầu phù hợp sẽ sử dụng các thành phần khác cho các dịch vụ không gian địa lý cũng như thông báo.

35
00:06:23,110 --> 00:06:34,130
Vì vậy, đây là kiến ​​trúc cấp cao của hệ thống Raksha.  Tiếp theo sẽ thực hiện một bài tập nhanh.  Hãy coi bạn như người thiết kế hệ thống chia sẻ xe.

36
00:06:34,540 --> 00:06:43,150
Bây giờ bạn được cung cấp sơ đồ kiến ​​trúc này, trong đó có một số yêu cầu và cách bố trí các thành phần khác nhau tạo nên hệ thống.

37
00:06:43,180 --> 00:06:53,880
Như bạn có thể thấy, không có chi tiết triển khai nào trong đó.  Nhiệm vụ của bạn là quyết định những công nghệ nào bạn sẽ sử dụng để triển khai thành phần trong mỗi hộp này.

38
00:06:53,890 --> 00:07:01,540
Công nghệ bạn chọn phải đáp ứng mọi yêu cầu của hệ thống.  Hãy nhớ rằng, không có câu trả lời đúng hay sai.

39
00:07:01,550 --> 00:07:14,170
Bạn là người đánh giá tốt nhất với tư cách là nhà thiết kế.  Vì vậy, hãy tiếp tục đăng video và thử xem.  Tiếp theo, tôi sẽ hướng dẫn bạn một thiết kế có thể được coi là điểm khởi đầu cho thiết kế chi tiết cho từng thành phần này.

40
00:07:14,410 --> 00:07:25,350
Với tư cách là người thiết kế hệ thống, tôi đã quyết định triển khai ứng dụng người dùng trên Android và iOS vì 10000 tin nhắn cần được xử lý trong luồng vị trí.

41
00:07:25,630 --> 00:07:38,970
Tôi đã quyết định đồng hành cùng COFCO.  Tôi xem xét Jabat Amcu và AMCU đang hoạt động, nhưng những nền tảng nhắn tin đó sẽ không thể xử lý loại tải như mong đợi và đó là lý do tôi quyết định sử dụng Kafka.

42
00:07:39,160 --> 00:07:48,430
AP trước đó sẽ có thể xử lý 500 cuộc gọi mỗi giây và tôi cũng nghĩ chúng ta sẽ cần khả năng quản lý AIPA tốt.

43
00:07:48,610 --> 00:08:02,360
Vì vậy tôi đã quyết định đi cùng APJ, tài xế và khách hàng.  Krako cần theo dõi 100000 người dùng đang hoạt động và tôi sẽ sử dụng Mongo DB chứ không chỉ triển khai dựa trên.

44
00:08:02,410 --> 00:08:29,680
Tôi có yêu cầu Bộ xử lý phải xử lý 5000 chuyến đi mỗi giờ không và tôi nghĩ sẽ dễ dàng xử lý 5000 chuyến đi này khi chúng tôi sử dụng lò xo và bộ xử lý yêu cầu chuyến đi sẽ cần lớp dữ liệu mà tôi đã quyết định triển khai bằng cách sử dụng  Mongo DB và phần tiếp theo của hệ thống thông báo sẽ sử dụng Tullio và đối với các dịch vụ không gian địa lý sẽ sử dụng API Google Maps.

45
00:08:29,950 --> 00:08:42,340
Vì vậy, đây là một mô hình kiến ​​trúc được phủ lên nhưng có một số chi tiết triển khai.  Do đó, đây là cấp độ thiết kế đầu tiên của hệ thống chia sẻ xe và là bước tiếp theo, thiết kế hệ thống.

46
00:08:42,460 --> 00:08:49,060
Macario thiết kế chi tiết cho từng bộ phận.  Có ba khái niệm chính mà bạn đã học được trong bài giảng này.

47
00:08:49,120 --> 00:09:02,710
Đầu tiên là các mô hình khái niệm, là tập hợp các khái niệm và mối quan hệ của chúng.  Các mô hình kiến ​​trúc là sự thể hiện có cấu trúc của một giải pháp đáp ứng các yêu cầu từ không gian vấn đề.

48
00:09:02,710 --> 00:09:13,630
Kiến trúc hơn không có bất kỳ chi tiết triển khai nào, trong khi thiết kế là sự thể hiện có cấu trúc của một giải pháp có một số mức độ chi tiết triển khai trong đó.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03IntroductiontoDomainDrivenDesign_VVN\000000003.srt -->

1
00:00:00,180 --> 00:00:10,860
Các kỹ thuật lập mô hình và phong cách kiến ​​trúc trong bài học này sẽ được thảo luận về các kỹ thuật lập mô hình và phong cách kiến ​​trúc thường được sử dụng để phát triển phần mềm.

2
00:00:11,190 --> 00:00:19,430
Ở cuối bài học này, tôi đề cập đến Thiết kế theo nhu cầu.  Có nhiều cách để tạo mô hình kiến ​​trúc cho hệ thống phần mềm.

3
00:00:19,440 --> 00:00:28,010
Khi tôi tạo một mô hình, tôi tuân theo ba nguyên tắc hướng dẫn.  Tôi nghĩ về mục đích của mô hình và đối tượng khán giả của mô hình mà tôi đang tạo ra là ai.

4
00:00:28,020 --> 00:00:39,300
Tôi nghĩ về quan điểm và quan điểm của khán giả.  Ý tưởng là suy nghĩ về mối quan tâm và mối quan tâm của họ, xây dựng mô hình mà tôi đang tạo ra, giải quyết mối quan tâm và trả lời câu hỏi của họ.

5
00:00:39,310 --> 00:00:46,920
Và thứ ba là mức độ chi tiết.  Mô hình của tôi phải chi tiết đến mức nào để mang lại giá trị cao nhất cho đối tượng mục tiêu?

6
00:00:47,070 --> 00:00:53,190
Có nhiều kỹ thuật để tạo mô hình kiến ​​trúc.  Tôi sẽ đề cập đến hai kỹ thuật phổ biến.

7
00:00:53,190 --> 00:01:03,270
Mô hình khung nhìn kiến ​​trúc bốn cộng một và ngôn ngữ mô hình hóa thống nhất hoặc diễn ngôn UML không yêu cầu bạn phải là chuyên gia về một trong hai lĩnh vực này.

8
00:01:03,540 --> 00:01:12,750
Nhưng chúng tôi khuyên bạn nếu trước đây bạn chưa từng làm việc với UML, vui lòng xem một số hướng dẫn nhanh mà bạn có thể dễ dàng tìm thấy trên Google.

9
00:01:13,080 --> 00:01:20,560
Mô hình khung nhìn kiến ​​trúc bốn cộng một mô tả kiến ​​trúc từ quan điểm của nhiều bên liên quan.

10
00:01:20,580 --> 00:01:36,540
Trọng tâm của kỹ thuật này là ý tưởng về các kịch bản hoặc trường hợp sử dụng hoặc coi đây là các yêu cầu.  Các kịch bản này được sử dụng làm hướng dẫn để tạo nhiều chế độ xem và các kịch bản này cũng được sử dụng để xác thực kiến ​​trúc.

11
00:01:36,690 --> 00:01:44,830
Chế độ xem logic tập trung vào chức năng hoặc khả năng mà hệ thống cung cấp cho người dùng cuối.

12
00:01:45,120 --> 00:01:53,420
Chế độ xem quy trình, như tên cho thấy, giải thích các quy trình trong hệ thống và cách các quy trình này tương tác với nhau.

13
00:01:53,580 --> 00:02:01,710
Khung nhìn phát triển minh họa một hệ thống từ góc độ của người lập trình viên và liên quan đến việc quản lý phần mềm.

14
00:02:01,890 --> 00:02:12,480
Chế độ xem này còn được gọi là chế độ xem triển khai.  Cái cuối cùng là cái nhìn vật lý mô tả hệ thống theo quan điểm của các kỹ sư.

15
00:02:12,630 --> 00:02:21,720
Nó liên quan đến sự ổn định của các thành phần phần mềm trên lớp vật lý cũng như các kết nối vật lý giữa các thành phần này.

16
00:02:22,080 --> 00:02:29,820
Chắc hẳn bạn đang thắc mắc tại sao kỹ thuật này lại được đặt tên là bốn cộng một.  Lý do là có bốn lượt xem và một lượt xem dành cho các kịch bản.

17
00:02:30,180 --> 00:02:38,730
Một dự án phần mềm lớn có sự tham gia của nhiều bên liên quan.  Có thể có hàng chục, thậm chí hàng trăm bên liên quan tham gia vào dự án.

18
00:02:38,820 --> 00:02:47,130
Các bên liên quan này có những mối quan tâm và mối quan tâm khác nhau.  Hãy nghĩ về người điều hành doanh nghiệp đang tài trợ cho dự án.

19
00:02:47,160 --> 00:02:58,770
Mối quan tâm của họ là hiểu giá trị mà hệ thống sẽ cung cấp cho người dùng cuối và giá trị đó của người dùng cuối sẽ chuyển thành giá trị cho doanh nghiệp như thế nào.

20
00:02:58,770 --> 00:03:08,490
Đối với các chuyên gia kinh doanh hiểu rõ về doanh nghiệp, điều quan trọng là hệ thống phải triển khai đúng bộ quy trình và các quy trình này phải chính xác.

21
00:03:08,490 --> 00:03:16,260
Kết quả là, mối quan tâm của họ sẽ là các khung nhìn quá trình.  Các nhà phát triển quan tâm đến việc triển khai hệ thống.

22
00:03:16,260 --> 00:03:24,330
Họ quan tâm đến việc triển khai và quản lý phần mềm.  Kết quả là mối quan tâm của họ là quan điểm phát triển.

23
00:03:24,390 --> 00:03:30,210
Các kỹ sư mạng không quan tâm đến.  Sự phát triển dành cho bạn là cái nhìn hợp lý về chế độ xem quy trình.

24
00:03:30,510 --> 00:03:39,270
Họ muốn hiểu cách các máy chủ khác nhau lưu trữ ứng dụng hoặc các thành phần sẽ giao tiếp với nhau qua mạng như thế nào.

25
00:03:39,270 --> 00:03:51,660
Và cuối cùng nhưng không kém phần quan trọng, chúng tôi có kiến ​​trúc sư chịu trách nhiệm tạo ra tất cả các chế độ xem này và đảm bảo rằng các chế độ xem này đang mang lại giá trị cao nhất cho mỗi bên liên quan.

26
00:03:51,750 --> 00:04:01,410
Bây giờ, hãy nhớ rằng tôi chỉ mô tả một nhóm nhỏ các bên liên quan.  Có thể có nhiều bên liên quan hơn đóng các vai trò khác nhau và sáng kiến ​​​​phần mềm.

27
00:04:01,440 --> 00:04:12,330
Bây giờ là lúc thực hiện nhanh việc liệt kê các bên liên quan trong tổ chức của bạn và suy nghĩ xem quan điểm nào sẽ phù hợp nhất với họ.

28
00:04:12,330 --> 00:04:20,490
Vì vậy, chúng ta sẽ có video tích cực và dùng thử ngôn ngữ mô hình hóa thống nhất hoặc UML do Nhóm quản lý đối tượng tạo ra.

29
00:04:20,490 --> 00:04:30,660
Nó cung cấp một bộ sơ đồ tiêu chuẩn cho mô hình kiến ​​trúc và những sơ đồ này được tạo bằng cách sử dụng một bộ ký hiệu tiêu chuẩn.

30
00:04:30,690 --> 00:04:38,660
Chủ đề về UML khá rộng và sẽ cần một khóa học riêng để giải thích tất cả các khía cạnh của UML.

31
00:04:38,820 --> 00:04:46,920
Vì vậy, đề nghị của tôi là bạn vui lòng tự mình xem ký hiệu và sơ đồ UML cơ bản trước khi tiếp tục.

32
00:04:47,070 --> 00:04:59,910
Phiên bản mới nhất của UML bao gồm mười bốn sơ đồ tiêu chuẩn và mười bốn sơ đồ tiêu chuẩn này có thể được sử dụng để tạo các khung nhìn khác nhau trong kiến ​​trúc bốn cộng một.

33
00:05:00,090 --> 00:05:09,500
Xem mô hình, tôi thích sử dụng sơ đồ ca sử dụng để mô tả các kịch bản cho các khung nhìn logic.  Tôi thích sử dụng sơ đồ thẳng và sơ đồ lớp để xử lý cho bạn.

34
00:05:09,540 --> 00:05:16,770
Bạn có thể sử dụng sơ đồ trình tự và sơ đồ hoạt động để phát triển cho mình.  Bạn có thể sử dụng sơ đồ thành phần và sơ đồ gói.

35
00:05:16,950 --> 00:05:22,970
Và đối với sơ đồ triển khai chế độ xem vật lý, thời điểm tốt nhất để thảo luận về các phong cách kiến ​​trúc là vào giờ tiếp theo.

36
00:05:23,010 --> 00:05:29,600
Bây giờ, trước khi đi thẳng vào các phong cách kiến ​​trúc phần mềm, tôi muốn bạn nghĩ về các kiểu cầu nối khác nhau mà bạn đã thấy.

37
00:05:29,760 --> 00:05:46,070
Có nhiều cách để thiết kế những cây cầu.  Mỗi thiết kế cầu này đều tuân theo một bộ nguyên tắc chung và tùy theo nhu cầu, yêu cầu và điều kiện mà người thiết kế cầu có thể mô hình hóa cây cầu bằng một trong những phong cách kiến ​​trúc này.

38
00:05:46,080 --> 00:05:59,760
Ý tưởng về phong cách kiến ​​trúc phần mềm là phần mềm tương tự.  Phong cách kiến ​​trúc có thể được coi là mẫu kiến ​​trúc có thể tái sử dụng, có thể được sử dụng như một giải pháp cho một vấn đề thường xảy ra.

39
00:06:00,120 --> 00:06:07,170
Có nhiều phong cách kiến ​​trúc và những phong cách kiến ​​trúc này được phân loại dựa trên khu vực trọng tâm chính.

40
00:06:07,200 --> 00:06:20,490
Kiến trúc hướng dịch vụ và kiến ​​trúc thông điệp thuộc loại phong cách kiến ​​trúc tập trung vào sự giao tiếp giữa các thành phần, kiến ​​trúc và hướng đối tượng.

41
00:06:20,490 --> 00:06:41,280
Kiến trúc và thiết kế là các phong cách phổ biến được sử dụng khi kiến ​​trúc sư tập trung vào cấu trúc của hệ thống, máy chủ khách và các phong cách kiến ​​trúc ba tầng thuộc danh mục triển khai trong đó trọng tâm là triển khai các thành phần khác nhau tạo nên  hệ thống này.

42
00:06:41,430 --> 00:06:50,670
Thiết kế tập trung vào cơ sở dữ liệu và sơ đồ sàn ăn tối khi sử dụng gạch với kiến ​​trúc sư đang tập trung vào dữ liệu cốt lõi trong miền kinh doanh.

43
00:06:51,000 --> 00:07:00,320
Và phong cách kiến ​​trúc cuối cùng mà tôi sẽ đề cập đến là thiết kế tham chiếu miền, trong đó trọng tâm là miền kinh doanh hơn là công nghệ.

44
00:07:00,690 --> 00:07:09,990
Mục đích của tôi đối với bài học này chỉ là cung cấp cho bạn cái nhìn tổng thể về thiết kế hướng miền là gì và nó khác với các phong cách kiến ​​trúc khác như thế nào.

45
00:07:10,020 --> 00:07:17,400
Tại thời điểm này, bạn sẽ học mọi thứ về thiết kế hướng miền trong khóa học này, hãy cùng xem lại những bài học chính từ bài học này.

46
00:07:17,610 --> 00:07:28,920
Kiến trúc sư tạo ra các mô hình bằng cách sử dụng các kỹ thuật mô hình hóa khác nhau.  Tôi đã đề cập đến hai kỹ thuật như vậy, mô hình khung nhìn kiến ​​trúc bốn cộng một và ngôn ngữ mô hình hóa thống nhất.

47
00:07:28,920 --> 00:07:35,880
Cả hai được kết hợp để tạo ra các mô hình kiến ​​trúc rất hiệu quả.  Có nhiều phong cách kiến ​​trúc.

48
00:07:36,000 --> 00:07:43,470
Mỗi phong cách này tuân theo một bộ nguyên tắc chung và chúng tập trung vào khía cạnh cụ thể nhất định của hệ thống.

49
00:07:43,470 --> 00:07:53,880
Các kiến ​​trúc sư điên cuồng thực hiện bất kỳ phong cách nào trong số này tùy thuộc vào nhu cầu và sở thích của họ.  Thiết kế hướng miền là một phong cách kiến ​​trúc trong đó trọng tâm là lĩnh vực kinh doanh.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03IntroductiontoDomainDrivenDesign_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:08,820
Mô hình miền Trong bài giảng này, tôi sẽ nói về mô hình miền là gì và sau đó tôi sẽ thảo luận về các thành phần của mô hình miền.

2
00:00:09,480 --> 00:00:25,600
Tôi sẽ bắt đầu bài học này bằng câu hỏi tại sao doanh nghiệp lại đầu tư vào phần mềm?  Hãy nghĩ về những trải nghiệm trong quá khứ của bạn với việc phát triển phần mềm và nghĩ về lý do tại sao người chủ của bạn lại chi hàng trăm nghìn, thậm chí hàng triệu đô la để xây dựng phần mềm.

3
00:00:25,650 --> 00:00:31,520
Không có câu trả lời đúng hay sai ở đây.  Vì vậy, hãy tiếp tục, tạm dừng video và suy nghĩ trong vài giây.

4
00:00:31,860 --> 00:00:39,920
Một câu trả lời phổ biến cho câu hỏi này là các doanh nghiệp đầu tư vào phần mềm để đáp ứng một số nhu cầu.  Từ khóa ở đây là nhu cầu.

5
00:00:40,230 --> 00:00:51,170
Và khi tôi nhìn lại kinh nghiệm của mình với tư cách là nhà phát triển phần mềm và kiến ​​trúc sư, tôi có thể nghĩ ra nhiều nhu cầu như vậy về việc giảm lao động chân tay.

6
00:00:51,480 --> 00:01:00,760
Vì vậy, tôi đã nghiên cứu một hệ thống tự động hóa quy trình và xây dựng một số mô hình máy học để giúp doanh nghiệp giảm bớt lao động thủ công.

7
00:01:00,780 --> 00:01:12,190
Một vấn đề khác nảy ra trong đầu tôi là nhu cầu tăng cổ tức hiệu quả.  Tôi đã làm việc trong một nhóm xây dựng công cụ xử lý công việc và tạo ra nhiều công cụ năng suất trong một sáng kiến.

8
00:01:12,210 --> 00:01:20,020
Tôi được giao nhiệm vụ giúp doanh nghiệp đạt được lợi thế cạnh tranh bằng cách xây dựng hệ thống khách hàng thân thiết và nền tảng kinh doanh thông minh.

9
00:01:20,040 --> 00:01:29,000
Bây giờ, tôi khá chắc chắn rằng bạn hẳn đã đưa ra danh sách những nhu cầu như vậy của riêng mình.  Bây giờ, đây là những nhu cầu hoặc mục tiêu cuối cùng mong muốn mà phần mềm sẽ đáp ứng.

10
00:01:29,340 --> 00:01:41,160
Nhưng lý do đằng sau những nhu cầu này là gì?  Tôi nảy ra những vấn đề kinh doanh này khi người chủ của tôi nói rằng họ muốn giảm lao động chân tay.

11
00:01:41,310 --> 00:01:58,890
Họ thực sự đang tìm cách giảm quy mô lực lượng lao động để tiết kiệm chi phí trả lương.  Mục tiêu cuối cùng của việc tăng hiệu quả là do khách hàng phàn nàn về thời gian phản hồi lâu để hoàn thành đơn hàng.

12
00:01:59,130 --> 00:02:12,580
Và từ góc độ lợi thế cạnh tranh, tôi nhận ra rằng ông chủ của tôi lo ngại về việc đối thủ cạnh tranh lôi kéo khách hàng của họ bằng cách đưa ra mức giảm giá tốt hơn hoặc cung cấp cho họ các chương trình khách hàng thân thiết.

13
00:02:12,630 --> 00:02:23,640
Vì vậy sở dĩ doanh nghiệp đầu tư vào phần mềm là để giải quyết một số vấn đề kinh doanh.  Và đây là một số vấn đề kinh doanh mà tôi đã giải quyết với tư cách là nhà phát triển phần mềm.

14
00:02:24,000 --> 00:02:33,360
Các vấn đề kinh doanh có thể được định nghĩa là những thách thức và vấn đề hiện tại hoặc dài hạn mà doanh nghiệp phải đối mặt có thể ngăn cản doanh nghiệp đạt được mục tiêu của mình.

15
00:02:33,840 --> 00:02:42,770
Những mục tiêu này có thể là ngắn hạn hoặc có thể dài hạn.  Điều quan trọng là kiến ​​trúc sư phải hiểu vấn đề doanh nghiệp và hiểu vấn đề doanh nghiệp.

16
00:02:42,840 --> 00:02:57,900
Kiến trúc sư phải hiểu miền nhanh và để làm được điều đó, kiến ​​trúc sư tạo ra các mô hình miền.  Mô hình miền được định nghĩa là kiến ​​thức có tổ chức và có cấu trúc về miền phù hợp để giải quyết vấn đề kinh doanh.

17
00:02:58,200 --> 00:03:05,190
Các từ khóa ở đây là kiến ​​thức có tổ chức và có cấu trúc.  Mô hình miền bao gồm nhiều phần.

18
00:03:05,610 --> 00:03:12,700
Các khái niệm chính là các khái niệm nền tảng liên quan đến lĩnh vực này, ví dụ như trong lĩnh vực ngân hàng.

19
00:03:12,720 --> 00:03:21,330
Các khái niệm chính có thể bao gồm việc tính toán lãi suất đơn giản và tính toán độ tin cậy thành phần.  Tiếp theo là từ vựng miền.

20
00:03:21,360 --> 00:03:32,400
Từ vựng của miền bao gồm các thuật ngữ phổ biến và định nghĩa của chúng được các bên liên quan sử dụng khi họ thảo luận về các vấn đề gặp phải trong miền đó đối với lĩnh vực ngân hàng.

21
00:03:32,610 --> 00:03:40,660
Từ vựng miền sẽ bao gồm danh sách các mục như giao dịch, tín dụng, đăng giao dịch, v.v. kèm theo ý nghĩa của chúng.

22
00:03:40,710 --> 00:03:48,420
Điều này nhằm đảm bảo rằng tất cả các bên liên quan có sự hiểu biết chung về tất cả các thuật ngữ được sử dụng trong lĩnh vực đó.

23
00:03:48,720 --> 00:04:03,730
Hãy coi các thực thể miền là các đối tượng miền có nhận dạng duy nhất.  Thuộc tính trong đối tượng miền có thể thay đổi trong suốt thời gian tồn tại của đối tượng, nhưng danh tính được giữ lại trong miền ngân hàng.

24
00:04:03,930 --> 00:04:15,660
Các ví dụ là tài khoản tiết kiệm và tài khoản séc, được tài khoản xác định duy nhất.  Không có giao dịch nào là một thực thể khác được xác định duy nhất bằng ID giao dịch.

25
00:04:15,840 --> 00:04:27,200
Trong thế giới thực, các thực thể miền có mối quan hệ với các thực thể miền khác và mô hình miền nắm bắt các mối quan hệ này trong miền ngân hàng.

26
00:04:27,300 --> 00:04:36,310
Thực thể tài khoản có các thực thể giao dịch.  Đây là sự mô tả về một mối quan hệ rất đơn giản trong lĩnh vực ngân hàng.

27
00:04:36,750 --> 00:04:48,270
Các doanh nghiệp sử dụng các quy trình đã xác định để thực hiện các hoạt động và các quy trình này được ghi lại trong mô hình miền bằng các quy trình công việc và hoạt động.

28
00:04:48,540 --> 00:04:55,530
Các ví dụ cho lĩnh vực ngân hàng là quy trình mở tài khoản tiết kiệm và quy trình phê duyệt khoản vay.

29
00:04:56,100 --> 00:05:10,140
Điều quan trọng cần ghi nhớ là mô hình miền.  Nắm bắt kiến ​​thức có cấu trúc được sử dụng để giải quyết một vấn đề kinh doanh, nó không chỉ giới hạn ở những yếu tố mà tôi đã thảo luận.

30
00:05:10,160 --> 00:05:18,850
Trên thực tế, mô hình miền có thể chứa kiến ​​thức bổ sung bằng cách mô tả trực quan hoặc sơ đồ và tài liệu văn bản.

31
00:05:18,950 --> 00:05:27,350
Bạn, với tư cách là người tạo ra các mô hình miền, có quyền kiểm soát những gì sẽ có trong mô hình miền để làm cho mô hình miền hiệu quả nhất có thể.

32
00:05:27,770 --> 00:05:34,580
Không có công cụ đặc biệt nào để tạo mô hình miền để trực quan hóa, điều này thường xảy ra trong email của bạn.

33
00:05:34,940 --> 00:05:47,510
Bạn có thể sử dụng bất kỳ công cụ nào hỗ trợ việc lập mô hình con người hoặc tài liệu văn bản.  Tôi đã thấy các nhóm sử dụng chó cũng như wiki và các công cụ quản lý thông tin khác.

34
00:05:47,540 --> 00:05:54,790
Vào cuối ngày, các bên liên quan làm việc trên các mô hình miền có thể quyết định các công cụ phù hợp nhất với họ.

35
00:05:55,010 --> 00:06:02,250
Đã đến lúc xem lại những điểm chính trong lĩnh vực bài học này.  Morang là kiến ​​thức có tổ chức và có cấu trúc về miền.

36
00:06:02,780 --> 00:06:11,450
Mục đích của mô hình miền là giúp tạo ra giải pháp cho các vấn đề kinh doanh.  Trong phạm vi đó được thảo luận.

37
00:06:11,450 --> 00:06:23,500
Năm yếu tố tạo nên mô hình miền, miền, từ vựng, thực thể miền, mối quan hệ giữa các thực thể, quy trình làm việc và hoạt động cũng như các khái niệm chính.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\03IntroductiontoDomainDrivenDesign_VVN\000000005.srt -->

1
00:00:00,180 --> 00:00:14,600
Mô hình miền doanh nghiệp, trong bài học này, bạn tìm hiểu về các mô hình miền doanh nghiệp còn được gọi là mô hình miền tổng hợp hoặc thống nhất, đến cuối bài giảng này, bạn sẽ có thể giải thích thuật ngữ thu thập kiến ​​thức.

2
00:00:14,970 --> 00:00:24,270
Bạn sẽ có thể giải thích mô hình miền doanh nghiệp là gì và bạn có thể thảo luận về những thách thức mà thiết kế hướng miền giải quyết.

3
00:00:24,690 --> 00:00:35,700
Tôi sẽ bắt đầu bài học này bằng một câu hỏi.  Ai trong tổ chức của bạn thực sự hiểu quy trình kinh doanh của tổ chức bạn đề nghị bạn nên tạm dừng video trong vài giây và suy nghĩ kỹ về nó.

4
00:00:35,910 --> 00:00:44,190
Bây giờ, nếu bạn làm việc cho một tổ chức nhỏ trong một ngành quy mô nhỏ, bạn rất có thể tìm được một hoặc hai chuyên gia.

5
00:00:44,200 --> 00:00:56,120
Nhưng nếu bạn làm việc trong một ngành phức tạp như ngân hàng, thì bạn có thể khó tìm được một chuyên gia biết mọi thứ về lĩnh vực đó hoặc ngành đó.

6
00:00:56,160 --> 00:01:05,240
Ngân hàng là một lĩnh vực phức tạp và bạn sẽ thấy rằng có nhiều chuyên gia chuyên về các khía cạnh nhất định của sản phẩm ngân hàng.

7
00:01:05,610 --> 00:01:14,220
Ví dụ: chuyên gia tài khoản người bán có thể cung cấp cho bạn tất cả thông tin bạn cần về dịch vụ tài khoản người bán của ngân hàng.

8
00:01:14,580 --> 00:01:24,990
Nhưng họ có thể không thể nói về việc xử lý các khoản vay chẳng hạn.  Tương tự, trong ví dụ của Akhmatova, chúng ta có nhiều chuyên gia mà tôi đã thảo luận trước đó.

9
00:01:25,320 --> 00:01:38,130
Cố vấn du lịch là chuyên gia trong việc tạo ra các gói du lịch cho khách hàng, nhưng họ có thể không cung cấp được thông tin về cách Achmat đi lại, thực hiện kế toán hoặc cách tạo hợp đồng đối tác.

10
00:01:38,310 --> 00:01:54,000
Những việc đó bạn cần phải tìm đến các chuyên gia khác để không lấy được kiến ​​thức về miền.  Các nhóm phải làm việc với các chuyên gia miền này vì kiến ​​thức này hầu như không được ghi lại ở bất kỳ đâu mà nằm trong đầu các chuyên gia miền này.

11
00:01:55,050 --> 00:02:18,690
Kiến thức miền RECALDE là kiến ​​thức có tổ chức và có cấu trúc về miền và các mô hình miền này được tạo bằng một quy trình được gọi là thu thập kiến ​​thức, đơn giản để nhóm nhận kiến ​​thức từ chuyên gia miền hoặc chuyên gia phân tích thông tin và kiến ​​thức nhận được và tạo miền  các mô hình.

12
00:02:19,110 --> 00:02:31,660
Thông thường, quy trình xử lý kiến ​​thức được dẫn đầu bởi nhóm công nghệ làm việc rất chặt chẽ với các chuyên gia tên miền để tạo ra cấu trúc, kiến ​​thức tên miền hoặc mô hình tên miền đó.

13
00:02:32,130 --> 00:02:40,820
Thông thường, nhóm công nghệ sẽ được dẫn dắt bởi một kỹ thuật viên có kinh nghiệm.  Vì lợi ích của cuộc thảo luận này, tôi sẽ gọi người này một cách lý tưởng.

14
00:02:40,890 --> 00:02:52,920
Lý tưởng nhất là người lãnh đạo lý tưởng phải có một số kinh nghiệm trước đó về thực hành lập mô hình miền và người lý tưởng không bắt buộc phải là chuyên gia về các công nghệ cụ thể.

15
00:02:52,950 --> 00:03:01,310
Theo kinh nghiệm của tôi, I.T.  khách hàng tiềm năng có kiến ​​thức sâu rộng và nhiều công nghệ, đồng thời họ cũng sẵn sàng tìm hiểu các chủ đề liên quan đến kinh doanh.

16
00:03:01,770 --> 00:03:22,710
Nhóm công nghệ có thể bao gồm các thành viên trong nhóm với các bộ kỹ năng và vai trò khác nhau.  Vào cuối những năm 1990 và đầu năm 2000, tôi đã thực hiện nhiều công việc tư vấn, trong đó tôi là thành viên của các nhóm thu thập kiến ​​thức từ nhiều chuyên gia trong một tổ chức để tạo ra mô hình miền doanh nghiệp.

17
00:03:22,890 --> 00:03:30,510
Mô hình miền doanh nghiệp này nắm bắt tất cả kiến ​​thức từ khắp doanh nghiệp vào một bộ mô hình.

18
00:03:30,540 --> 00:03:38,580
Ý tưởng là những mô hình này có thể được các nhóm phát triển phần mềm sử dụng để xây dựng các hệ thống mạnh mẽ, được ghi chép đầy đủ.

19
00:03:38,730 --> 00:03:47,130
Những mô hình doanh nghiệp này còn được gọi là mô hình thống nhất hoặc mô hình tổng hợp.  Ý tưởng đằng sau tất cả những điều này đều giống nhau.

20
00:03:47,400 --> 00:04:03,630
Quá trình phát triển phần mềm dự định trông giống như thế này.  Các nhóm phát triển phần mềm sẽ tập trung vào các lĩnh vực cụ thể trong mô hình miền doanh nghiệp, sau đó thực hiện mã thiết kế kỹ thuật và sau đó xây dựng sản phẩm cuối cùng.

21
00:04:03,690 --> 00:04:13,820
Về lý thuyết, điều này nghe có vẻ tốt, nhưng trên thực tế, quá trình này gặp phải nhiều thách thức.  Thử thách đầu tiên là việc tạo ra mô hình.

22
00:04:13,830 --> 00:04:23,940
Các mô hình doanh nghiệp vốn đã phức tạp do phạm vi, quy mô và thực tế là cần phải có nhiều chuyên gia tham gia để tạo ra các mô hình đó.

23
00:04:24,210 --> 00:04:36,660
Thứ hai là rất khó để cập nhật các mô hình vì không có chủ sở hữu duy nhất cho mô hình và IGT phải quản lý mô hình cũng như sản phẩm phần mềm.

24
00:04:36,720 --> 00:04:47,300
Thật không may, sau một thời gian, do ưu tiên phân phối sản phẩm, các mô hình bắt đầu tụt hậu so với việc triển khai thực tế và mất đi giá trị.

25
00:04:47,520 --> 00:04:59,580
Và thứ ba là có những thách thức về mặt ngôn ngữ.  Khi bạn cố gắng hợp nhất kiến ​​thức về nhiều lĩnh vực vào một mô hình duy nhất, việc thấy cùng một doanh nghiệp là điều rất bình thường.

26
00:05:00,160 --> 00:05:13,460
Có ý nghĩa khác nhau trong các tên miền phụ khác nhau trong tổ chức và những thách thức về ngôn ngữ này có thể gây ra sự nhầm lẫn lớn cho các nhóm phát triển phần mềm cũng như các chuyên gia về miền.

27
00:05:13,570 --> 00:05:26,830
Một điểm quan trọng cần lưu ý là những thách thức này không chỉ áp dụng cho các mô hình miền cấp doanh nghiệp mà còn cho bất kỳ mô hình miền nào phải xử lý các miền phức tạp.

28
00:05:26,890 --> 00:05:34,120
Tin tốt là phương pháp thiết kế hướng miền cung cấp các nguyên tắc và mô hình để giải quyết các thách thức.

29
00:05:34,120 --> 00:05:42,740
Đối mặt với việc phát triển các mô hình miền phức tạp, bắt đầu với bài giảng tiếp theo, chúng ta sẽ nghiên cứu sâu hơn về cách thức hoạt động của phương pháp thiết kế hướng miền.

30
00:05:42,760 --> 00:05:54,320
Chúng ta hãy điểm qua những bài học quan trọng từ bài học này.  Việc xử lý kiến ​​thức đề cập đến quá trình tạo mô hình miền từ kiến ​​thức được thu thập từ các chuyên gia về miền.

31
00:05:54,790 --> 00:06:04,630
Có nhiều thách thức khi tạo mô hình cho các miền phức tạp và những thách thức này được giải quyết bằng phương pháp thiết kế hướng miền.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04 Understanding the Business Domain\001 Why understand the Business_.en.srt -->

1

00:00:00,150 --> 00:00:04,050

Every business today is a technology business for some businesses.



2

00:00:04,080 --> 00:00:05,970

Technology is the core model.



3

00:00:06,330 --> 00:00:11,950

For example, Ed Lewis and Google cannot survive without the technology.



4

00:00:11,970 --> 00:00:19,560

As technology is their core business, whereas for other businesses, technology supports the core business



5

00:00:19,560 --> 00:00:20,000

model.



6

00:00:20,250 --> 00:00:26,940

For example, Capital One and Domino's are legacy businesses that depend on technology to achieve their



7

00:00:26,940 --> 00:00:28,120

business objectives.



8

00:00:28,560 --> 00:00:35,800

So irrespective of the core business model, technology is an essential part of the business today.



9

00:00:36,150 --> 00:00:43,890

The goal of the I.T. teams is to help the business achieve the business goals, and I.T. teams must



10

00:00:43,890 --> 00:00:45,570

understand the business model.



11

00:00:46,290 --> 00:00:53,750

Understanding of the business model by I.T. teams will lead to faster delivery of value to the business.



12

00:00:53,790 --> 00:01:00,750

It'll lead to more active participation of the teams in the business decisions, and it'll align the



13

00:01:01,140 --> 00:01:03,810

objectives with the business objectives.



14

00:01:03,930 --> 00:01:10,230

And the most important outcome of having I.T. teams understand the business is that business starts



15

00:01:10,230 --> 00:01:15,590

to think of it as a trusted partner rather than just as a service provider.



16

00:01:15,870 --> 00:01:22,500

And what this essentially means is more value to the business, more value to the customers of the business.



17

00:01:23,010 --> 00:01:30,450

Now, I have to give you one reason why you as a technologist should learn business then that one reason



18

00:01:30,450 --> 00:01:36,560

would be that architects and developers are technologists in general who understand the business owns



19

00:01:36,570 --> 00:01:39,720

the trust of the business and their peers.



20

00:01:40,050 --> 00:01:43,130

I've seen this many, many times in my career.



21

00:01:43,470 --> 00:01:49,590

So make sure that you, as the technologies are not only focusing on learning new technologies, but



22

00:01:49,590 --> 00:01:53,220

are also spending time on understanding the business.



23

00:01:53,790 --> 00:01:59,670

In next sections, you will be learning about domain driven design and domain driven design requires



24

00:01:59,670 --> 00:02:06,930

that the technologist involved in the domain driven design exercise must understand the domain.



25

00:02:07,110 --> 00:02:14,100

Lectures in this section will teach you one technique that you can use for understanding the business



26

00:02:14,100 --> 00:02:14,520

model.



27

00:02:14,760 --> 00:02:19,710

This technique is known as the business model canvas section objectives.



28

00:02:20,130 --> 00:02:26,610

Lectures in this section will teach you how to develop the business model canvas and by the end of the



29

00:02:26,640 --> 00:02:33,270

section we would have developed the business model canvas for Akhmatova's and we will be using this



30

00:02:33,270 --> 00:02:36,590

business model canvas in later lectures throughout the course.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04 Understanding the Business Domain\002 Introduction to Business Model Canvas.en.srt -->

1

00:00:00,210 --> 00:00:06,550

Business model canvas, in this lesson, you learn what a business model canvas is and describe the



2

00:00:06,840 --> 00:00:09,230

building blocks of the business model canvas.



3

00:00:09,630 --> 00:00:16,590

And as part of this lesson, we will create the business model canvas for our business model.



4

00:00:16,590 --> 00:00:23,970

Canvas is a tool that helps discuss, communicate, design and understand the organization's business



5

00:00:23,970 --> 00:00:24,390

model.



6

00:00:24,510 --> 00:00:32,000

The benefit of the business model canvas is that the entire business model may be depicted in one image.



7

00:00:32,110 --> 00:00:36,900

Here is how the completed business model canvas looks like for accurate travel.



8

00:00:37,080 --> 00:00:43,920

To create the business model canvas, one has to focus on nine core areas of the business.



9

00:00:43,920 --> 00:00:48,630

And these are the nine basic building blocks organized in the form of a canvas.



10

00:00:48,780 --> 00:00:53,700

This is how a black business model canvas looks like in this lecture.



11

00:00:53,850 --> 00:01:00,560

I'll explain to you what goes into each of these building blocks, and I'll use Uber as an example.



12

00:01:00,570 --> 00:01:05,250

So by the end of this lecture, we will have the business model canvas for oboH.



13

00:01:05,490 --> 00:01:11,750

Please note that my intent for this lecture is to provide you an overview of the business model canvas.



14

00:01:11,760 --> 00:01:14,170

I'll encourage you to do your own research.



15

00:01:14,190 --> 00:01:19,250

There are many, many good sites that provide a deeper dive into the business model canvas.



16

00:01:19,290 --> 00:01:24,650

Suggest that you start by reading the Wikipedia page on a business model canvas.



17

00:01:24,840 --> 00:01:27,690

The first building block that I discuss is the customer.



18

00:01:27,690 --> 00:01:33,840

Segments of customers are the reason business exist, so one has to carefully think about who are the



19

00:01:33,930 --> 00:01:34,680

customers.



20

00:01:34,680 --> 00:01:41,100

And in the case of UBA, the customers may be divided into two segments the drivers and the customers,



21

00:01:41,100 --> 00:01:43,710

which can be the individuals or the businesses.



22

00:01:43,720 --> 00:01:50,670

So in case of Uber individuals, businesses and drivers, are the customers next building block as the



23

00:01:50,670 --> 00:01:51,900

value proposition?



24

00:01:52,260 --> 00:01:56,370

Now, what kind of a value are providing to each of these customers?



25

00:01:56,550 --> 00:01:57,960

That's what we need to think about.



26

00:01:57,960 --> 00:02:05,160

In case of Uber, the customers are getting the convenience of getting it right by just tapping on the



27

00:02:05,160 --> 00:02:05,570

phone.



28

00:02:05,820 --> 00:02:08,580

For drivers, it is the supplementary income.



29

00:02:09,030 --> 00:02:11,210

The next one is the key resources.



30

00:02:11,670 --> 00:02:13,410

The keyword here is the key.



31

00:02:13,560 --> 00:02:20,070

There are many resources that a business requires, but you need to think about those resources which



32

00:02:20,070 --> 00:02:23,190

are essential for the value proposition.



33

00:02:23,200 --> 00:02:28,860

In other words, there may be multiple resources the business needs, but think about those key ones



34

00:02:28,860 --> 00:02:30,990

without which the business cannot exist.



35

00:02:31,230 --> 00:02:37,050

In the case of over these resources or the platform that connects the customers to the driver, the



36

00:02:37,050 --> 00:02:44,700

software that has the algorithms for pricing, road matching, etc. and last but not least, the driver



37

00:02:44,700 --> 00:02:45,240

network.



38

00:02:45,240 --> 00:02:49,320

Without the drivers, Uber cannot deliver the value to the customers.



39

00:02:49,740 --> 00:02:56,280

Next one is the key partners who are the suppliers of the key resources to the business.



40

00:02:56,280 --> 00:03:02,880

In case of Uber, it is the drivers who own a car and these drivers give the right to the customers.



41

00:03:03,090 --> 00:03:05,400

Next one is the technology providers.



42

00:03:05,430 --> 00:03:10,410

Uber does not create all of the technologies that are needed for its platform.



43

00:03:10,620 --> 00:03:17,400

It procure technology from other suppliers or partners such as mapping technology provider.



44

00:03:17,550 --> 00:03:22,260

It also has to get permissions to operate from the state authorities.



45

00:03:22,380 --> 00:03:26,700

Without the appropriate permissions, Uber will not be allowed to operate.



46

00:03:27,240 --> 00:03:32,310

Businesses need to carry out multiple activities under the key activities.



47

00:03:32,610 --> 00:03:38,490

You need to think about the activities that the business carries out to create value for the customer.



48

00:03:38,580 --> 00:03:42,540

Uber builds and maintains the platform and the software.



49

00:03:42,630 --> 00:03:49,320

Uber is always looking for new drivers, so the driver recruitment is one of the key activities.



50

00:03:49,320 --> 00:03:50,760

And then there are legal affairs.



51

00:03:50,760 --> 00:03:56,400

I mean, if you have been paying attention to the news on Google, you will find that Uber is always



52

00:03:56,400 --> 00:04:01,200

involved in some kind of legal battles with state and city authorities.



53

00:04:01,860 --> 00:04:06,600

Customer retention is one of the most important thing for any business.



54

00:04:06,780 --> 00:04:13,200

And to retain a customer, you need to ensure that the customers are happy with the service you are



55

00:04:13,200 --> 00:04:16,680

providing and the relationship that you have with them.



56

00:04:17,280 --> 00:04:24,210

So under the customer relationships, one has to think about the type of relationship that is offered



57

00:04:24,300 --> 00:04:26,250

to each of the customer segments.



58

00:04:26,460 --> 00:04:32,130

So in case of whoever it is, the ratings and the feedback system for the customers and the drivers,



59

00:04:32,400 --> 00:04:39,300

then there is a self-service mechanism by which the customers and drivers can get the service and support



60

00:04:39,300 --> 00:04:40,160

from over.



61

00:04:40,320 --> 00:04:46,740

Uber also provides the customer and the driver support by way of emails, by way of even phone.



62

00:04:46,740 --> 00:04:53,150

For example, Uber drivers have 24 by seven phone support next to covers.



63

00:04:53,160 --> 00:04:59,070

The cashflow revenue stream depicts the inflow of revenue for the business.



64

00:04:59,070 --> 00:04:59,470

For what?



65

00:04:59,970 --> 00:05:06,650

The customer paid for in case of Uber, it is the right commissions that we will get from each other,



66

00:05:06,660 --> 00:05:07,060

right.



67

00:05:07,110 --> 00:05:14,160

The premium for some of the right types, the search price and the cancellation fee, the cost structure



68

00:05:14,160 --> 00:05:16,940

has the depiction of the cash outflow.



69

00:05:17,280 --> 00:05:25,310

These are the expenses incurred by the business on carrying out the key activities in case of Uber.



70

00:05:25,350 --> 00:05:31,390

These are marketing, legal affairs, technology development, employee salaries.



71

00:05:31,740 --> 00:05:35,280

Last but not the least, we will spend a lot on R&amp;D.



72

00:05:35,640 --> 00:05:40,820

Next one is the channels by which the customers would like to be reached for over.



73

00:05:40,830 --> 00:05:49,110

It is the mobile application that we will provide and also certain third party applications that allow



74

00:05:49,110 --> 00:05:51,510

the customers to avail over services.



75

00:05:51,630 --> 00:05:57,810

In this lesson, I covered the business model canvas, which is a tool that helps in understanding the



76

00:05:57,810 --> 00:05:59,590

organization's business model.



77

00:05:59,940 --> 00:06:03,090

There are nine part in our business model canvas.



78

00:06:03,090 --> 00:06:08,850

As part of this lesson, I walked you through the simplistic view of the business model canvas for Uber.



79

00:06:09,000 --> 00:06:12,930

Uber has drivers, individual and businesses as its customers.



80

00:06:12,930 --> 00:06:16,350

They get convenience and supplementary income from work.



81

00:06:16,350 --> 00:06:21,780

To deliver this value, Uber has to maintain a platform carrier driver recruitment and take care of



82

00:06:21,780 --> 00:06:22,800

legal affairs.



83

00:06:22,800 --> 00:06:29,130

It requires platform, software and drivers to operate its business from the key partners and suppliers



84

00:06:29,130 --> 00:06:34,380

perspective, Uber has to partner with drivers, technology providers and state authorities.



85

00:06:34,470 --> 00:06:41,310

Customer relationships is managed by way of ratings, feedback and self-service mechanisms available



86

00:06:41,310 --> 00:06:47,580

in the applications and would also provide support to the drivers by way of a 24/7 phone line.



87

00:06:47,760 --> 00:06:53,400

From the chairman's perspective, the services are offered to the customers by way of mobile applications



88

00:06:53,400 --> 00:06:55,080

and third party applications.



89

00:06:55,350 --> 00:07:02,550

Uber makes money by way of right commissions, premium rides, surge pricing and cancellation fees.



90

00:07:02,580 --> 00:07:09,990

Uber incur expenses and pays for the marketing, legal affairs, technology development, R&amp;D and employee



91

00:07:09,990 --> 00:07:10,620

salaries.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04 Understanding the Business Domain\003 Exercise _ ACME Travels Business Model Canvas.en.srt -->

1

00:00:00,210 --> 00:00:05,940

Business model, canvas for travel, in this lecture, you will learn how the business model canvas



2

00:00:05,940 --> 00:00:12,840

has created and by the end of this lecture we will have the business model canvas for ACMC travels to



3

00:00:12,840 --> 00:00:14,310

get the most out of this lecture.



4

00:00:14,460 --> 00:00:21,160

I suggest that you follow along, create the business model canvas for the organization you work for.



5

00:00:21,480 --> 00:00:27,780

So for each of the nine building blocks, think about your own organization, put some stickies on a



6

00:00:27,780 --> 00:00:34,110

piece of paper and if you're interested in reviewing it with me, put it out as an image and the question



7

00:00:34,110 --> 00:00:36,880

and answers will be happy to discuss it.



8

00:00:37,380 --> 00:00:38,760

Let's start with the question.



9

00:00:38,760 --> 00:00:45,050

How is the business model canvas created for an organization that is in existence for years?



10

00:00:45,060 --> 00:00:46,070

Like Acme?



11

00:00:46,230 --> 00:00:52,830

The best place to start are the subject matter experts from across the domains within the organization.



12

00:00:52,890 --> 00:00:55,950

This is done mostly by interviewing the experts.



13

00:00:56,370 --> 00:01:01,560

You can also observe the business to gain an understanding of their business model.



14

00:01:01,620 --> 00:01:07,380

And publicly available information provides quite a good insight into the business.



15

00:01:07,410 --> 00:01:11,000

Now the question may come here is what if it's a new business?



16

00:01:11,010 --> 00:01:18,120

In that case, the founders must create a business model canvas to clarify their own understanding and



17

00:01:18,120 --> 00:01:20,970

to sell the idea to the venture capitalist.



18

00:01:21,150 --> 00:01:27,690

Though they may not be any business expert, but there are industry experts who may be able to provide



19

00:01:27,690 --> 00:01:34,220

insight into what kind of a business model would work the best in that specific industry.



20

00:01:35,090 --> 00:01:42,170

For the sake of this lecture, as you that we interviewed the Achmea Travels business experts, and



21

00:01:42,170 --> 00:01:47,990

based on the input we received from these experts, we created our business model canvas.



22

00:01:49,380 --> 00:01:55,170

The Acme business experts talked about three types of customers, the first type, the vacationers who



23

00:01:55,170 --> 00:01:57,430

appreciate the ease and convenience.



24

00:01:57,780 --> 00:02:00,930

These are the folks who do not like the hassle of planning.



25

00:02:01,260 --> 00:02:06,290

And these folks just like to pack up their bags and hit the road with an acme.



26

00:02:06,630 --> 00:02:11,040

This particular category of vacationers is referred to as the hassle free traveler.



27

00:02:11,220 --> 00:02:17,280

The second category are the customers who are very budget conscious and they are looking for discounts



28

00:02:17,280 --> 00:02:20,340

and deals and are willing to cut down on their luxuries.



29

00:02:20,340 --> 00:02:24,120

And these are the customers who are referred to as the budget conscious customer.



30

00:02:24,260 --> 00:02:30,210

The third one are the corporations that are arranging group tours for their employees, and Acme gives



31

00:02:30,210 --> 00:02:33,210

them group discounts and offer them specialized services.



32

00:02:33,510 --> 00:02:35,580

For example, travel guides.



33

00:02:35,610 --> 00:02:39,990

This third type of customers are referred to as the corporations or corporate customers.



34

00:02:40,140 --> 00:02:44,370

So these are the three customer segments for Acme.



35

00:02:44,640 --> 00:02:49,100

Each of these customer segments are looking for a different value proposition.



36

00:02:49,470 --> 00:02:52,560

The hassle free travelers are looking for convenience.



37

00:02:52,930 --> 00:02:56,820

So Acme designed all inclusive vacation packages.



38

00:02:57,060 --> 00:03:00,900

So for them, the convenience is the value proposition.



39

00:03:01,260 --> 00:03:08,820

Budget conscious customers are looking for affordable travel packages, and so Acme offers them customizable



40

00:03:08,820 --> 00:03:13,910

travel bundles and for them, value for money is important.



41

00:03:14,160 --> 00:03:21,180

Corporate customers arrange group vacations for their employees and they like to get into in logistics



42

00:03:21,180 --> 00:03:22,080

from Acme.



43

00:03:22,380 --> 00:03:28,860

So the value for the corporate customer is the logistics and the planning provided by the act by way



44

00:03:28,860 --> 00:03:30,650

of the group vacation packages.



45

00:03:31,110 --> 00:03:37,920

The business expert at Acme mentioned that the vacation package consists of multiple parts and it listed



46

00:03:37,920 --> 00:03:39,180

all the various parts.



47

00:03:39,210 --> 00:03:43,240

What I realized was that these parts could be put in three buckets.



48

00:03:43,260 --> 00:03:48,530

They were the airline train and bus tickets, which may be thought of as transportation.



49

00:03:48,690 --> 00:03:52,950

The second part for the accommodation, the hotel and Airbnb.



50

00:03:52,950 --> 00:03:58,620

And the third part was the excursions that Acme offers as part of the vacation packages.



51

00:03:58,830 --> 00:04:01,890

So these are the key resources for Acme.



52

00:04:02,100 --> 00:04:07,650

Next, let's cover the key partners and suppliers for Acme for transportation needs.



53

00:04:07,800 --> 00:04:15,060

Achmea depends on the airlines, cruises, bus companies and also have business relationships with car



54

00:04:15,060 --> 00:04:18,330

rental companies that give them commission or discounts.



55

00:04:18,540 --> 00:04:25,650

Akman depends on hotels and Airbnb for accommodations and for excursions.



56

00:04:25,830 --> 00:04:31,740

Acme has established relationships with multiple tour operators around the world.



57

00:04:32,160 --> 00:04:36,870

Like other businesses, there are multiple key activities that Acme is involved in.



58

00:04:37,410 --> 00:04:42,240

To be successful, Acme needs to understand the preferences of the customers and product.



59

00:04:42,360 --> 00:04:44,400

ACMC carries out market research.



60

00:04:44,730 --> 00:04:51,930

Achmea runs marketing campaigns on a constant basis, so campaigns management is another key activity.



61

00:04:51,930 --> 00:04:57,510

For Acme to be profitable, Ackman needs to negotiate optimal contract with its providers.



62

00:04:57,780 --> 00:05:02,040

So contract negotiation is a key activity for Acme.



63

00:05:02,160 --> 00:05:08,790

To be competitive in the market, Ackman has to create vacation packages that are very attractive to



64

00:05:08,790 --> 00:05:10,110

its customers.



65

00:05:10,110 --> 00:05:16,620

So product design or vacation package design is another key activity that the experts at Acme are involved



66

00:05:16,620 --> 00:05:21,330

in, although in the past years they don't spend a lot of effort on technology.



67

00:05:21,630 --> 00:05:27,810

But with the recent mandate from the CTO and the CEO of the company, the experts at Acme have started



68

00:05:27,810 --> 00:05:34,380

to spend more and more time and effort in understanding how technology can be leveraged by Ackman to



69

00:05:34,380 --> 00:05:36,720

become more competitive and profitable.



70

00:05:37,080 --> 00:05:39,480

Next, let's talk about customer relationship.



71

00:05:39,750 --> 00:05:46,320

Achmat provides 24/7 support to its customers by way of phone, email and text messages.



72

00:05:46,530 --> 00:05:53,140

Sometime ACMS partners do not provide the best experience for the customer, and that leads to conflicts.



73

00:05:53,370 --> 00:05:59,070

Acne protects its customer by helping out with the resolution of the conflict.



74

00:05:59,070 --> 00:06:02,340

They work directly with their providers or partners.



75

00:06:02,340 --> 00:06:10,230

As customers advocates, Achmat encourages its customers to provide feedback during and after the vacation.



76

00:06:10,260 --> 00:06:14,930

Achmat takes this feedback very seriously and acts on it whenever possible.



77

00:06:15,210 --> 00:06:21,600

The biggest chunk of business for ACMC comes from the travel agents who sell the vacation packages to



78

00:06:21,600 --> 00:06:23,400

the customers and corporations.



79

00:06:23,550 --> 00:06:29,970

Unfortunately, the travel agent business is declining because of the changing customer preferences.



80

00:06:29,970 --> 00:06:36,990

Direct sales account for roughly 35 percent of Acme revenue, and the target is to take it up to 55



81

00:06:36,990 --> 00:06:38,370

percent the next two years.



82

00:06:38,370 --> 00:06:44,070

With the help of technology, e-commerce competition has started to use affiliate partners, whereas



83

00:06:44,100 --> 00:06:48,810

Acme has still not been able to effectively use affiliate and.



84

00:06:48,870 --> 00:06:55,980

This is considered as a big opportunity for Acme Wholesale Clubs to not provide a lot of business to



85

00:06:55,980 --> 00:07:02,730

Acme because they require Acme to be ready to integrate with certain technologies.



86

00:07:02,940 --> 00:07:06,860

And Acme is lagging in the adoption of technology.



87

00:07:06,930 --> 00:07:11,310

But still, a part of ACMS business comes from wholesale clubs.



88

00:07:11,700 --> 00:07:14,640

Primarily, Achmea makes money in three ways.



89

00:07:14,640 --> 00:07:20,220

The first wherein they receive commissions from the various partners and providers.



90

00:07:20,310 --> 00:07:27,540

Second way is by way of the markup on the provider services, and third way is by way of markup on the



91

00:07:27,540 --> 00:07:30,080

vacation packages that Achmat designs.



92

00:07:30,080 --> 00:07:34,620

So these three represent the cash inflow sources for Acme.



93

00:07:35,040 --> 00:07:41,670

Acme is constantly running marketing campaigns and for that it has to spend a big chunk of money like



94

00:07:41,670 --> 00:07:45,420

Acme gets commissions from its partners and providers.



95

00:07:45,610 --> 00:07:49,080

It also has to pay commissions to its sales partner.



96

00:07:49,620 --> 00:07:57,870

All the technology was not a big focus for Ackman, but more recently it has started to spend a significant



97

00:07:57,870 --> 00:07:59,310

amount on technology.



98

00:07:59,670 --> 00:08:05,940

Last but not the least, employee salaries and travel specialist commissions are another big expense



99

00:08:05,940 --> 00:08:06,960

for Acme.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04UnderstandingtheBusinessDomain_VVN\000000001.srt -->

1
00:00:00,150 --> 00:00:11,950
Mỗi doanh nghiệp ngày nay đều là một doanh nghiệp công nghệ đối với một số doanh nghiệp.  Công nghệ là mô hình cốt lõi.  Chẳng hạn, Ed Lewis và Google không thể tồn tại được nếu không có công nghệ.

2
00:00:11,970 --> 00:00:20,000
Vì công nghệ là hoạt động kinh doanh cốt lõi của họ, trong khi đối với các doanh nghiệp khác, công nghệ hỗ trợ mô hình kinh doanh cốt lõi.

3
00:00:20,250 --> 00:00:28,120
Ví dụ: Capital One và Domino's là những doanh nghiệp truyền thống phụ thuộc vào công nghệ để đạt được mục tiêu kinh doanh của họ.

4
00:00:28,560 --> 00:00:45,570
Vì vậy, bất kể mô hình kinh doanh cốt lõi là gì, công nghệ vẫn là một phần thiết yếu của hoạt động kinh doanh ngày nay.  Mục tiêu của I.T.  các nhóm là giúp doanh nghiệp đạt được các mục tiêu kinh doanh và I.T.  các nhóm phải hiểu mô hình kinh doanh.

5
00:00:46,290 --> 00:00:53,750
Sự hiểu biết về mô hình kinh doanh của I.T.  các nhóm sẽ dẫn đến việc cung cấp giá trị nhanh hơn cho doanh nghiệp.

6
00:00:53,790 --> 00:01:03,810
Nó sẽ dẫn đến sự tham gia tích cực hơn của các nhóm vào các quyết định kinh doanh và nó sẽ điều chỉnh các mục tiêu phù hợp với mục tiêu kinh doanh.

7
00:01:03,930 --> 00:01:15,590
Và kết quả quan trọng nhất của việc có I.T.  các nhóm hiểu doanh nghiệp là doanh nghiệp bắt đầu coi doanh nghiệp đó như một đối tác đáng tin cậy thay vì chỉ là nhà cung cấp dịch vụ.

8
00:01:15,870 --> 00:01:22,500
Và điều này về cơ bản có nghĩa là mang lại nhiều giá trị hơn cho doanh nghiệp, nhiều giá trị hơn cho khách hàng của doanh nghiệp.

9
00:01:23,010 --> 00:01:39,720
Bây giờ, tôi phải cho bạn một lý do tại sao bạn với tư cách là một nhà công nghệ nên học kinh doanh thì một lý do đó là các kiến ​​trúc sư và nhà phát triển là những nhà công nghệ nói chung, những người hiểu rằng doanh nghiệp sở hữu sự tin tưởng của doanh nghiệp và các đồng nghiệp của họ.

10
00:01:40,050 --> 00:01:53,220
Tôi đã thấy điều này rất nhiều lần trong sự nghiệp của mình.  Vì vậy, hãy đảm bảo rằng bạn, với tư cách là công nghệ, không chỉ tập trung vào việc học các công nghệ mới mà còn dành thời gian để tìm hiểu hoạt động kinh doanh.

11
00:01:53,790 --> 00:02:06,930
Trong các phần tiếp theo, bạn sẽ tìm hiểu về thiết kế hướng miền và thiết kế hướng miền yêu cầu kỹ thuật viên tham gia vào bài tập thiết kế hướng miền phải hiểu miền.

12
00:02:07,110 --> 00:02:14,520
Các bài giảng trong phần này sẽ dạy cho bạn một kỹ thuật mà bạn có thể sử dụng để hiểu mô hình kinh doanh.

13
00:02:14,760 --> 00:02:36,590
Kỹ thuật này được gọi là mục tiêu của phần canvas mô hình kinh doanh.  Các bài giảng trong phần này sẽ hướng dẫn bạn cách phát triển canvas mô hình kinh doanh và đến cuối phần này, chúng tôi sẽ phát triển canvas mô hình kinh doanh cho Akhmatova và chúng tôi sẽ sử dụng canvas mô hình kinh doanh này trong các bài giảng sau trong suốt khóa học.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04UnderstandingtheBusinessDomain_VVN\000000002.srt -->

1
00:00:00,210 --> 00:00:09,230
Canvas mô hình kinh doanh, trong bài học này, bạn tìm hiểu canvas mô hình kinh doanh là gì và mô tả các khối xây dựng của canvas mô hình kinh doanh.

2
00:00:09,630 --> 00:00:24,390
Và như một phần của bài học này, chúng ta sẽ tạo khung mô hình kinh doanh cho mô hình kinh doanh của mình.  Canvas là công cụ giúp thảo luận, giao tiếp, thiết kế và tìm hiểu mô hình kinh doanh của tổ chức.

3
00:00:24,510 --> 00:00:32,000
Lợi ích của canvas mô hình kinh doanh là toàn bộ mô hình kinh doanh có thể được mô tả bằng một hình ảnh.

4
00:00:32,110 --> 00:00:43,920
Đây là cách mô hình kinh doanh hoàn chỉnh trông như thế nào để có chuyến đi chính xác.  Để tạo ra bức vẽ mô hình kinh doanh, người ta phải tập trung vào chín lĩnh vực cốt lõi của doanh nghiệp.

5
00:00:43,920 --> 00:00:53,700
Và đây là chín khối xây dựng cơ bản được sắp xếp dưới dạng canvas.  Đây là hình ảnh của canvas mô hình kinh doanh màu đen trong bài giảng này.

6
00:00:53,850 --> 00:01:05,250
Tôi sẽ giải thích cho bạn những gì cấu thành nên từng khối xây dựng này và tôi sẽ lấy Uber làm ví dụ.  Vì vậy, đến cuối bài giảng này, chúng ta sẽ có được bức vẽ mô hình kinh doanh cho oboH.

7
00:01:05,490 --> 00:01:11,750
Xin lưu ý rằng mục đích của bài giảng này là cung cấp cho bạn cái nhìn tổng quan về bức vẽ mô hình kinh doanh.

8
00:01:11,760 --> 00:01:19,250
Tôi sẽ khuyến khích bạn thực hiện nghiên cứu của riêng bạn.  Có rất nhiều trang web hay giúp bạn tìm hiểu sâu hơn về mô hình mô hình kinh doanh.

9
00:01:19,290 --> 00:01:27,690
Đề nghị bạn bắt đầu bằng cách đọc trang Wikipedia về mô hình kinh doanh.  Khối xây dựng đầu tiên mà tôi thảo luận là khách hàng.

10
00:01:27,690 --> 00:01:34,680
Các phân khúc khách hàng là lý do doanh nghiệp tồn tại, vì vậy người ta phải suy nghĩ cẩn thận xem khách hàng là ai.

11
00:01:34,680 --> 00:01:43,710
Và trong trường hợp của UBA, khách hàng có thể được chia thành hai phân khúc là tài xế và khách hàng, có thể là cá nhân hoặc doanh nghiệp.

12
00:01:43,720 --> 00:01:51,900
Vì vậy, trong trường hợp các cá nhân, doanh nghiệp và tài xế Uber, khách hàng có phải là đối tượng tiếp theo là đề xuất giá trị không?

13
00:01:52,260 --> 00:01:57,960
Bây giờ, loại giá trị nào đang mang lại cho mỗi khách hàng này?  Đó là điều chúng ta cần phải suy nghĩ.

14
00:01:57,960 --> 00:02:05,570
Trong trường hợp của Uber, khách hàng sẽ nhận được sự tiện lợi khi chỉ cần chạm vào điện thoại.

15
00:02:05,820 --> 00:02:13,410
Đối với tài xế, đó là thu nhập bổ sung.  Tiếp theo là nguồn tài nguyên quan trọng.  Từ khóa ở đây là chìa khóa.

16
00:02:13,560 --> 00:02:23,190
Có nhiều nguồn lực mà doanh nghiệp yêu cầu, nhưng bạn cần suy nghĩ về những nguồn lực cần thiết cho việc đề xuất giá trị.

17
00:02:23,200 --> 00:02:30,990
Nói cách khác, có thể có nhiều nguồn lực mà doanh nghiệp cần, nhưng hãy nghĩ về những nguồn lực quan trọng mà doanh nghiệp không thể tồn tại nếu không có.

18
00:02:31,230 --> 00:02:45,240
Trong trường hợp vượt quá các tài nguyên này hoặc nền tảng kết nối khách hàng với tài xế, phần mềm có các thuật toán định giá, khớp đường, v.v. và cuối cùng nhưng không kém phần quan trọng là mạng lưới tài xế.

19
00:02:45,240 --> 00:02:56,280
Không có tài xế, Uber không thể mang lại giá trị cho khách hàng.  Tiếp theo là các đối tác chính là nhà cung cấp các nguồn lực chính cho doanh nghiệp.

20
00:02:56,280 --> 00:03:05,400
Trong trường hợp của Uber, chính tài xế là người sở hữu ô tô và những tài xế này trao quyền cho khách hàng.  Tiếp theo là các nhà cung cấp công nghệ.

21
00:03:05,430 --> 00:03:17,400
Uber không tạo ra tất cả các công nghệ cần thiết cho nền tảng của mình.  Nó mua công nghệ từ các nhà cung cấp hoặc đối tác khác, chẳng hạn như nhà cung cấp công nghệ lập bản đồ.

22
00:03:17,550 --> 00:03:26,700
Nó cũng phải có được sự cho phép hoạt động từ cơ quan nhà nước.  Nếu không có sự cho phép phù hợp, Uber sẽ không được phép hoạt động.

23
00:03:27,240 --> 00:03:38,490
Doanh nghiệp cần thực hiện nhiều hoạt động theo các hoạt động trọng tâm.  Bạn cần suy nghĩ về những hoạt động mà doanh nghiệp thực hiện để tạo ra giá trị cho khách hàng.

24
00:03:38,580 --> 00:03:49,320
Uber xây dựng và duy trì nền tảng và phần mềm.  Uber luôn tìm kiếm tài xế mới nên việc tuyển dụng tài xế là một trong những hoạt động trọng tâm.

25
00:03:49,320 --> 00:04:01,200
Và sau đó là các vấn đề pháp lý.  Ý tôi là, nếu bạn chú ý đến tin tức trên Google, bạn sẽ thấy rằng Uber luôn tham gia vào một số cuộc chiến pháp lý với chính quyền tiểu bang và thành phố.

26
00:04:01,860 --> 00:04:16,680
Giữ chân khách hàng là một trong những điều quan trọng nhất đối với bất kỳ doanh nghiệp nào.  Và để giữ chân khách hàng, bạn cần đảm bảo rằng khách hàng hài lòng với dịch vụ bạn đang cung cấp và mối quan hệ mà bạn có với họ.

27
00:04:17,280 --> 00:04:26,250
Vì vậy, trong mối quan hệ khách hàng, người ta phải suy nghĩ về loại mối quan hệ được cung cấp cho từng phân khúc khách hàng.

28
00:04:26,460 --> 00:04:40,160
Vì vậy, trong trường hợp đó là ai, hệ thống xếp hạng và phản hồi dành cho khách hàng và tài xế, thì sẽ có một cơ chế tự phục vụ để khách hàng và tài xế có thể nhận được dịch vụ và hỗ trợ từ bên kia.

29
00:04:40,320 --> 00:04:53,150
Uber cũng cung cấp hỗ trợ cho khách hàng và tài xế bằng email, thậm chí bằng điện thoại.  Ví dụ: tài xế Uber có hỗ trợ qua điện thoại 24/7 bên cạnh vỏ bọc.

30
00:04:53,160 --> 00:05:07,060
Dòng doanh thu dòng tiền mô tả dòng doanh thu của doanh nghiệp.  Để làm gì?  Khách hàng đã trả tiền trong trường hợp Uber, đó là khoản hoa hồng phù hợp mà chúng ta sẽ nhận được từ nhau, đúng không.

31
00:05:07,110 --> 00:05:16,940
Phí bảo hiểm cho một số loại phù hợp, giá tìm kiếm và phí hủy, cơ cấu chi phí mô tả dòng tiền ra.

32
00:05:17,280 --> 00:05:31,390
Đây là những chi phí mà doanh nghiệp phải chịu khi thực hiện các hoạt động chính trong trường hợp Uber.  Đó là tiếp thị, pháp lý, phát triển công nghệ, lương nhân viên.

33
00:05:31,740 --> 00:05:40,820
Cuối cùng nhưng không kém phần quan trọng, chúng tôi sẽ chi rất nhiều cho hoạt động R&D.  Tiếp theo là các kênh mà khách hàng muốn tiếp cận.

34
00:05:40,830 --> 00:05:51,510
Đó là ứng dụng di động mà chúng tôi sẽ cung cấp và một số ứng dụng của bên thứ ba cho phép khách hàng sử dụng các dịch vụ.

35
00:05:51,630 --> 00:05:59,590
Trong bài học này, tôi đã trình bày sơ đồ mô hình kinh doanh, đây là một công cụ giúp hiểu được mô hình kinh doanh của tổ chức.

36
00:05:59,940 --> 00:06:08,850
Có chín phần trong mô hình kinh doanh của chúng tôi.  Là một phần của bài học này, tôi đã hướng dẫn bạn cái nhìn đơn giản về sơ đồ mô hình kinh doanh của Uber.

37
00:06:09,000 --> 00:06:16,350
Uber có tài xế, cá nhân và doanh nghiệp là khách hàng của mình.  Họ có được sự thuận tiện và thu nhập bổ sung từ công việc.

38
00:06:16,350 --> 00:06:22,800
Để mang lại giá trị này, Uber phải duy trì việc tuyển dụng tài xế vận chuyển nền tảng và lo các vấn đề pháp lý.

39
00:06:22,800 --> 00:06:34,380
Nó đòi hỏi nền tảng, phần mềm và tài xế để vận hành hoạt động kinh doanh của mình từ góc độ đối tác và nhà cung cấp chính, Uber phải hợp tác với các tài xế, nhà cung cấp công nghệ và cơ quan nhà nước.

40
00:06:34,470 --> 00:06:47,580
Mối quan hệ khách hàng được quản lý bằng cách xếp hạng, phản hồi và cơ chế tự phục vụ có sẵn trong ứng dụng, đồng thời cũng sẽ cung cấp hỗ trợ cho người lái xe qua đường dây điện thoại 24/7.

41
00:06:47,760 --> 00:06:55,080
Theo quan điểm của chủ tịch, các dịch vụ được cung cấp cho khách hàng thông qua các ứng dụng di động và ứng dụng của bên thứ ba.

42
00:06:55,350 --> 00:07:10,620
Uber kiếm tiền bằng hoa hồng phù hợp, các chuyến đi cao cấp, giá tăng đột biến và phí hủy.  Uber phải chịu các chi phí và chi trả cho hoạt động tiếp thị, pháp lý, phát triển công nghệ, R&D và trả lương cho nhân viên.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\04UnderstandingtheBusinessDomain_VVN\000000003.srt -->

1
00:00:00,210 --> 00:00:14,310
Mô hình kinh doanh, canvas cho du lịch, trong bài giảng này, bạn sẽ tìm hiểu canvas mô hình kinh doanh đã được tạo ra như thế nào và đến cuối bài giảng này, chúng ta sẽ có canvas mô hình kinh doanh cho các chuyến đi của ACMC để tận dụng tối đa bài giảng này.

2
00:00:14,460 --> 00:00:21,160
Tôi khuyên bạn nên làm theo và tạo ra bức vẽ mô hình kinh doanh cho tổ chức mà bạn đang làm việc.

3
00:00:21,480 --> 00:00:36,880
Vì vậy, đối với mỗi khối trong số chín khối xây dựng, hãy nghĩ về tổ chức của riêng bạn, dán một số miếng dán lên một tờ giấy và nếu bạn muốn xem lại nó với tôi, hãy đưa nó ra dưới dạng hình ảnh và câu hỏi cũng như câu trả lời sẽ rất vui được thảo luận  Nó.

4
00:00:37,380 --> 00:00:45,050
Hãy bắt đầu với câu hỏi.  Làm thế nào để tạo ra canvas mô hình kinh doanh cho một tổ chức đã tồn tại trong nhiều năm?

5
00:00:45,060 --> 00:00:52,830
Giống như Acme?  Nơi tốt nhất để bắt đầu là các chuyên gia về chủ đề từ khắp các lĩnh vực trong tổ chức.

6
00:00:52,890 --> 00:01:01,560
Điều này được thực hiện chủ yếu bằng cách phỏng vấn các chuyên gia.  Bạn cũng có thể quan sát doanh nghiệp để hiểu về mô hình kinh doanh của họ.

7
00:01:01,620 --> 00:01:11,000
Và thông tin có sẵn công khai cung cấp cái nhìn sâu sắc về doanh nghiệp.  Bây giờ câu hỏi có thể được đặt ra ở đây là nếu đó là một doanh nghiệp mới thì sao?

8
00:01:11,010 --> 00:01:20,970
Trong trường hợp đó, những người sáng lập phải tạo ra một bức tranh mô hình kinh doanh để làm rõ sự hiểu biết của họ và bán ý tưởng cho nhà đầu tư mạo hiểm.

9
00:01:21,150 --> 00:01:34,220
Mặc dù họ có thể không phải là chuyên gia kinh doanh nhưng có những chuyên gia trong ngành có thể cung cấp cái nhìn sâu sắc về loại mô hình kinh doanh nào sẽ hoạt động tốt nhất trong ngành cụ thể đó.

10
00:01:35,090 --> 00:01:47,990
Vì lợi ích của bài giảng này, với tư cách là bạn, chúng tôi đã phỏng vấn các chuyên gia kinh doanh của Achmea Travels và dựa trên thông tin đầu vào mà chúng tôi nhận được từ các chuyên gia này, chúng tôi đã tạo ra khung vẽ mô hình kinh doanh của mình.

11
00:01:49,380 --> 00:01:57,430
Các chuyên gia kinh doanh của Acme nói về ba loại khách hàng, loại thứ nhất là những người đi nghỉ mát đánh giá cao sự thoải mái và tiện lợi.

12
00:01:57,780 --> 00:02:06,290
Đây là những người không thích sự rắc rối của việc lập kế hoạch.  Và những người này chỉ thích xách ba lô lên và lên đường với một thành tích cao.

13
00:02:06,630 --> 00:02:20,340
Loại khách du lịch đặc biệt này được gọi là khách du lịch không gặp rắc rối.  Loại thứ hai là những khách hàng rất quan tâm đến ngân sách và họ đang tìm kiếm các khoản giảm giá và giao dịch cũng như sẵn sàng cắt giảm những thứ xa xỉ của mình.

14
00:02:20,340 --> 00:02:33,210
Và đây là những khách hàng được coi là khách hàng quan tâm đến ngân sách.  Thứ ba là các tập đoàn đang sắp xếp các chuyến tham quan theo nhóm cho nhân viên của họ và Acme giảm giá theo nhóm và cung cấp cho họ các dịch vụ chuyên biệt.

15
00:02:33,510 --> 00:02:39,990
Ví dụ: hướng dẫn du lịch.  Loại khách hàng thứ ba này được gọi là các tập đoàn hoặc khách hàng doanh nghiệp.

16
00:02:40,140 --> 00:02:49,100
Đây là ba phân khúc khách hàng của Acme.  Mỗi phân khúc khách hàng này đang tìm kiếm một đề xuất giá trị khác nhau.

17
00:02:49,470 --> 00:02:56,820
Những du khách không gặp rắc rối đang tìm kiếm sự thuận tiện.  Vì vậy Acme đã thiết kế các gói kỳ nghỉ trọn gói.

18
00:02:57,060 --> 00:03:13,910
Vì vậy, đối với họ, sự tiện lợi là đề xuất có giá trị.  Những khách hàng quan tâm đến ngân sách đang tìm kiếm các gói du lịch giá cả phải chăng và vì vậy Acme cung cấp cho họ các gói du lịch có thể tùy chỉnh và đối với họ, giá trị đồng tiền là quan trọng.

19
00:03:14,160 --> 00:03:22,080
Khách hàng doanh nghiệp sắp xếp các kỳ nghỉ theo nhóm cho nhân viên của họ và họ muốn tham gia vào lĩnh vực hậu cần từ Acme.

20
00:03:22,380 --> 00:03:30,650
Vì vậy, giá trị đối với khách hàng doanh nghiệp là dịch vụ hậu cần và kế hoạch được cung cấp bởi hành động thông qua các gói kỳ nghỉ theo nhóm.

21
00:03:31,110 --> 00:03:39,180
Chuyên gia kinh doanh tại Acme đã đề cập rằng gói kỳ nghỉ bao gồm nhiều phần và nó liệt kê tất cả các phần khác nhau.

22
00:03:39,210 --> 00:03:48,530
Điều tôi nhận ra là những bộ phận này có thể được bỏ vào ba thùng.  Đó là vé tàu và vé xe buýt của hãng hàng không, có thể được coi là phương tiện di chuyển.

23
00:03:48,690 --> 00:03:58,620
Phần thứ hai dành cho chỗ ở, khách sạn và Airbnb.  Và phần thứ ba là các chuyến du ngoạn mà Acme cung cấp như một phần của gói kỳ nghỉ.

24
00:03:58,830 --> 00:04:07,650
Vì vậy, đây là những nguồn lực chính cho Acme.  Tiếp theo, hãy đề cập đến các đối tác và nhà cung cấp chính của Acme cho nhu cầu vận chuyển.

25
00:04:07,800 --> 00:04:18,330
Achmea phụ thuộc vào các hãng hàng không, công ty du lịch trên biển, xe buýt và cũng có mối quan hệ kinh doanh với các công ty cho thuê ô tô để cung cấp cho họ hoa hồng hoặc giảm giá.

26
00:04:18,540 --> 00:04:31,740
Akman phụ thuộc vào các khách sạn và Airbnb để có chỗ ở và các chuyến du ngoạn.  Acme đã thiết lập mối quan hệ với nhiều công ty lữ hành trên khắp thế giới.

27
00:04:32,160 --> 00:04:42,240
Giống như các doanh nghiệp khác, Acme tham gia vào nhiều hoạt động chính. Để thành công, Acme cần hiểu sở thích của khách hàng và sản phẩm.

28
00:04:42,360 --> 00:04:51,930
ACMC thực hiện nghiên cứu thị trường.  Achmea thường xuyên thực hiện các chiến dịch tiếp thị nên quản lý chiến dịch là một hoạt động quan trọng khác.

29
00:04:51,930 --> 00:05:02,040
Để Acme có lãi, Ackman cần đàm phán hợp đồng tối ưu với các nhà cung cấp của mình.  Vì vậy đàm phán hợp đồng là hoạt động chủ chốt của Acme.

30
00:05:02,160 --> 00:05:10,110
Để cạnh tranh trên thị trường, Ackman phải tạo ra các gói kỳ nghỉ thật hấp dẫn đối với khách hàng của mình.

31
00:05:10,110 --> 00:05:21,330
Vì vậy, thiết kế sản phẩm hay thiết kế gói kỳ nghỉ cũng là một hoạt động quan trọng khác mà các chuyên gia tại Acme tham gia, mặc dù những năm qua họ không dành nhiều công sức cho công nghệ.

32
00:05:21,630 --> 00:05:36,720
Nhưng với sự ủy quyền gần đây của CTO và Giám đốc điều hành của công ty, các chuyên gia tại Acme đã bắt đầu dành ngày càng nhiều thời gian và nỗ lực để tìm hiểu cách Ackman có thể tận dụng công nghệ để trở nên cạnh tranh và sinh lời nhiều hơn.

33
00:05:37,080 --> 00:05:46,320
Tiếp theo, hãy nói về mối quan hệ khách hàng.  Achmat cung cấp hỗ trợ 24/7 cho khách hàng của mình qua điện thoại, email và tin nhắn văn bản.

34
00:05:46,530 --> 00:05:53,140
Đôi khi các đối tác của ACMS không mang lại trải nghiệm tốt nhất cho khách hàng và điều đó dẫn đến xung đột.

35
00:05:53,370 --> 00:06:02,340
Acne bảo vệ khách hàng của mình bằng cách giúp giải quyết xung đột.  Họ làm việc trực tiếp với các nhà cung cấp hoặc đối tác của họ.

36
00:06:02,340 --> 00:06:10,230
Với tư cách là người ủng hộ khách hàng, Achmat khuyến khích khách hàng đưa ra phản hồi trong và sau kỳ nghỉ.

37
00:06:10,260 --> 00:06:23,400
Achmat rất coi trọng phản hồi này và hành động dựa trên phản hồi đó bất cứ khi nào có thể.  Mảng kinh doanh lớn nhất của ACMC đến từ các đại lý du lịch bán các gói kỳ nghỉ cho khách hàng và các tập đoàn.

38
00:06:23,550 --> 00:06:38,370
Thật không may, việc kinh doanh đại lý du lịch đang suy giảm do sở thích của khách hàng đang thay đổi.  Doanh số bán hàng trực tiếp chiếm khoảng 35% doanh thu của Acme và mục tiêu là tăng lên 55% trong hai năm tới.

39
00:06:38,370 --> 00:06:48,810
Với sự trợ giúp của công nghệ, các đối thủ cạnh tranh thương mại điện tử đã bắt đầu sử dụng các đối tác liên kết, trong khi Acme vẫn chưa thể sử dụng hiệu quả các đối tác liên kết và.

40
00:06:48,870 --> 00:07:02,730
Đây được coi là cơ hội lớn để các Câu lạc bộ Bán buôn Acme không cung cấp nhiều hoạt động kinh doanh cho Acme vì họ yêu cầu Acme phải sẵn sàng tích hợp với một số công nghệ nhất định.

41
00:07:02,940 --> 00:07:11,310
Và Acme đang tụt hậu trong việc áp dụng công nghệ.  Tuy nhiên, một phần hoạt động kinh doanh của ACMS vẫn đến từ các câu lạc bộ bán buôn.

42
00:07:11,700 --> 00:07:20,220
Về cơ bản, Achmea kiếm tiền theo ba cách.  Lần đầu tiên họ nhận được hoa hồng từ các đối tác và nhà cung cấp khác nhau.

43
00:07:20,310 --> 00:07:30,080
Cách thứ hai là đánh dấu các dịch vụ của nhà cung cấp, và cách thứ ba là đánh dấu các gói kỳ nghỉ mà Achmat thiết kế.

44
00:07:30,080 --> 00:07:45,420
Vì vậy, ba yếu tố này đại diện cho nguồn tiền vào của Acme.  Acme liên tục thực hiện các chiến dịch tiếp thị và để làm được điều đó họ phải chi một khoản tiền lớn giống như Acme nhận được hoa hồng từ các đối tác và nhà cung cấp của mình.

45
00:07:45,610 --> 00:07:59,310
Nó cũng phải trả tiền hoa hồng cho đối tác bán hàng của mình.  Tất cả công nghệ không phải là trọng tâm lớn đối với Ackman, nhưng gần đây hãng đã bắt đầu chi một khoản đáng kể cho công nghệ.

46
00:07:59,670 --> 00:08:06,960
Cuối cùng nhưng không kém phần quan trọng, tiền lương nhân viên và hoa hồng cho chuyên gia du lịch cũng là một khoản chi lớn khác đối với Acme.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\001 Introduction to DDD and Patterns.en.srt -->

1

00:00:00,200 --> 00:00:07,140

Demand-Driven Design is an architectural approach that provides principles and patterns to address the



2

00:00:07,140 --> 00:00:14,490

challenges faced with developing complex domain models that own domain driven design was coined by Eric



3

00:00:14,490 --> 00:00:21,230

Events and his book, Domain Driven Design, Domain driven design emphasis is on the fact that the itte



4

00:00:21,270 --> 00:00:27,930

project primary focus should be on the business domain and business logic rather than technology.



5

00:00:28,050 --> 00:00:34,590

It promotes the idea of breaking the unified model into smaller, more manageable models.



6

00:00:34,590 --> 00:00:41,490

And it suggests the use of our creative process for improving the model to solve our domain problem



7

00:00:42,090 --> 00:00:42,510

domain.



8

00:00:42,510 --> 00:00:45,390

Rehren design offers two types of patterns.



9

00:00:45,390 --> 00:00:52,230

Strategic patterns are used for dividing a complex and large business problem into smaller chunks with



10

00:00:52,230 --> 00:00:53,490

well-defined boundaries.



11

00:00:53,490 --> 00:01:01,050

Technical patterns are used for translating the conceptual models to software application and service



12

00:01:01,050 --> 00:01:01,590

designs.



13

00:01:01,890 --> 00:01:09,360

The strategic pattern applies across multiple bounded contexts, whereas technical patterns are applicable



14

00:01:09,360 --> 00:01:11,770

only within a bounded context.



15

00:01:11,790 --> 00:01:17,630

This will become clear as you will gain more understanding of the strategic and tactical patterns.



16

00:01:17,880 --> 00:01:24,060

These are domain driven design strategic patterns in the section we will be covering the bounded context



17

00:01:24,060 --> 00:01:27,140

partan and the ubiquitous language pattern.



18

00:01:27,570 --> 00:01:33,390

So the question you may be asking is how is the domain different design related to micro services?



19

00:01:33,720 --> 00:01:40,350

The idea is that domain driven design approach leads to smaller independent domain models that can be



20

00:01:40,350 --> 00:01:48,450

built as highly decoupled and independent set of micro services so that the strategic pattern we are



21

00:01:48,450 --> 00:01:51,960

identifying the boundaries for the micro services.



22

00:01:52,920 --> 00:01:58,770

Let's go over the section objectives by the end of the section, you should be able to identify and



23

00:01:58,770 --> 00:02:02,000

categorize the subdomains in a business domain.



24

00:02:02,400 --> 00:02:06,200

You know why understanding the business context is important.



25

00:02:06,600 --> 00:02:11,820

You should be able to describe the domain driven design, strategic partners, ubiquitous language and



26

00:02:11,820 --> 00:02:12,690

bounded context.



27

00:02:13,080 --> 00:02:19,350

And you will also be able to describe the process that may be used for discovering the bonded contacts



28

00:02:19,350 --> 00:02:20,070

in a domain.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\002 Business Subdomain Types.en.srt -->

1

00:00:00,210 --> 00:00:07,680

SubDomains, a business domain, is composed of multiple subdomains, there are three types of subdomains,



2

00:00:07,680 --> 00:00:13,760

the type depends on the value a subdomain generates for the business and its leader.



3

00:00:13,860 --> 00:00:20,460

Having an understanding of the type of subdomains is in a position to assist the business in making



4

00:00:20,460 --> 00:00:24,570

the build versus buy decisions for the technology solutions.



5

00:00:24,870 --> 00:00:29,250

Businesses need to perform multiple different functions to operate.



6

00:00:29,280 --> 00:00:33,330

These functions are performed in the purview of subdomains.



7

00:00:33,330 --> 00:00:37,220

For the banking example, we've already seen many such subdomains.



8

00:00:37,230 --> 00:00:44,130

One important point to note is that this is a very high level generic view of how the bank subdomains



9

00:00:44,250 --> 00:00:45,000

look like.



10

00:00:45,000 --> 00:00:49,110

But each bank may view their enterprise in a different way.



11

00:00:49,110 --> 00:00:55,950

From the subdomains perspective, what are the most common reason is that businesses may not operate



12

00:00:55,950 --> 00:01:01,440

at all subdomains in that overarching domain or the industry, for example, bank.



13

00:01:01,440 --> 00:01:04,860

It may offer only retail accounts to their customers.



14

00:01:04,860 --> 00:01:10,020

The retail accounts are like checking account or the savings account, whereas Bank B deals only with



15

00:01:10,020 --> 00:01:12,390

the credit card and merchant services.



16

00:01:12,420 --> 00:01:17,780

As a result, the subdomains structure for the bank here and Bank B will look different.



17

00:01:18,120 --> 00:01:24,960

Now, if you think about it, these subdomains may be further divided into smaller subdomains and this



18

00:01:24,960 --> 00:01:28,410

is what I refer to as the subdomain granularity.



19

00:01:28,410 --> 00:01:31,080

And it depends on the focus of the business.



20

00:01:31,080 --> 00:01:38,970

For example, a bank that deals only with retail accounts may decide to break this retail account subdomain



21

00:01:39,090 --> 00:01:45,420

into multiple subdomains such as saving accounts, checking accounts, certificates of deposit, etc..



22

00:01:45,420 --> 00:01:50,880

So at the end of the day, each bank, depending on their focus, may view the enterprise as composed



23

00:01:50,880 --> 00:01:56,490

of different subdomains under the purview of which they perform their business operations.



24

00:01:56,910 --> 00:02:01,940

Each subdomain has a different level of complexity associated with it.



25

00:02:02,370 --> 00:02:07,560

There are multiple factors that may be contributing toward the complexity of the subdomain.



26

00:02:07,860 --> 00:02:10,050

Alcoa, some of the common reasons.



27

00:02:10,470 --> 00:02:14,910

The most common reason is the complexity of the business rules itself.



28

00:02:14,910 --> 00:02:17,460

The next one is the compliance aspect.



29

00:02:17,460 --> 00:02:24,750

If the subdomain is operating in a highly regulated environment, then that will add complexity to the



30

00:02:24,750 --> 00:02:25,380

subdomain.



31

00:02:25,380 --> 00:02:32,670

Complex calculations or complex algorithms may require specialized skills or specialized knowledge to



32

00:02:32,670 --> 00:02:36,540

understand the subdomain, and that adds to the complexity.



33

00:02:36,560 --> 00:02:43,230

The next one is the processes, and the handle was required between the subdomain and other subdomains



34

00:02:43,230 --> 00:02:49,230

or even external entities will also contribute toward the complexity of the subdomain dunamis.



35

00:02:49,230 --> 00:02:50,370

It is an interesting one.



36

00:02:50,400 --> 00:02:58,020

The idea here is that if the subdomain requires changes to processes, rules, structures or any other



37

00:02:58,020 --> 00:03:04,410

aspect, then it'll be difficult to manage the knowledge and understanding of the domain as it is changing



38

00:03:04,410 --> 00:03:07,590

with time, not depending on the business, depending on the industry.



39

00:03:07,770 --> 00:03:12,930

There may be other factors that will contribute to the complexity of the subdomain.



40

00:03:12,960 --> 00:03:20,100

The subdomains can be categorized into three categories, and the category in which the subdomain falls



41

00:03:20,400 --> 00:03:26,460

is decided by subdomains, complexity and the business value, it adds.



42

00:03:26,460 --> 00:03:32,790

These three types are the generic subdomain, the core subdomain and the supporting subdomain.



43

00:03:32,910 --> 00:03:35,430

Let's go to the details of each one of these.



44

00:03:35,610 --> 00:03:41,700

Generic subdomains are characterized by the fact that there are no one solution that exists for such



45

00:03:41,700 --> 00:03:42,540

subdomains.



46

00:03:42,570 --> 00:03:48,660

There's nothing special about these subdomains and best practices are readily available for these domains.



47

00:03:49,020 --> 00:03:56,550

Business cannot achieve any kind of competitive edge by doing things differently within the generic



48

00:03:56,560 --> 00:03:57,300

subdomain.



49

00:03:57,330 --> 00:04:02,280

Examples of such subdomains are the human resources and facilities management.



50

00:04:02,280 --> 00:04:08,610

So no matter which industry or which business we are referring to, human resources practices and facilities



51

00:04:08,610 --> 00:04:15,150

management practices are quite mature and does not add any kind of differentiating value for the business.



52

00:04:15,310 --> 00:04:18,840

Core subdomain is the differentiator for the business.



53

00:04:18,840 --> 00:04:26,220

Each business within a specific industry operate differently within the core subdomains to gain some



54

00:04:26,220 --> 00:04:28,950

kind of advantage over their competition.



55

00:04:29,070 --> 00:04:34,800

Typically, it is said that the secret sauce for the business resides in the core subdomain and the



56

00:04:34,800 --> 00:04:41,340

business is always looking to carry out things differently in these core subdomains to get some kind



57

00:04:41,340 --> 00:04:43,170

of competitive advantage.



58

00:04:43,290 --> 00:04:50,760

Depending on the industry and the environment, these core subdomains may evolve at a very rapid pace



59

00:04:50,760 --> 00:04:54,420

or may have a very high level of dynamic city examples.



60

00:04:54,420 --> 00:04:59,880

Of course, subdomains are the manufacturing subdomain within the auto industry.



61

00:05:00,050 --> 00:05:06,620

Auto manufacturers are looking to do things differently within these manufacturing subdomains to gain



62

00:05:06,620 --> 00:05:13,400

some kind of a competitive edge or to achieve high levels of cost savings, which again translates into



63

00:05:13,400 --> 00:05:16,020

value for the business in the banking industry.



64

00:05:16,190 --> 00:05:21,740

Think of the credit cards, each bank offering credit cards to the consumers for a different kind of



65

00:05:21,740 --> 00:05:27,350

benefits and may operate the credit card business differently to achieve some kind of advantage.



66

00:05:27,770 --> 00:05:29,470

Time for a quick exercise.



67

00:05:29,900 --> 00:05:36,680

Take a look at the subdomains for bank and subdomains for Bank B, identify the differentiators for



68

00:05:36,680 --> 00:05:37,350

the two bank.



69

00:05:37,520 --> 00:05:39,740

Go ahead, post a video for a few seconds.



70

00:05:39,950 --> 00:05:40,930

Answer the question.



71

00:05:41,660 --> 00:05:48,740

The first differentiator is in the products the two banks offer bank offers, retail accounts, credit



72

00:05:48,740 --> 00:05:54,500

card and merchant services, whereas Bank B offers retail account and mortgage services.



73

00:05:54,770 --> 00:06:01,700

The second differentiator is the fact that Bank and Bank B may be operating the retail account differently.



74

00:06:01,700 --> 00:06:06,370

So the bottom line is that both have the retail account as their core domains.



75

00:06:06,500 --> 00:06:14,090

They may be differentiating themselves by operating differently in the retail account subdomain supporting



76

00:06:14,090 --> 00:06:17,360

subdomains to not provide any direct business advantage.



77

00:06:17,720 --> 00:06:22,070

But the core subdomains depend on the supporting subdomains.



78

00:06:22,220 --> 00:06:28,310

There are well-known practices available for the supporting subdomains, but solutions may not be readily



79

00:06:28,310 --> 00:06:28,960

available.



80

00:06:29,060 --> 00:06:35,780

And even if the solutions are available, those solutions may need to be customized to meet the needs



81

00:06:35,780 --> 00:06:37,340

of the code subdomain.



82

00:06:37,370 --> 00:06:44,140

Typically, the supporting subdomain does not have high levels of complexity in terms of business logic,



83

00:06:44,150 --> 00:06:48,640

examples of supporting subdomain or customer support and compliance.



84

00:06:48,650 --> 00:06:54,770

The core subdomain in a bank heavily dependent on the customer support, subdomain and the compliance



85

00:06:54,770 --> 00:06:58,310

subdomain to identify the type of the subdomain.



86

00:06:58,440 --> 00:07:02,780

You must start by looking at the business capabilities in that subdomain.



87

00:07:02,810 --> 00:07:06,560

Are there any known solutions available for that subdomain?



88

00:07:06,650 --> 00:07:11,510

And if the answer is yes, then the subdomain is likely to be genetic.



89

00:07:11,690 --> 00:07:16,460

Otherwise you need to check if the subdomain adds any business value.



90

00:07:16,460 --> 00:07:22,760

For example, is there an opportunity for the business to differentiate itself from its competitors



91

00:07:22,970 --> 00:07:26,300

by doing things differently within this subdomain?



92

00:07:26,310 --> 00:07:33,290

And if the answer is no, then the next check is to see if the core subdomains depend on this subdomain.



93

00:07:33,290 --> 00:07:37,520

And that answer is yes, then it is likely to be a supporting subdomain.



94

00:07:37,790 --> 00:07:43,340

And if the answer is no, then it is a generic subdomain wherein you may need to build a solution.



95

00:07:43,430 --> 00:07:49,850

If the subdomain has the potential of adding some business value, then the next check is to see if



96

00:07:49,850 --> 00:07:51,920

the business domain has high complexity.



97

00:07:52,010 --> 00:07:58,310

If the business domain does not have high level of complexity, then it is likely to be supporting subdomain.



98

00:07:58,430 --> 00:08:01,100

Otherwise it is likely to be a course of domain.



99

00:08:01,190 --> 00:08:05,930

My suggestion to you would be to post a video and go through this chart on your own.



100

00:08:06,290 --> 00:08:11,600

One obvious question that may be coming to your mind at this point is why do we need to categorize the



101

00:08:11,600 --> 00:08:12,350

subdomains?



102

00:08:12,800 --> 00:08:14,300

There are multiple reasons.



103

00:08:14,310 --> 00:08:21,290

The first one is that businesses have limited resources and these resources here are referring to the



104

00:08:21,440 --> 00:08:27,590

human resources, as well as the money put aside for the various initiatives across the enterprise.



105

00:08:27,880 --> 00:08:33,680

Categorization of the subdomains helps in prioritization of the various initiatives.



106

00:08:34,010 --> 00:08:36,710

Second reason is the return on investment.



107

00:08:37,010 --> 00:08:41,180

Businesses would like to maximize the return on the investments.



108

00:08:41,300 --> 00:08:46,910

As a result, preference will be given to the initiatives related to core subdomains, which will lead



109

00:08:46,910 --> 00:08:50,030

to the maximization of the return on investment.



110

00:08:50,090 --> 00:08:57,110

The third reason is that categorization of the subdomain helps the business in making the buy what build



111

00:08:57,110 --> 00:08:57,720

decisions.



112

00:08:57,740 --> 00:08:59,390

Let's dig a little deeper.



113

00:08:59,390 --> 00:09:06,410

If the subdomain is a generic subdomain, that business would buy it a solution rather than building.



114

00:09:06,410 --> 00:09:12,320

Examples of such solutions are the enterprise resource planning software such as SAP.



115

00:09:12,320 --> 00:09:15,470

And what if the subdomain is supporting subdomain?



116

00:09:15,560 --> 00:09:23,510

Then the business may decide to build a solution by way of outsourcing, or they may buy a generic solution



117

00:09:23,510 --> 00:09:26,780

and customize it to meet the needs of their code.



118

00:09:26,780 --> 00:09:30,560

To be an example of such a solution will be Salesforce.



119

00:09:30,680 --> 00:09:37,940

If the subdomain is categorized as code, then the business will use its best teams and best talent



120

00:09:38,210 --> 00:09:40,910

to build a solution in this subdomain.



121

00:09:41,750 --> 00:09:44,300

Let's call with a key point from this lesson.



122

00:09:44,300 --> 00:09:47,630

The first one is that there are three types of subdomains.



123

00:09:48,080 --> 00:09:55,070

The generic subdomain has readily available solutions that the business can buy because of domain is



124

00:09:55,070 --> 00:09:59,690

the subdomain where the business has the opportunity to define.



125

00:09:59,840 --> 00:10:06,950

Insured itself from its competitors, supporting subdomain is needed because the core subdomains depend



126

00:10:06,980 --> 00:10:13,340

on the supporting subdomains, capitalization of the subdomains held the business in making the build



127

00:10:13,340 --> 00:10:14,930

versus buy decisions.



128

00:10:14,930 --> 00:10:20,080

And the business gets the most return on investment by investing in the solutions.



129

00:10:20,090 --> 00:10:27,080

In the course of typically, the business will use its best talent and resources for building the solutions



130

00:10:27,080 --> 00:10:28,470

in the core subdomain.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\003 Exercise _ ACME Subdomain Type Assignment.en.srt -->

1

00:00:00,150 --> 00:00:06,990

In this exercise, I'll provide you some information on ACMS subdomain, and you will need to identify



2

00:00:07,200 --> 00:00:09,150

the type of that subdomain.



3

00:00:09,660 --> 00:00:16,830

The objective of this exercise is to assign a category for each of the subdomains, for ACMC covered,



4

00:00:17,250 --> 00:00:24,340

subdomains are given and we need to put them in genetic supporting and the course of domain categories.



5

00:00:24,660 --> 00:00:29,820

Now, you may be thinking that you will need some more information about each of these subdomains to



6

00:00:29,820 --> 00:00:34,050

categorize them, and that's where we'll take John's help.



7

00:00:34,140 --> 00:00:38,190

John is a business subject matter expert at Acme.



8

00:00:38,340 --> 00:00:45,660

He will provide us some information on each of these subdomains so that we can categorize these subdomains



9

00:00:45,660 --> 00:00:47,430

under appropriate categories.



10

00:00:47,940 --> 00:00:53,760

Let's start with the product management and the accounting subdomain product at Acme refers to the vacation



11

00:00:53,760 --> 00:00:54,390

package.



12

00:00:54,390 --> 00:01:00,630

And this is where Acme spends most of its time thinking about products that are better than their competitors



13

00:01:00,630 --> 00:01:01,510

for accounting.



14

00:01:01,560 --> 00:01:07,470

What John has told us is that Achmat follows the general accounting practices and there's nothing different



15

00:01:07,470 --> 00:01:12,310

from others except that there may be a few rules of thumb that makes Acme different.



16

00:01:12,480 --> 00:01:15,350

So what do you think product management and accounting do?



17

00:01:15,360 --> 00:01:22,020

The full court supporting or genetic subdomains pause the video, give it some thought and put the answers



18

00:01:22,020 --> 00:01:22,890

on a piece of paper.



19

00:01:22,920 --> 00:01:27,640

Next, I'll discuss where I think these two belong for product management.



20

00:01:27,670 --> 00:01:33,570

John mentioned that Acme is always looking at creating vacation packages of product better than its



21

00:01:33,570 --> 00:01:34,230

competitors.



22

00:01:34,230 --> 00:01:40,830

So obviously product management is a space where Acme can do things differently than their competitors



23

00:01:40,830 --> 00:01:42,990

and gain competitive advantage.



24

00:01:43,170 --> 00:01:46,470

Hence it'll fall under the course category accounting.



25

00:01:46,510 --> 00:01:51,240

John mentioned there's nothing special about it, and Ackman follows general accounting practices.



26

00:01:51,240 --> 00:01:57,580

So I'll place it under the generic subdomain next to the customer support and partner management.



27

00:01:57,600 --> 00:02:03,030

What John is telling us about customer support is that Achmea provides the best customer support in



28

00:02:03,030 --> 00:02:06,300

the industry to sustain competitive advantage.



29

00:02:06,300 --> 00:02:10,110

And there are many tools available to build customer support function.



30

00:02:10,110 --> 00:02:16,140

And Acme is always looking to improve this function somehow from the proper management perspective.



31

00:02:16,170 --> 00:02:22,410

John is saying that partners are Rachman's lifeline, and Achmea would like to ensure that the partners



32

00:02:22,410 --> 00:02:22,960

are happy.



33

00:02:23,490 --> 00:02:29,700

The challenge with partner management is that the contracts are very complex due to multiple business



34

00:02:29,700 --> 00:02:30,090

rules.



35

00:02:30,510 --> 00:02:31,560

So what do you think?



36

00:02:31,560 --> 00:02:33,950

Customer support and partner management?



37

00:02:34,230 --> 00:02:37,100

What is the category for each of these positivist?



38

00:02:37,110 --> 00:02:42,430

You write down your answers and then I'll discuss my thoughts for customer support.



39

00:02:42,450 --> 00:02:45,630

John mentioned a few things that made it a little confusing for me.



40

00:02:45,690 --> 00:02:51,270

You mentioned that customer support differentiates Acme from its competitors, but at the same time,



41

00:02:51,510 --> 00:02:57,570

he has mentioned that there are tools available for customer support so it can either go into court



42

00:02:57,570 --> 00:02:58,740

or the supporting domain.



43

00:02:58,740 --> 00:03:04,020

Since we are not sure at this time, I'll place it somewhere between the two and as we will learn more



44

00:03:04,020 --> 00:03:08,760

about that, will place it either in court or supporting for partner management.



45

00:03:08,790 --> 00:03:15,450

John indicated that ACMC cannot survive without its partners and they seem to be complex contracts between



46

00:03:15,480 --> 00:03:17,120

Acme and its partners.



47

00:03:17,550 --> 00:03:24,030

So I'll place it under the core subdomain category next to all the sales channels and human resources.



48

00:03:24,030 --> 00:03:30,750

Sales channels are the way by which Acme sells its products to the consumers, for example, direct



49

00:03:30,750 --> 00:03:32,790

sales and travel agents, etc..



50

00:03:32,970 --> 00:03:39,990

The sales teams are always looking for creative ways to sell Acme products and for human resources.



51

00:03:39,990 --> 00:03:44,960

John has very conveniently mentioned to us that the management team know what they're doing.



52

00:03:44,970 --> 00:03:45,770

They are the best.



53

00:03:45,780 --> 00:03:47,070

So what do you think?



54

00:03:47,070 --> 00:03:49,200

Sales channel and human resources?



55

00:03:49,560 --> 00:03:55,920

My thought is that the sales channel should go under the core category as Acme sales team are always



56

00:03:55,920 --> 00:03:59,990

looking for creative ways to sell their product and human resources.



57

00:04:00,000 --> 00:04:07,530

Clearly it is a generic subdomain, as H.R. practices at Acme are quite mature at this time and there



58

00:04:07,530 --> 00:04:10,640

seem to be no complexity for the marketing subdomain.



59

00:04:10,680 --> 00:04:16,890

What John is telling us is that campaigns are managed by the marketing team and the sales and product



60

00:04:16,890 --> 00:04:23,370

management team need to adjust to these campaigns based on the information they receive from marketing.



61

00:04:23,670 --> 00:04:30,130

This kind of indicates that sales and product management has some kind of a dependency on marketing.



62

00:04:30,300 --> 00:04:31,040

What do you think?



63

00:04:31,590 --> 00:04:32,700

So one thing is clear.



64

00:04:32,700 --> 00:04:39,330

Marketing will differentiate Acme from its competitors, but at the same time, marketing doesn't seem



65

00:04:39,330 --> 00:04:40,260

to be complex.



66

00:04:40,440 --> 00:04:46,160

But the product management and the sales channel function depends on marketing.



67

00:04:46,500 --> 00:04:49,980

So all place marketing under the supporting category.



68

00:04:50,100 --> 00:04:56,550

And this is the final distribution of achmea subdomains under the three categories.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\004 Understanding the Business Context.en.srt -->

1

00:00:00,500 --> 00:00:06,230

Business context, by the end of this lecture, you should be able to explain what is context, what



2

00:00:06,230 --> 00:00:13,190

is business context and why is it important for I.T. teams to understand the business context?



3

00:00:13,670 --> 00:00:14,860

Let's start with a question.



4

00:00:14,960 --> 00:00:21,230

Let's say you meet with a person and his name is Jack and Jack, ask you, should I prefer an account



5

00:00:21,230 --> 00:00:25,730

with high interest rate or should I prefer an account with low interest rate?



6

00:00:26,060 --> 00:00:31,240

And at this point, you need to answer the question that'll help Jack make a decision.



7

00:00:31,880 --> 00:00:33,770

What would you tell Jack to do?



8

00:00:34,760 --> 00:00:39,640

The interesting part about this exercise is that both the options are good.



9

00:00:39,650 --> 00:00:46,160

For example, if Jack is asking you this question because he wants to open a savings account, then



10

00:00:46,160 --> 00:00:47,900

option number one is good.



11

00:00:48,140 --> 00:00:55,160

That is, he should prefer a savings account with high interest rate, whereas if Jack is in the market



12

00:00:55,160 --> 00:01:03,770

to open a credit card account, then he should go for the second option, as low interest rate would



13

00:01:03,770 --> 00:01:10,030

mean that he will have to pay less to the credit card company in terms of the interest on the principal.



14

00:01:10,310 --> 00:01:16,970

So the reason I ask you this question is to talk about the fact that to make an objective decision,



15

00:01:17,150 --> 00:01:21,230

you will need additional facts or information on the situation.



16

00:01:21,620 --> 00:01:23,720

That is, you will need the context.



17

00:01:23,930 --> 00:01:26,360

Why is Jack asking this question?



18

00:01:26,540 --> 00:01:27,800

What is his intent?



19

00:01:28,130 --> 00:01:31,190

What type of an account is Jack planning to open?



20

00:01:31,490 --> 00:01:35,440

That is what you need in order to help him make a decision.



21

00:01:36,200 --> 00:01:43,730

The dictionary definition of context is it is these circumstances or facts that form the setting for



22

00:01:43,730 --> 00:01:46,340

a statement even or an idea?



23

00:01:46,790 --> 00:01:48,410

Let's revisit the question again.



24

00:01:48,710 --> 00:01:50,540

But this time we have the context.



25

00:01:50,660 --> 00:01:54,860

Jack is looking to borrow money from the bank in this case.



26

00:01:55,040 --> 00:01:56,080

What would you tell him?



27

00:01:56,420 --> 00:02:02,930

Obviously, this time you are in a position to guide Jack with a high level of confidence and you will



28

00:02:02,930 --> 00:02:06,770

tell him that he should prefer an account with low interest rate.



29

00:02:06,860 --> 00:02:11,210

Now, you must be wondering, how does this relate to a business situation?



30

00:02:11,630 --> 00:02:18,590

The idea is that as an IT team, you and your colleagues will be carrying out knowledge crunching exercise.



31

00:02:18,890 --> 00:02:25,760

And to carry out this knowledge crunching exercises in a business setup, you must be aware of the business



32

00:02:25,760 --> 00:02:26,390

context.



33

00:02:26,390 --> 00:02:32,480

In the case of a bank offering these products, there are multiple contacts and the IT teams must be



34

00:02:32,480 --> 00:02:39,800

mindful of the context as they interpret the information and knowledge gathered for each of these contacts



35

00:02:39,800 --> 00:02:40,580

or products.



36

00:02:40,910 --> 00:02:47,090

The key point here is that in order for the I.T. teams to understand the business domain, they must



37

00:02:47,090 --> 00:02:49,460

first understand the business context.



38

00:02:49,730 --> 00:02:55,430

It is an example of the credit cards, let's say the SMB or the subject matter.



39

00:02:55,430 --> 00:03:02,270

Experts say something like this funds received from the customer are credited to customers account.



40

00:03:02,420 --> 00:03:09,550

The I.T. team having an understanding of the credit cards context, will be able to interpret it as



41

00:03:09,560 --> 00:03:16,010

customer pays the credit card bill and they may come up with the use case model that may have a use



42

00:03:16,010 --> 00:03:19,060

case for pay bill and update account.



43

00:03:19,790 --> 00:03:26,780

Now, let's say that the I.T. team is having a meeting with the SME in the savings account team.



44

00:03:27,140 --> 00:03:28,280

No savings account.



45

00:03:28,280 --> 00:03:30,500

SME makes the same statement.



46

00:03:30,680 --> 00:03:34,310

Funds received from the customer are credited to customer's account.



47

00:03:34,700 --> 00:03:42,170

Now, since the team is aware of the business contact, which is the saving account in this case, they



48

00:03:42,170 --> 00:03:44,660

will interpret the statement differently.



49

00:03:44,840 --> 00:03:51,110

Customer deposit funds to the savings account and they will come up with a use case model, which will



50

00:03:51,110 --> 00:03:55,100

look different from the use case model for the credit card payments.



51

00:03:55,460 --> 00:04:02,390

Now, if you're thinking why I'm putting so much emphasis on business contacts, it is because lack



52

00:04:02,390 --> 00:04:09,260

of understanding of the business contacts may lead to confusion and misinterpretations, and that will



53

00:04:09,260 --> 00:04:13,250

lead to misrepresentation of the domain models.



54

00:04:13,730 --> 00:04:16,280

Time to go with the key learnings from this lesson.



55

00:04:16,280 --> 00:04:24,260

Context is the circumstances or effects that form the setting for statement even, or an idea for understanding



56

00:04:24,260 --> 00:04:25,280

the business domain.



57

00:04:25,310 --> 00:04:31,670

It is a must that the IT team understand the business context without the appropriate understanding



58

00:04:31,670 --> 00:04:33,200

of the business context.



59

00:04:33,230 --> 00:04:39,440

The team may not be able to come up with accurate models representing the business domain.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\005 Business Domain Language.en.srt -->

1

00:00:00,150 --> 00:00:07,890

Business teams use business language, whereas the technology teams tend to use technical terms in their



2

00:00:07,890 --> 00:00:08,760

communication.



3

00:00:09,000 --> 00:00:16,260

This difference in language between the business teams and the I.T. teams can lead to linguistic challenges.



4

00:00:16,260 --> 00:00:23,100

Domain driven design suggests use of ubiquitous language to address these linguistic challenges.



5

00:00:23,790 --> 00:00:27,210

I'll start this lesson with a quick fun exercise.



6

00:00:27,570 --> 00:00:30,220

If I say the word tuna, what comes to your mind?



7

00:00:30,780 --> 00:00:36,540

And if you're thinking about fish, you're right, because in Japanese, tuna means large fish.



8

00:00:37,110 --> 00:00:42,960

But if you are in a Spanish speaking country and ask for a tuna, you will not get a fish, but you



9

00:00:42,960 --> 00:00:46,900

will get a cactus because in Spanish, tuna means cactus.



10

00:00:46,950 --> 00:00:48,340

How about pasta?



11

00:00:48,450 --> 00:00:54,420

Now, if you're thinking about some type of noodle, then you're right, because in Italian pasta means



12

00:00:54,510 --> 00:00:54,960

noodle.



13

00:00:55,120 --> 00:01:02,020

But if you ask for pasta in Poland, you will get toothpaste because in Polish, pasta means toothpaste.



14

00:01:02,260 --> 00:01:04,710

No, I'm pretty sure you know the word kiss.



15

00:01:05,010 --> 00:01:09,900

Don't ask for it in Sweden because in Swedish, kess means pee.



16

00:01:10,170 --> 00:01:17,190

The message here is that same tone used in different regions may lead to confusions, and that is true



17

00:01:17,190 --> 00:01:21,850

even for the business language used in multiple domains.



18

00:01:21,990 --> 00:01:28,620

What that means is that if you're using the business terms from one domain in another domain, then



19

00:01:28,620 --> 00:01:31,830

it may lead to confusion and misinterpretations.



20

00:01:32,100 --> 00:01:33,600

Let's dig a little deeper.



21

00:01:34,110 --> 00:01:36,540

Each industry has its own lingo.



22

00:01:36,570 --> 00:01:43,030

Bilingual, I mean, a set of terms which the experts in that industry or profession use.



23

00:01:43,590 --> 00:01:47,430

Think about the accountant, an engineer and doctor.



24

00:01:47,460 --> 00:01:52,590

They all use a set of tools that have meaning only in their professions.



25

00:01:52,770 --> 00:01:57,200

In fact, within the same industry, they may be specialisations.



26

00:01:57,210 --> 00:02:03,660

For example, there are many types of accountants that are auditors, management accountant, forensic



27

00:02:03,660 --> 00:02:04,920

accountant and so on.



28

00:02:05,310 --> 00:02:13,230

And each of these different types of specialized accountants have different tomes that may or may not



29

00:02:13,230 --> 00:02:18,790

have a meaning outside of their specialized domain on the same lines.



30

00:02:18,810 --> 00:02:25,380

If you think about an enterprise that has multiple parts or multiple departments or multiple teams,



31

00:02:25,740 --> 00:02:34,080

these teams within the Enterprise have their own lingo and the experts within these teams use the team's



32

00:02:34,080 --> 00:02:36,400

language and all their communication.



33

00:02:36,780 --> 00:02:43,560

Essentially, what that means is that when these saving accounts domain expert will provide the knowledge



34

00:02:43,560 --> 00:02:52,290

or the information to the I.T. expert, they will use the language used in the savings account domain.



35

00:02:52,380 --> 00:03:00,930

Similarly, a domain expert from the credit cards domain will use the credit cards tome's to explain



36

00:03:01,080 --> 00:03:03,650

how the credit cards domain work.



37

00:03:04,200 --> 00:03:10,980

So clearly to understand the domain or to gain knowledge of the domain, one must understand the language



38

00:03:10,980 --> 00:03:13,220

used by the domain experts.



39

00:03:13,230 --> 00:03:14,950

But there are some challenges.



40

00:03:15,570 --> 00:03:17,770

The first challenge is an obvious one.



41

00:03:17,790 --> 00:03:21,060

There are multiple business languages across the enterprise.



42

00:03:21,330 --> 00:03:27,930

In case of a bank, the business team for the savings account may use the terms like credit deposit



43

00:03:27,930 --> 00:03:34,470

withdrawing Dovid, whereas the business team for the credit card may use the terms like credit payment,



44

00:03:34,470 --> 00:03:36,950

merchant cash advances, etc..



45

00:03:37,200 --> 00:03:44,250

The challenge here is that for building complex systems, I.T. teams must learn multiple business languages



46

00:03:44,490 --> 00:03:49,380

used by the experts in the context of different domains or subdomains.



47

00:03:49,440 --> 00:03:55,970

The second challenge is that same term may appear in the context of different business domains.



48

00:03:56,280 --> 00:04:02,250

For example, in the case of savings account and the credit cards subdomain, you will see that there



49

00:04:02,250 --> 00:04:06,810

is a common term credit and the meaning of this common term is different.



50

00:04:06,810 --> 00:04:13,460

Credit in the case of saving accounts may mean deposit by the customer and in the case of credit cards,



51

00:04:13,590 --> 00:04:17,940

it may mean payment made by the customer against a credit card bill.



52

00:04:17,970 --> 00:04:24,270

So the challenge here is that the same time across multiple domains may have a different meaning, depending



53

00:04:24,270 --> 00:04:28,950

on the context, and this can cause a confusion among the items.



54

00:04:29,610 --> 00:04:34,620

The third challenge is related to the fact that it does have their own lingo.



55

00:04:35,220 --> 00:04:42,060

Getters and setters create and delete object DBI and many such other times.



56

00:04:42,210 --> 00:04:49,230

These are the terms that are commonly used for the items, and technology teams tend to translate the



57

00:04:49,560 --> 00:04:53,040

business terms to EITE lingo or items.



58

00:04:53,050 --> 00:04:58,500

And so when they receive the information about the domain or the knowledge about the domain from the



59

00:04:58,500 --> 00:04:59,760

domain expert in.



60

00:05:00,110 --> 00:05:07,630

Don't they translated into technology terms, in effect, the communication from the domain expert to



61

00:05:07,630 --> 00:05:14,650

the idea what happens in terms of the domain language, whereas the communication from the IP expert



62

00:05:14,950 --> 00:05:19,240

to the domain expert happens in terms of the technology language?



63

00:05:19,450 --> 00:05:21,240

Here is how it may play out.



64

00:05:21,250 --> 00:05:25,990

In the case of our savings account expert discussing how the account is opened.



65

00:05:26,140 --> 00:05:28,610

Wiecek customer's credit card history.



66

00:05:28,630 --> 00:05:36,030

Then we open a savings account for the customer and then deposit the initial amount to customer's account.



67

00:05:36,160 --> 00:05:41,400

The equity may translate it into will call get credit history.



68

00:05:41,590 --> 00:05:49,630

Then we will create the account and database and then we will set the initial amount on the account



69

00:05:49,630 --> 00:05:50,290

object.



70

00:05:50,290 --> 00:05:56,230

As a result, every time the business and the teams communicate, they need to carry out the translation



71

00:05:56,410 --> 00:05:59,760

between the business terms and the items.



72

00:05:59,770 --> 00:06:07,960

And this back and forth translation result in the loss of meaning and confusion between the ID and the



73

00:06:08,080 --> 00:06:09,000

domain teams.



74

00:06:09,220 --> 00:06:13,780

At this point you may be saying, OK, I know the problem tells me the solution.



75

00:06:13,900 --> 00:06:21,250

Domain driven design suggests setting up a common language within each business context, and this language



76

00:06:21,430 --> 00:06:25,640

is used by all stakeholders, including the IT teams.



77

00:06:25,690 --> 00:06:29,650

This language is referred to as the ubiquitous language.



78

00:06:29,830 --> 00:06:34,110

This is one of the strategic patterns in Demand-Driven design.



79

00:06:34,210 --> 00:06:40,780

In later lessons, you will learn the details of ubiquitous language and you will also learn how it



80

00:06:40,780 --> 00:06:47,750

helps in breaking the domain into multiple parts that are suitable for building micro services.



81

00:06:47,770 --> 00:06:50,260

Time to go with the key learnings from this lesson.



82

00:06:50,380 --> 00:06:53,350

I.T. teams must learn business language.



83

00:06:53,350 --> 00:07:00,610

I.T. teams have their own I.T. lingo, and confusion is caused by the translation between the domain



84

00:07:00,760 --> 00:07:07,210

and the IP language domain driven design, such as the creation of a common language that must be used



85

00:07:07,210 --> 00:07:10,500

by all stakeholders, including the IT.



86

00:07:11,110 --> 00:07:14,710

This language is referred to as the ubiquitous language.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\006 Strategic Pattern _ Ubiquitous Language.en.srt -->

1

00:00:00,150 --> 00:00:07,200

In the last lesson, I introduce you to the term ubiquitous language in this lecture, Al Gore, the



2

00:00:07,350 --> 00:00:14,820

characteristics of ubiquitous language discussed how the ubiquitous language is built and managed and



3

00:00:14,820 --> 00:00:17,010

where is the ubiquitous language used.



4

00:00:17,460 --> 00:00:23,850

Ubiquitous language is one of these strategic patterns and domain driven design, the domain driven



5

00:00:23,850 --> 00:00:29,190

design such as setting up a common language within each business context.



6

00:00:29,400 --> 00:00:33,630

And this common language is referred to as the ubiquitous language.



7

00:00:33,810 --> 00:00:38,550

The English meaning of ubiquitous is constantly encountered or seen.



8

00:00:38,790 --> 00:00:45,990

The idea is that ubiquitous language addresses all of the linguistic challenges that I have discussed



9

00:00:46,140 --> 00:00:46,650

earlier.



10

00:00:47,010 --> 00:00:52,980

Ubiquitous language may be thought of as a dialect that is used by the various teams within an organization.



11

00:00:53,340 --> 00:01:00,960

A dialect is defined by the vocabulary, and ubiquitous language has a clear definition of the context



12

00:01:00,960 --> 00:01:04,320

to which the vocabulary or the glossary applies to.



13

00:01:04,530 --> 00:01:11,520

This glossary contains the common terms and acronyms used within the defined context.



14

00:01:11,550 --> 00:01:18,570

Optionally, it may also help example usage for the terms and acronyms, and it may also have references



15

00:01:18,570 --> 00:01:20,660

or links to relevant assets.



16

00:01:21,150 --> 00:01:27,840

At this point, you may say that this looks like Enterprise Business Dictionary and you are right up



17

00:01:27,840 --> 00:01:28,770

to an extent.



18

00:01:28,770 --> 00:01:33,270

It is a dictionary word terms, but there are differences.



19

00:01:33,330 --> 00:01:35,160

Let me explain it with an example.



20

00:01:35,370 --> 00:01:42,120

In one of the lectures I talked about my experience building a unified enterprise business model.



21

00:01:42,510 --> 00:01:46,080

That project also consisted of creating a business dictionary.



22

00:01:46,350 --> 00:01:52,950

And this business dictionary that I created had the terms from across the enterprise, and it also had



23

00:01:53,190 --> 00:01:56,640

and if then else logic for many other items.



24

00:01:56,640 --> 00:02:04,170

And this logic basically guided the user of the dictionary as to what the term means under different



25

00:02:04,170 --> 00:02:04,890

contexts.



26

00:02:05,130 --> 00:02:09,440

And that added complexity to the usage of this business dictionary.



27

00:02:09,750 --> 00:02:16,740

At the end of this project, I handed over this business dictionary to a business analyst who managed



28

00:02:16,740 --> 00:02:19,250

it centrally in an Excel sheet.



29

00:02:19,290 --> 00:02:23,730

You can imagine where this business dictionary went over a period of time.



30

00:02:23,880 --> 00:02:28,040

Ubiquitous language is not created and managed centrally.



31

00:02:28,080 --> 00:02:31,790

There are multiple ubiquitous languages in an organization.



32

00:02:32,100 --> 00:02:38,730

So in the case of bank, there will be a ubiquitous language for savings account and a ubiquitous language



33

00:02:38,730 --> 00:02:45,210

for credit account, and the teams for saving account and the credit card will create and manage these



34

00:02:45,210 --> 00:02:47,560

ubiquitous languages independently.



35

00:02:47,670 --> 00:02:51,840

Let's go with the ubiquitous language comes from the business.



36

00:02:51,840 --> 00:02:58,890

Export uses a language that consists of business terms, whereas the technology expert uses a language



37

00:02:59,070 --> 00:03:01,350

that consists of technical terms.



38

00:03:01,350 --> 00:03:08,070

Ubiquitous language consists of tomes which are commonly used by both business experts and the technology



39

00:03:08,070 --> 00:03:08,610

expert.



40

00:03:08,610 --> 00:03:15,690

And there is a misconception behind the ubiquitous language that it is always the business export defining



41

00:03:15,690 --> 00:03:16,260

the language.



42

00:03:16,620 --> 00:03:18,780

Actually, that is not ubiquitous.



43

00:03:18,780 --> 00:03:21,390

Language is not imposed by the experts.



44

00:03:21,570 --> 00:03:25,230

And not only that, it is not a language used in the industry.



45

00:03:25,230 --> 00:03:32,010

Think of it as a team language, a tribal language that develops or evolves over a period of time by



46

00:03:32,010 --> 00:03:36,750

way of collaboration between the business and the technology experts.



47

00:03:36,750 --> 00:03:42,900

The team creating the ubiquitous language can use multiple techniques, such as drawing process diagrams,



48

00:03:42,900 --> 00:03:46,770

user stories, storyboarding and even storming.



49

00:03:47,130 --> 00:03:50,610

And this leads to the creation of the ubiquitous language.



50

00:03:50,610 --> 00:03:57,360

For that important thing to keep in mind is that creation of the ubiquitous language is not a one time



51

00:03:57,360 --> 00:03:57,720

job.



52

00:03:57,870 --> 00:04:04,590

It is a continuous process as the language takes a while to reach the high level of maturity.



53

00:04:04,830 --> 00:04:11,040

When a common question that comes up at this point is if there are any special tools for creation and



54

00:04:11,040 --> 00:04:14,910

management of ubiquitous language, the short answer is no.



55

00:04:15,300 --> 00:04:22,500

Any tool can be used as long as it'll make the ubiquitous language accessible to all team members.



56

00:04:22,500 --> 00:04:28,920

Collaboration and knowledge sharing tools such as conference and quip are commonly used.



57

00:04:28,980 --> 00:04:33,240

Please note that these are not the only collaboration and knowledge sharing tools.



58

00:04:33,570 --> 00:04:40,710

Any tool available within your organization that will make the ubiquitous language easily accessible



59

00:04:40,710 --> 00:04:42,930

to our team members should be good to go.



60

00:04:43,650 --> 00:04:49,320

Once the team has reached a decent level of maturity for their ubiquitous language, they should start



61

00:04:49,320 --> 00:04:51,000

using it for everything.



62

00:04:51,000 --> 00:04:54,780

And then this language will evolve over a period of time.



63

00:04:54,930 --> 00:04:56,670

Domain experts should use it.



64

00:04:56,670 --> 00:04:59,880

The delivery teams must use it for their day to day common.



65

00:05:00,330 --> 00:05:07,050

And all of the documentation should use ubiquitous language if the team is developing the documentation



66

00:05:07,320 --> 00:05:13,620

and they create a new term or they find a new term, then that term should be added to the ubiquitous



67

00:05:13,620 --> 00:05:15,310

language at the end of the day.



68

00:05:15,330 --> 00:05:22,950

The ubiquitous language should act as a source of truth for all to use by the time the ubiquitous language



69

00:05:22,950 --> 00:05:27,150

should be used in the application code as well as in the testing code.



70

00:05:27,270 --> 00:05:33,780

Last but not least, teams must use the ubiquitous language in all of their conversations.



71

00:05:34,110 --> 00:05:38,050

So at this point you may ask what is the benefit of doing it?



72

00:05:38,490 --> 00:05:45,480

Well, recall the example that I discussed in one of the earlier lectures at the Domain Expert and the



73

00:05:45,510 --> 00:05:49,260

idea experts are working on the designing of the software.



74

00:05:49,710 --> 00:05:55,780

The I.T. expert has to translate the domain language to the I.T. language.



75

00:05:56,280 --> 00:06:01,020

This translation is a big challenge with the use of common language.



76

00:06:01,530 --> 00:06:09,090

This translation is no more needed, as both the experts and the domain experts will use the ubiquitous



77

00:06:09,090 --> 00:06:09,700

language.



78

00:06:09,900 --> 00:06:18,120

So in this example here, a domain expert is explaining how a savings account is open and the I.T. expert



79

00:06:18,270 --> 00:06:25,290

is thinking about the process in terms of the ubiquitous language, which is what the domain expert



80

00:06:25,290 --> 00:06:28,830

is using for explaining the business process.



81

00:06:29,340 --> 00:06:36,570

Things become consistent and easier to follow for both the domain expert as well as the ID expert.



82

00:06:36,840 --> 00:06:44,340

One interesting side effect of the ubiquitous language is that it helps in identifying overlapping contacts.



83

00:06:44,520 --> 00:06:51,930

And what that means is that we can use ubiquitous language to break apart our business contacts into



84

00:06:51,930 --> 00:06:55,260

smaller parts and in domain different design.



85

00:06:55,260 --> 00:07:00,110

These smaller parts of context are referred to as the bonded context.



86

00:07:00,360 --> 00:07:02,350

More on this in later lectures.



87

00:07:02,880 --> 00:07:06,150

In this lesson, you learned about ubiquitous language.



88

00:07:06,630 --> 00:07:08,220

Three key points to keep in mind.



89

00:07:08,220 --> 00:07:11,490

Ubiquitous language evolved over a period of time.



90

00:07:11,760 --> 00:07:19,260

It is not a one time job and it is created by the collaboration between the domain expert and the technology



91

00:07:19,260 --> 00:07:19,800

experts.



92

00:07:19,980 --> 00:07:26,820

Ubiquitous language does not require any special tool you may use any knowledge collaboration platform.



93

00:07:27,090 --> 00:07:33,330

Ubiquitous language must be used in all forms of communications and in the code.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\007 Exercise _ Define ACME's Ubiquitous Language.en.srt -->

1

00:00:00,180 --> 00:00:08,550

The objective of this exercise is to identify the ubiquitous language terms for the sales team and the



2

00:00:08,560 --> 00:00:12,060

ACMS product management team in this exercise.



3

00:00:12,090 --> 00:00:20,490

Let's assume that you as the I.T. lead have already interviewed two of the experts from the Acme business



4

00:00:20,490 --> 00:00:21,140

domains.



5

00:00:21,150 --> 00:00:28,740

John is from the sales team and Paul is a product manager and is part of the product management team.



6

00:00:29,220 --> 00:00:30,970

John is a travel advisor.



7

00:00:31,290 --> 00:00:39,060

He's part of the direct sales team that works directly with the customers to make sales of the vacation



8

00:00:39,060 --> 00:00:39,840

packages.



9

00:00:39,870 --> 00:00:47,190

John understands the customer's needs and based on the customer's desire, budget and other aspects,



10

00:00:47,190 --> 00:00:51,670

help them select the right vacation package offered by Acme.



11

00:00:51,990 --> 00:00:57,600

Now, let's assume that you, as the I.T. lead has already interviewed John and you're captured.



12

00:00:57,930 --> 00:01:01,890

All of the interview details in a transcript at this point.



13

00:01:02,010 --> 00:01:08,290

Your objective is to identify all of the weakness language terms in that transcript.



14

00:01:08,610 --> 00:01:10,280

So here is the transcript.



15

00:01:10,470 --> 00:01:14,930

Please read through this transcript and identify as many terms as possible.



16

00:01:15,300 --> 00:01:16,950

Go ahead, pause the video.



17

00:01:17,190 --> 00:01:21,720

And next, I'll discuss the terms that I have found in this transcript.



18

00:01:23,100 --> 00:01:30,570

OK, let's go to the solution and we'll read through each of these paragraphs and identify the terms



19

00:01:31,320 --> 00:01:31,680

we are in.



20

00:01:31,680 --> 00:01:38,370

The business of selling vacation packages or vacation package is the first on the sale process starts



21

00:01:38,520 --> 00:01:40,080

with a customer calling us.



22

00:01:40,440 --> 00:01:45,570

The second term here is the customer based on the customer's desires.



23

00:01:45,870 --> 00:01:48,800

We select the packages and describe it.



24

00:01:49,140 --> 00:01:55,770

Now, I'm making an assumption here that package refers to the vacation package, so I'm not going to



25

00:01:55,800 --> 00:02:04,650

add a package as another term, but rather in the description for the vacation package.



26

00:02:04,980 --> 00:02:08,880

I'll just say that it is also referred to as package.



27

00:02:09,600 --> 00:02:15,270

If the customer shows interest, we start a proposal for the selected package.



28

00:02:15,270 --> 00:02:18,180

So proposal is another term.



29

00:02:19,230 --> 00:02:27,240

Packages have a suggested retail price, but our product team also puts out offers that we can apply



30

00:02:27,240 --> 00:02:28,350

to the packages.



31

00:02:28,530 --> 00:02:31,020

So offers is another town.



32

00:02:31,560 --> 00:02:36,410

These offers are essentially the discounts based on various criteria.



33

00:02:36,420 --> 00:02:41,070

So just make a note that offers are also known as discounts.



34

00:02:41,430 --> 00:02:45,930

Once the customer commits to the proposal, we gather the package details.



35

00:02:45,930 --> 00:02:47,640

That is passenger detail.



36

00:02:47,650 --> 00:02:53,070

So bags or passengers is another item that we have learned.



37

00:02:53,070 --> 00:03:01,860

All the information is gathered into a purchase order and then we get the payment information and submit



38

00:03:02,070 --> 00:03:03,720

the proposal for reservation.



39

00:03:03,720 --> 00:03:07,670

And if everything goes fine, we receive the booking confirmation.



40

00:03:08,220 --> 00:03:13,830

So these are the terms that I have identified in this transcript.



41

00:03:14,670 --> 00:03:16,560

Paul is a product manager.



42

00:03:16,680 --> 00:03:19,350

He's involved in two key activities.



43

00:03:19,650 --> 00:03:26,540

The first activity is that he is the one responsible for designing the Acme products.



44

00:03:26,730 --> 00:03:31,470

Think of these products as the vacation packages that are sold to the customers.



45

00:03:31,920 --> 00:03:36,900

Second, he's involved in managing the relationship with the partners.



46

00:03:37,200 --> 00:03:41,130

And these key partners are the airlines, cruise liners, etc..



47

00:03:41,610 --> 00:03:50,310

Both these activities have a direct or indirect influence on the revenue streams and hence the profits



48

00:03:50,310 --> 00:03:51,390

at Acme.



49

00:03:51,810 --> 00:03:56,340

So he plays an extremely important role in this exercise.



50

00:03:56,610 --> 00:04:04,980

You will go through the transcript that you have captured as the lead and identify as many ubiquitous



51

00:04:04,980 --> 00:04:07,890

language terms as possible at this time.



52

00:04:08,040 --> 00:04:10,050

Please go ahead and pause the video.



53

00:04:10,170 --> 00:04:12,120

Next, I'll discuss the solution.



54

00:04:12,690 --> 00:04:13,230

All right.



55

00:04:13,230 --> 00:04:15,810

Hopefully you picked up all of the relevant terms.



56

00:04:16,170 --> 00:04:20,670

I'm responsible for the product design and provider relationships.



57

00:04:20,670 --> 00:04:24,540

These products are what customers buy from Acme.



58

00:04:24,660 --> 00:04:28,530

So there are three items here product, provider and customers.



59

00:04:29,190 --> 00:04:33,180

Based on the market research, I pick up the parts of the product.



60

00:04:33,690 --> 00:04:37,290

Sometimes we refer to these products as bundles.



61

00:04:37,650 --> 00:04:39,720

So here is what it is.



62

00:04:40,080 --> 00:04:42,420

Product is also known as Bundle.



63

00:04:42,630 --> 00:04:48,090

There are certain markup guidelines that I need to follow in order to make the product profitable.



64

00:04:48,240 --> 00:04:52,110

Also, I need to take into account the seasonality.



65

00:04:52,110 --> 00:04:57,390

So markup and seasonality are two new terms that we have learned here.



66

00:04:57,780 --> 00:04:59,430

Correct pricing of the bundle.



67

00:05:00,220 --> 00:05:07,940

Careful negotiations with the providers, some providers, such as airlines and hotels, offer us bulk



68

00:05:07,960 --> 00:05:11,040

prices, which are below the market prices.



69

00:05:11,350 --> 00:05:15,220

Some providers prefer to work with us on commissions.



70

00:05:15,760 --> 00:05:22,450

We sign contracts with the providers that the commission structure as well as any penalties and terms.



71

00:05:22,750 --> 00:05:29,250

So in this paragraph, we learn three times while prices, market price and commissions.



72

00:05:29,500 --> 00:05:35,650

So these are the terms that we have learned from Paul, who's from the product management subdomain.



73

00:05:36,680 --> 00:05:42,830

Next, let's do a side by side comparison of the terms that we have identified, the first observation



74

00:05:42,830 --> 00:05:49,850

I have made here is that there is a common term customer which refers to the end customer, and the



75

00:05:49,850 --> 00:05:53,510

same term is being used by both Paul and John.



76

00:05:53,750 --> 00:06:00,510

Another observation I have here is that vacation package and product, also known as Bundall, refer



77

00:06:00,530 --> 00:06:03,800

to a similar concept, but different terms.



78

00:06:03,980 --> 00:06:09,810

Apart from these two terms, there is no overlap in the terms so far.



79

00:06:09,860 --> 00:06:16,670

The reason I'm emphasizing so far is because we have carried out limited analysis as we will start to



80

00:06:16,670 --> 00:06:20,240

dig deeper into Paul and John's respective domains.



81

00:06:20,480 --> 00:06:27,110

We learn more terms and there is a potential of overlap between the new terms that we will learn from



82

00:06:27,110 --> 00:06:27,350

them.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\008 Strategic Pattern _ Bounded Context.en.srt -->

1

00:00:00,180 --> 00:00:07,170

Bonded context in one of the earlier lectures I introduced you to Tom Bodett, context and context is



2

00:00:07,170 --> 00:00:10,490

one of the strategic patterns in domain driven design.



3

00:00:10,740 --> 00:00:18,000

In this lesson, I discussed the challenges associated with the use of a common model across multiple



4

00:00:18,000 --> 00:00:18,870

subdomains.



5

00:00:18,900 --> 00:00:22,370

These common moral challenges are addressed by the blended context.



6

00:00:22,380 --> 00:00:27,540

I discussed the characteristics of bonded context, followed by a discussion on relationship between



7

00:00:27,540 --> 00:00:29,580

the bonded context and domain models.



8

00:00:30,120 --> 00:00:36,380

Business domain models are commonly created by laying out the domain capabilities in the business.



9

00:00:36,750 --> 00:00:43,290

So in the case of banking, there are multiple capabilities such as retail banking, credit card compliance



10

00:00:43,290 --> 00:00:45,040

loans and customer management.



11

00:00:45,060 --> 00:00:49,600

Each of these represent a functional area within a bank.



12

00:00:49,690 --> 00:00:54,860

Traditionally, common models were created for use across the enterprise.



13

00:00:55,050 --> 00:00:56,500

Think about a customer.



14

00:00:56,640 --> 00:00:59,040

Each of these capabilities are functional.



15

00:00:59,040 --> 00:01:03,920

Areas need some kind of a customer representation and technical term.



16

00:01:04,200 --> 00:01:09,360

Think about a customer, class or customer object to create a common domain model.



17

00:01:09,750 --> 00:01:16,740

The technical expert will put together the class definition with multiple attributes, and to do that,



18

00:01:16,740 --> 00:01:24,570

the technical expert will gather the attributes from multiple experts from across these domains, although



19

00:01:24,570 --> 00:01:27,720

the customer object may have multiple attributes.



20

00:01:27,870 --> 00:01:34,680

Each of these capabilities will need only a few of those attributes to manage the model in the long



21

00:01:34,680 --> 00:01:35,060

term.



22

00:01:35,460 --> 00:01:40,200

What other teams will be assigned the ownership for the common model?



23

00:01:40,210 --> 00:01:47,610

And this would lead to a dependency between the teams in other capability or functional areas on the



24

00:01:47,610 --> 00:01:50,000

central theme that will be managing the model.



25

00:01:50,580 --> 00:01:57,420

And this dependency will lead to loss of agility, conflict and complexity, the domain driven design.



26

00:01:57,630 --> 00:02:00,450

And this is the problems with the common domain model.



27

00:02:00,690 --> 00:02:06,600

By breaking the domain into independent parts referred to as the bounded context.



28

00:02:06,870 --> 00:02:14,480

This addresses the inherent complexity in the unified enterprise model or the common models.



29

00:02:15,240 --> 00:02:19,350

There are three key words here independent, bonded and contacts.



30

00:02:19,470 --> 00:02:27,180

You already know the meaning of context bounded here means limited to or within some kind of a boundary,



31

00:02:27,330 --> 00:02:35,100

and the meaning of independent is free from outside control or not dependent on any other entity.



32

00:02:35,670 --> 00:02:37,710

Think of the countries in Europe.



33

00:02:37,740 --> 00:02:43,200

Each of these countries in Europe are independent with well-defined boundaries.



34

00:02:43,590 --> 00:02:50,400

If there is a political change in any country, it does not have a direct impact on other countries.



35

00:02:50,400 --> 00:02:57,150

In Europe, the law is defined in each of these countries are applicable within the boundaries of each



36

00:02:57,150 --> 00:02:58,070

of these countries.



37

00:02:58,350 --> 00:03:03,690

In other words, you cannot code a law for Germany in Russia to justify your case.



38

00:03:03,900 --> 00:03:11,250

And last but not the least, culture, social norms and language within each country are well understood



39

00:03:11,400 --> 00:03:13,620

within the boundaries of that country.



40

00:03:13,930 --> 00:03:19,350

So, for example, if you speak polish within the boundaries of Poland, you will be good.



41

00:03:19,350 --> 00:03:24,360

But if you try to use Polish and let's say France, you will have a tough time.



42

00:03:24,960 --> 00:03:30,900

So each of these countries may be thought of as representing a bonded context in Europe.



43

00:03:31,170 --> 00:03:33,390

All right, enough talk on geography.



44

00:03:33,420 --> 00:03:34,980

Let's get back to business now.



45

00:03:35,250 --> 00:03:42,090

In the case of a bank, these boundaries can be drawn by way of the business domain capabilities.



46

00:03:42,120 --> 00:03:47,970

So we have the bounded contacts here for retail banking, credit card compliance loans and customer



47

00:03:47,970 --> 00:03:48,660

management.



48

00:03:49,290 --> 00:03:54,900

Now, you may say that just trying these boundaries around these capabilities should not be enough.



49

00:03:54,900 --> 00:04:01,380

And you are right, there are certain characteristics that must be met for these bounded capabilities



50

00:04:01,380 --> 00:04:03,900

to be referred to as the bounded context.



51

00:04:04,260 --> 00:04:11,340

The first one is that each of these bounded contacts must be represented with its own domain model.



52

00:04:11,520 --> 00:04:14,070

That is, there is no sharing of model.



53

00:04:14,640 --> 00:04:23,730

The domain model built for the bounded context is applicable only within the boundaries of that bounded



54

00:04:23,730 --> 00:04:24,440

context.



55

00:04:24,450 --> 00:04:31,950

So, for example, the retail banking model may not have a meaningful interpretation within the credit



56

00:04:31,950 --> 00:04:33,660

card bounded context.



57

00:04:33,840 --> 00:04:40,470

And the third one is that the language used by other means within the bounded context does not suffer



58

00:04:40,470 --> 00:04:44,720

from any kind of linguistic challenges that I have discussed earlier.



59

00:04:44,850 --> 00:04:49,980

In other words, each of the bomblet context has its own ubiquitous language.



60

00:04:50,430 --> 00:04:56,490

Let's go through each of these characteristics indicate the first one is independent domain models.



61

00:04:56,490 --> 00:04:59,430

In the banking example, we have these bounded.



62

00:05:00,060 --> 00:05:06,630

Now, if you think about it, each of these capabilities have different modeling requirements or model



63

00:05:06,630 --> 00:05:07,360

requirements.



64

00:05:07,680 --> 00:05:14,490

If you go back to our customer object representation, the retail banking may need only the demographics,



65

00:05:14,490 --> 00:05:20,490

information about the customer and the employee information to open a bank account or to manage the



66

00:05:20,490 --> 00:05:25,850

bank account, whereas the credit card may need a different representation of the customer.



67

00:05:25,980 --> 00:05:32,250

That includes not only the demographics and the employee information, but it also has additional information



68

00:05:32,430 --> 00:05:34,970

on the income and credit history.



69

00:05:35,340 --> 00:05:41,310

As you can see, the retail banking and the credit cards, functional areas have their own unique needs



70

00:05:41,400 --> 00:05:47,430

and similarly, other functional areas in the bank will have their own unique needs and they will need



71

00:05:47,430 --> 00:05:51,540

to have their own representation of the customer object.



72

00:05:51,570 --> 00:05:58,530

These models are created and managed independently by the technology teams assigned to each of these



73

00:05:58,530 --> 00:05:59,580

functional units.



74

00:05:59,610 --> 00:06:05,160

Since these models are independent, team from one functional unit does not have to have the knowledge



75

00:06:05,310 --> 00:06:07,380

of the models managed by the team.



76

00:06:07,380 --> 00:06:13,860

In another functional unit, for example, AT&amp;T does not have to have any kind of knowledge about the



77

00:06:13,860 --> 00:06:16,410

models managed by the credit card team.



78

00:06:16,620 --> 00:06:22,860

Similarly, the credit cards team does not have to have any kind of knowledge about the models managed



79

00:06:22,860 --> 00:06:24,240

by the retail team.



80

00:06:24,420 --> 00:06:31,920

And all of it boils down to one thing, and that is that the models can evolve independently across



81

00:06:31,920 --> 00:06:34,930

the functional units within an enterprise.



82

00:06:35,280 --> 00:06:42,150

The third characteristic of the blended context is that there is a language that holds a meaning within



83

00:06:42,150 --> 00:06:46,890

the bounded context, and you already know what this language is referred to as.



84

00:06:47,130 --> 00:06:49,240

This is the ubiquitous language.



85

00:06:49,290 --> 00:06:56,640

So in other words, each of the bounded context has a ubiquitous language which has a set of terms meaningful



86

00:06:56,790 --> 00:06:58,740

within the bounded context.



87

00:06:58,980 --> 00:07:06,020

So, for example, the retail team will create its own ubiquitous language, whereas the credit cards



88

00:07:06,060 --> 00:07:09,090

team will use its own ubiquitous language.



89

00:07:09,750 --> 00:07:17,070

In this lesson you learned about bounded context DTT, such as breaking the problem space into bounded



90

00:07:17,070 --> 00:07:17,730

contacts.



91

00:07:18,000 --> 00:07:24,060

Bounded context may be thought of as a conceptual boundary around the business capabilities.



92

00:07:24,090 --> 00:07:26,880

These Mongered contacts have certain characteristics.



93

00:07:27,060 --> 00:07:32,160

Models may be developed independently within each bounded context.



94

00:07:32,160 --> 00:07:39,750

Models developed in the BONARD context have applicability only within that boundary context.



95

00:07:39,870 --> 00:07:46,950

Each bounded context has its own ubiquitous language, which is meaningful only within that bounded



96

00:07:46,950 --> 00:07:47,580

context.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\009 Discovering the Bounded Contexts in a Domain.en.srt -->

1

00:00:00,150 --> 00:00:05,280

Discovering the bonded contacts in this lesson, I'll provide guidance on discovery of bonded contacts



2

00:00:05,280 --> 00:00:12,870

based on the organization's structure, business, export responsibilities and existing monolithic applications.



3

00:00:13,110 --> 00:00:19,170

I'll start this lesson on bonded contacts discovery by saying that there is no silver bullet that will



4

00:00:19,170 --> 00:00:22,800

help you in discovering the bonded contacts in your domain.



5

00:00:23,010 --> 00:00:29,580

Now, it may sound cliche to you, but I do agree with the experts when they say that discovering the



6

00:00:29,580 --> 00:00:33,330

100 contacts in a domain is an art and not a science.



7

00:00:33,720 --> 00:00:39,780

At this point, you may be wondering if there is no defined process for discovering the bonded context,



8

00:00:40,080 --> 00:00:43,200

then what is Raj going to discuss in this lesson?



9

00:00:43,320 --> 00:00:50,400

Well, I'll share with you the guidance on carrying out the discovery process for Bundrick contacts.



10

00:00:50,760 --> 00:00:57,630

And I've put together this guidance based on my personal experiences, as well as the experiences shared



11

00:00:57,630 --> 00:01:03,270

by the experts and practitioners to discover the bonded contacts in a domain.



12

00:01:03,450 --> 00:01:10,470

You need to leverage the existing assets and you need to partner with the domain experts start by looking



13

00:01:10,470 --> 00:01:12,540

at the organization structure.



14

00:01:12,660 --> 00:01:20,640

Typically, organization structures are available as diagrams that depict the various business capabilities



15

00:01:20,640 --> 00:01:25,200

or functional areas within the organization as a next step.



16

00:01:25,500 --> 00:01:33,600

Identify the business experts in the core domains and partner with them to understand their responsibilities



17

00:01:33,840 --> 00:01:36,720

and the key activities they are involved in.



18

00:01:36,840 --> 00:01:43,500

Go deeper into some of these key activities as you carrying out these two tasks, be on the lookout



19

00:01:43,710 --> 00:01:48,590

for clues in the business language used by the domain experts.



20

00:01:48,600 --> 00:01:55,530

If your organization has invested in well-designed, modular, monolithic applications, they can also



21

00:01:55,560 --> 00:01:58,770

act as the starting point for this exercise.



22

00:01:58,860 --> 00:02:06,870

Look at the modules and the monolithic application and create the boundaries for the business contacts



23

00:02:06,990 --> 00:02:09,180

realized in those applications.



24

00:02:09,610 --> 00:02:17,130

Overall, the idea is to gather the clues from these exercises and then use these clues for marking



25

00:02:17,130 --> 00:02:23,890

the boundaries for the bounded context to describe each one of these and the use of these clues.



26

00:02:24,060 --> 00:02:26,220

I'll use the example of a bank.



27

00:02:26,220 --> 00:02:32,940

But before that one important point, please do not get hung up on finding the perfect boundaries for



28

00:02:32,940 --> 00:02:35,390

your bounded context as it would take time.



29

00:02:35,730 --> 00:02:38,480

It is okay to start with some boundary then.



30

00:02:38,910 --> 00:02:40,580

This is my suggestion to you.



31

00:02:40,800 --> 00:02:46,480

Most organizations are good at documenting and maintaining their organization structure.



32

00:02:46,500 --> 00:02:52,980

So if you're starting afresh in an organization to understand the bounding context, a good place would



33

00:02:52,980 --> 00:02:58,490

be to pay attention to the business functions depicted in the organization structure.



34

00:02:58,620 --> 00:03:05,610

So this is the organization's structure for a bank and these are the business capabilities or functional



35

00:03:05,760 --> 00:03:07,460

areas within the bank.



36

00:03:07,920 --> 00:03:14,820

These business functions are the business capabilities may be treated as the starting point for the



37

00:03:14,970 --> 00:03:16,200

bounded contacts.



38

00:03:16,350 --> 00:03:23,100

So in the case of banking, we have the consumer banking cards and merchant services, business, banking,



39

00:03:23,100 --> 00:03:29,280

treasury, transaction banking, financial institutions and international and payment services.



40

00:03:29,430 --> 00:03:36,240

Keep in mind that this is a starting point and you need to delve deeper into each of these business



41

00:03:36,240 --> 00:03:39,030

capabilities to refine these boundaries further.



42

00:03:39,450 --> 00:03:46,230

As a next step, you may look at the responsibilities of each of the business experts and keep in mind



43

00:03:46,230 --> 00:03:51,480

that these business experts may be responsible for multiple functions.



44

00:03:51,690 --> 00:03:58,170

For example, the consumer banking expert in a bank may be responsible for the savings and checking



45

00:03:58,170 --> 00:04:00,420

account as well as the credit cards.



46

00:04:00,540 --> 00:04:07,320

And as you are gathering information and knowledge from these business experts, pay attention to the



47

00:04:07,320 --> 00:04:10,620

business language that these experts are using.



48

00:04:11,040 --> 00:04:18,240

The key activities of the business are the activities that the business must carry out to make the business



49

00:04:18,240 --> 00:04:19,280

model work.



50

00:04:19,590 --> 00:04:26,550

In the case of consumer banking, examples of such key activities are customer support operations,



51

00:04:26,550 --> 00:04:29,430

account management and branch operations.



52

00:04:29,820 --> 00:04:36,870

Going deeper into each of these activities in collaboration with the business experts will help the



53

00:04:37,230 --> 00:04:43,860

experts to understand the contextual boundaries within the consumer banking domain.



54

00:04:44,250 --> 00:04:52,380

You, as the IT expert, need to collaborate with the business experts to identify the appropriate key



55

00:04:52,380 --> 00:04:59,130

activities in your organization and then dig deeper into each of these activities.



56

00:04:59,130 --> 00:04:59,910

And as you.



57

00:04:59,980 --> 00:05:06,160

Going through these activities ensure that you are capturing the business language used for each of



58

00:05:06,160 --> 00:05:13,540

these activities, using the flow of these key activities and the linguistic clues will help you identify



59

00:05:13,660 --> 00:05:18,970

the bonded contacts from the business, use cases and processes perspective.



60

00:05:19,810 --> 00:05:26,920

If you work for an organization that has invested in building well-designed, monolithic modular applications,



61

00:05:26,920 --> 00:05:35,290

then you are lucky because you may use these well designed applications to identify the bonded contacts.



62

00:05:35,560 --> 00:05:42,250

As an example, let's consider a branch operations application, which is used by the bank's employees



63

00:05:42,610 --> 00:05:49,180

to carry out account related functions across multiple products such as saving accounts, checking accounts,



64

00:05:49,180 --> 00:05:50,980

credit accounts and loan accounts.



65

00:05:51,130 --> 00:05:57,640

Let's say the savings accounts and checking accounts are implemented in a common module, so this module



66

00:05:57,790 --> 00:06:01,420

may represent the bonded contacts for the retail account.



67

00:06:01,540 --> 00:06:07,030

Similarly, the credit card and the loan account are implemented in their own independent modules,



68

00:06:07,030 --> 00:06:13,040

and each of those modules may represent the bonded contacts for the credit card and the loans.



69

00:06:13,300 --> 00:06:19,870

So long story short, existing monolithic applications should not be ignored, and they may be used



70

00:06:19,870 --> 00:06:24,530

as a starting point for creating the bonded contacts in your business domain.



71

00:06:24,940 --> 00:06:31,660

In this lesson, I provided you a walk through of a set of steps that you can carry out to discover



72

00:06:31,660 --> 00:06:33,670

the bonded contacts in your domain.



73

00:06:33,820 --> 00:06:40,390

Suggestion is to leverage the available assets, such as the organization structure, existing well-designed,



74

00:06:40,390 --> 00:06:46,060

monolithic applications to identify the bounded contacts and other thing that you as an I.T. expert



75

00:06:46,060 --> 00:06:53,050

need to do is partner with the business experts to understand their responsibilities and key activities



76

00:06:53,080 --> 00:06:55,480

as you work closely with the business expert.



77

00:06:55,510 --> 00:07:01,960

You need to pay attention to the business language and the linguistic clues that will help you demarcate



78

00:07:01,960 --> 00:07:04,570

the boundaries of the bounded context.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05 Domain Driven Design _ Strategic Patterns\010 Exercise _ Identify ACME's Bounded Contexts.en.srt -->

1

00:00:00,210 --> 00:00:07,240

The objective of this exercise is to identify the bonded context for ACMS support subdomain.



2

00:00:07,860 --> 00:00:11,420

Let's start by looking at ACMS organization structure.



3

00:00:11,460 --> 00:00:18,300

The CEO has to direct reports, vice president of business and vice president of support and the support



4

00:00:18,570 --> 00:00:25,350

that are typical business functions such as legal, human resources, admin, accounting, I.T. systems



5

00:00:25,350 --> 00:00:26,280

and facilities.



6

00:00:26,310 --> 00:00:31,980

And under the business there are six core functional areas we will be focusing on.



7

00:00:31,980 --> 00:00:39,270

These six core functional areas start by drawing the boundaries around marketing, sales, partner management,



8

00:00:39,270 --> 00:00:43,540

support, new business and channels and product management.



9

00:00:43,560 --> 00:00:47,730

So this is the starting point for the BONARD context.



10

00:00:47,730 --> 00:00:54,330

For Acme as a next step, we will dig deeper into the support bonded context.



11

00:00:54,570 --> 00:01:00,180

And to do that, we as the IP expert will work with Kathee from the support team.



12

00:01:00,410 --> 00:01:07,710

Kathy is responsible for supporting customers and partners and she'll explain to us some of the key



13

00:01:07,710 --> 00:01:10,020

activities that she's involved in.



14

00:01:10,200 --> 00:01:17,130

Our objective is to understand if the boundaries that we have drawn around support are good or not.



15

00:01:17,310 --> 00:01:23,360

From the big picture perspective, Kathee and her team plays a very important role at Acme.



16

00:01:23,400 --> 00:01:26,520

Kathee totally understand ACMS customers.



17

00:01:26,670 --> 00:01:33,780

In case of issues, customers may reach the Acme support by calling a toll free number twenty four by



18

00:01:33,780 --> 00:01:34,290

seven.



19

00:01:34,530 --> 00:01:39,960

The support team received these calls and try to help the customers as much as they can.



20

00:01:40,200 --> 00:01:47,130

Partners can get the support from Acme by calling the same toll free number between eight a.m. and five



21

00:01:47,130 --> 00:01:49,920

p.m. Eastern Time Monday through Friday.



22

00:01:50,010 --> 00:01:52,830

And these calls are also received by the support team.



23

00:01:53,010 --> 00:02:00,000

Now that we know the responsibilities of the support team, let's get into the details of the key activities



24

00:02:00,000 --> 00:02:07,650

carried out by supporting customers and providers called the common toll free number for Hackman's call



25

00:02:07,650 --> 00:02:08,100

center.



26

00:02:08,580 --> 00:02:11,850

The call is directed to the support agent.



27

00:02:11,940 --> 00:02:17,820

Depending on whether the call is from the customer or the provider, the agent follows the customer



28

00:02:17,820 --> 00:02:20,010

process or the provider process.



29

00:02:20,430 --> 00:02:25,410

These are the two key activities that the support agent gets involved in.



30

00:02:25,680 --> 00:02:28,980

Let's dig deeper into the customer process now.



31

00:02:29,100 --> 00:02:33,830

On receiving the phone call from the customer, the agent opens up a ticket.



32

00:02:33,960 --> 00:02:41,850

This ticket is used for recording the customer's request on the issue and relevant part of the conversation



33

00:02:42,090 --> 00:02:45,740

between the customer and the support agents.



34

00:02:45,750 --> 00:02:51,990

So here we have learned about a business Tom referred to as the ticket in the context of customer support



35

00:02:51,990 --> 00:02:52,620

process.



36

00:02:52,620 --> 00:03:00,000

The agent then checks the knowledgebase to see if there is any article that describes how to address



37

00:03:00,270 --> 00:03:02,220

the customer request or the issue.



38

00:03:02,340 --> 00:03:07,950

This knowledgebase is managed specifically for supporting customer requests.



39

00:03:07,950 --> 00:03:13,410

So here we have learned about a new business Tom referred to as the Knowledge Base, which is a collection



40

00:03:13,410 --> 00:03:19,230

of articles that describe how to address the customer requests or issues.



41

00:03:19,230 --> 00:03:27,120

If the issue is related to existing purchase by the customer, then the agent may also check the sales



42

00:03:27,120 --> 00:03:28,790

order for that request.



43

00:03:28,890 --> 00:03:32,610

So here we learn about a new comp sales order.



44

00:03:32,790 --> 00:03:36,750

If the agent is able to resolve the issue, then they close the ticket.



45

00:03:36,930 --> 00:03:40,620

Otherwise they assign the ticket to customer care.



46

00:03:40,680 --> 00:03:45,690

So customer care is a separate team and so we learn a new business.



47

00:03:46,080 --> 00:03:47,040

Customer care.



48

00:03:47,100 --> 00:03:53,280

The customer care team then carries out the investigation and worked directly with the customer to resolve



49

00:03:53,280 --> 00:03:55,020

the issue and close the ticket.



50

00:03:55,560 --> 00:04:01,920

During this investigation process, the customer can call the call center and get the ticket status



51

00:04:01,920 --> 00:04:03,600

from the support agent.



52

00:04:03,720 --> 00:04:10,170

Next, let's talk about the provider process for the support on receiving a call from the provider.



53

00:04:10,500 --> 00:04:13,550

The support agent opens up provider case.



54

00:04:13,560 --> 00:04:20,910

So this is a new term provider case which is applicable in the case of the provider support process.



55

00:04:21,030 --> 00:04:25,830

And Cathy has also mentioned that the provider case is also known as the partner.



56

00:04:26,250 --> 00:04:32,550

The provider case, like the ticket, has the information about the request or the issue for which the



57

00:04:32,550 --> 00:04:33,420

provider called.



58

00:04:33,690 --> 00:04:42,180

And it also has relevant parts of the conversations between the provider and the support agent to address



59

00:04:42,180 --> 00:04:43,740

the issue or the request.



60

00:04:43,740 --> 00:04:46,650

The agent checks the knowledge base.



61

00:04:46,950 --> 00:04:53,760

This knowledge base is a collection of articles related to resolving the requests or issues brought



62

00:04:53,760 --> 00:04:54,960

up by the providers.



63

00:04:55,260 --> 00:04:58,590

The agent also checks the provider contracts.



64

00:04:58,650 --> 00:04:59,720

This is the contract, but.



65

00:05:00,130 --> 00:05:07,660

Acme and the provider, so provider contract is another term applicable in the context of the provider



66

00:05:07,660 --> 00:05:13,480

support process, if the agent is able to resolve the issue, then the provider case is closed.



67

00:05:13,630 --> 00:05:22,030

Otherwise, the agent based on the issue assigns the provider case to an appropriate team.



68

00:05:22,030 --> 00:05:29,770

Within Achmat, for example, if it is a contractual issue, then the partner management team is assigned



69

00:05:29,770 --> 00:05:34,910

to take it if it is related to accounting and the accounting team is assigned the ticket.



70

00:05:35,110 --> 00:05:41,030

The teams working on addressing the provider request then work directly with the provider.



71

00:05:41,050 --> 00:05:47,530

So at a high level, the process of providing support to the customer looks very similar to the process



72

00:05:47,530 --> 00:05:50,980

used for providing support to the partners, other providers.



73

00:05:50,980 --> 00:05:57,280

And interestingly, we have learned different tones used in the context of each process.



74

00:05:57,610 --> 00:06:01,240

Let's compare the terms that we have gathered from these two processes.



75

00:06:01,250 --> 00:06:04,780

The first two terms are the ticket and the provider case.



76

00:06:04,810 --> 00:06:09,070

Conceptually, they are similar, but semantically they are different.



77

00:06:09,370 --> 00:06:17,290

Take it has no meaning in the case of the provider process context, whereas provider case has no meaning



78

00:06:17,470 --> 00:06:25,030

in the context of the customer process the next time or the knowledge base common terms used in different



79

00:06:25,030 --> 00:06:25,770

context.



80

00:06:25,780 --> 00:06:33,280

The knowledge base in the context of customer process refers to a repository of article that describes



81

00:06:33,280 --> 00:06:40,090

how to support the customer, whereas the knowledge base for the provider context refers to a knowledge



82

00:06:40,090 --> 00:06:44,050

base that has articles for supporting the provider's.



83

00:06:44,050 --> 00:06:51,070

Next one is the sales are and the customer care needs to have meaning only in the context of the customer



84

00:06:51,070 --> 00:06:51,730

process.



85

00:06:51,740 --> 00:06:57,510

And similarly, we have the provider contract which has meaning in the creative process context.



86

00:06:57,520 --> 00:07:04,510

So based on the clues that we are seeing here, the support bounded contacts may be split into two independent



87

00:07:04,510 --> 00:07:10,750

bonded contacts, the customer support contacts and the provider support context.



88

00:07:10,750 --> 00:07:16,960

And we are making this call based on the fact that the two wonted contacts are using different business



89

00:07:16,960 --> 00:07:17,530

terms.



90

00:07:17,980 --> 00:07:25,090

So we started with these bonded contacts and decided to split the support, bonded contacts into two



91

00:07:25,090 --> 00:07:32,470

independent bonded contacts, the customer support bonder contacts and the provider support bonded contacts.



92

00:07:32,590 --> 00:07:37,570

Let's review the steps that we have carried out in order to get to these bomblet contacts.



93

00:07:37,900 --> 00:07:44,980

The first thing we did is we looked at the ACMS organization structure, picked up the business capabilities



94

00:07:44,980 --> 00:07:49,870

and created the set of bonded contacts as a starting point.



95

00:07:50,020 --> 00:07:57,160

After that, we focused on the support activities and we found that there are two key activities carried



96

00:07:57,160 --> 00:07:59,830

out by the call center support agents.



97

00:07:59,860 --> 00:08:04,810

As we walk through these key activities, we gather the business teams.



98

00:08:04,810 --> 00:08:11,800

After that, we compared the business terms and figured out that it made sense for the support contacts



99

00:08:11,800 --> 00:08:17,020

to be split into customer support contacts and provide a support context.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000001.srt -->

1
00:00:00,200 --> 00:00:27,930
Thiết kế theo nhu cầu là một phương pháp kiến ​​trúc cung cấp các nguyên tắc và mô hình để giải quyết các thách thức gặp phải khi phát triển các mô hình miền phức tạp có thiết kế theo hướng miền do Eric Events đặt ra và cuốn sách của ông, Thiết kế theo hướng miền, Thiết kế hướng miền nhấn mạnh vào thực tế là  trọng tâm chính của dự án itte phải là lĩnh vực kinh doanh và logic kinh doanh hơn là công nghệ.

2
00:00:28,050 --> 00:00:42,510
Nó thúc đẩy ý tưởng chia mô hình thống nhất thành các mô hình nhỏ hơn, dễ quản lý hơn.  Và nó gợi ý việc sử dụng quy trình sáng tạo của chúng tôi để cải thiện mô hình nhằm giải quyết miền vấn đề miền của chúng tôi.

3
00:00:42,510 --> 00:00:53,490
Thiết kế Rehren cung cấp hai loại mẫu.  Các mô hình chiến lược được sử dụng để chia một vấn đề kinh doanh lớn và phức tạp thành các phần nhỏ hơn với ranh giới được xác định rõ ràng.

4
00:00:53,490 --> 00:01:01,590
Các mẫu kỹ thuật được sử dụng để chuyển các mô hình khái niệm sang các thiết kế dịch vụ và ứng dụng phần mềm.

5
00:01:01,890 --> 00:01:11,770
Mẫu chiến lược áp dụng trên nhiều bối cảnh bị giới hạn, trong khi các mẫu kỹ thuật chỉ có thể áp dụng trong bối cảnh bị giới hạn.

6
00:01:11,790 --> 00:01:27,140
Điều này sẽ trở nên rõ ràng khi bạn hiểu rõ hơn về các mô hình chiến lược và chiến thuật.  Đây là các mẫu chiến lược thiết kế theo miền trong phần chúng tôi sẽ đề cập đến phần ngữ cảnh bị giới hạn và mẫu ngôn ngữ phổ biến.

7
00:01:27,570 --> 00:01:51,960
Vì vậy, câu hỏi bạn có thể đặt ra là thiết kế miền khác nhau như thế nào liên quan đến các dịch vụ vi mô?  Ý tưởng là phương pháp thiết kế hướng miền dẫn đến các mô hình miền độc lập nhỏ hơn có thể được xây dựng dưới dạng tập hợp các dịch vụ vi mô độc lập và có tính tách rời cao để mô hình chiến lược mà chúng tôi đang xác định ranh giới cho các dịch vụ vi mô.

8
00:01:52,920 --> 00:02:02,000
Chúng ta hãy xem qua các mục tiêu của phần ở cuối phần này, bạn sẽ có thể xác định và phân loại các tên miền phụ trong một miền doanh nghiệp.

9
00:02:02,400 --> 00:02:12,690
Bạn biết tại sao việc hiểu bối cảnh kinh doanh lại quan trọng.  Bạn sẽ có thể mô tả thiết kế hướng đến miền, đối tác chiến lược, ngôn ngữ phổ biến và bối cảnh bị giới hạn.

10
00:02:13,080 --> 00:02:20,070
Và bạn cũng sẽ có thể mô tả quy trình có thể được sử dụng để khám phá các liên hệ được liên kết trong một miền.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000002.srt -->

1
00:00:00,210 --> 00:00:13,760
Tên miền phụ, một miền doanh nghiệp, bao gồm nhiều tên miền phụ, có ba loại tên miền phụ, loại phụ thuộc vào giá trị mà tên miền phụ tạo ra cho doanh nghiệp và người đứng đầu doanh nghiệp.

2
00:00:13,860 --> 00:00:24,570
Hiểu biết về loại tên miền phụ có thể hỗ trợ doanh nghiệp đưa ra quyết định xây dựng hay mua các giải pháp công nghệ.

3
00:00:24,870 --> 00:00:33,330
Doanh nghiệp cần thực hiện nhiều chức năng khác nhau để hoạt động.  Các chức năng này được thực hiện trong phạm vi hoạt động của tên miền phụ.

4
00:00:33,330 --> 00:00:45,000
Đối với ví dụ về ngân hàng, chúng tôi đã thấy nhiều tên miền phụ như vậy.  Một điểm quan trọng cần lưu ý là đây là cái nhìn chung ở cấp độ rất cao về cách các tên miền phụ của ngân hàng trông như thế nào.

5
00:00:45,000 --> 00:01:01,440
Nhưng mỗi ngân hàng có thể nhìn doanh nghiệp của mình theo một cách khác.  Từ góc độ tên miền phụ, lý do phổ biến nhất là các doanh nghiệp có thể không hoạt động ở tất cả các tên miền phụ trong tên miền bao quát đó hoặc ngành, chẳng hạn như ngân hàng.

6
00:01:01,440 --> 00:01:12,390
Nó có thể chỉ cung cấp tài khoản bán lẻ cho khách hàng của họ.  Tài khoản bán lẻ giống như tài khoản séc hoặc tài khoản tiết kiệm, trong khi Ngân hàng B chỉ xử lý thẻ tín dụng và dịch vụ thương mại.

7
00:01:12,420 --> 00:01:28,410
Kết quả là cấu trúc tên miền phụ của ngân hàng ở đây và Ngân hàng B sẽ trông khác nhau.  Bây giờ, nếu bạn nghĩ về điều đó, những tên miền phụ này có thể được chia thành các tên miền phụ nhỏ hơn và đây là những gì tôi gọi là mức độ chi tiết của tên miền phụ.

8
00:01:28,410 --> 00:01:45,420
Và nó phụ thuộc vào trọng tâm của doanh nghiệp.  Ví dụ: ngân hàng chỉ giao dịch với tài khoản bán lẻ có thể quyết định chia tên miền phụ tài khoản bán lẻ này thành nhiều tên miền phụ như tài khoản tiết kiệm, tài khoản séc, chứng chỉ tiền gửi, v.v..

9
00:01:45,420 --> 00:01:56,490
Vì vậy, cuối cùng, mỗi ngân hàng, tùy thuộc vào trọng tâm của mình, có thể xem doanh nghiệp bao gồm các tên miền phụ khác nhau mà họ thực hiện các hoạt động kinh doanh của mình.

10
00:01:56,910 --> 00:02:07,560
Mỗi tên miền phụ có mức độ phức tạp khác nhau liên quan đến nó.  Có nhiều yếu tố có thể góp phần tạo nên sự phức tạp của tên miền phụ.

11
00:02:07,860 --> 00:02:14,910
Alcoa, một số lý do phổ biến.  Lý do phổ biến nhất là sự phức tạp của chính các quy tắc kinh doanh.

12
00:02:14,910 --> 00:02:25,380
Tiếp theo là khía cạnh tuân thủ.  Nếu tên miền phụ đang hoạt động trong môi trường được quản lý chặt chẽ thì điều đó sẽ làm tăng thêm độ phức tạp cho tên miền phụ.

13
00:02:25,380 --> 00:02:36,540
Các phép tính phức tạp hoặc thuật toán phức tạp có thể yêu cầu các kỹ năng chuyên môn hoặc kiến ​​thức chuyên biệt để hiểu tên miền phụ và điều đó làm tăng thêm độ phức tạp.

14
00:02:36,560 --> 00:02:49,230
Phần tiếp theo là các quy trình và việc xử lý được yêu cầu giữa tên miền phụ và các tên miền phụ khác hoặc thậm chí các thực thể bên ngoài cũng sẽ góp phần tạo nên sự phức tạp của các tên miền phụ.

15
00:02:49,230 --> 00:03:07,590
Đó là một điều thú vị.  Ý tưởng ở đây là nếu tên miền phụ yêu cầu thay đổi quy trình, quy tắc, cấu trúc hoặc bất kỳ khía cạnh nào khác thì sẽ khó quản lý kiến ​​thức và hiểu biết về tên miền vì nó thay đổi theo thời gian chứ không phụ thuộc vào doanh nghiệp, tùy thuộc vào  trên ngành công nghiệp.

16
00:03:07,770 --> 00:03:26,460
Có thể có các yếu tố khác góp phần tạo nên sự phức tạp của tên miền phụ.  Các tên miền phụ có thể được phân loại thành ba loại và danh mục mà tên miền phụ nằm trong đó được quyết định bởi tên miền phụ, độ phức tạp và giá trị kinh doanh, nó cho biết thêm.

17
00:03:26,460 --> 00:03:35,430
Ba loại này là tên miền phụ chung, tên miền phụ cốt lõi và tên miền phụ hỗ trợ.  Chúng ta hãy đi vào chi tiết của từng cái một.

18
00:03:35,610 --> 00:03:42,540
Tên miền phụ chung được đặc trưng bởi thực tế là không có giải pháp duy nhất nào tồn tại cho các tên miền phụ đó.

19
00:03:42,570 --> 00:03:48,660
Không có gì đặc biệt về những tên miền phụ này và các phương pháp hay nhất đều có sẵn cho những tên miền này.

20
00:03:49,020 --> 00:03:57,300
Doanh nghiệp không thể đạt được bất kỳ lợi thế cạnh tranh nào bằng cách thực hiện những điều khác biệt trong tên miền phụ chung.

21
00:03:57,330 --> 00:04:15,150
Ví dụ về các tên miền phụ như vậy là quản lý nguồn nhân lực và cơ sở vật chất.  Vì vậy, bất kể chúng ta đang đề cập đến ngành nào hoặc doanh nghiệp nào, các hoạt động quản lý nhân sự và quản lý cơ sở vật chất đều khá trưởng thành và không tạo thêm bất kỳ loại giá trị khác biệt nào cho doanh nghiệp.

22
00:04:15,310 --> 00:04:28,950
Tên miền phụ cốt lõi là điểm khác biệt cho doanh nghiệp.  Mỗi doanh nghiệp trong một ngành cụ thể hoạt động khác nhau trong các tên miền phụ cốt lõi để đạt được một số lợi thế so với đối thủ cạnh tranh.

23
00:04:29,070 --> 00:04:43,170
Thông thường, người ta nói rằng nước sốt bí mật dành cho doanh nghiệp nằm ở tên miền phụ cốt lõi và doanh nghiệp luôn tìm cách thực hiện những điều khác biệt trong các tên miền phụ cốt lõi này để có được một số lợi thế cạnh tranh.

24
00:04:43,290 --> 00:04:54,420
Tùy thuộc vào ngành và môi trường, các tên miền phụ cốt lõi này có thể phát triển với tốc độ rất nhanh hoặc có thể có ví dụ về thành phố năng động ở mức độ rất cao.

25
00:04:54,420 --> 00:05:16,020
Tất nhiên, tên miền phụ là tên miền phụ sản xuất trong ngành ô tô.  Các nhà sản xuất ô tô đang tìm cách thực hiện những điều khác biệt trong các lĩnh vực sản xuất phụ này để đạt được một số lợi thế cạnh tranh hoặc để đạt được mức tiết kiệm chi phí cao, điều này một lần nữa chuyển thành giá trị cho hoạt động kinh doanh trong ngành ngân hàng.

26
00:05:16,190 --> 00:05:27,350
Hãy nghĩ đến thẻ tín dụng, mỗi ngân hàng cung cấp thẻ tín dụng cho người tiêu dùng với những loại lợi ích khác nhau và có thể vận hành hoạt động kinh doanh thẻ tín dụng khác nhau để đạt được một số lợi thế.

27
00:05:27,770 --> 00:05:37,350
Đã đến lúc tập thể dục nhanh.  Hãy xem các tên miền phụ cho ngân hàng và tên miền phụ cho Ngân hàng B, xác định điểm khác biệt của hai ngân hàng.

28
00:05:37,520 --> 00:05:54,500
Hãy tiếp tục, đăng một video trong vài giây.  Trả lời câu hỏi.  Điểm khác biệt đầu tiên là ở các sản phẩm mà hai ngân hàng cung cấp, tài khoản bán lẻ, thẻ tín dụng và dịch vụ thương mại, trong khi Ngân hàng B cung cấp dịch vụ tài khoản bán lẻ và thế chấp.

29
00:05:54,770 --> 00:06:01,700
Điểm khác biệt thứ hai là việc Ngân hàng và Ngân hàng B có thể vận hành tài khoản bán lẻ khác nhau.

30
00:06:01,700 --> 00:06:17,360
Vì vậy, điểm mấu chốt là cả hai đều có tài khoản bán lẻ làm miền cốt lõi của mình.  Họ có thể tự tạo sự khác biệt bằng cách hoạt động khác nhau trong tên miền phụ hỗ trợ tài khoản bán lẻ để không mang lại bất kỳ lợi thế kinh doanh trực tiếp nào.

31
00:06:17,720 --> 00:06:28,960
Nhưng các tên miền phụ cốt lõi lại phụ thuộc vào các tên miền phụ hỗ trợ.  Có những phương pháp phổ biến dành cho các tên miền phụ hỗ trợ nhưng có thể không có sẵn giải pháp.

32
00:06:29,060 --> 00:06:37,340
Và ngay cả khi có sẵn các giải pháp, những giải pháp đó có thể cần được tùy chỉnh để đáp ứng nhu cầu của tên miền phụ mã.

33
00:06:37,370 --> 00:06:48,640
Thông thường, tên miền phụ hỗ trợ không có mức độ phức tạp cao về logic nghiệp vụ, ví dụ về hỗ trợ tên miền phụ hoặc hỗ trợ và tuân thủ khách hàng.

34
00:06:48,650 --> 00:06:58,310
Tên miền phụ cốt lõi trong ngân hàng phụ thuộc rất nhiều vào bộ phận hỗ trợ khách hàng, tên miền phụ và tên miền phụ tuân thủ để xác định loại tên miền phụ.

35
00:06:58,440 --> 00:07:06,560
Bạn phải bắt đầu bằng cách xem xét khả năng kinh doanh trong tên miền phụ đó.  Có giải pháp nào được biết đến cho tên miền phụ đó không?

36
00:07:06,650 --> 00:07:16,460
Và nếu câu trả lời là có thì tên miền phụ có thể là do di truyền.  Nếu không, bạn cần kiểm tra xem tên miền phụ có thêm bất kỳ giá trị kinh doanh nào không.

37
00:07:16,460 --> 00:07:26,300
Ví dụ: liệu doanh nghiệp có cơ hội tạo sự khác biệt so với các đối thủ cạnh tranh bằng cách thực hiện những điều khác biệt trong tên miền phụ này không?

38
00:07:26,310 --> 00:07:33,290
Và nếu câu trả lời là không thì bước kiểm tra tiếp theo là xem liệu các tên miền phụ cốt lõi có phụ thuộc vào tên miền phụ này hay không.

39
00:07:33,290 --> 00:07:43,340
Và câu trả lời đó là có thì rất có thể đó là một subdomain hỗ trợ.  Và nếu câu trả lời là không thì đó là tên miền phụ chung mà bạn có thể cần xây dựng giải pháp.

40
00:07:43,430 --> 00:07:51,920
Nếu tên miền phụ có tiềm năng bổ sung một số giá trị kinh doanh thì bước kiểm tra tiếp theo là xem liệu tên miền doanh nghiệp có độ phức tạp cao hay không.

41
00:07:52,010 --> 00:07:58,310
Nếu miền doanh nghiệp không có độ phức tạp cao thì có khả năng nó sẽ hỗ trợ tên miền phụ.

42
00:07:58,430 --> 00:08:05,930
Nếu không thì nó có thể là một khóa học của miền.  Đề xuất của tôi dành cho bạn là hãy đăng một video và tự mình xem qua biểu đồ này.

43
00:08:06,290 --> 00:08:12,350
Một câu hỏi rõ ràng có thể xuất hiện trong đầu bạn vào thời điểm này là tại sao chúng ta cần phân loại các tên miền phụ?

44
00:08:12,800 --> 00:08:27,590
Có nhiều lý do.  Đầu tiên là doanh nghiệp có nguồn lực hạn chế và những nguồn lực này ở đây đề cập đến nguồn nhân lực cũng như số tiền dành cho các sáng kiến ​​​​khác nhau trong toàn doanh nghiệp.

45
00:08:27,880 --> 00:08:36,710
Việc phân loại các tên miền phụ giúp ưu tiên các sáng kiến ​​​​khác nhau.  Lý do thứ hai là lợi tức đầu tư.

46
00:08:37,010 --> 00:08:50,030
Các doanh nghiệp muốn tối đa hóa lợi tức đầu tư.  Do đó, các sáng kiến ​​liên quan đến tên miền phụ cốt lõi sẽ được ưu tiên, điều này sẽ giúp tối đa hóa lợi tức đầu tư.

47
00:08:50,090 --> 00:08:57,720
Lý do thứ ba là việc phân loại tên miền phụ giúp doanh nghiệp đưa ra quyết định mua gì.

48
00:08:57,740 --> 00:09:06,410
Hãy tìm hiểu sâu hơn một chút.  Nếu tên miền phụ là tên miền phụ chung, doanh nghiệp đó sẽ mua giải pháp cho nó thay vì xây dựng.

49
00:09:06,410 --> 00:09:15,470
Ví dụ về các giải pháp như vậy là phần mềm hoạch định nguồn lực doanh nghiệp như SAP.  Và nếu tên miền phụ hỗ trợ tên miền phụ thì sao?

50
00:09:15,560 --> 00:09:26,780
Sau đó, doanh nghiệp có thể quyết định xây dựng giải pháp bằng cách thuê ngoài hoặc họ có thể mua một giải pháp chung và tùy chỉnh giải pháp đó để đáp ứng nhu cầu về mã của họ.

51
00:09:26,780 --> 00:09:40,910
Là một ví dụ về giải pháp như vậy sẽ là Salesforce.  Nếu tên miền phụ được phân loại là mã thì doanh nghiệp sẽ sử dụng đội ngũ tốt nhất và tài năng tốt nhất của mình để xây dựng giải pháp trong tên miền phụ này.

52
00:09:41,750 --> 00:09:47,630
Hãy gọi với một điểm quan trọng từ bài học này.  Đầu tiên là có ba loại tên miền phụ.

53
00:09:48,080 --> 00:09:59,690
Tên miền phụ chung có sẵn các giải pháp mà doanh nghiệp có thể mua vì tên miền là tên miền phụ mà doanh nghiệp có cơ hội xác định.

54
00:09:59,840 --> 00:10:14,930
Được bảo hiểm khỏi các đối thủ cạnh tranh, việc hỗ trợ tên miền phụ là cần thiết vì các tên miền phụ cốt lõi phụ thuộc vào tên miền phụ hỗ trợ, việc viết hoa của các tên miền phụ đã giúp doanh nghiệp đưa ra quyết định xây dựng và mua.

55
00:10:14,930 --> 00:10:28,470
Và doanh nghiệp nhận được lợi tức đầu tư cao nhất bằng cách đầu tư vào các giải pháp.  Thông thường, doanh nghiệp sẽ sử dụng tài năng và nguồn lực tốt nhất của mình để xây dựng các giải pháp trong miền phụ cốt lõi.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000003.srt -->

1
00:00:00,150 --> 00:00:09,150
Trong bài tập này, tôi sẽ cung cấp cho bạn một số thông tin về tên miền phụ ACMS và bạn sẽ cần xác định loại tên miền phụ đó.

2
00:00:09,660 --> 00:00:24,340
Mục tiêu của bài tập này là chỉ định một danh mục cho từng tên miền phụ, đối với ACMC, các tên miền phụ được đưa ra và chúng ta cần đưa chúng vào hỗ trợ di truyền và tiến trình của các danh mục miền.

3
00:00:24,660 --> 00:00:34,050
Bây giờ, bạn có thể nghĩ rằng mình sẽ cần thêm một số thông tin về từng tên miền phụ này để phân loại chúng và đó là lúc chúng tôi sẽ nhờ sự trợ giúp của John.

4
00:00:34,140 --> 00:00:47,430
John là chuyên gia về lĩnh vực kinh doanh tại Acme.  Anh ấy sẽ cung cấp cho chúng tôi một số thông tin về từng tên miền phụ này để chúng tôi có thể phân loại các tên miền phụ này theo các danh mục thích hợp.

5
00:00:47,940 --> 00:00:54,390
Hãy bắt đầu với việc quản lý sản phẩm và sản phẩm tên miền phụ kế toán tại Acme đề cập đến gói kỳ nghỉ.

6
00:00:54,390 --> 00:01:01,510
Và đây là lúc Acme dành phần lớn thời gian để suy nghĩ về những sản phẩm tốt hơn đối thủ cạnh tranh về mặt kế toán.

7
00:01:01,560 --> 00:01:12,310
Điều John đã nói với chúng ta là Achmat tuân theo các thông lệ kế toán tổng quát và không có gì khác biệt so với những thông lệ khác ngoại trừ việc có thể có một vài quy tắc kinh nghiệm khiến Acme trở nên khác biệt.

8
00:01:12,480 --> 00:01:22,890
Vậy bạn nghĩ quản lý sản phẩm và kế toán làm gì?  Toàn bộ tòa án hỗ trợ hoặc tên miền phụ di truyền tạm dừng video, suy nghĩ một chút và ghi câu trả lời ra một tờ giấy.

9
00:01:22,920 --> 00:01:34,230
Tiếp theo, tôi sẽ thảo luận về việc tôi nghĩ hai điều này thuộc về việc quản lý sản phẩm ở đâu.  John đề cập rằng Acme luôn quan tâm đến việc tạo ra các gói sản phẩm dành cho kỳ nghỉ tốt hơn so với các đối thủ cạnh tranh.

10
00:01:34,230 --> 00:01:42,990
Vì vậy, rõ ràng quản lý sản phẩm là không gian nơi Acme có thể làm những điều khác biệt so với đối thủ cạnh tranh và đạt được lợi thế cạnh tranh.

11
00:01:43,170 --> 00:01:51,240
Do đó nó sẽ thuộc danh mục kế toán khóa học.  John đề cập rằng việc đó không có gì đặc biệt và Ackman tuân theo các thông lệ kế toán tổng hợp.

12
00:01:51,240 --> 00:02:06,300
Vì vậy tôi sẽ đặt nó dưới tên miền phụ chung bên cạnh phần hỗ trợ khách hàng và quản lý đối tác.  Điều John đang nói với chúng ta về hỗ trợ khách hàng là Achmea cung cấp dịch vụ hỗ trợ khách hàng tốt nhất trong ngành để duy trì lợi thế cạnh tranh.

13
00:02:06,300 --> 00:02:16,140
Và có rất nhiều công cụ có sẵn để xây dựng chức năng hỗ trợ khách hàng.  Và Acme luôn tìm cách cải thiện chức năng này bằng cách nào đó từ góc độ quản lý phù hợp.

14
00:02:16,170 --> 00:02:22,960
John đang nói rằng các đối tác là huyết mạch của Rachman và Achmea muốn đảm bảo rằng các đối tác được hạnh phúc.

15
00:02:23,490 --> 00:02:30,090
Thách thức với việc quản lý đối tác là các hợp đồng rất phức tạp do có nhiều quy tắc kinh doanh.

16
00:02:30,510 --> 00:02:37,100
Vậy bạn nghĩ như thế nào?  Hỗ trợ khách hàng và quản lý đối tác?  Phân loại của mỗi người theo chủ nghĩa thực chứng này là gì?

17
00:02:37,110 --> 00:02:45,630
Bạn viết ra câu trả lời của mình rồi tôi sẽ trao đổi suy nghĩ của mình để hỗ trợ khách hàng.  John đã đề cập đến một số điều khiến tôi hơi bối rối.

18
00:02:45,690 --> 00:02:58,740
Bạn đã đề cập rằng bộ phận hỗ trợ khách hàng giúp Acme khác biệt với các đối thủ cạnh tranh, nhưng đồng thời, anh ấy cũng đề cập rằng có sẵn các công cụ hỗ trợ khách hàng để họ có thể đưa ra tòa hoặc miền hỗ trợ.

19
00:02:58,740 --> 00:03:08,760
Vì chúng tôi không chắc chắn vào thời điểm này nên tôi sẽ đặt nó ở đâu đó giữa hai điều đó và khi chúng tôi tìm hiểu thêm về điều đó, tôi sẽ đưa nó ra tòa hoặc hỗ trợ quản lý đối tác.

20
00:03:08,790 --> 00:03:17,120
John chỉ ra rằng ACMC không thể tồn tại nếu không có đối tác và chúng dường như là những hợp đồng phức tạp giữa Acme và các đối tác.

21
00:03:17,550 --> 00:03:24,030
Vì vậy, tôi sẽ đặt nó trong danh mục tên miền phụ cốt lõi bên cạnh tất cả các kênh bán hàng và nhân sự.

22
00:03:24,030 --> 00:03:32,790
Kênh bán hàng là cách Acme bán sản phẩm của mình tới người tiêu dùng, ví dụ như bán hàng trực tiếp và đại lý du lịch, v.v..

23
00:03:32,970 --> 00:03:44,960
Đội ngũ bán hàng luôn tìm kiếm những cách sáng tạo để bán sản phẩm Acme và nhân lực.  John đã đề cập rất thuận tiện với chúng tôi rằng đội ngũ quản lý biết họ đang làm gì.

24
00:03:44,970 --> 00:03:59,990
Họ la tuyệt nhât.  Vậy bạn nghĩ như thế nào?  Kênh bán hàng và nguồn nhân lực?  Tôi nghĩ rằng kênh bán hàng nên thuộc danh mục cốt lõi vì đội ngũ bán hàng của Acme luôn tìm kiếm những cách sáng tạo để bán sản phẩm và nguồn nhân lực của họ.

25
00:04:00,000 --> 00:04:10,640
Rõ ràng đó là một tên miền phụ chung, vì các hoạt động nhân sự tại Acme đã khá hoàn thiện vào thời điểm này và dường như không có sự phức tạp nào đối với tên miền phụ tiếp thị.

26
00:04:10,680 --> 00:04:23,370
Điều John đang nói với chúng ta là các chiến dịch được quản lý bởi nhóm tiếp thị và nhóm quản lý sản phẩm và bán hàng cần điều chỉnh cho phù hợp với các chiến dịch này dựa trên thông tin họ nhận được từ hoạt động tiếp thị.

27
00:04:23,670 --> 00:04:30,130
Điều này cho thấy rằng việc bán hàng và quản lý sản phẩm phụ thuộc vào hoạt động tiếp thị.

28
00:04:30,300 --> 00:04:40,260
Bạn nghĩ sao?  Vì vậy, có một điều rõ ràng.  Hoạt động tiếp thị sẽ tạo sự khác biệt cho Acme với các đối thủ cạnh tranh, nhưng đồng thời hoạt động tiếp thị dường như không hề phức tạp.

29
00:04:40,440 --> 00:04:49,980
Nhưng việc quản lý sản phẩm và chức năng của kênh bán hàng lại phụ thuộc vào hoạt động tiếp thị.  Vì vậy, tất cả đều đặt hoạt động tiếp thị vào danh mục hỗ trợ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000004.srt -->

1
00:00:00,500 --> 00:00:13,190
Bối cảnh kinh doanh, khi kết thúc bài giảng này, bạn sẽ có thể giải thích bối cảnh là gì, bối cảnh kinh doanh là gì và tại sao nó lại quan trọng đối với CNTT.  nhóm để hiểu bối cảnh kinh doanh?

2
00:00:13,670 --> 00:00:25,730
Hãy bắt đầu bằng một câu hỏi.  Giả sử bạn gặp một người và tên anh ta là Jack và Jack, hãy hỏi bạn, tôi nên thích một tài khoản có lãi suất cao hay tôi nên thích một tài khoản có lãi suất thấp?

3
00:00:26,060 --> 00:00:33,770
Và tại thời điểm này, bạn cần trả lời câu hỏi sẽ giúp Jack đưa ra quyết định.  Bạn sẽ bảo Jack làm gì?

4
00:00:34,760 --> 00:00:47,900
Điều thú vị về bài tập này là cả hai lựa chọn đều tốt.  Ví dụ: nếu Jack hỏi bạn câu hỏi này vì anh ấy muốn mở một tài khoản tiết kiệm, thì lựa chọn số một là phù hợp.

5
00:00:48,140 --> 00:01:10,030
Nghĩa là, anh ta nên chọn một tài khoản tiết kiệm có lãi suất cao, trong khi nếu Jack sẵn sàng mở tài khoản thẻ tín dụng thì anh ta nên chọn phương án thứ hai, vì lãi suất thấp có nghĩa là anh ta sẽ phải trả ít hơn.  cho công ty thẻ tín dụng về lãi suất gốc.

6
00:01:10,310 --> 00:01:21,230
Vì vậy, lý do tôi hỏi bạn câu hỏi này là để nói về thực tế là để đưa ra quyết định khách quan, bạn sẽ cần thêm thông tin hoặc sự kiện về tình huống đó.

7
00:01:21,620 --> 00:01:31,190
Đó là, bạn sẽ cần bối cảnh.  Tại sao Jack lại hỏi câu hỏi này?  Ý định của anh ấy là gì?  Jack định mở loại tài khoản nào?

8
00:01:31,490 --> 00:01:46,340
Đó là những gì bạn cần để giúp anh ấy đưa ra quyết định.  Định nghĩa từ điển về ngữ cảnh là chính những hoàn cảnh hoặc sự kiện này hình thành nên bối cảnh cho một tuyên bố hay một ý tưởng?

9
00:01:46,790 --> 00:01:54,860
Chúng ta hãy xem lại câu hỏi một lần nữa.  Nhưng lần này chúng ta có bối cảnh.  Jack đang tìm cách vay tiền ngân hàng trong trường hợp này.

10
00:01:55,040 --> 00:02:06,770
Bạn sẽ nói gì với anh ấy?  Rõ ràng, lần này bạn ở vị trí có thể hướng dẫn Jack với mức độ tin cậy cao và bạn sẽ nói với anh ấy rằng anh ấy nên chọn một tài khoản có lãi suất thấp.

11
00:02:06,860 --> 00:02:18,590
Bây giờ, bạn chắc hẳn đang thắc mắc, điều này liên quan thế nào đến tình hình kinh doanh?  Ý tưởng là với tư cách là một nhóm CNTT, bạn và đồng nghiệp của mình sẽ thực hiện bài tập thu thập kiến ​​thức.

12
00:02:18,890 --> 00:02:26,390
Và để thực hiện bài tập nghiền ngẫm kiến ​​thức này trong quá trình thiết lập doanh nghiệp, bạn phải nhận thức được bối cảnh kinh doanh.

13
00:02:26,390 --> 00:02:40,580
Trong trường hợp ngân hàng cung cấp các sản phẩm này, có nhiều người liên hệ và nhóm CNTT phải lưu ý đến bối cảnh khi họ diễn giải thông tin và kiến ​​thức thu thập được cho từng người liên hệ hoặc sản phẩm này.

14
00:02:40,910 --> 00:02:49,460
Điểm mấu chốt ở đây là để I.T.  Để hiểu được lĩnh vực kinh doanh, trước tiên họ phải hiểu bối cảnh kinh doanh.

15
00:02:49,730 --> 00:03:02,270
Đó là một ví dụ về thẻ tín dụng, giả sử SMB hoặc chủ đề.  Các chuyên gia cho biết số tiền tương tự nhận được từ khách hàng sẽ được ghi có vào tài khoản của khách hàng.

16
00:03:02,420 --> 00:03:19,060
Cái đó.  nhóm hiểu biết về bối cảnh thẻ tín dụng sẽ có thể hiểu nó khi khách hàng thanh toán hóa đơn thẻ tín dụng và họ có thể đưa ra mô hình trường hợp sử dụng có thể có trường hợp sử dụng cho hóa đơn thanh toán và cập nhật tài khoản.

17
00:03:19,790 --> 00:03:28,280
Bây giờ, hãy nói rằng I.T.  nhóm đang có cuộc họp với SME trong nhóm tài khoản tiết kiệm.  Không có tài khoản tiết kiệm.

18
00:03:28,280 --> 00:03:44,660
SME cũng đưa ra tuyên bố tương tự.  Số tiền nhận được từ khách hàng sẽ được ghi có vào tài khoản của khách hàng.  Bây giờ, vì nhóm đã biết về người liên hệ kinh doanh, chính là tài khoản tiết kiệm trong trường hợp này, nên họ sẽ diễn giải câu lệnh theo cách khác.

19
00:03:44,840 --> 00:03:55,100
Khách hàng gửi tiền vào tài khoản tiết kiệm và họ sẽ đưa ra một mô hình ca sử dụng, trông sẽ khác với mô hình ca sử dụng cho các khoản thanh toán bằng thẻ tín dụng.

20
00:03:55,460 --> 00:04:13,250
Bây giờ, nếu bạn đang nghĩ tại sao tôi lại chú trọng nhiều đến các mối liên hệ kinh doanh thì đó là vì việc thiếu hiểu biết về các mối liên hệ kinh doanh có thể dẫn đến nhầm lẫn và hiểu sai, đồng thời dẫn đến việc trình bày sai về các mô hình miền.

21
00:04:13,730 --> 00:04:25,280
Đã đến lúc bắt đầu với những bài học quan trọng từ bài học này.  Bối cảnh là những hoàn cảnh hoặc tác động hình thành nên bối cảnh cho một tuyên bố hoặc một ý tưởng để hiểu lĩnh vực kinh doanh.

22
00:04:25,310 --> 00:04:33,200
Điều bắt buộc là nhóm CNTT phải hiểu bối cảnh kinh doanh mà không có sự hiểu biết phù hợp về bối cảnh kinh doanh.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000005.srt -->

1
00:00:00,150 --> 00:00:08,760
Nhóm kinh doanh sử dụng ngôn ngữ kinh doanh, trong khi nhóm công nghệ có xu hướng sử dụng các thuật ngữ kỹ thuật trong giao tiếp của họ.

2
00:00:09,000 --> 00:00:16,260
Sự khác biệt về ngôn ngữ giữa các nhóm kinh doanh và I.T.  các nhóm có thể dẫn đến những thách thức về ngôn ngữ.

3
00:00:16,260 --> 00:00:27,210
Thiết kế hướng miền đề xuất sử dụng ngôn ngữ phổ biến để giải quyết những thách thức ngôn ngữ này.  Tôi sẽ bắt đầu bài học này bằng một bài tập vui nhộn nhanh chóng.

4
00:00:27,570 --> 00:00:36,540
Nếu tôi nói từ cá ngừ, bạn sẽ nghĩ đến điều gì?  Và nếu bạn đang nghĩ về cá thì bạn đã đúng, vì trong tiếng Nhật, cá ngừ có nghĩa là cá lớn.

5
00:00:37,110 --> 00:00:46,900
Nhưng nếu bạn ở một quốc gia nói tiếng Tây Ban Nha và yêu cầu cá ngừ, bạn sẽ không nhận được cá mà sẽ nhận được một cây xương rồng vì trong tiếng Tây Ban Nha, cá ngừ có nghĩa là xương rồng.

6
00:00:46,950 --> 00:00:54,960
Thế còn mì ống thì sao?  Bây giờ, nếu bạn đang nghĩ về một loại mì nào đó thì bạn đã đúng, vì trong tiếng Ý mì ống có nghĩa là mì.

7
00:00:55,120 --> 00:01:02,020
Nhưng nếu bạn yêu cầu mì ống ở Ba Lan, bạn sẽ nhận được kem đánh răng vì trong tiếng Ba Lan, mì ống có nghĩa là kem đánh răng.

8
00:01:02,260 --> 00:01:09,900
Không, tôi khá chắc chắn rằng bạn biết từ hôn.  Đừng yêu cầu điều đó ở Thụy Điển vì trong tiếng Thụy Điển, kess có nghĩa là đái.

9
00:01:10,170 --> 00:01:21,850
Thông điệp ở đây là cùng một giọng điệu được sử dụng ở các khu vực khác nhau có thể dẫn đến nhầm lẫn và điều đó đúng ngay cả đối với ngôn ngữ kinh doanh được sử dụng trong nhiều miền.

10
00:01:21,990 --> 00:01:31,830
Điều đó có nghĩa là nếu bạn đang sử dụng các thuật ngữ kinh doanh từ tên miền này sang tên miền khác thì điều đó có thể dẫn đến nhầm lẫn và hiểu sai.

11
00:01:32,100 --> 00:01:43,030
Hãy tìm hiểu sâu hơn một chút.  Mỗi ngành đều có biệt ngữ riêng.  Ý tôi là song ngữ, một tập hợp các thuật ngữ mà các chuyên gia trong ngành hoặc nghề đó sử dụng.

12
00:01:43,590 --> 00:01:52,590
Hãy nghĩ về người kế toán, một kỹ sư và một bác sĩ.  Tất cả họ đều sử dụng một bộ công cụ chỉ có ý nghĩa trong nghề nghiệp của họ.

13
00:01:52,770 --> 00:02:04,920
Trên thực tế, trong cùng một ngành, chúng có thể là những chuyên ngành.  Ví dụ, có nhiều loại kế toán viên là kiểm toán viên, kế toán quản trị, kế toán pháp y, v.v.

14
00:02:05,310 --> 00:02:18,790
Và mỗi loại kế toán viên chuyên ngành khác nhau này có những bộ sách khác nhau, có thể có hoặc không có ý nghĩa bên ngoài lĩnh vực chuyên môn của họ trên cùng một dòng.

15
00:02:18,810 --> 00:02:36,400
Nếu bạn nghĩ về một doanh nghiệp có nhiều bộ phận, nhiều phòng ban hoặc nhiều nhóm thì các nhóm này trong Doanh nghiệp có biệt ngữ riêng và các chuyên gia trong các nhóm này sử dụng ngôn ngữ của nhóm cũng như mọi hoạt động giao tiếp của họ.

16
00:02:36,780 --> 00:02:52,290
Về cơ bản, điều đó có nghĩa là khi các chuyên gia về miền tài khoản tiết kiệm này sẽ cung cấp kiến ​​thức hoặc thông tin cho bộ phận CNTT.  chuyên gia, họ sẽ sử dụng ngôn ngữ được sử dụng trong lĩnh vực tài khoản tiết kiệm.

17
00:02:52,380 --> 00:03:03,650
Tương tự, một chuyên gia về miền từ miền thẻ tín dụng sẽ sử dụng bộ sưu tập thẻ tín dụng để giải thích cách hoạt động của miền thẻ tín dụng.

18
00:03:04,200 --> 00:03:13,220
Vì vậy, rõ ràng để hiểu tên miền hoặc để có được kiến ​​thức về tên miền, người ta phải hiểu ngôn ngữ được sử dụng bởi các chuyên gia tên miền.

19
00:03:13,230 --> 00:03:21,060
Nhưng có một số thách thức.  Thử thách đầu tiên là một điều hiển nhiên.  Có nhiều ngôn ngữ kinh doanh trên toàn doanh nghiệp.

20
00:03:21,330 --> 00:03:36,950
Trong trường hợp là ngân hàng, nhóm kinh doanh đối với tài khoản tiết kiệm có thể sử dụng các điều khoản như rút tiền gửi tín dụng Dovid, trong khi nhóm kinh doanh đối với thẻ tín dụng có thể sử dụng các điều khoản như thanh toán tín dụng, ứng tiền mặt cho người bán, v.v.

21
00:03:37,200 --> 00:03:49,380
Thách thức ở đây là để xây dựng các hệ thống phức tạp, I.T.  các nhóm phải học nhiều ngôn ngữ kinh doanh được các chuyên gia sử dụng trong bối cảnh các miền hoặc miền phụ khác nhau.

22
00:03:49,440 --> 00:04:06,810
Thách thức thứ hai là cùng một thuật ngữ có thể xuất hiện trong bối cảnh các lĩnh vực kinh doanh khác nhau.  Ví dụ, trong trường hợp tài khoản tiết kiệm và tên miền phụ thẻ tín dụng, bạn sẽ thấy có một thuật ngữ chung là tín dụng và ý nghĩa của thuật ngữ chung này là khác nhau.

23
00:04:06,810 --> 00:04:17,940
Tín dụng trong trường hợp tài khoản tiết kiệm có thể có nghĩa là tiền gửi của khách hàng và trong trường hợp thẻ tín dụng, nó có thể có nghĩa là khoản thanh toán của khách hàng đối với hóa đơn thẻ tín dụng.

24
00:04:17,970 --> 00:04:28,950
Vì vậy, thách thức ở đây là cùng một thời điểm trên nhiều miền có thể có ý nghĩa khác nhau, tùy thuộc vào ngữ cảnh và điều này có thể gây nhầm lẫn giữa các mục.

25
00:04:29,610 --> 00:04:42,060
Thử thách thứ ba liên quan đến việc nó có biệt ngữ riêng.  Getters và setters tạo và xóa đối tượng DBI và nhiều lần tương tự.

26
00:04:42,210 --> 00:04:53,040
Đây là những thuật ngữ thường được sử dụng cho các mặt hàng và các nhóm công nghệ có xu hướng dịch các thuật ngữ kinh doanh sang biệt ngữ hoặc mặt hàng EITE.

27
00:04:53,050 --> 00:04:59,760
Và vì vậy khi họ nhận được thông tin về tên miền hoặc những kiến ​​thức về tên miền từ các chuyên gia về tên miền.

28
00:05:00,110 --> 00:05:19,240
Trên thực tế, chúng không được dịch sang các thuật ngữ công nghệ, giao tiếp từ chuyên gia miền đến ý tưởng điều gì xảy ra theo ngôn ngữ miền, trong khi giao tiếp từ chuyên gia sở hữu trí tuệ đến chuyên gia miền diễn ra theo ngôn ngữ công nghệ?

29
00:05:19,450 --> 00:05:25,990
Đây là cách nó có thể diễn ra.  Trong trường hợp chuyên gia tài khoản tiết kiệm của chúng tôi thảo luận về cách mở tài khoản.

30
00:05:26,140 --> 00:05:36,030
Lịch sử thẻ tín dụng của khách hàng Wiecek.  Sau đó, chúng tôi mở tài khoản tiết kiệm cho khách hàng và gửi số tiền ban đầu vào tài khoản của khách hàng.

31
00:05:36,160 --> 00:05:50,290
Vốn chủ sở hữu có thể chuyển nó thành lịch sử tín dụng.  Sau đó, chúng ta sẽ tạo tài khoản và cơ sở dữ liệu, sau đó chúng ta sẽ đặt số tiền ban đầu trên đối tượng tài khoản.

32
00:05:50,290 --> 00:05:59,760
Do đó, mỗi khi doanh nghiệp và các nhóm giao tiếp, họ cần thực hiện việc dịch thuật giữa các điều khoản kinh doanh và các mặt hàng.

33
00:05:59,770 --> 00:06:09,000
Và việc dịch qua lại này dẫn đến việc mất ý nghĩa và nhầm lẫn giữa ID và nhóm miền.

34
00:06:09,220 --> 00:06:25,640
Tại thời điểm này, bạn có thể nói, được rồi, tôi biết vấn đề sẽ cho tôi biết giải pháp.  Thiết kế hướng miền gợi ý thiết lập một ngôn ngữ chung trong từng bối cảnh kinh doanh và ngôn ngữ này được tất cả các bên liên quan sử dụng, bao gồm cả nhóm CNTT.

35
00:06:25,690 --> 00:06:34,110
Ngôn ngữ này được gọi là ngôn ngữ phổ biến.  Đây là một trong những mô hình chiến lược trong thiết kế Theo nhu cầu.

36
00:06:34,210 --> 00:06:47,750
Trong các bài học sau, bạn sẽ tìm hiểu chi tiết về ngôn ngữ phổ biến và bạn cũng sẽ tìm hiểu cách nó giúp chia miền thành nhiều phần phù hợp để xây dựng các dịch vụ vi mô.

37
00:06:47,770 --> 00:07:10,500
Đã đến lúc bắt đầu với những bài học quan trọng từ bài học này.  NÓ.  các nhóm phải học ngôn ngữ kinh doanh.  NÓ.  các đội có I.T.  biệt ngữ và sự nhầm lẫn xảy ra do sự dịch thuật giữa miền và thiết kế hướng miền ngôn ngữ IP, chẳng hạn như việc tạo ra một ngôn ngữ chung phải được sử dụng bởi tất cả các bên liên quan, bao gồm cả CNTT.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000006.srt -->

1
00:00:00,150 --> 00:00:17,010
Ở bài trước tôi giới thiệu với các bạn thuật ngữ ngôn ngữ phổ biến trong bài giảng này, Al Gore, đặc điểm của ngôn ngữ phổ biến thảo luận về cách xây dựng và quản lý ngôn ngữ phổ biến và ngôn ngữ phổ biến được sử dụng ở đâu.

2
00:00:17,460 --> 00:00:29,190
Ngôn ngữ phổ biến là một trong những mô hình chiến lược và thiết kế hướng miền, thiết kế hướng miền, chẳng hạn như thiết lập một ngôn ngữ chung trong từng bối cảnh kinh doanh.

3
00:00:29,400 --> 00:00:38,550
Và ngôn ngữ chung này được gọi là ngôn ngữ phổ biến.  Ý nghĩa tiếng Anh của khắp nơi là liên tục gặp phải hoặc nhìn thấy.

4
00:00:38,790 --> 00:00:46,650
Ý tưởng là ngôn ngữ phổ biến giải quyết tất cả những thách thức ngôn ngữ mà tôi đã thảo luận trước đó.

5
00:00:47,010 --> 00:00:52,980
Ngôn ngữ phổ biến có thể được coi là một phương ngữ được sử dụng bởi các nhóm khác nhau trong một tổ chức.

6
00:00:53,340 --> 00:01:04,320
Một phương ngữ được xác định bởi từ vựng và ngôn ngữ phổ biến có định nghĩa rõ ràng về ngữ cảnh mà từ vựng hoặc bảng chú giải thuật ngữ áp dụng.

7
00:01:04,530 --> 00:01:20,660
Bảng thuật ngữ này chứa các thuật ngữ và từ viết tắt phổ biến được sử dụng trong ngữ cảnh được xác định.  Tùy chọn, nó cũng có thể giúp làm ví dụ về cách sử dụng các thuật ngữ và từ viết tắt, đồng thời nó cũng có thể có tham chiếu hoặc liên kết đến nội dung có liên quan.

8
00:01:21,150 --> 00:01:28,770
Tại thời điểm này, bạn có thể nói rằng nó trông giống như Từ điển Doanh nghiệp Doanh nghiệp và bạn đã đúng ở một mức độ nào đó.

9
00:01:28,770 --> 00:01:42,120
Đó là một thuật ngữ từ điển, nhưng có sự khác biệt.  Hãy để tôi giải thích nó bằng một ví dụ.  Trong một bài giảng, tôi đã nói về kinh nghiệm của mình khi xây dựng một mô hình kinh doanh doanh nghiệp thống nhất.

10
00:01:42,510 --> 00:01:56,640
Dự án đó cũng bao gồm việc tạo ra một từ điển kinh doanh.  Và từ điển kinh doanh mà tôi đã tạo này có các thuật ngữ trong toàn doanh nghiệp và nó cũng có logic cho nhiều mục khác.

11
00:01:56,640 --> 00:02:04,890
Và logic này về cơ bản đã hướng dẫn người sử dụng từ điển về ý nghĩa của thuật ngữ này trong các ngữ cảnh khác nhau.

12
00:02:05,130 --> 00:02:19,250
Và điều đó đã làm tăng thêm sự phức tạp cho việc sử dụng từ điển kinh doanh này.  Khi kết thúc dự án này, tôi đã giao cuốn từ điển kinh doanh này cho một nhà phân tích kinh doanh, người quản lý nó một cách tập trung trong một trang tính Excel.

13
00:02:19,290 --> 00:02:28,040
Bạn có thể tưởng tượng cuốn từ điển kinh doanh này đã đi đến đâu trong một khoảng thời gian.  Ngôn ngữ phổ biến không được tạo và quản lý tập trung.

14
00:02:28,080 --> 00:02:47,560
Có nhiều ngôn ngữ phổ biến trong một tổ chức.  Vì vậy, trong trường hợp của ngân hàng, sẽ có một ngôn ngữ phổ biến cho tài khoản tiết kiệm và một ngôn ngữ phổ biến cho tài khoản tín dụng, đồng thời các nhóm tài khoản tiết kiệm và thẻ tín dụng sẽ tạo và quản lý các ngôn ngữ phổ biến này một cách độc lập.

15
00:02:47,670 --> 00:03:01,350
Hãy đi với ngôn ngữ phổ biến xuất phát từ doanh nghiệp.  Xuất khẩu sử dụng ngôn ngữ bao gồm các thuật ngữ kinh doanh, trong khi chuyên gia công nghệ sử dụng ngôn ngữ bao gồm các thuật ngữ kỹ thuật.

16
00:03:01,350 --> 00:03:08,610
Ngôn ngữ phổ biến bao gồm các cuốn sách thường được sử dụng bởi cả chuyên gia kinh doanh và chuyên gia công nghệ.

17
00:03:08,610 --> 00:03:16,260
Và có một quan niệm sai lầm đằng sau ngôn ngữ phổ biến này rằng việc xuất khẩu kinh doanh luôn xác định ngôn ngữ.

18
00:03:16,620 --> 00:03:25,230
Trên thực tế, điều đó không phổ biến.  Ngôn ngữ không bị áp đặt bởi các chuyên gia.  Và không chỉ vậy, nó không phải là ngôn ngữ được sử dụng trong ngành.

19
00:03:25,230 --> 00:03:36,750
Hãy coi nó như một ngôn ngữ nhóm, một ngôn ngữ bộ lạc phát triển hoặc phát triển theo thời gian thông qua sự cộng tác giữa doanh nghiệp và các chuyên gia công nghệ.

20
00:03:36,750 --> 00:03:46,770
Nhóm tạo ra ngôn ngữ phổ biến có thể sử dụng nhiều kỹ thuật, chẳng hạn như vẽ sơ đồ quy trình, câu chuyện của người dùng, viết kịch bản phân cảnh và thậm chí là gây bão.

21
00:03:47,130 --> 00:03:57,720
Và điều này dẫn đến việc tạo ra ngôn ngữ phổ biến.  Điều quan trọng cần ghi nhớ là việc tạo ra ngôn ngữ phổ biến không phải là công việc chỉ làm một lần.

22
00:03:57,870 --> 00:04:14,910
Đó là một quá trình liên tục vì ngôn ngữ phải mất một thời gian để đạt đến mức độ trưởng thành cao.  Khi một câu hỏi phổ biến được đặt ra vào thời điểm này là liệu có bất kỳ công cụ đặc biệt nào để tạo và quản lý ngôn ngữ phổ biến hay không thì câu trả lời ngắn gọn là không.

23
00:04:15,300 --> 00:04:28,920
Bạn có thể sử dụng bất kỳ công cụ nào miễn là nó giúp tất cả thành viên trong nhóm có thể tiếp cận được ngôn ngữ phổ biến này.  Các công cụ cộng tác và chia sẻ kiến ​​thức như hội nghị và quip thường được sử dụng.

24
00:04:28,980 --> 00:04:42,930
Xin lưu ý rằng đây không phải là công cụ cộng tác và chia sẻ kiến ​​thức duy nhất.  Bất kỳ công cụ nào có sẵn trong tổ chức của bạn sẽ giúp các thành viên trong nhóm của chúng tôi có thể dễ dàng tiếp cận ngôn ngữ phổ biến này.

25
00:04:43,650 --> 00:04:51,000
Khi nhóm đã đạt đến mức độ trưởng thành khá cao đối với ngôn ngữ phổ biến của mình, họ nên bắt đầu sử dụng nó cho mọi thứ.

26
00:04:51,000 --> 00:04:59,880
Và sau đó ngôn ngữ này sẽ phát triển theo thời gian.  Các chuyên gia tên miền nên sử dụng nó.  Các đội giao hàng phải sử dụng nó cho công việc chung hàng ngày của họ.

27
00:05:00,330 --> 00:05:15,310
Và tất cả tài liệu nên sử dụng ngôn ngữ phổ biến nếu nhóm đang phát triển tài liệu và họ tạo một thuật ngữ mới hoặc tìm thấy một thuật ngữ mới, thì thuật ngữ đó sẽ được thêm vào ngôn ngữ phổ biến vào cuối ngày.

28
00:05:15,330 --> 00:05:27,150
Ngôn ngữ phổ biến phải đóng vai trò là nguồn thông tin chính xác cho tất cả mọi người sử dụng vào thời điểm ngôn ngữ phổ biến đó được sử dụng trong mã ứng dụng cũng như trong mã thử nghiệm.

29
00:05:27,270 --> 00:05:38,050
Cuối cùng nhưng không kém phần quan trọng, các nhóm phải sử dụng ngôn ngữ phổ biến trong tất cả các cuộc trò chuyện của mình.  Vì vậy, tại thời điểm này bạn có thể hỏi lợi ích của việc làm đó là gì?

30
00:05:38,490 --> 00:05:49,260
Chà, hãy nhớ lại ví dụ mà tôi đã thảo luận trong một trong những bài giảng trước đây tại Chuyên gia miền và các chuyên gia ý tưởng đang nghiên cứu thiết kế phần mềm.

31
00:05:49,710 --> 00:06:01,020
Cái đó.  chuyên gia phải dịch ngôn ngữ miền sang I.T.  ngôn ngữ.  Bản dịch này là một thách thức lớn với việc sử dụng ngôn ngữ chung.

32
00:06:01,530 --> 00:06:09,700
Bản dịch này không còn cần thiết nữa vì cả chuyên gia và chuyên gia lĩnh vực sẽ sử dụng ngôn ngữ phổ biến.

33
00:06:09,900 --> 00:06:28,830
Vì vậy, trong ví dụ này, một chuyên gia tên miền đang giải thích cách mở tài khoản tiết kiệm và I.T.  chuyên gia đang suy nghĩ về quy trình theo ngôn ngữ phổ biến, đó là ngôn ngữ mà chuyên gia lĩnh vực đang sử dụng để giải thích quy trình kinh doanh.

34
00:06:29,340 --> 00:06:44,340
Mọi thứ trở nên nhất quán và dễ theo dõi hơn đối với cả chuyên gia tên miền cũng như chuyên gia ID.  Một tác dụng phụ thú vị của ngôn ngữ phổ biến là nó giúp xác định các liên hệ chồng chéo.

35
00:06:44,520 --> 00:06:55,260
Và điều đó có nghĩa là chúng ta có thể sử dụng ngôn ngữ phổ biến để chia các mối liên hệ kinh doanh của mình thành các phần nhỏ hơn và theo các thiết kế khác nhau về miền.

36
00:06:55,260 --> 00:07:02,350
Những phần nhỏ hơn của bối cảnh này được gọi là bối cảnh liên kết.  Thêm về điều này trong các bài giảng sau.

37
00:07:02,880 --> 00:07:11,490
Trong bài học này, bạn đã học về ngôn ngữ phổ biến.  Ba điểm chính cần ghi nhớ.  Ngôn ngữ phổ biến phát triển trong một khoảng thời gian.

38
00:07:11,760 --> 00:07:19,800
Đây không phải là công việc chỉ làm một lần mà nó được tạo ra bởi sự cộng tác giữa chuyên gia tên miền và chuyên gia công nghệ.

39
00:07:19,980 --> 00:07:26,820
Ngôn ngữ phổ biến không yêu cầu bất kỳ công cụ đặc biệt nào mà bạn có thể sử dụng bất kỳ nền tảng cộng tác tri thức nào.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000007.srt -->

1
00:00:00,180 --> 00:00:12,060
Mục tiêu của bài tập này là xác định các thuật ngữ ngôn ngữ phổ biến dành cho nhóm bán hàng và nhóm quản lý sản phẩm ACMS trong bài tập này.

2
00:00:12,090 --> 00:00:21,140
Giả sử bạn là I.T.  trưởng nhóm đã phỏng vấn hai chuyên gia từ lĩnh vực kinh doanh Acme.

3
00:00:21,150 --> 00:00:28,740
John đến từ nhóm bán hàng còn Paul là giám đốc sản phẩm và là thành viên của nhóm quản lý sản phẩm.

4
00:00:29,220 --> 00:00:39,840
John là cố vấn du lịch.  Anh ấy là thành viên của nhóm bán hàng trực tiếp, làm việc trực tiếp với khách hàng để bán các gói kỳ nghỉ.

5
00:00:39,870 --> 00:00:51,670
John hiểu nhu cầu của khách hàng và dựa trên mong muốn, ngân sách và các khía cạnh khác của khách hàng, giúp họ lựa chọn gói kỳ nghỉ phù hợp do Acme cung cấp.

6
00:00:51,990 --> 00:01:01,890
Bây giờ, giả sử rằng bạn, với tư cách là I.T.  người đứng đầu đã phỏng vấn John và bạn đã bị bắt.  Tất cả các chi tiết cuộc phỏng vấn trong một bảng điểm tại thời điểm này.

7
00:01:02,010 --> 00:01:10,280
Mục tiêu của bạn là xác định tất cả các thuật ngữ ngôn ngữ yếu trong bản ghi đó.  Vì vậy, đây là bản ghi.

8
00:01:10,470 --> 00:01:16,950
Vui lòng đọc qua bản ghi này và xác định càng nhiều thuật ngữ càng tốt.  Hãy tiếp tục, tạm dừng video.

9
00:01:17,190 --> 00:01:31,680
Và tiếp theo, tôi sẽ thảo luận về các thuật ngữ mà tôi đã tìm thấy trong bản ghi này.  Được rồi, hãy đi đến phần giải pháp và chúng ta sẽ đọc qua từng đoạn văn này và xác định các thuật ngữ mà chúng ta đang sử dụng.

10
00:01:31,680 --> 00:01:40,080
Việc kinh doanh bán các gói kỳ nghỉ hoặc gói kỳ nghỉ là hoạt động đầu tiên trong quá trình bán hàng bắt đầu bằng việc khách hàng gọi cho chúng tôi.

11
00:01:40,440 --> 00:01:48,800
Thuật ngữ thứ hai ở đây là khách hàng dựa trên mong muốn của khách hàng.  Chúng tôi chọn các gói và mô tả nó.

12
00:01:49,140 --> 00:02:04,650
Bây giờ, tôi đang giả định ở đây rằng gói đề cập đến gói kỳ nghỉ, vì vậy tôi sẽ không thêm gói dưới dạng một thuật ngữ khác mà thay vào đó là trong phần mô tả cho gói kỳ nghỉ.

13
00:02:04,980 --> 00:02:15,270
Tôi sẽ chỉ nói rằng nó còn được gọi là package.  Nếu khách hàng tỏ ra quan tâm, chúng tôi sẽ bắt đầu đề xuất cho gói đã chọn.

14
00:02:15,270 --> 00:02:28,350
Vì vậy, đề xuất là một thuật ngữ khác.  Các gói có giá bán lẻ đề xuất nhưng nhóm sản phẩm của chúng tôi cũng đưa ra các ưu đãi mà chúng tôi có thể áp dụng cho các gói.

15
00:02:28,530 --> 00:02:41,070
Vì vậy, cung cấp là một thị trấn khác.  Những ưu đãi này về cơ bản là giảm giá dựa trên các tiêu chí khác nhau.  Vì vậy, chỉ cần lưu ý rằng ưu đãi còn được gọi là giảm giá.

16
00:02:41,430 --> 00:02:53,070
Sau khi khách hàng cam kết với đề xuất, chúng tôi sẽ thu thập chi tiết gói hàng.  Đó là chi tiết hành khách.  Vì vậy, hành lý hoặc hành khách là một mục khác mà chúng ta đã học.

17
00:02:53,070 --> 00:03:03,720
Tất cả thông tin được tập hợp thành một đơn đặt hàng, sau đó chúng tôi lấy thông tin thanh toán và gửi đề xuất đặt chỗ.

18
00:03:03,720 --> 00:03:13,830
Và nếu mọi việc suôn sẻ, chúng tôi sẽ nhận được xác nhận đặt phòng.  Đây là những thuật ngữ mà tôi đã xác định trong bản ghi này.

19
00:03:14,670 --> 00:03:26,540
Paul là giám đốc sản phẩm.  Anh ấy tham gia vào hai hoạt động chính.  Hoạt động đầu tiên là anh là người chịu trách nhiệm thiết kế các sản phẩm Acme.

20
00:03:26,730 --> 00:03:36,900
Hãy coi những sản phẩm này như những gói kỳ nghỉ được bán cho khách hàng.  Thứ hai, anh ta tham gia vào việc quản lý mối quan hệ với các đối tác.

21
00:03:37,200 --> 00:03:51,390
Và những đối tác quan trọng này là các hãng hàng không, tàu du lịch, v.v. Cả hai hoạt động này đều có ảnh hưởng trực tiếp hoặc gián tiếp đến dòng doanh thu và từ đó là lợi nhuận tại Acme.

22
00:03:51,810 --> 00:04:07,890
Vì vậy anh ấy đóng một vai trò cực kỳ quan trọng trong bài tập này.  Bạn sẽ xem qua bản ghi mà bạn đã ghi lại làm người dẫn đầu và xác định càng nhiều thuật ngữ ngôn ngữ phổ biến càng tốt tại thời điểm này.

23
00:04:08,040 --> 00:04:15,810
Vui lòng tiếp tục và tạm dừng video.  Tiếp theo, tôi sẽ thảo luận về giải pháp.  Được rồi.  Hy vọng rằng bạn đã chọn được tất cả các điều khoản có liên quan.

24
00:04:16,170 --> 00:04:24,540
Tôi chịu trách nhiệm về việc thiết kế sản phẩm và các mối quan hệ với nhà cung cấp.  Những sản phẩm này là những gì khách hàng mua từ Acme.

25
00:04:24,660 --> 00:04:33,180
Vì vậy, có ba mục ở đây là sản phẩm, nhà cung cấp và khách hàng.  Dựa trên việc nghiên cứu thị trường, tôi chọn lọc các bộ phận của sản phẩm.

26
00:04:33,690 --> 00:04:42,420
Đôi khi chúng tôi gọi những sản phẩm này là gói.  Vì vậy, đây là những gì nó được.  Sản phẩm còn được gọi là Bundle.

27
00:04:42,630 --> 00:04:52,110
Có một số nguyên tắc đánh dấu nhất định mà tôi cần phải tuân theo để làm cho sản phẩm có lãi.  Ngoài ra, tôi cần phải tính đến tính thời vụ.

28
00:04:52,110 --> 00:04:59,430
Vì vậy, mức tăng giá và tính thời vụ là hai thuật ngữ mới mà chúng ta đã học ở đây.  Định giá chính xác của gói.

29
00:05:00,220 --> 00:05:11,040
Đàm phán cẩn thận với các nhà cung cấp, một số nhà cung cấp, chẳng hạn như hãng hàng không và khách sạn, cung cấp cho chúng tôi mức giá sỉ, thấp hơn giá thị trường.

30
00:05:11,350 --> 00:05:22,450
Một số nhà cung cấp thích hợp tác với chúng tôi để hưởng hoa hồng hơn.  Chúng tôi ký hợp đồng với các nhà cung cấp về cơ cấu hoa hồng cũng như mọi hình phạt và điều khoản.

31
00:05:22,750 --> 00:05:35,650
Vì vậy, trong đoạn này, chúng ta tìm hiểu ba lần về giá cả, giá thị trường và hoa hồng.  Vì vậy, đây là những thuật ngữ mà chúng tôi đã học được từ Paul, người thuộc miền phụ quản lý sản phẩm.

32
00:05:36,680 --> 00:05:53,510
Tiếp theo, chúng ta hãy so sánh song song các thuật ngữ mà chúng ta đã xác định, nhận xét đầu tiên tôi đưa ra ở đây là có một thuật ngữ chung là khách hàng dùng để chỉ khách hàng cuối và thuật ngữ này đang được cả Paul và Paul sử dụng.  John.

33
00:05:53,750 --> 00:06:03,800
Một quan sát khác mà tôi có ở đây là sản phẩm và gói kỳ nghỉ, còn được gọi là Bundall, đề cập đến một khái niệm tương tự nhưng các thuật ngữ khác nhau.

34
00:06:03,980 --> 00:06:20,240
Ngoài hai điều khoản này, cho đến nay không có sự trùng lặp nào về các điều khoản.  Lý do tôi nhấn mạnh cho đến nay là vì chúng tôi đã tiến hành phân tích một cách hạn chế vì chúng tôi sẽ bắt đầu tìm hiểu sâu hơn về các lĩnh vực tương ứng của Paul và John.

35
00:06:20,480 --> 00:06:27,350
Chúng tôi tìm hiểu thêm các thuật ngữ và có khả năng trùng lặp giữa các thuật ngữ mới mà chúng tôi sẽ học từ chúng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000008.srt -->

1
00:00:00,180 --> 00:00:10,490
Bối cảnh liên kết trong một trong những bài giảng trước đây tôi đã giới thiệu với bạn với Tom Bodett, bối cảnh và bối cảnh là một trong những mô hình chiến lược trong thiết kế hướng miền.

2
00:00:10,740 --> 00:00:18,870
Trong bài học này, tôi đã thảo luận về những thách thức liên quan đến việc sử dụng một mô hình chung trên nhiều miền phụ.

3
00:00:18,900 --> 00:00:29,580
Những thách thức đạo đức chung này được giải quyết bằng bối cảnh hỗn hợp.  Tôi đã thảo luận về các đặc điểm của bối cảnh liên kết, sau đó là thảo luận về mối quan hệ giữa bối cảnh liên kết và các mô hình miền.

4
00:00:30,120 --> 00:00:45,040
Các mô hình miền doanh nghiệp thường được tạo bằng cách bố trí các khả năng của miền trong doanh nghiệp.  Vì vậy, trong lĩnh vực ngân hàng, có nhiều khả năng như ngân hàng bán lẻ, cho vay tuân thủ thẻ tín dụng và quản lý khách hàng.

5
00:00:45,060 --> 00:00:54,860
Mỗi trong số này đại diện cho một khu vực chức năng trong một ngân hàng.  Theo truyền thống, các mô hình chung được tạo ra để sử dụng trong toàn doanh nghiệp.

6
00:00:55,050 --> 00:01:03,920
Hãy nghĩ về một khách hàng.  Mỗi khả năng này đều có chức năng.  Các khu vực cần một số loại đại diện cho khách hàng và thuật ngữ kỹ thuật.

7
00:01:04,200 --> 00:01:27,720
Hãy suy nghĩ về một khách hàng, tầng lớp hoặc đối tượng khách hàng để tạo ra một mô hình miền chung.  Chuyên gia kỹ thuật sẽ kết hợp định nghĩa lớp với nhiều thuộc tính và để làm điều đó, chuyên gia kỹ thuật sẽ thu thập các thuộc tính từ nhiều chuyên gia trên các miền này, mặc dù đối tượng khách hàng có thể có nhiều thuộc tính.

8
00:01:27,870 --> 00:01:35,060
Mỗi khả năng này sẽ chỉ cần một vài thuộc tính trong số đó để quản lý mô hình về lâu dài.

9
00:01:35,460 --> 00:01:50,000
Những đội nào khác sẽ được giao quyền sở hữu mô hình chung?  Và điều này sẽ dẫn đến sự phụ thuộc giữa các nhóm ở các lĩnh vực năng lực hoặc chức năng khác vào chủ đề trọng tâm là quản lý mô hình.

10
00:01:50,580 --> 00:01:57,420
Và sự phụ thuộc này sẽ dẫn đến mất đi tính linh hoạt, xung đột và độ phức tạp của thiết kế hướng miền.

11
00:01:57,630 --> 00:02:06,600
Và đây là vấn đề với mô hình miền chung.  Bằng cách chia miền thành các phần độc lập được gọi là bối cảnh bị chặn.

12
00:02:06,870 --> 00:02:19,350
Điều này giải quyết sự phức tạp vốn có trong mô hình doanh nghiệp thống nhất hoặc các mô hình chung.  Có ba từ khóa ở đây độc lập, gắn kết và liên hệ.

13
00:02:19,470 --> 00:02:35,100
Bạn đã biết ý nghĩa của ngữ cảnh giới hạn ở đây có nghĩa là bị giới hạn trong hoặc trong một loại ranh giới nào đó, và ý nghĩa của từ độc lập là không bị kiểm soát từ bên ngoài hoặc không phụ thuộc vào bất kỳ thực thể nào khác.

14
00:02:35,670 --> 00:02:43,200
Hãy nghĩ đến các quốc gia ở Châu Âu.  Mỗi quốc gia ở châu Âu đều độc lập với ranh giới được xác định rõ ràng.

15
00:02:43,590 --> 00:02:58,070
Nếu có một sự thay đổi chính trị ở bất kỳ quốc gia nào, nó sẽ không có tác động trực tiếp đến các quốc gia khác.  Ở châu Âu, luật được quy định tại mỗi quốc gia này đều được áp dụng trong phạm vi ranh giới của mỗi quốc gia này.

16
00:02:58,350 --> 00:03:13,620
Nói cách khác, bạn không thể mã hóa luật cho Đức ở Nga để biện minh cho trường hợp của mình.  Và cuối cùng nhưng không kém phần quan trọng, văn hóa, chuẩn mực xã hội và ngôn ngữ ở mỗi quốc gia đều được hiểu rõ trong ranh giới của quốc gia đó.

17
00:03:13,930 --> 00:03:24,360
Vì vậy, ví dụ, nếu bạn nói tiếng Ba Lan trong ranh giới Ba Lan, bạn sẽ giỏi.  Nhưng nếu bạn cố gắng sử dụng tiếng Ba Lan và chẳng hạn như Pháp, bạn sẽ gặp khó khăn.

18
00:03:24,960 --> 00:03:33,390
Vì vậy, mỗi quốc gia này có thể được coi là đại diện cho một bối cảnh gắn kết ở châu Âu.  Được rồi, nói về địa lý thế là đủ rồi.

19
00:03:33,420 --> 00:03:42,090
Hãy quay trở lại công việc kinh doanh ngay bây giờ.  Trong trường hợp của một ngân hàng, những ranh giới này có thể được xác định bằng khả năng của lĩnh vực kinh doanh.

20
00:03:42,120 --> 00:03:48,660
Vì vậy, chúng tôi có các mối liên hệ giới hạn ở đây về ngân hàng bán lẻ, các khoản vay tuân thủ thẻ tín dụng và quản lý khách hàng.

21
00:03:49,290 --> 00:04:03,900
Bây giờ, bạn có thể nói rằng chỉ thử những ranh giới xung quanh những khả năng này là không đủ.  Và bạn nói đúng, có một số đặc điểm nhất định phải được đáp ứng để những khả năng bị giới hạn này được gọi là bối cảnh bị giới hạn.

22
00:04:04,260 --> 00:04:14,070
Điều đầu tiên là mỗi liên hệ bị giới hạn này phải được thể hiện bằng mô hình miền riêng của nó.  Tức là không có sự chia sẻ về mô hình.

23
00:04:14,640 --> 00:04:24,440
Mô hình miền được xây dựng cho bối cảnh giới hạn chỉ được áp dụng trong phạm vi ranh giới của bối cảnh giới hạn đó.

24
00:04:24,450 --> 00:04:33,660
Vì vậy, ví dụ, mô hình ngân hàng bán lẻ có thể không có cách giải thích có ý nghĩa trong bối cảnh bị giới hạn bởi thẻ tín dụng.

25
00:04:33,840 --> 00:04:44,720
Và điều thứ ba là ngôn ngữ được sử dụng bằng các phương tiện khác trong bối cảnh giới hạn không gặp phải bất kỳ thách thức ngôn ngữ nào mà tôi đã thảo luận trước đó.

26
00:04:44,850 --> 00:04:56,490
Nói cách khác, mỗi bối cảnh bom nhỏ đều có ngôn ngữ phổ biến của riêng nó.  Chúng ta hãy đi qua từng đặc điểm này để chỉ ra đặc điểm đầu tiên là các mô hình miền độc lập.

27
00:04:56,490 --> 00:05:07,360
Trong ví dụ về ngân hàng, chúng ta có những giới hạn này.  Bây giờ, nếu bạn nghĩ về điều đó, mỗi khả năng này có các yêu cầu về mô hình hóa hoặc yêu cầu về mô hình khác nhau.

28
00:05:07,680 --> 00:05:25,850
Nếu bạn quay lại phần trình bày đối tượng khách hàng của chúng ta, ngân hàng bán lẻ có thể chỉ cần thông tin nhân khẩu học, thông tin về khách hàng và thông tin nhân viên để mở tài khoản ngân hàng hoặc quản lý tài khoản ngân hàng, trong khi thẻ tín dụng có thể cần một cách trình bày khác về đối tượng khách hàng.  khách hàng.

29
00:05:25,980 --> 00:05:34,970
Điều đó không chỉ bao gồm nhân khẩu học và thông tin nhân viên mà còn có thêm thông tin về thu nhập và lịch sử tín dụng.

30
00:05:35,340 --> 00:05:51,540
Như bạn có thể thấy, ngân hàng bán lẻ và thẻ tín dụng, các bộ phận chức năng đều có những nhu cầu riêng và tương tự, các bộ phận chức năng khác trong ngân hàng sẽ có những nhu cầu riêng và chúng sẽ cần có đại diện riêng cho đối tượng khách hàng.

31
00:05:51,570 --> 00:05:59,580
Các mô hình này được tạo ra và quản lý độc lập bởi các nhóm công nghệ được phân công cho từng đơn vị chức năng này.

32
00:05:59,610 --> 00:06:07,380
Vì các mô hình này độc lập nên nhóm từ một đơn vị chức năng không cần phải có kiến ​​thức về các mô hình do nhóm quản lý.

33
00:06:07,380 --> 00:06:16,410
Ví dụ, ở một đơn vị chức năng khác, AT&T không cần phải có bất kỳ loại kiến ​​thức nào về các mô hình do nhóm thẻ tín dụng quản lý.

34
00:06:16,620 --> 00:06:24,240
Tương tự, nhóm thẻ tín dụng không cần phải có bất kỳ loại kiến ​​thức nào về các mô hình do nhóm bán lẻ quản lý.

35
00:06:24,420 --> 00:06:34,930
Và tất cả đều tóm gọn lại một điều, đó là các mô hình có thể phát triển độc lập giữa các đơn vị chức năng trong doanh nghiệp.

36
00:06:35,280 --> 00:06:46,890
Đặc điểm thứ ba của ngữ cảnh kết hợp là có một ngôn ngữ chứa đựng ý nghĩa trong ngữ cảnh bị ràng buộc và bạn đã biết ngôn ngữ này được gọi là gì.

37
00:06:47,130 --> 00:06:58,740
Đây là ngôn ngữ phổ biến.  Vì vậy, nói cách khác, mỗi ngữ cảnh bị giới hạn có một ngôn ngữ phổ biến có một tập hợp các thuật ngữ có ý nghĩa trong ngữ cảnh bị ràng buộc.

38
00:06:58,980 --> 00:07:09,090
Vì vậy, ví dụ: nhóm bán lẻ sẽ tạo ngôn ngữ phổ biến của riêng mình, trong khi nhóm thẻ tín dụng sẽ sử dụng ngôn ngữ phổ biến của riêng mình.

39
00:07:09,750 --> 00:07:17,730
Trong bài học này, bạn đã tìm hiểu về DTT ngữ cảnh bị giới hạn, chẳng hạn như chia không gian bài toán thành các liên hệ bị giới hạn.

40
00:07:18,000 --> 00:07:26,880
Bối cảnh bị giới hạn có thể được coi là ranh giới khái niệm xung quanh khả năng kinh doanh.  Những liên hệ Mongered này có những đặc điểm nhất định.

41
00:07:27,060 --> 00:07:39,750
Các mô hình có thể được phát triển độc lập trong từng bối cảnh giới hạn.  Các mô hình được phát triển trong bối cảnh BONARD chỉ có khả năng áp dụng trong bối cảnh ranh giới đó.

42
00:07:39,870 --> 00:07:47,580
Mỗi bối cảnh giới hạn có ngôn ngữ phổ biến riêng, ngôn ngữ này chỉ có ý nghĩa trong bối cảnh giới hạn đó.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000009.srt -->

1
00:00:00,150 --> 00:00:12,870
Khám phá các liên hệ được liên kết trong bài học này, tôi sẽ cung cấp hướng dẫn cách khám phá các liên hệ được liên kết dựa trên cấu trúc, hoạt động kinh doanh, trách nhiệm xuất khẩu và các ứng dụng nguyên khối hiện có của tổ chức.

2
00:00:13,110 --> 00:00:22,800
Tôi sẽ bắt đầu bài học này về khám phá các liên hệ ngoại quan bằng cách nói rằng không có viên đạn bạc nào có thể giúp bạn khám phá các liên hệ ngoại quan trong miền của bạn.

3
00:00:23,010 --> 00:00:33,330
Bây giờ, điều này nghe có vẻ sáo rỗng đối với bạn, nhưng tôi đồng ý với các chuyên gia khi họ nói rằng việc khám phá 100 địa chỉ liên hệ trong một miền là một nghệ thuật chứ không phải khoa học.

4
00:00:33,720 --> 00:00:43,200
Tại thời điểm này, bạn có thể thắc mắc nếu không có quy trình xác định để khám phá bối cảnh liên kết, thì Raj sẽ thảo luận điều gì trong bài học này?

5
00:00:43,320 --> 00:01:03,270
Vâng, tôi sẽ chia sẻ với bạn hướng dẫn thực hiện quy trình khám phá đối với những người liên hệ Bundrick.  Và tôi đã tổng hợp hướng dẫn này dựa trên kinh nghiệm cá nhân của mình cũng như kinh nghiệm được các chuyên gia và học viên chia sẻ để khám phá những mối liên hệ gắn kết trong một miền.

6
00:01:03,450 --> 00:01:12,540
Bạn cần tận dụng các tài sản hiện có và bạn cần hợp tác với các chuyên gia trong lĩnh vực, hãy bắt đầu bằng cách xem xét cơ cấu tổ chức.

7
00:01:12,660 --> 00:01:25,200
Thông thường, các cấu trúc tổ chức có sẵn dưới dạng sơ đồ mô tả các khả năng kinh doanh hoặc lĩnh vực chức năng khác nhau trong tổ chức như một bước tiếp theo.

8
00:01:25,500 --> 00:01:36,720
Xác định các chuyên gia kinh doanh trong các lĩnh vực cốt lõi và hợp tác với họ để hiểu trách nhiệm của họ cũng như các hoạt động chính mà họ tham gia.

9
00:01:36,840 --> 00:01:48,590
Đi sâu hơn vào một số hoạt động chính khi bạn thực hiện hai nhiệm vụ này, hãy chú ý tìm kiếm manh mối trong ngôn ngữ kinh doanh được các chuyên gia trong lĩnh vực sử dụng.

10
00:01:48,600 --> 00:01:58,770
Nếu tổ chức của bạn đã đầu tư vào các ứng dụng nguyên khối, mô-đun, được thiết kế tốt thì chúng cũng có thể đóng vai trò là điểm khởi đầu cho bài tập này.

11
00:01:58,860 --> 00:02:09,180
Xem xét các mô-đun và ứng dụng nguyên khối và tạo ranh giới cho các mối liên hệ kinh doanh được thực hiện trong các ứng dụng đó.

12
00:02:09,610 --> 00:02:23,890
Nhìn chung, ý tưởng là thu thập manh mối từ các bài tập này và sau đó sử dụng những manh mối này để đánh dấu ranh giới cho bối cảnh được giới hạn nhằm mô tả từng bối cảnh này và cách sử dụng các manh mối này.

13
00:02:24,060 --> 00:02:35,390
Tôi sẽ sử dụng ví dụ về một ngân hàng.  Nhưng trước điểm quan trọng đó, xin đừng bận tâm đến việc tìm ra ranh giới hoàn hảo cho bối cảnh bị giới hạn của bạn vì việc này sẽ mất thời gian.

14
00:02:35,730 --> 00:02:46,480
Sau đó, bạn có thể bắt đầu với một số ranh giới.  Đây là gợi ý của tôi cho bạn.  Hầu hết các tổ chức đều giỏi ghi chép và duy trì cơ cấu tổ chức của họ.

15
00:02:46,500 --> 00:02:58,490
Vì vậy, nếu bạn đang bắt đầu lại từ đầu trong một tổ chức để hiểu bối cảnh giới hạn, thì tốt nhất bạn nên chú ý đến các chức năng kinh doanh được mô tả trong cơ cấu tổ chức.

16
00:02:58,620 --> 00:03:07,460
Vì vậy, đây là cơ cấu tổ chức của một ngân hàng và đây là các khả năng kinh doanh hoặc các lĩnh vực chức năng trong ngân hàng.

17
00:03:07,920 --> 00:03:16,200
Các chức năng kinh doanh này là các khả năng kinh doanh có thể được coi là điểm khởi đầu cho các liên hệ bị giới hạn.

18
00:03:16,350 --> 00:03:29,280
Vì vậy, trong trường hợp ngân hàng, chúng ta có thẻ ngân hàng tiêu dùng và dịch vụ thương mại, kinh doanh, ngân hàng, kho bạc, ngân hàng giao dịch, tổ chức tài chính và dịch vụ thanh toán và quốc tế.

19
00:03:29,430 --> 00:03:39,030
Hãy nhớ rằng đây là điểm khởi đầu và bạn cần nghiên cứu sâu hơn về từng khả năng kinh doanh này để tinh chỉnh các ranh giới này hơn nữa.

20
00:03:39,450 --> 00:03:51,480
Bước tiếp theo, bạn có thể xem xét trách nhiệm của từng chuyên gia kinh doanh và lưu ý rằng những chuyên gia kinh doanh này có thể chịu trách nhiệm về nhiều chức năng.

21
00:03:51,690 --> 00:04:00,420
Ví dụ, chuyên gia ngân hàng tiêu dùng trong ngân hàng có thể chịu trách nhiệm về tài khoản tiết kiệm và séc cũng như thẻ tín dụng.

22
00:04:00,540 --> 00:04:10,620
Và khi bạn đang thu thập thông tin và kiến ​​thức từ các chuyên gia kinh doanh này, hãy chú ý đến ngôn ngữ kinh doanh mà các chuyên gia này đang sử dụng.

23
00:04:11,040 --> 00:04:19,280
Các hoạt động chính của doanh nghiệp là những hoạt động mà doanh nghiệp phải thực hiện để mô hình kinh doanh hoạt động.

24
00:04:19,590 --> 00:04:29,430
Trong trường hợp ngân hàng tiêu dùng, ví dụ về các hoạt động chính như vậy là hoạt động hỗ trợ khách hàng, quản lý tài khoản và hoạt động chi nhánh.

25
00:04:29,820 --> 00:04:43,860
Đi sâu hơn vào từng hoạt động này với sự cộng tác của các chuyên gia kinh doanh sẽ giúp các chuyên gia hiểu được ranh giới bối cảnh trong lĩnh vực ngân hàng tiêu dùng.

26
00:04:44,250 --> 00:04:59,130
Bạn, với tư cách là chuyên gia CNTT, cần cộng tác với các chuyên gia kinh doanh để xác định các hoạt động chính phù hợp trong tổ chức của mình và sau đó tìm hiểu sâu hơn về từng hoạt động này.

27
00:04:59,130 --> 00:05:18,970
Và như bạn.  Việc thực hiện các hoạt động này đảm bảo rằng bạn nắm bắt được ngôn ngữ kinh doanh được sử dụng cho từng hoạt động này, việc sử dụng luồng của các hoạt động chính này và manh mối ngôn ngữ sẽ giúp bạn xác định các mối liên hệ gắn kết từ góc độ kinh doanh, trường hợp sử dụng và quy trình.

28
00:05:19,810 --> 00:05:35,290
Nếu bạn làm việc cho một tổ chức đã đầu tư vào việc xây dựng các ứng dụng mô-đun nguyên khối, được thiết kế tốt thì bạn thật may mắn vì bạn có thể sử dụng các ứng dụng được thiết kế tốt này để xác định các liên hệ được liên kết.

29
00:05:35,560 --> 00:05:50,980
Ví dụ: hãy xem xét một ứng dụng hoạt động chi nhánh, được nhân viên ngân hàng sử dụng để thực hiện các chức năng liên quan đến tài khoản trên nhiều sản phẩm như tài khoản tiết kiệm, tài khoản séc, tài khoản tín dụng và tài khoản cho vay.

30
00:05:51,130 --> 00:06:01,420
Giả sử tài khoản tiết kiệm và tài khoản séc được triển khai trong một mô-đun chung, vì vậy mô-đun này có thể đại diện cho các liên hệ ngoại quan cho tài khoản bán lẻ.

31
00:06:01,540 --> 00:06:13,040
Tương tự, thẻ tín dụng và tài khoản vay được triển khai trong các mô-đun độc lập của riêng chúng và mỗi mô-đun đó có thể đại diện cho các liên hệ ngoại quan đối với thẻ tín dụng và các khoản vay.

32
00:06:13,300 --> 00:06:24,530
Nói tóm lại, không nên bỏ qua các ứng dụng nguyên khối hiện có và chúng có thể được sử dụng làm điểm khởi đầu để tạo các liên hệ được liên kết trong miền doanh nghiệp của bạn.

33
00:06:24,940 --> 00:06:33,670
Trong bài học này, tôi đã hướng dẫn bạn một loạt các bước mà bạn có thể thực hiện để khám phá các liên hệ được liên kết trong miền của mình.

34
00:06:33,820 --> 00:06:55,480
Đề xuất là tận dụng các tài sản sẵn có, chẳng hạn như cơ cấu tổ chức, các ứng dụng nguyên khối, được thiết kế tốt hiện có để xác định các liên hệ bị ràng buộc và những thứ khác mà bạn với tư cách là I.T.  điều chuyên gia cần làm là hợp tác với các chuyên gia kinh doanh để hiểu trách nhiệm và hoạt động chính của họ khi bạn làm việc chặt chẽ với chuyên gia kinh doanh.

35
00:06:55,510 --> 00:07:04,570
Bạn cần chú ý đến ngôn ngữ kinh doanh và những manh mối ngôn ngữ sẽ giúp bạn phân định ranh giới của bối cảnh bị giới hạn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\05DomainDrivenDesignStrategicPatterns_VVN\000000010.srt -->

1
00:00:00,210 --> 00:00:11,420
Mục tiêu của bài tập này là xác định bối cảnh liên kết cho tên miền phụ hỗ trợ ACMS.  Hãy bắt đầu bằng cách xem xét cơ cấu tổ chức ACMS.

2
00:00:11,460 --> 00:00:26,280
CEO phải trực tiếp báo cáo, phó chủ tịch kinh doanh và phó chủ tịch phụ trách hỗ trợ, hỗ trợ các chức năng kinh doanh điển hình như pháp lý, nhân sự, quản trị, kế toán, I.T.  hệ thống và cơ sở vật chất.

3
00:00:26,310 --> 00:00:43,540
Và trong lĩnh vực kinh doanh có sáu lĩnh vực chức năng cốt lõi mà chúng tôi sẽ tập trung vào.  Sáu lĩnh vực chức năng cốt lõi này bắt đầu bằng việc vạch ra các ranh giới xung quanh tiếp thị, bán hàng, quản lý đối tác, hỗ trợ, kinh doanh mới, các kênh và quản lý sản phẩm.

4
00:00:43,560 --> 00:00:54,330
Vì vậy, đây là điểm khởi đầu cho bối cảnh BONARD.  Đối với Acme, bước tiếp theo là chúng ta sẽ tìm hiểu sâu hơn về bối cảnh liên kết hỗ trợ.

5
00:00:54,570 --> 00:01:10,020
Và để làm được điều đó, chúng tôi với tư cách là chuyên gia IP sẽ làm việc với Kathee từ nhóm hỗ trợ.  Kathy chịu trách nhiệm hỗ trợ khách hàng và đối tác và cô ấy sẽ giải thích cho chúng tôi một số hoạt động chính mà cô ấy tham gia.

6
00:01:10,200 --> 00:01:23,360
Mục tiêu của chúng tôi là tìm hiểu xem ranh giới mà chúng tôi đã vạch ra xung quanh hỗ trợ có tốt hay không.  Từ góc nhìn tổng thể, Kathee và nhóm của cô ấy đóng một vai trò rất quan trọng tại Acme.

7
00:01:23,400 --> 00:01:34,290
Kathee hoàn toàn hiểu khách hàng của ACMS.  Trong trường hợp có vấn đề, khách hàng có thể liên hệ với bộ phận hỗ trợ của Acme bằng cách gọi đến số điện thoại miễn phí 24/7.

8
00:01:34,530 --> 00:01:49,920
Nhóm hỗ trợ đã nhận được những cuộc gọi này và cố gắng giúp đỡ khách hàng nhiều nhất có thể.  Các đối tác có thể nhận được sự hỗ trợ từ Acme bằng cách gọi đến cùng một số điện thoại miễn phí trong khoảng thời gian từ 8 giờ sáng đến 5 giờ chiều.  Giờ miền Đông từ thứ Hai đến thứ Sáu.

9
00:01:50,010 --> 00:02:08,100
Và những cuộc gọi này cũng được đội ngũ hỗ trợ tiếp nhận.  Bây giờ chúng ta đã biết trách nhiệm của nhóm hỗ trợ, hãy đi vào chi tiết về các hoạt động chính được thực hiện bằng cách hỗ trợ khách hàng và nhà cung cấp được gọi là số điện thoại miễn phí chung cho trung tâm cuộc gọi của Hackman.

10
00:02:08,580 --> 00:02:20,010
Cuộc gọi được chuyển đến đại lý hỗ trợ.  Tùy thuộc vào cuộc gọi từ khách hàng hay nhà cung cấp mà đại lý thực hiện theo quy trình của khách hàng hay quy trình của nhà cung cấp.

11
00:02:20,430 --> 00:02:28,980
Đây là hai hoạt động chính mà nhân viên hỗ trợ tham gia. Bây giờ chúng ta hãy tìm hiểu sâu hơn về quy trình của khách hàng.

12
00:02:29,100 --> 00:02:45,740
Khi nhận được điện thoại của khách hàng, nhân viên sẽ mở một phiếu yêu cầu.  Phiếu này được sử dụng để ghi lại yêu cầu của khách hàng về vấn đề này và phần liên quan của cuộc trò chuyện giữa khách hàng và nhân viên hỗ trợ.

13
00:02:45,750 --> 00:02:52,620
Như vậy ở đây chúng ta đã tìm hiểu về một doanh nghiệp mà Tom gọi là tấm vé trong bối cảnh quy trình hỗ trợ khách hàng.

14
00:02:52,620 --> 00:03:02,220
Sau đó, tổng đài viên sẽ kiểm tra cơ sở kiến ​​thức để xem liệu có bài viết nào mô tả cách giải quyết yêu cầu hoặc vấn đề của khách hàng hay không.

15
00:03:02,340 --> 00:03:19,230
Cơ sở kiến ​​thức này được quản lý đặc biệt để hỗ trợ các yêu cầu của khách hàng.  Vì vậy, ở đây chúng ta đã tìm hiểu về một doanh nghiệp mới mà Tom gọi là Cơ sở Kiến thức, là tập hợp các bài viết mô tả cách giải quyết các yêu cầu hoặc vấn đề của khách hàng.

16
00:03:19,230 --> 00:03:28,790
Nếu vấn đề liên quan đến việc mua hàng hiện tại của khách hàng thì đại lý cũng có thể kiểm tra đơn đặt hàng cho yêu cầu đó.

17
00:03:28,890 --> 00:03:36,750
Vì vậy, ở đây chúng ta tìm hiểu về một đơn đặt hàng bán hàng comp mới.  Nếu đại lý có thể giải quyết được vấn đề thì họ sẽ đóng phiếu.

18
00:03:36,930 --> 00:03:45,690
Nếu không họ giao vé cho bộ phận chăm sóc khách hàng.  Vì vậy, chăm sóc khách hàng là một nhóm riêng biệt và vì vậy chúng tôi học một công việc kinh doanh mới.

19
00:03:46,080 --> 00:03:55,020
Chăm sóc khách hàng.  Sau đó, đội ngũ chăm sóc khách hàng sẽ tiến hành điều tra và làm việc trực tiếp với khách hàng để giải quyết vấn đề và đóng phiếu yêu cầu.

20
00:03:55,560 --> 00:04:03,600
Trong quá trình điều tra này, khách hàng có thể gọi đến tổng đài và nhận trạng thái yêu cầu từ nhân viên hỗ trợ.

21
00:04:03,720 --> 00:04:13,550
Tiếp theo, hãy nói về quy trình hỗ trợ nhận cuộc gọi từ nhà cung cấp.  Nhân viên hỗ trợ mở trường hợp nhà cung cấp.

22
00:04:13,560 --> 00:04:20,910
Vì vậy, đây là trường hợp nhà cung cấp thuật ngữ mới được áp dụng trong trường hợp quy trình hỗ trợ nhà cung cấp.

23
00:04:21,030 --> 00:04:33,420
Và Cathy cũng đã đề cập rằng trường hợp nhà cung cấp còn được gọi là đối tác.  Trường hợp nhà cung cấp, giống như phiếu, có thông tin về yêu cầu hoặc vấn đề mà nhà cung cấp đã gọi.

24
00:04:33,690 --> 00:04:43,740
Và nó cũng có các phần liên quan trong cuộc trò chuyện giữa nhà cung cấp và nhân viên hỗ trợ để giải quyết vấn đề hoặc yêu cầu.

25
00:04:43,740 --> 00:04:54,960
Tác nhân kiểm tra cơ sở tri thức.  Cơ sở kiến ​​thức này là tập hợp các bài viết liên quan đến việc giải quyết các yêu cầu hoặc vấn đề do nhà cung cấp đưa ra.

26
00:04:55,260 --> 00:05:13,480
Đại lý cũng kiểm tra các hợp đồng của nhà cung cấp.  Đây là hợp đồng, nhưng.  Acme và nhà cung cấp, vì vậy, hợp đồng với nhà cung cấp là một điều khoản khác có thể áp dụng trong bối cảnh quy trình hỗ trợ của nhà cung cấp, nếu đại lý có thể giải quyết vấn đề thì trường hợp của nhà cung cấp sẽ kết thúc.

27
00:05:13,630 --> 00:05:34,910
Nếu không, nhân viên dựa trên vấn đề sẽ chỉ định trường hợp nhà cung cấp cho một nhóm thích hợp.  Ví dụ, trong nội bộ Achmat, nếu là vấn đề hợp đồng thì đội quản lý đối tác sẽ được phân công xử lý nếu liên quan đến kế toán và đội kế toán sẽ được giao phiếu xử lý.

28
00:05:35,110 --> 00:05:50,980
Sau đó, các nhóm giải quyết yêu cầu của nhà cung cấp sẽ làm việc trực tiếp với nhà cung cấp.  Vì vậy, ở mức độ cao, quy trình cung cấp hỗ trợ cho khách hàng trông rất giống với quy trình được sử dụng để cung cấp hỗ trợ cho các đối tác, nhà cung cấp khác.

29
00:05:50,980 --> 00:06:01,240
Và thật thú vị, chúng tôi đã học được các âm khác nhau được sử dụng trong ngữ cảnh của từng quy trình.  Hãy so sánh các thuật ngữ mà chúng tôi đã thu thập được từ hai quá trình này.

30
00:06:01,250 --> 00:06:09,070
Hai điều khoản đầu tiên là vé và trường hợp nhà cung cấp.  Về mặt khái niệm, chúng giống nhau, nhưng về mặt ngữ nghĩa thì chúng khác nhau.

31
00:06:09,370 --> 00:06:25,770
Hãy coi nó không có ý nghĩa trong trường hợp bối cảnh quy trình của nhà cung cấp, trong khi trường hợp nhà cung cấp không có ý nghĩa trong bối cảnh quy trình khách hàng vào lần tiếp theo hoặc các thuật ngữ phổ biến trong cơ sở kiến ​​thức được sử dụng trong bối cảnh khác.

32
00:06:25,780 --> 00:06:44,050
Cơ sở kiến ​​thức trong bối cảnh quy trình của khách hàng đề cập đến kho lưu trữ bài viết mô tả cách hỗ trợ khách hàng, trong khi cơ sở kiến ​​thức cho bối cảnh nhà cung cấp đề cập đến cơ sở kiến ​​thức có các bài viết để hỗ trợ nhà cung cấp.

33
00:06:44,050 --> 00:06:51,730
Tiếp theo là bán hàng và chăm sóc khách hàng chỉ cần có ý nghĩa trong bối cảnh của quy trình khách hàng.

34
00:06:51,740 --> 00:07:10,750
Và tương tự, chúng ta có hợp đồng nhà cung cấp có ý nghĩa trong bối cảnh quá trình sáng tạo.  Vì vậy, dựa trên những manh mối mà chúng ta đang thấy ở đây, các liên hệ giới hạn hỗ trợ có thể được chia thành hai liên hệ liên kết độc lập, liên hệ hỗ trợ khách hàng và bối cảnh hỗ trợ của nhà cung cấp.

35
00:07:10,750 --> 00:07:17,530
Và chúng tôi thực hiện cuộc gọi này dựa trên thực tế là hai người liên hệ quen thuộc đang sử dụng các điều khoản kinh doanh khác nhau.

36
00:07:17,980 --> 00:07:32,470
Vì vậy, chúng tôi bắt đầu với những người liên hệ liên kết này và quyết định chia những người liên hệ hỗ trợ, liên kết thành hai người liên hệ liên kết độc lập, những người liên hệ liên kết hỗ trợ khách hàng và những người liên hệ liên kết hỗ trợ nhà cung cấp.

37
00:07:32,590 --> 00:07:49,870
Hãy xem lại các bước mà chúng tôi đã thực hiện để tiếp cận các địa chỉ liên hệ của bom nhỏ này.  Điều đầu tiên chúng tôi làm là xem xét cơ cấu tổ chức ACMS, chọn lọc các khả năng kinh doanh và tạo ra một tập hợp các mối liên hệ gắn kết làm điểm khởi đầu.

38
00:07:50,020 --> 00:07:59,830
Sau đó, chúng tôi tập trung vào các hoạt động hỗ trợ và nhận thấy có hai hoạt động chính được thực hiện bởi các nhân viên hỗ trợ của trung tâm cuộc gọi.

39
00:07:59,860 --> 00:08:17,020
Khi chúng ta xem qua các hoạt động chính này, chúng ta tập hợp các nhóm kinh doanh.  Sau đó, chúng tôi so sánh các điều khoản kinh doanh và nhận ra rằng việc chia các liên hệ hỗ trợ thành các liên hệ hỗ trợ khách hàng và cung cấp bối cảnh hỗ trợ là hợp lý.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\001 Intro to DDD Integration Patterns.en.srt -->

1

00:00:00,210 --> 00:00:07,380

Bonded context, relationships, not bonded contacts are independent, body bonded contacts are not



2

00:00:07,530 --> 00:00:15,200

isolated from other bonded contacts around them, models in the bonded contacts collaborate to fulfill



3

00:00:15,390 --> 00:00:17,050

requirements of a system.



4

00:00:17,250 --> 00:00:23,400

The basic premise behind this is that when you will build micro services, they will not fulfill all



5

00:00:23,400 --> 00:00:25,650

of the system requirements on their own.



6

00:00:25,940 --> 00:00:30,510

These micro services will need to interact with other micro services.



7

00:00:30,870 --> 00:00:38,010

These relationships imply some kind of dependency between the bonded contacts or the micro services.



8

00:00:38,280 --> 00:00:44,910

There are multiple types of relationships between the bonded contacts in a symmetric relationship to



9

00:00:44,910 --> 00:00:47,610

bonded contacts depend on each other.



10

00:00:48,120 --> 00:00:52,290

So here in this scenario, the context is dependent on boundry.



11

00:00:52,300 --> 00:00:57,570

Contacts be inbounded contacts B is dependent on bonded context.



12

00:00:57,600 --> 00:01:03,850

It in an asymmetric relationship, 100 contacts depends on another 100 contacts.



13

00:01:03,870 --> 00:01:10,770

So here in this example, BONARD context is dependent on bonded context b in a one to many relationship,



14

00:01:10,920 --> 00:01:15,120

multiple bonded contacts depend on one bonded context.



15

00:01:15,570 --> 00:01:18,470

There are multiple delivery relationship patterns.



16

00:01:18,510 --> 00:01:24,600

These relationship patterns define the dependency relationship between the bonded contacts.



17

00:01:24,600 --> 00:01:28,290

You will be learning all of the relationship patterns in this section.



18

00:01:28,530 --> 00:01:34,920

Big bowl of Maat is an antipodal in software development and as a designer of the micro services, you



19

00:01:34,920 --> 00:01:38,280

must avoid creating a big bowl of context.



20

00:01:38,280 --> 00:01:45,270

Perhaps are visual representation of the relationship between the bounded contacts you will be learning



21

00:01:45,270 --> 00:01:49,560

about the contacts, maps and big ball of mud in the next lecture.



22

00:01:50,580 --> 00:01:56,380

Let's go over the learning objectives for this section of this section you should be able to explain.



23

00:01:56,410 --> 00:02:02,230

Big ball of mud and contacts, maps, you should be able to describe the challenges associated with



24

00:02:02,520 --> 00:02:10,350

big ball of mud and how context mapping can help you learn all of the detailed patterns related to the



25

00:02:10,350 --> 00:02:11,100

relationship.



26

00:02:11,260 --> 00:02:18,090

So you should be able to pick up an appropriate relationship pattern for defining your bonded context



27

00:02:18,090 --> 00:02:18,960

dependencies.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\002 Managing BC Relationships using Context Maps.en.srt -->

1

00:00:00,120 --> 00:00:06,270

Managing the relationship between bonded contacts in this lesson, Alcoa and Antiproton referred to



2

00:00:06,270 --> 00:00:13,200

as the big ball of mud, you'll also learn about the challenges associated with bonded contacts, dependencies,



3

00:00:13,200 --> 00:00:20,340

and you learn about contacts, maps that can help in managing the BONARD context dependencies, unmanaged



4

00:00:20,340 --> 00:00:24,510

bounded contacts, relationship leads to big ball of mud.



5

00:00:24,510 --> 00:00:31,430

Big ball of mud refers to have presently structured models that lead to spaghetti code.



6

00:00:31,590 --> 00:00:40,350

This kind of a model and spaghetti code is typically created by unregulated growth and fixes over a



7

00:00:40,350 --> 00:00:41,210

period of time.



8

00:00:41,340 --> 00:00:47,130

Big bowl of mud in the context of domain driven design refers to an active pattern.



9

00:00:47,400 --> 00:00:53,080

As a designer of a service, you should make sure that you're not creating a big ball of mud.



10

00:00:53,730 --> 00:00:58,520

Now we know that bonded contacts cannot stay isolated.



11

00:00:58,560 --> 00:01:00,750

There are going to be dependency relationships.



12

00:01:00,960 --> 00:01:02,970

These relationships need to be managed.



13

00:01:03,150 --> 00:01:10,710

Otherwise there will be a loss of moral integrity and there will be a loss of team's ability to operate



14

00:01:10,710 --> 00:01:11,580

independently.



15

00:01:11,760 --> 00:01:13,550

Let's go over these challenges.



16

00:01:14,100 --> 00:01:20,810

Consider the scenario in which we have bonded context and bonded context beat each of these bonded contacts,



17

00:01:20,820 --> 00:01:22,200

have their own models.



18

00:01:22,590 --> 00:01:26,730

Now, let's say there is a dependency between A and B now.



19

00:01:26,730 --> 00:01:33,540

It depends on B, which means that you will have visibility of these models.



20

00:01:33,870 --> 00:01:41,930

And the impact is that no linguistic boundaries within the bonded context, it does not hold.



21

00:01:41,970 --> 00:01:48,930

There may be confusions in terms of the language used for A's and B's models.



22

00:01:49,080 --> 00:01:51,360

In other words, the blended context.



23

00:01:51,360 --> 00:01:58,170

It is now contaminated and this is what is referred to as the loss of moral integrity.



24

00:01:59,070 --> 00:02:06,350

The bonded context discovered in the domain of urban design are translated into one or more micro services.



25

00:02:06,690 --> 00:02:13,770

So here in this example, customer management bounded contacts is translated into a customer microcircuits,



26

00:02:13,770 --> 00:02:20,610

whereas retail accounts bounded context is translated to two micro services saving account, micro service



27

00:02:20,820 --> 00:02:23,070

and a checking account micro service.



28

00:02:23,100 --> 00:02:30,150

The dependencies between the bounded context are eventually translated to the dependencies between the



29

00:02:30,150 --> 00:02:31,100

micro services.



30

00:02:31,530 --> 00:02:38,890

So here in this example, the credit card account maiko service is dependent on the customer micro service.



31

00:02:38,910 --> 00:02:45,600

Each of these services are managed by independent teams and this dependency relationship between the



32

00:02:45,600 --> 00:02:52,800

micro services will mean that any time there is a change in the customer micro service, the credit



33

00:02:52,800 --> 00:02:55,170

card micro service will need to change.



34

00:02:55,170 --> 00:03:02,160

So all changes will require some kind of collaboration between the teams owning these micro services.



35

00:03:02,160 --> 00:03:09,450

And what that means is that the teams will lose the ability to operate independently and that will lead



36

00:03:09,450 --> 00:03:16,560

to loss of agility, which is counter to one of the reasons why micro services architecture is adopted.



37

00:03:17,570 --> 00:03:23,180

Now, we know that Mongered contacts, dependancy or Microsoft says dependencies cannot be avoided.



38

00:03:23,450 --> 00:03:31,240

So the suggestion is to manage these bonded contacts, relationships using appropriate domain driven



39

00:03:31,250 --> 00:03:32,270

design patterns.



40

00:03:32,480 --> 00:03:40,010

Teams must make a conscious effort not to create a big ball of mud, and they must document the relationship



41

00:03:40,010 --> 00:03:43,730

between the bonded contacts using contacts, maps.



42

00:03:44,210 --> 00:03:46,370

Let me explain what context maps are.



43

00:03:47,060 --> 00:03:54,950

Context maps are a visual representation of the systems, Bundgaard contacts and relationships between



44

00:03:54,950 --> 00:03:55,260

them.



45

00:03:55,640 --> 00:04:02,780

It is an example of how our contacts map look like the relationship between the bonded contacts is depicted



46

00:04:02,930 --> 00:04:08,060

by way of these letters in the block you will learn the context map notations.



47

00:04:08,300 --> 00:04:09,290

In this section.



48

00:04:09,530 --> 00:04:12,500

There are multiple benefits of using contacts maps.



49

00:04:12,740 --> 00:04:18,010

First one is that it makes it easier for the team members to understand the big picture.



50

00:04:18,050 --> 00:04:24,680

The next is that it helps in understanding the interdependencies between bounded contacts.



51

00:04:25,030 --> 00:04:32,420

The third one is that it helps the teams gauge the level of collaboration needed with other teams.



52

00:04:32,600 --> 00:04:37,720

The contacts map also helps in refinement of the bounded contacts and the models.



53

00:04:38,360 --> 00:04:40,730

Let's go over the key points from this lesson.



54

00:04:41,250 --> 00:04:46,670

As a designer of the micro servers, you must avoid creating a big ball of mud.



55

00:04:46,820 --> 00:04:53,300

The idea is that if you create too many dependencies between the bounded contacts, it'll lead to the



56

00:04:53,300 --> 00:04:58,940

loss of benefits that you expect to realize from the micro services architecture.



57

00:04:59,270 --> 00:05:06,800

Next one is that as a micro services designer, you must use well-defined DTT patterns for defining



58

00:05:06,800 --> 00:05:09,950

the relationships between your bounded contacts.



59

00:05:10,160 --> 00:05:16,310

Last but not the least, document the relationship between the bonded contacts using contacts, maps.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\003 Symmetric Relationship Patterns.en.srt -->

1

00:00:00,180 --> 00:00:06,840

Symmetric relationship in this lesson, you learned about three new strategic patterns, separate ways,



2

00:00:06,840 --> 00:00:13,470

partnership pattern and the shared kernel pattern, there may be a scenario where the bonded contacts



3

00:00:13,470 --> 00:00:17,970

in a system has no relationship with other bonded contacts.



4

00:00:18,180 --> 00:00:24,150

In such a scenario, the bonded contacts are truly independent or autonomous.



5

00:00:24,420 --> 00:00:29,440

Consider the scenario where we have two bonded contacts and B which have no relationship.



6

00:00:29,610 --> 00:00:35,810

What that means is that there is no sharing of models between these two bonded contacts since their



7

00:00:35,820 --> 00:00:40,770

independent teams can work on these two bonded contacts autonomously.



8

00:00:40,780 --> 00:00:45,510

In other words, these teams do not have to collaborate or coordinate for any task.



9

00:00:45,550 --> 00:00:52,920

Now, some would argue that there are opportunities to reuse parts of A and B or vice versa.



10

00:00:52,980 --> 00:00:55,200

But one has to consider the tradeoff.



11

00:00:55,200 --> 00:01:00,180

And the tradeoff is that if there is reuse, then there will be a loss of autonomy.



12

00:01:00,180 --> 00:01:01,420

So of go a little deeper.



13

00:01:01,440 --> 00:01:09,420

Let's say there is a model and a that is shared by B, no, the teams cannot work autonomously y because



14

00:01:09,420 --> 00:01:14,700

if it has to change the model, then the team for B will need to agree to the changes.



15

00:01:14,700 --> 00:01:17,750

And that is a concern regarding the reuse.



16

00:01:17,760 --> 00:01:23,700

There's no relationship between the boundary contacts is referred to as the separate ways pattern from



17

00:01:23,700 --> 00:01:25,320

the realization perspective.



18

00:01:25,560 --> 00:01:32,010

What that means is that they will be independent set of applications or services for each of the bonded



19

00:01:32,010 --> 00:01:32,610

contacts.



20

00:01:32,820 --> 00:01:41,330

For example, in the case of banking, we have the credit cards and home loans that have no relationship.



21

00:01:41,490 --> 00:01:47,760

In that case, teams will independently develop applications and services for these two bonded contacts.



22

00:01:47,760 --> 00:01:54,180

And what that means is that these two teams can work independently at their own pace to meet the business



23

00:01:54,180 --> 00:01:57,020

goals of their respective business unit.



24

00:01:57,300 --> 00:02:02,770

Sometime you find bounded contacts that have mutual dependency on each other.



25

00:02:03,150 --> 00:02:09,000

This kind of relationship between the bonded contacts is referred to as the symmetric relationship or



26

00:02:09,000 --> 00:02:15,960

bidirectional dependency could be a symmetric relationship, a solid lightless place between the bonded



27

00:02:15,960 --> 00:02:16,710

contacts.



28

00:02:16,740 --> 00:02:23,400

This mutual dependency leads to a high level of coupling between the bonded context and this type of



29

00:02:23,400 --> 00:02:28,290

relationship is referred to as the Partnership Parathion and Demand-Driven Design.



30

00:02:28,710 --> 00:02:35,580

From the realization perspective, the partnership pattern translates into services that have mutual



31

00:02:35,580 --> 00:02:36,450

dependencies.



32

00:02:36,480 --> 00:02:43,410

So what that means is that the services may be developed by different teams, but because of the mutual



33

00:02:43,410 --> 00:02:49,040

dependencies between the services, the teams cannot operate independently.



34

00:02:49,260 --> 00:02:56,100

Not only that, each of the teams engage in this kind of relationship would need to learn the business



35

00:02:56,100 --> 00:03:01,200

models and that ubiquitous language for the bonded contacts managed by the other team.



36

00:03:01,230 --> 00:03:06,060

At the end of the day, what this means is that the teams in this kind of relationship will need to



37

00:03:06,060 --> 00:03:13,260

coordinate their changes, deployments and releases, and that will defeat the purpose of adopting micro



38

00:03:13,260 --> 00:03:14,700

services architecture.



39

00:03:15,090 --> 00:03:19,040

Now, the obvious question you may have at this point is how do we solve this problem?



40

00:03:19,170 --> 00:03:25,670

One way of solving this problem is to demarcate the boundaries for the shared models.



41

00:03:26,040 --> 00:03:31,680

So let's say two independent teams are working on the blended context and voluntary context.



42

00:03:31,680 --> 00:03:39,400

B, they can create a demarcation around the models that are shared between the two bonded contacts.



43

00:03:39,600 --> 00:03:45,600

The idea is to manage these shared models independent of the rest of the bonded context.



44

00:03:45,600 --> 00:03:50,760

So what that means is that if it needs a change and this change is not part of the shared models, then



45

00:03:50,760 --> 00:03:55,740

the team assigned to bounded contacts, it can make independent decisions.



46

00:03:55,770 --> 00:04:02,010

Similarly, if there are changes needed outside of the shared models and bounded contacts, be the team



47

00:04:02,010 --> 00:04:03,360

assigned to bonder contacts.



48

00:04:03,360 --> 00:04:05,760

B can make those decisions independently.



49

00:04:05,820 --> 00:04:11,370

But at any point, if there is a need for making a change to the shared models, then the two teams



50

00:04:11,490 --> 00:04:12,390

will coordinate.



51

00:04:12,510 --> 00:04:19,260

The sharing of models between the bounded contacts is referred to as the shared goal pattern.



52

00:04:19,650 --> 00:04:26,820

The important thing to keep in mind for the shared Carneal is that the overlapping parts of the contacts



53

00:04:26,940 --> 00:04:34,770

represent the shared domain model, the shared concepts and the shared business language between the



54

00:04:34,770 --> 00:04:36,180

two bonded contacts.



55

00:04:36,850 --> 00:04:45,510

Typically, the shared kernel is realized by way of shared Labrys, such as Java, Java, Python Packages



56

00:04:45,510 --> 00:04:46,560

and Ruby Gems.



57

00:04:46,560 --> 00:04:52,260

Teams can independently develop services that use these shared libraries.



58

00:04:52,620 --> 00:04:59,850

It is OK for the teams to use shared kernel and the shared Labrys as long as the scope of sharing.



59

00:05:00,070 --> 00:05:07,690

Between the bonder contacts is limited to a small set of models for scenarios involving sharing of too



60

00:05:07,690 --> 00:05:15,190

many models between the bonded contacts, it becomes difficult to maintain the integrity of the boundaries



61

00:05:15,370 --> 00:05:16,950

of the boundary contacts.



62

00:05:16,960 --> 00:05:23,770

And that is the reason for the suggestion to use shared kernel only if we are talking about a small



63

00:05:23,770 --> 00:05:27,070

set of shared concepts between the bounded contacts.



64

00:05:27,580 --> 00:05:31,090

In this lesson, I covered three strategic patterns for.



65

00:05:31,630 --> 00:05:37,570

The first one is the separate ways in which there is no relationship between the bounded contacts.



66

00:05:37,600 --> 00:05:42,980

As a result, the teams working on the two bonded contacts can work truly independently.



67

00:05:43,390 --> 00:05:49,840

The next one is the partnership pattern in which there are interdependencies between the bounded contacts.



68

00:05:49,960 --> 00:05:56,650

As a result, teams must coordinate with each other to make changes to their own bounded contacts.



69

00:05:56,680 --> 00:06:04,090

The third one is the shared Kamna, in which it is suggested that the boundaries of the shared concepts



70

00:06:04,090 --> 00:06:12,130

and models be clearly demarcated, and only the changes to these shared models need to be coordinated



71

00:06:12,280 --> 00:06:13,070

by the teams.



72

00:06:13,240 --> 00:06:19,180

In other words, if the team is working on changes that are not related to the shared models or concepts,



73

00:06:19,450 --> 00:06:24,940

then it can carry out those changes without needing input from the other team.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\004 Asymmetric Relationship Patterns.en.srt -->

1

00:00:00,180 --> 00:00:07,110

Asymmetric relationships in this lesson, you learn two new terms, upstream boundary context and downstream



2

00:00:07,110 --> 00:00:13,770

boundary context, and I'll cover three patterns customer supply pattern, conformist pattern and the



3

00:00:13,770 --> 00:00:15,200

anti-corruption layer pattern.



4

00:00:15,780 --> 00:00:19,190

In the last lecture you learned about symmetric relationship.



5

00:00:19,200 --> 00:00:25,170

In this lecture, I'll cover the details of asymmetric relationships between the bounded context in



6

00:00:25,170 --> 00:00:32,100

an asymmetric relationship, one bounded context has dependency on another bounded context.



7

00:00:32,220 --> 00:00:38,220

This kind of relationship is depicted by way of assigning roles to the bounded context.



8

00:00:38,250 --> 00:00:45,630

The BONARD context that exposes mortals to the other bounded context is referred to be in the upstream



9

00:00:45,630 --> 00:00:52,050

role, and the bounded context that is dependent on the other bounded context is referred to by the



10

00:00:52,140 --> 00:00:53,910

downstream bounded context.



11

00:00:54,030 --> 00:00:57,620

So this depicts a relationship in which bounded context.



12

00:00:57,630 --> 00:01:00,480

It is dependent on the bounded context.



13

00:01:00,630 --> 00:01:03,210

B in other words, boundary context.



14

00:01:03,210 --> 00:01:07,020

It has knowledge of models and bounded context.



15

00:01:07,020 --> 00:01:14,220

B And since the relationship is asymmetric boundary context B does not have any knowledge of the model



16

00:01:14,340 --> 00:01:15,530

in bounded context.



17

00:01:15,540 --> 00:01:22,320

It is an important thing to keep in mind here is that this relationship does not indicate the flow of



18

00:01:22,320 --> 00:01:24,240

data or information.



19

00:01:24,360 --> 00:01:28,920

It depicts the dependencies from the realisation perspective.



20

00:01:29,190 --> 00:01:36,810

The upstream bounded context exposes some functionality and models that are consumed by the downstream



21

00:01:36,810 --> 00:01:37,770

bounded context.



22

00:01:37,980 --> 00:01:42,300

Now there are two options that the upstream bounded context has.



23

00:01:42,510 --> 00:01:50,490

It can expose the functionality and models based on the needs of the downstream bounded context.



24

00:01:50,820 --> 00:01:57,990

And the second option is that the upstream bounded context exposes certain functionality and models



25

00:01:58,140 --> 00:02:03,180

without any consideration to the needs of the downstream bounded context.



26

00:02:03,480 --> 00:02:05,460

These are two separate patterns.



27

00:02:05,970 --> 00:02:07,790

Let's discuss these in details.



28

00:02:08,760 --> 00:02:17,700

So in case of option number one, the upstream bounded context fulfilled some specific need of the downstream



29

00:02:17,700 --> 00:02:18,840

bounded context.



30

00:02:19,050 --> 00:02:23,150

And this pattern is referred to as the customer supply of pattern.



31

00:02:23,340 --> 00:02:30,480

Think of it like a client server, Pachon, wherein the server creates the interfaces based on the needs



32

00:02:30,480 --> 00:02:31,140

of the client.



33

00:02:31,260 --> 00:02:39,720

From the realisation perspective, the supplier team always consults with the customer team to ensure



34

00:02:39,960 --> 00:02:44,910

that the supplier servers fulfilled the needs of the customer service.



35

00:02:45,810 --> 00:02:53,220

Let's discuss option number two, in which the upstream bounded context exposes models with no regard



36

00:02:53,220 --> 00:02:57,060

to any downstream bounded context requirements or needs.



37

00:02:57,210 --> 00:03:05,430

In the scenario, the downstream bounded context except the models exposed by the upstream bounded context.



38

00:03:05,550 --> 00:03:09,930

This type of relationship is referred to as the conformist pattern.



39

00:03:10,200 --> 00:03:17,430

In this pattern, the downstream boundary context conforms to the upstream bounded context models to



40

00:03:17,460 --> 00:03:24,930

depict this relationship, the D next to the downstream bounded context is replaced with a seat F,



41

00:03:24,940 --> 00:03:31,770

so in this diagram bounded context, it is conforming to the models exposed by the bounded context.



42

00:03:31,770 --> 00:03:37,980

B One important point to note here is that both the bounded context used the same model.



43

00:03:38,130 --> 00:03:40,800

To give you an example from the banking domain.



44

00:03:40,950 --> 00:03:46,530

Let's say there is a bounded context credit card and a bounded context for customer management.



45

00:03:46,620 --> 00:03:53,970

The team for the customer management develops and own the model for customer and the customer management



46

00:03:53,970 --> 00:03:54,450

boundary.



47

00:03:54,460 --> 00:03:58,360

Context acts as a upstream for the credit cards.



48

00:03:58,410 --> 00:04:06,210

The credit cards team decides to adopt the model created and managed by the customer management team.



49

00:04:06,540 --> 00:04:14,160

In that case, they will not be any need for the translation of the customer object between the bounded



50

00:04:14,160 --> 00:04:14,850

contacts.



51

00:04:15,360 --> 00:04:22,860

Not consider a scenario in which the downstream bounded context decides not to conform to the upstream



52

00:04:22,860 --> 00:04:23,940

bounded context.



53

00:04:23,940 --> 00:04:26,310

In other words, the team for bounded context.



54

00:04:26,310 --> 00:04:32,580

It decides to create their own model instead of adopting the models for bounded context be.



55

00:04:32,940 --> 00:04:39,840

In that scenario, the models from bounded context be exposed to the bounded context.



56

00:04:39,840 --> 00:04:46,140

It would require some kind of a translation to convert the models from bounded context be to bounded



57

00:04:46,140 --> 00:04:46,710

context.



58

00:04:47,070 --> 00:04:52,050

The suggestion is to isolate this translation logic in a separate layer.



59

00:04:52,050 --> 00:04:58,380

This level for the translation is referred to as the anti-corruption live, and this pattern is also



60

00:04:58,380 --> 00:04:59,730

referred to as the Antichrist.



61

00:05:00,860 --> 00:05:06,620

The idea behind the anti-corruption lawyer is to protect the bonded context from corruption.



62

00:05:06,740 --> 00:05:11,530

This kind of relationship is depicted by replacing the ACL.



63

00:05:11,600 --> 00:05:17,870

So here we are depicting a relationship between A and B within each of these bonded context, have their



64

00:05:17,900 --> 00:05:18,620

own model.



65

00:05:18,620 --> 00:05:25,010

They have no knowledge of each other's models except that the ACL has the required knowledge of both



66

00:05:25,010 --> 00:05:31,750

the models for A and B and carries out the translation from B's morou to his model.



67

00:05:32,120 --> 00:05:39,770

Let's say the customer management team decides to depict the customer with these three attributes and



68

00:05:39,770 --> 00:05:46,790

the credit card team decides to call the customer the account holder in the context of credit card.



69

00:05:47,030 --> 00:05:53,660

And these are the attributes that they decided to use for describing the account holder credit card



70

00:05:53,660 --> 00:06:01,890

team decided to leverage some function from the customer management and contacts with the anti-corruption.



71

00:06:02,510 --> 00:06:11,420

So in this scenario, the anti-corruption layer will have the translation logic for converting the customer



72

00:06:11,420 --> 00:06:17,630

from the customer management context to the account holder in the credit card context.



73

00:06:17,930 --> 00:06:24,020

And this would mean mapping the various attributes, such as first name, last name.



74

00:06:24,290 --> 00:06:30,770

And here, as you can see, there is some kind of a government identity attribute which is mapped to



75

00:06:30,770 --> 00:06:33,880

the customer SSN or Social Security number.



76

00:06:33,890 --> 00:06:39,100

And this mapping also involves setting the identity type to SSN.



77

00:06:39,260 --> 00:06:46,050

So this is an example of the translation logic built into the ACL or the anti-corruption layer.



78

00:06:46,460 --> 00:06:53,330

So that means that the anti-corruption layer needs to have the knowledge of both the downstream models



79

00:06:53,330 --> 00:06:55,430

as well as the upstream models.



80

00:06:55,760 --> 00:07:03,260

But the downstream has no knowledge of the upstream bounded context, and that is how the anti-corruption



81

00:07:03,260 --> 00:07:07,580

layer protects the downstream from upstream changes.



82

00:07:08,720 --> 00:07:15,530

In this lesson, you learned about the asymmetric relationships between the boundary context and asymmetric



83

00:07:15,540 --> 00:07:16,310

relationship.



84

00:07:16,490 --> 00:07:23,480

The downstream boundary context depends on the upstream boundary context in the customer supplier pattern.



85

00:07:23,480 --> 00:07:31,130

The upstream bounded context adjust the models to the needs of the downstream bounded context, whereas



86

00:07:31,130 --> 00:07:38,750

in the conformists pattern, the upstream bounded context does not give any regard to the needs of the



87

00:07:38,750 --> 00:07:40,430

downstream bounded context.



88

00:07:40,430 --> 00:07:45,140

And so the downstream boundary context conforms to the upstream models.



89

00:07:45,140 --> 00:07:52,310

In order to protect the downstream boundary context, teams will decide to use the anti-corruption layer.



90

00:07:52,470 --> 00:07:59,390

This anti-corruption layer has the logic for translating the models from the upstream format to the



91

00:07:59,540 --> 00:08:00,200

downstream.



92

00:08:00,200 --> 00:08:02,300

Formic, that way downstream.



93

00:08:02,300 --> 00:08:09,410

Bounded context has no knowledge of the upstream model context and hence there is no direct dependency.



94

00:08:09,410 --> 00:08:14,780

As such, all of the code related to the dependency is isolated in the atheel.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\005 One to Many Relationship Patterns.en.srt -->

1

00:00:00,150 --> 00:00:06,880

One to many, relationship in this lecture underscores two patterns open house surveys and the published



2

00:00:06,910 --> 00:00:14,070

language pattern in the one to many relationship upstream bounded contacts referred to as Provida offers



3

00:00:14,070 --> 00:00:17,640

common services to two or more bounded contexts.



4

00:00:17,670 --> 00:00:25,020

In this example, Inbee are the downstream bounded context and C is the upstream boundary context,



5

00:00:25,110 --> 00:00:27,300

which is offering common services to.



6

00:00:27,430 --> 00:00:31,920

And B the common integration models are defined by the bounded context.



7

00:00:31,920 --> 00:00:41,610

C With no regard to the needs of A or B the downstream bounded context may decide to conform or use



8

00:00:41,610 --> 00:00:42,780

the athea.



9

00:00:42,990 --> 00:00:49,340

So in this example here is A conformist, whereas B is using the anti-corruption layer.



10

00:00:49,590 --> 00:00:55,340

These decisions are made by the teams who work on these bounded context independently.



11

00:00:55,590 --> 00:01:02,370

The upstream boundary context that provides the common services is referred to as the open source service,



12

00:01:02,580 --> 00:01:09,540

and this pattern is referred to as the open source service pattern to depict this common service as



13

00:01:09,540 --> 00:01:16,980

pattern which is placed in front of the upstream bounded context that provides the common services,



14

00:01:17,310 --> 00:01:24,000

the upstream bounded context or the open hosted service provider in this relationship offers a common



15

00:01:24,000 --> 00:01:25,800

language for integration.



16

00:01:26,030 --> 00:01:32,210

This common language is accepted by the teams working on the downstream bounded context.



17

00:01:32,310 --> 00:01:38,340

This common language is referred to as the published language, and this pattern is referred to as the



18

00:01:38,520 --> 00:01:39,990

published language pattern.



19

00:01:40,650 --> 00:01:48,960

The use of published language is depicted by placing a APL in front of the upstream alongside the Oireachtas.



20

00:01:49,240 --> 00:01:56,400

So this context mapping depicts a scenario where C is providing common services.



21

00:01:56,610 --> 00:02:01,500

That is, it has the Oireachtas provider and also has a published language.



22

00:02:02,070 --> 00:02:06,300

Let's call it an example of common services realisation.



23

00:02:06,750 --> 00:02:14,610

The functionality is exposed by way of which has bounded contexts, and it is well accepted by the downstream



24

00:02:14,610 --> 00:02:15,580

bounded context.



25

00:02:15,660 --> 00:02:20,850

So think of a team that creates a service which exposes gaps.



26

00:02:21,150 --> 00:02:29,220

And lets say this team is also publishing the rest API models and schemas by way of open API specifications



27

00:02:29,250 --> 00:02:30,840

or Swagga specifications.



28

00:02:30,840 --> 00:02:38,580

Other teams may build their own services by using these recipes, and they will build these recipes



29

00:02:38,700 --> 00:02:44,220

by referring the open AP specifications for the apps and the schemas.



30

00:02:44,220 --> 00:02:50,070

And looking at this diagram, you may say that you are already creating your APIs exactly in this manner



31

00:02:50,640 --> 00:02:52,220

and you are absolutely right.



32

00:02:52,230 --> 00:02:54,270

There is no difference in this lesson.



33

00:02:54,270 --> 00:02:58,230

You learned about two patterns related to one to many relationship.



34

00:02:58,240 --> 00:03:05,310

The first partners, the open hosted service pattern in which the upstream blended context provides



35

00:03:05,310 --> 00:03:10,710

a set of common services or common capabilities to the downstream bounded context.



36

00:03:10,800 --> 00:03:15,570

The second one is the published language, which goes hand-in-hand with the open hosted service.



37

00:03:15,570 --> 00:03:23,100

Back on the upstream, bounded contacts on the open hosted service provider exposes the common language



38

00:03:23,100 --> 00:03:30,240

for the common services, and this language is managed by the team responsible for the open hosted service,



39

00:03:30,270 --> 00:03:34,110

the downstream bounded contacts except this published language.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06 Bounded Context Relationships\006 Exercise _ Context Mapping for a Bank.en.srt -->

1

00:00:00,090 --> 00:00:07,350

Context mapping for a bank in this exercise, the objective is for you to learn how to set up the context



2

00:00:07,350 --> 00:00:14,400

maps, and the second objective is to identify the impact of changes in one bounded context on other



3

00:00:14,400 --> 00:00:17,880

bonder context, using the context maps.



4

00:00:17,880 --> 00:00:24,780

In this exercise, we will use the simplified version of the bounded context for a bank.



5

00:00:24,820 --> 00:00:26,920

There are two parts in this exercise.



6

00:00:27,120 --> 00:00:28,590

Let's start with part one.



7

00:00:28,710 --> 00:00:35,490

In part one, I'll ask you a question and this question will describe the relationship between the bonded



8

00:00:35,490 --> 00:00:42,900

context and you will need to decide which pattern you would use to settle the desired relationships



9

00:00:42,900 --> 00:00:44,750

between the bounded context.



10

00:00:44,970 --> 00:00:45,690

Here is the question.



11

00:00:45,690 --> 00:00:46,240

Number one.



12

00:00:46,260 --> 00:00:50,130

Let's say credit cards is dependent on the retail account.



13

00:00:50,610 --> 00:00:57,030

And this may be because customers may set up direct payments from the retail account for the credit



14

00:00:57,030 --> 00:01:03,650

cards, but the credit cards team has decided to accept the models from the retail account.



15

00:01:03,780 --> 00:01:08,040

So what will be the relationship between the credit cards and retail accounts?



16

00:01:08,190 --> 00:01:10,580

Please post the video if you need a little bit of time.



17

00:01:11,400 --> 00:01:13,590

At this point, you must be having the answer.



18

00:01:13,770 --> 00:01:20,400

The answer is that the credit cards bounded contacts will be a conformists for the retail account,



19

00:01:20,730 --> 00:01:26,280

and the reason is because credit cards team has decided to accept the model from the account.



20

00:01:27,000 --> 00:01:27,910

Next question.



21

00:01:27,930 --> 00:01:34,770

The personal loans team is using the retail account function but is concerned about the use of outside



22

00:01:34,770 --> 00:01:37,440

model within the bonded context.



23

00:01:37,590 --> 00:01:43,950

What kind of a pattern would you place between the personal loans and the retail accounts if you need



24

00:01:43,950 --> 00:01:44,950

more time to think?



25

00:01:44,970 --> 00:01:45,990

Please pause the video.



26

00:01:46,770 --> 00:01:53,490

OK, the answer is that since the personal loans is concerned about corruption of the personal loans,



27

00:01:53,490 --> 00:01:59,700

bonded contacts, they will use the anti-corruption layer for carrying out the translation between the



28

00:01:59,880 --> 00:02:03,420

models from retail account to personal loans account.



29

00:02:03,960 --> 00:02:06,180

Next question involves two parts.



30

00:02:06,450 --> 00:02:13,890

The customer management team is exposing a common set of services and the retail accounts team has decided



31

00:02:13,890 --> 00:02:15,780

to use the common services.



32

00:02:15,780 --> 00:02:17,030

But what protection?



33

00:02:17,340 --> 00:02:22,620

So what are the patterns used between the customer management and retailer called?



34

00:02:22,950 --> 00:02:25,440

Please pause the video and try to answer the question.



35

00:02:26,310 --> 00:02:26,770

All right.



36

00:02:27,240 --> 00:02:32,610

The answer is the customer management team will implement the open hosted service pattern.



37

00:02:32,790 --> 00:02:38,430

The published language and the retail accounts team will use the anti-corruption layer.



38

00:02:39,570 --> 00:02:40,470

Next question.



39

00:02:40,740 --> 00:02:47,640

Personal loans and credit card teams have decided to use the common services exposed by customer management



40

00:02:47,640 --> 00:02:52,190

team, and they have also decided to accept the purchase models.



41

00:02:52,650 --> 00:02:59,790

So what would the relationship between the customer management and credit cards and customer management



42

00:03:00,120 --> 00:03:02,640

and personal loans deliver the answer?



43

00:03:03,240 --> 00:03:10,770

The answer is that since both have decided to accept the purchase models, they will both be the conformist



44

00:03:10,920 --> 00:03:12,140

in this relationship.



45

00:03:12,450 --> 00:03:15,060

So this is an example of context.



46

00:03:15,060 --> 00:03:23,270

Map for banking, ready for part two in part to I'm going to describe a change to one of the bonded



47

00:03:23,280 --> 00:03:30,450

contacts and based on the context mapping, you need to decide the impact of that change on other bonded



48

00:03:30,450 --> 00:03:31,080

contacts.



49

00:03:31,530 --> 00:03:38,910

Question number one and part two, which blended context is expected to be most influenced by changes



50

00:03:38,910 --> 00:03:40,620

in other blended contexts.



51

00:03:40,800 --> 00:03:43,200

And why are you ready for the answer?



52

00:03:43,740 --> 00:03:52,380

The answer is the credit cards blended context will be most impacted because it is dependent on customer



53

00:03:52,380 --> 00:03:54,360

management and the retail accounts.



54

00:03:54,670 --> 00:04:01,500

And since it's a conformist, any change to the retail accounts or customer management would require



55

00:04:01,500 --> 00:04:03,630

a change in the credit cards.



56

00:04:04,140 --> 00:04:10,380

Question number two, which blended context is not expected to be influenced by changes in the other



57

00:04:10,380 --> 00:04:11,310

blended context.



58

00:04:11,460 --> 00:04:13,180

And why ready for the answer?



59

00:04:13,620 --> 00:04:15,510

The answer is retail Ellacott.



60

00:04:15,780 --> 00:04:25,620

And the reason is that in the relationships where it is acting as the downstream, it is using an anti-corruption



61

00:04:25,620 --> 00:04:28,950

layer and the other relationships are both upstream.



62

00:04:29,220 --> 00:04:35,850

As a result, the retail account is the most independent of protected bounded context in this context



63

00:04:35,850 --> 00:04:36,310

mapping.



64

00:04:36,750 --> 00:04:37,530

Last question.



65

00:04:37,890 --> 00:04:45,530

What all will need to be adjusted if there is a change in the integration model exposed by the Oireachtas



66

00:04:45,540 --> 00:04:50,360

or the open hosted service implemented by the customer management team?



67

00:04:50,510 --> 00:04:52,660

Please post the video if you need more time.



68

00:04:52,830 --> 00:04:53,260

All right.



69

00:04:53,400 --> 00:04:59,700

The answer is that the credit cards and the personal loans, bonded contacts are both.



70

00:04:59,930 --> 00:05:06,860

Conformist to the customer management common services, so a change in the integration model will require



71

00:05:07,010 --> 00:05:09,940

a change in both of these bonded contacts.



72

00:05:10,440 --> 00:05:17,480

Now that Lecomte is also using the purchase, but since it is using the issue or the anti-corruption



73

00:05:17,480 --> 00:05:20,990

law, changes will only be needed in the easier.



74

00:05:21,260 --> 00:05:25,730

And the retail accounts bonded contracts will not need to be adjusted.



75

00:05:25,880 --> 00:05:28,310

I hope you enjoyed this exercise.



76

00:05:28,610 --> 00:05:30,470

Let's move on to the next lecture.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000001.srt -->

1
00:00:00,210 --> 00:00:17,050
Bối cảnh liên kết, các mối quan hệ, không liên kết với các liên hệ là độc lập, các liên hệ được liên kết trên cơ thể không bị cô lập với các liên hệ được liên kết khác xung quanh chúng, các mô hình trong các liên hệ được liên kết cộng tác để đáp ứng các yêu cầu của hệ thống.

2
00:00:17,250 --> 00:00:25,650
Tiền đề cơ bản đằng sau điều này là khi bạn xây dựng các dịch vụ vi mô, chúng sẽ không tự đáp ứng tất cả các yêu cầu của hệ thống.

3
00:00:25,940 --> 00:00:38,010
Các dịch vụ vi mô này sẽ cần tương tác với các dịch vụ vi mô khác.  Những mối quan hệ này ngụ ý một số loại phụ thuộc giữa các liên hệ được liên kết hoặc các dịch vụ vi mô.

4
00:00:38,280 --> 00:00:47,610
Có nhiều loại mối quan hệ giữa các tiếp điểm liên kết theo mối quan hệ đối xứng để các tiếp điểm liên kết phụ thuộc lẫn nhau.

5
00:00:48,120 --> 00:00:57,570
Vì vậy, trong trường hợp này, bối cảnh phụ thuộc vào ranh giới.  Địa chỉ liên hệ là địa chỉ liên hệ được gửi đến B phụ thuộc vào bối cảnh được liên kết.

6
00:00:57,600 --> 00:01:15,120
Trong một mối quan hệ không đối xứng, 100 liên hệ phụ thuộc vào 100 liên hệ khác.  Vì vậy, trong ví dụ này, bối cảnh BONARD phụ thuộc vào bối cảnh liên kết b trong mối quan hệ một-nhiều, nhiều liên hệ liên kết phụ thuộc vào một bối cảnh liên kết.

7
00:01:15,570 --> 00:01:24,600
Có nhiều mẫu mối quan hệ phân phối.  Các mẫu mối quan hệ này xác định mối quan hệ phụ thuộc giữa các tiếp điểm được liên kết.

8
00:01:24,600 --> 00:01:38,280
Bạn sẽ học tất cả các mẫu hình mối quan hệ trong phần này.  Big bowl of Maat là một đối cực trong quá trình phát triển phần mềm và với tư cách là nhà thiết kế các dịch vụ vi mô, bạn phải tránh tạo ra một bối cảnh lớn.

9
00:01:38,280 --> 00:01:49,560
Có lẽ là sự thể hiện trực quan về mối quan hệ giữa các điểm tiếp xúc bị chặn mà bạn sẽ học về các điểm tiếp xúc, bản đồ và quả cầu bùn lớn trong bài giảng tiếp theo.

10
00:01:50,580 --> 00:01:56,380
Hãy cùng điểm qua các mục tiêu học tập của phần này để bạn có thể giải thích được.

11
00:01:56,410 --> 00:02:11,100
Quả bóng bùn lớn và các địa chỉ liên hệ, bản đồ, bạn sẽ có thể mô tả những thách thức liên quan đến quả bóng bùn lớn và cách lập bản đồ ngữ cảnh có thể giúp bạn tìm hiểu tất cả các mẫu chi tiết liên quan đến mối quan hệ.

12
00:02:11,260 --> 00:02:18,960
Vì vậy, bạn sẽ có thể chọn một mẫu mối quan hệ thích hợp để xác định các phụ thuộc bối cảnh liên kết của mình.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000002.srt -->

1
00:00:00,120 --> 00:00:24,510
Quản lý mối quan hệ giữa các liên hệ liên kết trong bài học này, Alcoa và Antiproton được gọi là quả bóng bùn lớn, bạn cũng sẽ tìm hiểu về những thách thức liên quan đến các liên hệ liên kết, sự phụ thuộc và bạn tìm hiểu về các liên hệ, bản đồ có thể giúp quản lý BONARD  sự phụ thuộc vào bối cảnh, các liên hệ bị giới hạn không được quản lý, mối quan hệ dẫn đến một cục bùn lớn.

2
00:00:24,510 --> 00:00:41,210
Quả bóng bùn lớn đề cập đến các mô hình có cấu trúc hiện tại dẫn đến mã spaghetti.  Loại mô hình và mã spaghetti này thường được tạo ra bởi sự tăng trưởng và sửa lỗi không được kiểm soát trong một khoảng thời gian.

3
00:00:41,340 --> 00:00:53,080
Bát bùn lớn trong bối cảnh thiết kế hướng miền đề cập đến một mô hình hoạt động.  Với tư cách là người thiết kế một dịch vụ, bạn nên đảm bảo rằng mình không tạo ra một quả bùn lớn.

4
00:00:53,730 --> 00:01:00,750
Bây giờ chúng tôi biết rằng các liên hệ ngoại quan không thể bị cô lập.  Sẽ có những mối quan hệ phụ thuộc.

5
00:01:00,960 --> 00:01:11,580
Những mối quan hệ này cần được quản lý.  Nếu không thì sẽ mất đi sự liêm chính về mặt đạo đức và sẽ mất đi khả năng hoạt động độc lập của nhóm.

6
00:01:11,760 --> 00:01:22,200
Chúng ta hãy vượt qua những thử thách này.  Hãy xem xét kịch bản trong đó chúng ta có bối cảnh liên kết và bối cảnh liên kết đánh bại từng liên hệ liên kết này, có mô hình riêng.

7
00:01:22,590 --> 00:01:33,540
Bây giờ, giả sử hiện có sự phụ thuộc giữa A và B.  Nó phụ thuộc vào B, có nghĩa là bạn sẽ có khả năng hiển thị các mô hình này.

8
00:01:33,870 --> 00:01:48,930
Và tác động là không có ranh giới ngôn ngữ trong bối cảnh ngoại quan, nó không giữ được.  Có thể có sự nhầm lẫn về ngôn ngữ được sử dụng cho mô hình của A và B.

9
00:01:49,080 --> 00:01:58,170
Nói cách khác, bối cảnh pha trộn.  Bây giờ nó đã bị ô nhiễm và đây là điều được gọi là sự mất liêm chính về mặt đạo đức.

10
00:01:59,070 --> 00:02:06,350
Bối cảnh ngoại quan được phát hiện trong lĩnh vực thiết kế đô thị được chuyển thành một hoặc nhiều dịch vụ vi mô.

11
00:02:06,690 --> 00:02:23,070
Vì vậy, trong ví dụ này, các liên hệ giới hạn quản lý khách hàng được dịch sang vi mạch khách hàng, trong khi ngữ cảnh giới hạn tài khoản bán lẻ được dịch sang hai tài khoản tiết kiệm dịch vụ vi mô, dịch vụ vi mô và dịch vụ vi mô tài khoản séc.

12
00:02:23,100 --> 00:02:31,100
Sự phụ thuộc giữa bối cảnh bị ràng buộc cuối cùng được chuyển thành sự phụ thuộc giữa các dịch vụ vi mô.

13
00:02:31,530 --> 00:02:38,890
Vì vậy, trong ví dụ này, dịch vụ maiko tài khoản thẻ tín dụng phụ thuộc vào dịch vụ vi mô của khách hàng.

14
00:02:38,910 --> 00:02:55,170
Mỗi dịch vụ này được quản lý bởi các nhóm độc lập và mối quan hệ phụ thuộc giữa các dịch vụ vi mô này sẽ có nghĩa là bất cứ khi nào có thay đổi về dịch vụ vi mô của khách hàng thì dịch vụ vi mô thẻ tín dụng sẽ cần phải thay đổi.

15
00:02:55,170 --> 00:03:02,160
Vì vậy, tất cả các thay đổi sẽ yêu cầu một số hình thức hợp tác giữa các nhóm sở hữu các dịch vụ vi mô này.

16
00:03:02,160 --> 00:03:16,560
Và điều đó có nghĩa là các nhóm sẽ mất khả năng hoạt động độc lập và điều đó sẽ dẫn đến mất đi tính linh hoạt, điều này trái ngược với một trong những lý do khiến kiến ​​trúc dịch vụ vi mô được áp dụng.

17
00:03:17,570 --> 00:03:32,270
Bây giờ, chúng ta biết rằng các liên hệ Mongered, sự phụ thuộc hoặc Microsoft cho biết không thể tránh khỏi sự phụ thuộc.  Vì vậy, đề xuất là quản lý các liên hệ, mối quan hệ được liên kết này bằng cách sử dụng các mẫu thiết kế hướng miền thích hợp.

18
00:03:32,480 --> 00:03:43,730
Các đội phải nỗ lực có ý thức để không tạo ra một quả bóng bùn lớn và họ phải ghi lại mối quan hệ giữa các điểm tiếp xúc được liên kết bằng cách sử dụng danh bạ, bản đồ.

19
00:03:44,210 --> 00:03:55,260
Hãy để tôi giải thích bản đồ bối cảnh là gì.  Bản đồ bối cảnh là sự thể hiện trực quan của các hệ thống, các liên hệ Bundgaard và mối quan hệ giữa chúng.

20
00:03:55,640 --> 00:04:08,060
Đây là một ví dụ về cách bản đồ liên hệ của chúng tôi trông giống như mối quan hệ giữa các liên hệ được liên kết được mô tả bằng các chữ cái này trong khối, bạn sẽ tìm hiểu các ký hiệu bản đồ ngữ cảnh.

21
00:04:08,300 --> 00:04:18,010
Trong phần này.  Có nhiều lợi ích của việc sử dụng bản đồ liên lạc.  Đầu tiên là nó giúp các thành viên trong nhóm dễ dàng hiểu được bức tranh toàn cảnh hơn.

22
00:04:18,050 --> 00:04:32,420
Tiếp theo là nó giúp hiểu được sự phụ thuộc lẫn nhau giữa các liên hệ bị ràng buộc.  Thứ ba là nó giúp các nhóm đánh giá mức độ hợp tác cần thiết với các nhóm khác.

23
00:04:32,600 --> 00:04:40,730
Bản đồ liên hệ cũng giúp sàng lọc các liên hệ được giới hạn và các mô hình.  Chúng ta hãy điểm qua những điểm chính từ bài học này.

24
00:04:41,250 --> 00:04:58,940
Với tư cách là người thiết kế các máy chủ vi mô, bạn phải tránh tạo ra một cục bùn lớn.  Ý tưởng là nếu bạn tạo quá nhiều sự phụ thuộc giữa các liên hệ bị ràng buộc, điều đó sẽ dẫn đến việc mất đi những lợi ích mà bạn mong đợi nhận được từ kiến ​​trúc dịch vụ vi mô.

25
00:04:59,270 --> 00:05:09,950
Điều tiếp theo là với tư cách là nhà thiết kế dịch vụ vi mô, bạn phải sử dụng các mẫu DTT được xác định rõ ràng để xác định mối quan hệ giữa các liên hệ bị ràng buộc của mình.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000003.srt -->

1
00:00:00,180 --> 00:00:17,970
Mối quan hệ đối xứng trong bài học này, bạn đã học về ba mô hình chiến lược mới, các cách thức riêng biệt, mô hình hợp tác và mô hình hạt nhân chung, có thể xảy ra tình huống trong đó các liên hệ được liên kết trong một hệ thống không có mối quan hệ nào với các liên hệ được liên kết khác.

2
00:00:18,180 --> 00:00:29,440
Trong trường hợp như vậy, các liên hệ được liên kết thực sự độc lập hoặc tự chủ.  Hãy xem xét tình huống trong đó chúng ta có hai liên hệ liên kết và B không có mối quan hệ nào.

3
00:00:29,610 --> 00:00:40,770
Điều đó có nghĩa là không có sự chia sẻ mô hình giữa hai địa chỉ liên hệ được liên kết này vì các nhóm độc lập của họ có thể tự động làm việc trên hai địa chỉ liên hệ được liên kết này.

4
00:00:40,780 --> 00:00:52,920
Nói cách khác, các nhóm này không phải cộng tác hay phối hợp cho bất kỳ nhiệm vụ nào.  Bây giờ, một số người sẽ cho rằng có cơ hội sử dụng lại các phần của A và B hoặc ngược lại.

5
00:00:52,980 --> 00:01:00,180
Nhưng người ta phải xem xét sự đánh đổi.  Và đánh đổi là nếu có tái sử dụng thì sẽ mất quyền tự chủ.

6
00:01:00,180 --> 00:01:14,700
Vì vậy hãy đi sâu hơn một chút.  Giả sử có một mô hình và một được chia sẻ bởi B, không, các nhóm không thể làm việc tự chủ y vì nếu phải thay đổi mô hình thì nhóm của B sẽ phải đồng ý với những thay đổi đó.

7
00:01:14,700 --> 00:01:25,320
Và đó là mối quan tâm liên quan đến việc tái sử dụng.  Không có mối quan hệ nào giữa các ranh giới liên hệ được gọi là các cách riêng biệt từ góc nhìn hiện thực hóa.

8
00:01:25,560 --> 00:01:32,610
Điều đó có nghĩa là chúng sẽ là tập hợp các ứng dụng hoặc dịch vụ độc lập cho từng điểm tiếp xúc được liên kết.

9
00:01:32,820 --> 00:01:41,330
Ví dụ, trong trường hợp ngân hàng, chúng ta có thẻ tín dụng và khoản vay mua nhà không có mối quan hệ nào.

10
00:01:41,490 --> 00:01:47,760
Trong trường hợp đó, các nhóm sẽ độc lập phát triển các ứng dụng và dịch vụ cho hai liên hệ liên kết này.

11
00:01:47,760 --> 00:01:57,020
Và điều đó có nghĩa là hai nhóm này có thể làm việc độc lập theo nhịp độ riêng của họ để đáp ứng các mục tiêu kinh doanh của đơn vị kinh doanh tương ứng của họ.

12
00:01:57,300 --> 00:02:16,710
Đôi khi bạn tìm thấy những liên hệ bị giới hạn có sự phụ thuộc lẫn nhau.  Loại mối quan hệ giữa các tiếp điểm được liên kết này được gọi là mối quan hệ đối xứng hoặc sự phụ thuộc hai chiều có thể là mối quan hệ đối xứng, một nơi chắc chắn không có ánh sáng giữa các tiếp điểm được liên kết.

13
00:02:16,740 --> 00:02:28,290
Sự phụ thuộc lẫn nhau này dẫn đến mức độ kết hợp cao giữa bối cảnh gắn kết và loại mối quan hệ này được gọi là Quan hệ đối tác và Thiết kế theo nhu cầu.

14
00:02:28,710 --> 00:02:36,450
Từ góc độ hiện thực hóa, mô hình hợp tác chuyển thành các dịch vụ có sự phụ thuộc lẫn nhau.

15
00:02:36,480 --> 00:02:49,040
Vì vậy, điều đó có nghĩa là các dịch vụ có thể được phát triển bởi các nhóm khác nhau, nhưng do sự phụ thuộc lẫn nhau giữa các dịch vụ nên các nhóm không thể hoạt động độc lập.

16
00:02:49,260 --> 00:03:01,200
Không chỉ vậy, mỗi nhóm tham gia vào loại mối quan hệ này sẽ cần phải tìm hiểu các mô hình kinh doanh và ngôn ngữ phổ biến đó cho các mối liên hệ gắn kết do nhóm kia quản lý.

17
00:03:01,230 --> 00:03:14,700
Cuối cùng, điều này có nghĩa là các nhóm trong mối quan hệ kiểu này sẽ cần phối hợp các thay đổi, triển khai và phát hành của họ, và điều đó sẽ làm hỏng mục đích áp dụng kiến ​​trúc dịch vụ vi mô.

18
00:03:15,090 --> 00:03:25,670
Bây giờ, câu hỏi hiển nhiên mà bạn có thể có vào thời điểm này là làm cách nào để giải quyết vấn đề này?  Một cách để giải quyết vấn đề này là phân định ranh giới cho các mô hình dùng chung.

19
00:03:26,040 --> 00:03:39,400
Vì vậy, giả sử hai nhóm độc lập đang làm việc trên bối cảnh hỗn hợp và bối cảnh tự nguyện.  B, họ có thể tạo ranh giới xung quanh các mô hình được chia sẻ giữa hai điểm tiếp xúc được liên kết.

20
00:03:39,600 --> 00:03:55,740
Ý tưởng là quản lý các mô hình chia sẻ này một cách độc lập với phần còn lại của bối cảnh liên kết.  Vì vậy, điều đó có nghĩa là nếu cần thay đổi và thay đổi này không phải là một phần của mô hình được chia sẻ thì nhóm được chỉ định cho các liên hệ bị giới hạn có thể đưa ra quyết định độc lập.

21
00:03:55,770 --> 00:04:03,360
Tương tự, nếu có những thay đổi cần thiết bên ngoài các mô hình được chia sẻ và các liên hệ bị ràng buộc, hãy là nhóm được chỉ định cho các liên hệ liên kết.

22
00:04:03,360 --> 00:04:12,390
B có thể đưa ra những quyết định đó một cách độc lập.  Nhưng bất cứ lúc nào, nếu có nhu cầu thay đổi mẫu dùng chung thì 2 đội sẽ phối hợp.

23
00:04:12,510 --> 00:04:36,180
Việc chia sẻ mô hình giữa các liên hệ bị chặn được gọi là mẫu mục tiêu chung.  Điều quan trọng cần ghi nhớ đối với Carneal được chia sẻ là các phần chồng chéo của các liên hệ thể hiện mô hình miền chung, các khái niệm được chia sẻ và ngôn ngữ kinh doanh được chia sẻ giữa hai liên hệ được liên kết.

24
00:04:36,850 --> 00:04:46,560
Thông thường, hạt nhân dùng chung được hiện thực hóa bằng Labrys dùng chung, chẳng hạn như Java, Java, Gói Python và Ruby Gems.

25
00:04:46,560 --> 00:04:59,850
Các nhóm có thể phát triển độc lập các dịch vụ sử dụng các thư viện dùng chung này.  Các nhóm có thể sử dụng kernel dùng chung và Labrys dùng chung miễn là phạm vi chia sẻ.

26
00:05:00,070 --> 00:05:16,950
Giữa các tiếp điểm liên kết được giới hạn ở một tập hợp nhỏ các mô hình cho các tình huống liên quan đến việc chia sẻ quá nhiều mô hình giữa các tiếp điểm được liên kết, việc duy trì tính toàn vẹn của ranh giới của các tiếp điểm biên sẽ trở nên khó khăn.

27
00:05:16,960 --> 00:05:27,070
Và đó là lý do gợi ý chỉ sử dụng kernel dùng chung nếu chúng ta đang nói về một tập hợp nhỏ các khái niệm được chia sẻ giữa các liên hệ bị chặn.

28
00:05:27,580 --> 00:05:37,570
Trong bài học này, tôi đã đề cập đến ba mô hình chiến lược.  Cách đầu tiên là những cách riêng biệt trong đó không có mối quan hệ nào giữa các liên hệ bị chặn.

29
00:05:37,600 --> 00:05:49,840
Kết quả là, các nhóm làm việc trên hai điểm tiếp xúc liên kết có thể làm việc thực sự độc lập.  Tiếp theo là mô hình hợp tác trong đó có sự phụ thuộc lẫn nhau giữa các liên hệ bị ràng buộc.

30
00:05:49,960 --> 00:06:13,070
Do đó, các đội phải phối hợp với nhau để thực hiện các thay đổi đối với các liên hệ giới hạn của riêng mình.  Thứ ba là Kamna được chia sẻ, trong đó đề xuất rằng ranh giới của các khái niệm và mô hình được chia sẻ phải được phân định rõ ràng và chỉ những thay đổi đối với các mô hình chung này mới cần được các nhóm điều phối.

31
00:06:13,240 --> 00:06:24,940
Nói cách khác, nếu nhóm đang thực hiện những thay đổi không liên quan đến các mô hình hoặc khái niệm được chia sẻ thì nhóm có thể thực hiện những thay đổi đó mà không cần ý kiến ​​đóng góp của nhóm khác.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:15,200
Mối quan hệ bất đối xứng trong bài học này, bạn học hai thuật ngữ mới, bối cảnh ranh giới thượng nguồn và bối cảnh ranh giới hạ lưu, đồng thời tôi sẽ đề cập đến ba mô hình mô hình cung ứng khách hàng, mô hình tuân thủ và mô hình lớp chống tham nhũng.

2
00:00:15,780 --> 00:00:32,100
Trong bài giảng trước bạn đã học về mối quan hệ đối xứng.  Trong bài giảng này tôi sẽ trình bày chi tiết về mối quan hệ bất đối xứng giữa bối cảnh bị chặn trong một mối quan hệ bất đối xứng, một bối cảnh bị ràng buộc có sự phụ thuộc vào một bối cảnh bị ràng buộc khác.

3
00:00:32,220 --> 00:00:53,910
Loại mối quan hệ này được mô tả bằng cách gán vai trò cho bối cảnh bị ràng buộc.  Bối cảnh BONARD đưa người dùng vào bối cảnh bị ràng buộc khác được đề cập đến trong vai trò thượng nguồn và bối cảnh bị ràng buộc phụ thuộc vào bối cảnh bị ràng buộc khác được đề cập đến bởi bối cảnh bị ràng buộc ở phía dưới.

4
00:00:54,030 --> 00:01:03,210
Vì vậy, điều này mô tả một mối quan hệ trong đó bối cảnh bị ràng buộc.  Nó phụ thuộc vào bối cảnh giới hạn.  B nói cách khác, bối cảnh ranh giới.

5
00:01:03,210 --> 00:01:15,530
Nó có kiến ​​thức về các mô hình và bối cảnh giới hạn.  B Và vì mối quan hệ là bối cảnh ranh giới bất đối xứng nên B không có bất kỳ kiến ​​thức nào về mô hình trong bối cảnh bị chặn.

6
00:01:15,540 --> 00:01:24,240
Điều quan trọng cần ghi nhớ ở đây là mối quan hệ này không biểu thị luồng dữ liệu hoặc thông tin.

7
00:01:24,360 --> 00:01:37,770
Nó mô tả sự phụ thuộc từ góc độ hiện thực hóa.  Bối cảnh giới hạn ngược dòng hiển thị một số chức năng và mô hình được sử dụng bởi bối cảnh giới hạn xuôi dòng.

8
00:01:37,980 --> 00:01:50,490
Bây giờ có hai tùy chọn mà bối cảnh giới hạn ngược dòng có.  Nó có thể hiển thị chức năng và mô hình dựa trên nhu cầu của bối cảnh giới hạn xuôi dòng.

9
00:01:50,820 --> 00:02:03,180
Và tùy chọn thứ hai là bối cảnh giới hạn ngược dòng hiển thị các chức năng và mô hình nhất định mà không có bất kỳ sự cân nhắc nào đến nhu cầu của bối cảnh giới hạn xuôi dòng.

10
00:02:03,480 --> 00:02:18,840
Đây là hai mẫu riêng biệt.  Hãy thảo luận chi tiết về những điều này.  Vì vậy, trong trường hợp tùy chọn số một, bối cảnh giới hạn ngược dòng đã đáp ứng một số nhu cầu cụ thể của bối cảnh giới hạn xuôi dòng.

11
00:02:19,050 --> 00:02:31,140
Và mẫu này được gọi là nguồn cung mẫu của khách hàng.  Hãy nghĩ về nó giống như một máy chủ khách, Pachon, trong đó máy chủ tạo ra các giao diện dựa trên nhu cầu của khách hàng.

12
00:02:31,260 --> 00:02:44,910
Từ góc độ hiện thực hóa, nhóm nhà cung cấp luôn tham khảo ý kiến ​​​​của nhóm khách hàng để đảm bảo rằng máy chủ của nhà cung cấp đáp ứng được nhu cầu dịch vụ khách hàng.

13
00:02:45,810 --> 00:02:57,060
Hãy thảo luận về tùy chọn số hai, trong đó bối cảnh giới hạn ngược dòng hiển thị các mô hình mà không liên quan đến bất kỳ yêu cầu hoặc nhu cầu nào của bối cảnh giới hạn ngược dòng.

14
00:02:57,210 --> 00:03:05,430
Trong kịch bản, bối cảnh giới hạn xuôi dòng ngoại trừ các mô hình được hiển thị bởi bối cảnh giới hạn ngược dòng.

15
00:03:05,550 --> 00:03:31,770
Kiểu quan hệ này được gọi là mô hình tuân thủ.  Trong mẫu này, bối cảnh ranh giới hạ lưu tuân theo các mô hình bối cảnh giới hạn thượng nguồn để mô tả mối quan hệ này, chữ D bên cạnh bối cảnh giới hạn hạ lưu được thay thế bằng ghế F, do đó, trong bối cảnh giới hạn sơ đồ này, nó phù hợp với các mô hình được biểu thị bởi  bối cảnh bị giới hạn.

16
00:03:31,770 --> 00:03:40,800
B Một điểm quan trọng cần lưu ý ở đây là cả hai bối cảnh được giới hạn đều sử dụng cùng một mô hình.  Để cho bạn một ví dụ từ lĩnh vực ngân hàng.

17
00:03:40,950 --> 00:03:54,450
Giả sử có thẻ tín dụng ngữ cảnh giới hạn và bối cảnh giới hạn để quản lý khách hàng.  Đội ngũ quản lý khách hàng phát triển và làm chủ mô hình cho khách hàng và ranh giới quản lý khách hàng.

18
00:03:54,460 --> 00:04:06,210
Ngữ cảnh đóng vai trò ngược dòng đối với thẻ tín dụng.  Nhóm thẻ tín dụng quyết định áp dụng mô hình do nhóm quản lý khách hàng tạo ra và quản lý.

19
00:04:06,540 --> 00:04:14,850
Trong trường hợp đó, họ sẽ không cần dịch đối tượng khách hàng giữa các liên hệ được giới hạn.

20
00:04:15,360 --> 00:04:23,940
Không xem xét kịch bản trong đó bối cảnh giới hạn xuôi dòng quyết định không tuân theo bối cảnh giới hạn ngược dòng.

21
00:04:23,940 --> 00:04:32,580
Nói cách khác, nhóm dành cho bối cảnh bị giới hạn.  Nó quyết định tạo ra mô hình của riêng mình thay vì áp dụng các mô hình cho ngữ cảnh bị giới hạn.

22
00:04:32,940 --> 00:04:46,710
Trong trường hợp đó, các mô hình từ ngữ cảnh bị chặn sẽ được hiển thị trong ngữ cảnh bị chặn.  Nó sẽ yêu cầu một số loại bản dịch để chuyển đổi các mô hình từ bối cảnh bị ràng buộc sang bối cảnh bị ràng buộc.

23
00:04:47,070 --> 00:04:59,730
Đề xuất là tách logic dịch thuật này thành một lớp riêng biệt.  Cấp độ này của bản dịch được gọi là trực tiếp chống tham nhũng và mô hình này còn được gọi là Antichrist.

24
00:05:00,860 --> 00:05:11,530
Ý tưởng đằng sau luật sư chống tham nhũng là bảo vệ bối cảnh ngoại quan khỏi tham nhũng.  Loại mối quan hệ này được mô tả bằng cách thay thế ACL.

25
00:05:11,600 --> 00:05:18,620
Vì vậy, ở đây chúng tôi đang mô tả mối quan hệ giữa A và B trong mỗi bối cảnh liên kết này, có mô hình riêng.

26
00:05:18,620 --> 00:05:31,750
Họ không có kiến ​​thức gì về mô hình của nhau ngoại trừ việc ACL có kiến ​​thức cần thiết về cả hai mô hình của A và B và thực hiện việc chuyển đổi từ morou của B sang mô hình của anh ta.

27
00:05:32,120 --> 00:05:46,790
Giả sử nhóm quản lý khách hàng quyết định mô tả khách hàng bằng ba thuộc tính này và nhóm thẻ tín dụng quyết định gọi khách hàng là chủ tài khoản trong bối cảnh thẻ tín dụng.

28
00:05:47,030 --> 00:06:01,890
Và đây là những thuộc tính mà họ quyết định sử dụng để mô tả nhóm thẻ tín dụng của chủ tài khoản đã quyết định tận dụng một số chức năng từ bộ phận quản lý khách hàng và liên hệ với bộ phận chống tham nhũng.

29
00:06:02,510 --> 00:06:17,630
Vì vậy, trong kịch bản này, lớp chống tham nhũng sẽ có logic dịch thuật để chuyển đổi khách hàng từ bối cảnh quản lý khách hàng sang chủ tài khoản trong bối cảnh thẻ tín dụng.

30
00:06:17,930 --> 00:06:33,880
Và điều này có nghĩa là ánh xạ các thuộc tính khác nhau, chẳng hạn như tên, họ.  Và ở đây, như bạn có thể thấy, có một số loại thuộc tính nhận dạng chính phủ được ánh xạ tới SSN hoặc số An sinh xã hội của khách hàng.

31
00:06:33,890 --> 00:06:46,050
Và ánh xạ này cũng liên quan đến việc đặt loại nhận dạng thành SSN.  Vì vậy, đây là ví dụ về logic dịch thuật được tích hợp trong ACL hoặc lớp chống tham nhũng.

32
00:06:46,460 --> 00:06:55,430
Vì vậy, điều đó có nghĩa là lớp chống tham nhũng cần phải có kiến ​​thức về cả mô hình hạ nguồn cũng như mô hình thượng nguồn.

33
00:06:55,760 --> 00:07:07,580
Nhưng hạ lưu không có kiến ​​thức về bối cảnh giới hạn thượng nguồn, và đó là cách lớp chống tham nhũng bảo vệ hạ lưu khỏi những thay đổi ở thượng nguồn.

34
00:07:08,720 --> 00:07:16,310
Trong bài học này, bạn đã tìm hiểu về mối quan hệ bất đối xứng giữa bối cảnh ranh giới và mối quan hệ bất đối xứng.

35
00:07:16,490 --> 00:07:23,480
Bối cảnh ranh giới hạ nguồn phụ thuộc vào bối cảnh ranh giới thượng nguồn trong mẫu nhà cung cấp khách hàng.

36
00:07:23,480 --> 00:07:40,430
Bối cảnh giới hạn ngược dòng điều chỉnh các mô hình theo nhu cầu của bối cảnh giới hạn xuôi dòng, trong khi ở mẫu tuân thủ, bối cảnh giới hạn ngược dòng không liên quan đến nhu cầu của bối cảnh giới hạn xuôi dòng.

37
00:07:40,430 --> 00:07:52,310
Và do đó, bối cảnh ranh giới phía hạ nguồn phù hợp với các mô hình thượng nguồn.  Để bảo vệ bối cảnh ranh giới hạ nguồn, các đội sẽ quyết định sử dụng lớp chống tham nhũng.

38
00:07:52,470 --> 00:08:00,200
Lớp chống tham nhũng này có logic để dịch các mô hình từ định dạng ngược dòng sang định dạng xuôi dòng.

39
00:08:00,200 --> 00:08:09,410
Formic, theo hướng đó xuôi dòng.  Bối cảnh bị ràng buộc không có kiến ​​thức về bối cảnh mô hình ngược dòng và do đó không có sự phụ thuộc trực tiếp.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000005.srt -->

1
00:00:00,150 --> 00:00:17,640
Một đối nhiều, mối quan hệ trong bài giảng này nhấn mạnh hai mẫu khảo sát nội bộ mở và mẫu ngôn ngữ được công bố trong mối quan hệ một đến nhiều liên hệ giới hạn ngược dòng được gọi là Provida cung cấp các dịch vụ chung cho hai hoặc nhiều bối cảnh bị ràng buộc.

2
00:00:17,670 --> 00:00:27,300
Trong ví dụ này, Inbee là bối cảnh giới hạn xuôi dòng và C là bối cảnh ranh giới ngược dòng đang cung cấp các dịch vụ chung.

3
00:00:27,430 --> 00:00:42,780
Và B các mô hình tích hợp chung được xác định bởi bối cảnh bị ràng buộc.  C Bất kể nhu cầu của A hoặc B, bối cảnh giới hạn ở hạ lưu có thể quyết định tuân thủ hoặc sử dụng athea.

4
00:00:42,990 --> 00:00:55,340
Vì vậy, trong ví dụ này, A là người tuân thủ, trong khi B đang sử dụng lớp chống tham nhũng.  Những quyết định này được đưa ra bởi các nhóm làm việc độc lập trên các bối cảnh giới hạn này.

5
00:00:55,590 --> 00:01:25,800
Bối cảnh ranh giới ngược dòng cung cấp các dịch vụ chung được gọi là dịch vụ nguồn mở và mẫu này được gọi là mẫu dịch vụ nguồn mở để mô tả dịch vụ chung này dưới dạng mẫu được đặt trước bối cảnh giới hạn ngược dòng cung cấp  các dịch vụ chung, bối cảnh giới hạn ngược dòng hoặc nhà cung cấp dịch vụ được lưu trữ mở trong mối quan hệ này cung cấp một ngôn ngữ chung để tích hợp.

6
00:01:26,030 --> 00:01:39,990
Ngôn ngữ chung này được các nhóm làm việc trong bối cảnh giới hạn ở hạ lưu chấp nhận.  Ngôn ngữ chung này được gọi là ngôn ngữ được xuất bản và mẫu này được gọi là mẫu ngôn ngữ được xuất bản.

7
00:01:40,650 --> 00:01:48,960
Việc sử dụng ngôn ngữ đã xuất bản được mô tả bằng cách đặt APL ở phía trước thượng nguồn cùng với Oireachtas.

8
00:01:49,240 --> 00:02:01,500
Vì vậy, ánh xạ ngữ cảnh này mô tả một kịch bản trong đó C đang cung cấp các dịch vụ chung.  Tức là nó có nhà cung cấp Oireachtas và cũng có ngôn ngữ được xuất bản.

9
00:02:02,070 --> 00:02:15,580
Hãy gọi nó là một ví dụ về việc thực hiện các dịch vụ phổ biến.  Chức năng này được hiển thị theo cách có bối cảnh giới hạn và được chấp nhận tốt bởi bối cảnh giới hạn phía dưới.

10
00:02:15,660 --> 00:02:30,840
Vì vậy, hãy nghĩ đến một nhóm tạo ra một dịch vụ giúp bộc lộ những khoảng trống.  Và giả sử nhóm này cũng đang xuất bản các lược đồ và mô hình API còn lại thông qua các thông số kỹ thuật API mở hoặc thông số kỹ thuật Swagga.

11
00:02:30,840 --> 00:02:44,220
Các nhóm khác có thể xây dựng dịch vụ của riêng họ bằng cách sử dụng các công thức này và họ sẽ xây dựng các công thức này bằng cách tham khảo các thông số AP mở cho ứng dụng và lược đồ.

12
00:02:44,220 --> 00:02:52,220
Và nhìn vào sơ đồ này, bạn có thể nói rằng bạn đã tạo API chính xác theo cách này và bạn hoàn toàn đúng.

13
00:02:52,230 --> 00:02:58,230
Không có sự khác biệt trong bài học này.  Bạn đã tìm hiểu về hai mẫu liên quan đến mối quan hệ một-nhiều.

14
00:02:58,240 --> 00:03:10,710
Đối tác đầu tiên, mẫu dịch vụ được lưu trữ mở, trong đó bối cảnh kết hợp ngược dòng cung cấp một tập hợp các dịch vụ chung hoặc khả năng chung cho bối cảnh giới hạn xuôi dòng.

15
00:03:10,800 --> 00:03:34,110
Ngôn ngữ thứ hai là ngôn ngữ được xuất bản, đi đôi với dịch vụ lưu trữ mở.  Trở lại ngược dòng, các liên hệ được giới hạn trên nhà cung cấp dịch vụ được lưu trữ mở sẽ hiển thị ngôn ngữ chung cho các dịch vụ chung và ngôn ngữ này được quản lý bởi nhóm chịu trách nhiệm về dịch vụ được lưu trữ mở, các liên hệ được giới hạn ở hạ nguồn ngoại trừ ngôn ngữ được xuất bản này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\06BoundedContextRelationships_VVN\000000006.srt -->

1
00:00:00,090 --> 00:00:17,880
Lập bản đồ ngữ cảnh cho ngân hàng trong bài tập này, mục tiêu là để bạn tìm hiểu cách thiết lập bản đồ ngữ cảnh và mục tiêu thứ hai là xác định tác động của những thay đổi trong một ngữ cảnh bị giới hạn lên ngữ cảnh liên kết khác, bằng cách sử dụng các bản đồ ngữ cảnh.

2
00:00:17,880 --> 00:00:26,920
Trong bài tập này, chúng ta sẽ sử dụng phiên bản đơn giản của ngữ cảnh bị chặn cho một ngân hàng.  Có hai phần trong bài tập này.

3
00:00:27,120 --> 00:00:44,750
Hãy bắt đầu với phần một.  Trong phần một, tôi sẽ hỏi bạn một câu hỏi và câu hỏi này sẽ mô tả mối quan hệ giữa bối cảnh liên kết và bạn sẽ cần quyết định xem bạn sẽ sử dụng mẫu nào để giải quyết các mối quan hệ mong muốn giữa bối cảnh liên kết.

4
00:00:44,970 --> 00:01:03,650
Đây là câu hỏi.  Số một.  Giả sử thẻ tín dụng phụ thuộc vào tài khoản bán lẻ.  Và điều này có thể là do khách hàng có thể thiết lập thanh toán trực tiếp từ tài khoản bán lẻ cho thẻ tín dụng, nhưng nhóm thẻ tín dụng đã quyết định chấp nhận các mô hình từ tài khoản bán lẻ.

5
00:01:03,780 --> 00:01:10,580
Vậy mối quan hệ giữa thẻ tín dụng và tài khoản bán lẻ sẽ như thế nào?  Vui lòng đăng video nếu bạn cần một chút thời gian.

6
00:01:11,400 --> 00:01:26,280
Đến đây chắc chắn bạn đã có câu trả lời.  Câu trả lời là các liên hệ giới hạn thẻ tín dụng sẽ tuân thủ tài khoản bán lẻ và lý do là vì nhóm thẻ tín dụng đã quyết định chấp nhận mô hình từ tài khoản.

7
00:01:27,000 --> 00:01:37,440
Câu hỏi tiếp theo.  Nhóm cho vay cá nhân đang sử dụng chức năng tài khoản bán lẻ nhưng lo ngại về việc sử dụng mô hình bên ngoài trong bối cảnh ngoại quan.

8
00:01:37,590 --> 00:01:44,950
Bạn sẽ đặt ra khuôn mẫu nào giữa các khoản vay cá nhân và tài khoản bán lẻ nếu bạn cần thêm thời gian để suy nghĩ?

9
00:01:44,970 --> 00:02:03,420
Vui lòng tạm dừng video.  OK, câu trả lời là vì các khoản cho vay cá nhân lo ngại về việc tham nhũng của các khoản cho vay cá nhân, các mối liên hệ ngoại quan, nên họ sẽ sử dụng lớp chống tham nhũng để thực hiện chuyển đổi giữa các mô hình từ tài khoản bán lẻ sang tài khoản cho vay cá nhân.

10
00:02:03,960 --> 00:02:15,780
Câu hỏi tiếp theo bao gồm hai phần.  Nhóm quản lý khách hàng đang cung cấp một nhóm dịch vụ chung và nhóm tài khoản bán lẻ đã quyết định sử dụng các dịch vụ chung.

11
00:02:15,780 --> 00:02:22,620
Nhưng bảo vệ bằng gì?  Vậy các mô hình được sử dụng giữa quản lý khách hàng và nhà bán lẻ được gọi là gì?

12
00:02:22,950 --> 00:02:32,610
Vui lòng tạm dừng video và cố gắng trả lời câu hỏi.  Được rồi.  Câu trả lời là nhóm quản lý khách hàng sẽ triển khai mẫu dịch vụ được lưu trữ mở.

13
00:02:32,790 --> 00:02:40,470
Ngôn ngữ được xuất bản và nhóm tài khoản bán lẻ sẽ sử dụng lớp chống tham nhũng.  Câu hỏi tiếp theo.

14
00:02:40,740 --> 00:02:52,190
Nhóm cho vay cá nhân và thẻ tín dụng đã quyết định sử dụng các dịch vụ phổ biến do nhóm quản lý khách hàng cung cấp và họ cũng quyết định chấp nhận các mô hình mua hàng.

15
00:02:52,650 --> 00:03:02,640
Vậy mối quan hệ giữa quản lý khách hàng và thẻ tín dụng, quản lý khách hàng và các khoản vay cá nhân sẽ đưa ra câu trả lời là gì?

16
00:03:03,240 --> 00:03:12,140
Câu trả lời là vì cả hai đều đã quyết định chấp nhận mô hình mua hàng nên cả hai sẽ là người tuân thủ trong mối quan hệ này.

17
00:03:12,450 --> 00:03:31,080
Vì vậy, đây là một ví dụ về bối cảnh.  Bản đồ cho ngân hàng, sẵn sàng cho phần hai. Tôi sẽ mô tả sự thay đổi đối với một trong các liên hệ được liên kết và dựa trên ánh xạ ngữ cảnh, bạn cần quyết định tác động của thay đổi đó đối với các liên hệ được liên kết khác.

18
00:03:31,530 --> 00:03:40,620
Câu hỏi số một và phần hai, bối cảnh kết hợp nào được cho là sẽ bị ảnh hưởng nhiều nhất bởi những thay đổi trong các bối cảnh kết hợp khác.

19
00:03:40,800 --> 00:03:54,360
Và tại sao bạn lại sẵn sàng cho câu trả lời?  Câu trả lời là bối cảnh kết hợp thẻ tín dụng sẽ bị ảnh hưởng nhiều nhất vì nó phụ thuộc vào việc quản lý khách hàng và tài khoản bán lẻ.

20
00:03:54,670 --> 00:04:03,630
Và vì nó là một công ty tuân thủ nên bất kỳ thay đổi nào đối với tài khoản bán lẻ hoặc quản lý khách hàng sẽ yêu cầu thay đổi thẻ tín dụng.

21
00:04:04,140 --> 00:04:11,310
Câu hỏi số hai, bối cảnh pha trộn nào dự kiến ​​sẽ không bị ảnh hưởng bởi những thay đổi trong bối cảnh pha trộn khác.

22
00:04:11,460 --> 00:04:28,950
Và tại sao lại sẵn sàng cho câu trả lời?  Câu trả lời là bán lẻ Ellacott.  Và lý do là trong các mối quan hệ mà nó đóng vai trò là hạ nguồn, nó đang sử dụng lớp chống tham nhũng và các mối quan hệ khác đều là thượng nguồn.

23
00:04:29,220 --> 00:04:36,310
Do đó, tài khoản bán lẻ độc lập nhất với bối cảnh được giới hạn được bảo vệ trong ánh xạ ngữ cảnh này.

24
00:04:36,750 --> 00:04:50,360
Câu hỏi cuối cùng.  Tất cả những gì sẽ cần phải được điều chỉnh nếu có sự thay đổi trong mô hình tích hợp do Oireachtas đưa ra hoặc dịch vụ lưu trữ mở do nhóm quản lý khách hàng triển khai?

25
00:04:50,510 --> 00:04:59,700
Vui lòng đăng video nếu bạn cần thêm thời gian.  Được rồi.  Câu trả lời là thẻ tín dụng và các khoản vay cá nhân, liên lạc ngoại quan đều có.

26
00:04:59,930 --> 00:05:09,940
Tuân thủ các dịch vụ quản lý khách hàng thông thường, do đó, việc thay đổi mô hình tích hợp sẽ đòi hỏi phải thay đổi cả hai liên hệ ngoại quan này.

27
00:05:10,440 --> 00:05:20,990
Bây giờ Lecomte cũng đang sử dụng việc mua hàng, nhưng vì nó đang sử dụng vấn đề này hoặc luật chống tham nhũng nên những thay đổi sẽ chỉ cần thiết để dễ dàng hơn.

28
00:05:21,260 --> 00:05:28,310
Và hợp đồng ngoại quan tài khoản bán lẻ sẽ không cần phải điều chỉnh.  Tôi hy vọng bạn thích bài tập này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\001 Intro to DDD Tactical Patterns.en.srt -->

1

00:00:00,120 --> 00:00:06,990

Technical design patterns in the last two sections, you learn how to use strategic patterns for the



2

00:00:06,990 --> 00:00:14,580

decomposition of complex domains into smaller domains and for defining the relationship between these



3

00:00:14,580 --> 00:00:15,560

smaller domains.



4

00:00:16,080 --> 00:00:23,880

The focus in this section is on tactical patterns that may be used for modeling and for the realisation



5

00:00:24,030 --> 00:00:25,560

of micro services.



6

00:00:26,340 --> 00:00:33,240

Model driven design provides a framework for the realisation of systems model and using the domain driven



7

00:00:33,240 --> 00:00:39,750

design approach, the tactical patterns are building blocks and the model driven design.



8

00:00:40,710 --> 00:00:49,110

Entities value objects and aggregates are referred to as the domain objects, these domain objects are



9

00:00:49,110 --> 00:00:52,650

used for modeling the data in the domain model.



10

00:00:52,980 --> 00:00:56,730

Factories are for creation of the complex domain.



11

00:00:56,730 --> 00:01:02,710

Objects and repositories are used for managing the persistence of domain objects.



12

00:01:02,970 --> 00:01:05,130

And then there are services, patterns.



13

00:01:05,310 --> 00:01:13,950

Services are used for modeling the interactions of the domain objects with other domain objects, with



14

00:01:13,950 --> 00:01:17,420

infrastructure and with other external components.



15

00:01:17,910 --> 00:01:22,060

You will learn all of these tactical patterns in this section.



16

00:01:22,350 --> 00:01:26,400

I'll also cover two new terms anemic and rich model.



17

00:01:27,090 --> 00:01:34,380

I'll show you how to model these patterns for your micro services in general and how to build these



18

00:01:34,380 --> 00:01:37,980

technical patterns using plain old Java classes.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\002 Entity Object - Pattern.en.srt -->

1

00:00:00,150 --> 00:00:05,790

In this lesson, you learn about the entity pattern by the end of this lecture, you should be able



2

00:00:05,790 --> 00:00:13,200

to discuss the characteristics of entities and the relationship between the business logic and entity



3

00:00:13,200 --> 00:00:13,890

objects.



4

00:00:14,070 --> 00:00:21,930

An entity represents a uniquely identifiable business object that encapsulates attributes and a well-defined



5

00:00:21,930 --> 00:00:23,020

domain behavior.



6

00:00:23,340 --> 00:00:30,360

For example, in the case of banking, there are entities such as account, credit card and transaction.



7

00:00:30,360 --> 00:00:35,760

In the case of retail, there are entities such as order, product and invoice.



8

00:00:35,760 --> 00:00:41,100

Next time I'll walk you through the characteristics of the entities that differentiate them from other



9

00:00:41,100 --> 00:00:42,270

business objects.



10

00:00:42,570 --> 00:00:46,750

An entity is uniquely identified within a bounded context.



11

00:00:46,980 --> 00:00:53,130

So in the case of banking, for the retail accounts bounded context, there may be an entity checking



12

00:00:53,130 --> 00:00:56,700

account which is uniquely identified by the account number.



13

00:00:56,940 --> 00:01:03,510

Similarly, for the personal loans bounded contacts, they may be a loan account entity which is uniquely



14

00:01:03,510 --> 00:01:06,180

identified by way of the loan account number.



15

00:01:06,420 --> 00:01:13,710

And in the case of credit cards, bounded context, they may be a credit card entity which is uniquely



16

00:01:13,710 --> 00:01:16,200

identified by way of the credit card number.



17

00:01:16,500 --> 00:01:24,000

These entities and their identities are meaningful only within their respective bounded context.



18

00:01:24,450 --> 00:01:31,620

An entity has a set of attributes that are defined by the ubiquitous language for the bounded context.



19

00:01:31,930 --> 00:01:40,050

For example, a checking account entity may have attributes such as account number, customer balance



20

00:01:40,050 --> 00:01:41,130

and transactions.



21

00:01:41,550 --> 00:01:46,560

An entity has a behavior that is, it encapsulates business logic.



22

00:01:46,860 --> 00:01:50,430

And this business logic is exposed by way of operations.



23

00:01:50,880 --> 00:01:57,950

When these operations are executed against the entity, it leads to a change of state of the entity.



24

00:01:58,890 --> 00:02:04,830

For example, in the case of checking account, there are multiple attributes and there are multiple



25

00:02:04,830 --> 00:02:09,180

operations, such as the drawer deposit transfer funds.



26

00:02:09,540 --> 00:02:15,560

When some of these operations are executed, they change the state of the account.



27

00:02:15,570 --> 00:02:22,720

For example, the balance may go up or down as a result of the execution of some of these operations.



28

00:02:23,100 --> 00:02:25,800

Let's define what is business logic, not business.



29

00:02:25,800 --> 00:02:29,160

Logic is sometimes referred to as the domain logic.



30

00:02:29,160 --> 00:02:33,150

The business logic may consist of the business rules.



31

00:02:33,150 --> 00:02:38,680

For example, withdrawal will fail if the balance is less than the withdrawal amount.



32

00:02:38,850 --> 00:02:40,890

It may be the validations.



33

00:02:40,890 --> 00:02:45,050

For example, withdrawal amount cannot be less than or equal to zero.



34

00:02:45,210 --> 00:02:51,270

It may be calculations, for example, calculating the component cross for the checking account and



35

00:02:51,270 --> 00:02:55,860

it may be the operations that can change the state of the entity.



36

00:02:55,860 --> 00:03:03,300

For example, withdrawal transaction logic the could put together to implement all of these is referred



37

00:03:03,300 --> 00:03:05,880

to as the business logic in general.



38

00:03:06,330 --> 00:03:09,660

Let's go with an example of business logic or the behavior.



39

00:03:10,050 --> 00:03:15,150

In the case of the checking account, there may be an operation for the withdrawal of money from the



40

00:03:15,150 --> 00:03:15,600

account.



41

00:03:15,900 --> 00:03:20,430

This withdraw operation may take withdrawal amount as an argument.



42

00:03:20,430 --> 00:03:26,580

The first check that will be carried out in the implementation of the withdraw operation is the check



43

00:03:26,580 --> 00:03:28,320

on the available balance.



44

00:03:28,320 --> 00:03:34,110

If the available balance is less than the withdrawal amount, then the transaction will be rejected.



45

00:03:34,110 --> 00:03:39,840

Otherwise the transaction will be accepted and the balance will be reduced by the withdrawal amount.



46

00:03:40,140 --> 00:03:41,420

Time for a quick quiz.



47

00:03:41,790 --> 00:03:44,220

Take a look at this checking account entity.



48

00:03:44,610 --> 00:03:49,020

Do you think that this entity expose some business logic?



49

00:03:50,700 --> 00:03:57,000

The answer is no, it does not, and the reason I'm saying that is because these operations are just



50

00:03:57,000 --> 00:03:58,350

getters and setters.



51

00:03:58,350 --> 00:04:02,600

Similarly, this operation is to possess the object to the database.



52

00:04:02,610 --> 00:04:08,820

So from the surface, it does not appear that this entity is encapsulating any business.



53

00:04:08,820 --> 00:04:14,790

Logic entities are meaningful only within the boundary context in which they are defined.



54

00:04:15,600 --> 00:04:21,180

It is common to see the same entity names appearing across multiple bonded contexts.



55

00:04:21,630 --> 00:04:28,350

But you have to keep in mind that the definition of the entity across these bounded context is not guaranteed



56

00:04:28,350 --> 00:04:29,200

to stay the same.



57

00:04:29,310 --> 00:04:37,050

For example, a customer entity in the retail account may not look the same as the customer entity in



58

00:04:37,050 --> 00:04:39,300

the credit card bounded context.



59

00:04:39,660 --> 00:04:47,190

Recall that entities are uniquely identified within a bounded context, but sometimes it may so happen



60

00:04:47,520 --> 00:04:53,780

that the same attribute is used for uniquely identifying the entity across business contacts.



61

00:04:53,790 --> 00:04:55,980

But that is purely coincidental.



62

00:04:56,430 --> 00:05:03,420

So in this example, customers Social Security number is being used for identifying the customer uniquely



63

00:05:03,420 --> 00:05:05,620

in both these business contacts.



64

00:05:06,180 --> 00:05:09,260

Keep in mind, that is truly coincidental.



65

00:05:09,450 --> 00:05:16,860

The team's defining these entities will work independent of each other and define the attributes and



66

00:05:16,860 --> 00:05:24,270

operations for the entities based on the requirement in each of the business context, entities are



67

00:05:24,270 --> 00:05:26,420

persistent in long term storage.



68

00:05:26,700 --> 00:05:31,460

The data in the long term storage represents the current state of the entity.



69

00:05:31,680 --> 00:05:40,000

It is common for RDBMS and no single database is being used for persistent storage of the entities.



70

00:05:40,620 --> 00:05:46,890

In the case of an RDBMS, a table represents a collection of entities.



71

00:05:47,280 --> 00:05:55,650

The rules within the table represent the entities that are uniquely identified by way of the primary



72

00:05:55,650 --> 00:05:56,450

key column.



73

00:05:56,700 --> 00:06:02,920

The rest of the columns have the values for the attributes for each of the entities.



74

00:06:03,870 --> 00:06:06,740

Time for a quick review of the key points from this lecture.



75

00:06:06,840 --> 00:06:14,640

The first one is that entities are business objects that are meaningful only within a bounded context.



76

00:06:14,640 --> 00:06:20,520

Where they are defined entities are uniquely identified within a bounded context.



77

00:06:20,880 --> 00:06:26,760

Next one is that the definition of the entity consists of attribute and behavior.



78

00:06:27,060 --> 00:06:32,510

The behavior implements the business logic that may change the state of the entity.



79

00:06:32,550 --> 00:06:35,700

Entities are persisted in long term storage.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\003 Value Object - Pattern.en.srt -->

1

00:00:00,150 --> 00:00:07,260

In this lesson, you learn about value objects, their characteristics and the life cycle of the value



2

00:00:07,290 --> 00:00:15,080

object value objects, unlike the entity, objects have no conceptual identity in the bounded context.



3

00:00:15,300 --> 00:00:22,740

In other words, value, object attributes and behavior does not map directly to the core concepts in



4

00:00:22,740 --> 00:00:23,900

the bounded context.



5

00:00:24,450 --> 00:00:26,860

I will start this lesson with a quiz.



6

00:00:26,880 --> 00:00:29,760

Consider the customer and the object.



7

00:00:29,910 --> 00:00:36,060

There's an email address which is provided by the customer and the question is where would you put the



8

00:00:36,060 --> 00:00:38,770

validation logic for the email address?



9

00:00:39,510 --> 00:00:43,820

Think of the options, keeping in mind the definition of the value object.



10

00:00:46,020 --> 00:00:47,750

So here is option number one.



11

00:00:47,760 --> 00:00:53,850

You can put the validation logic for the email address in the customer entity itself.



12

00:00:54,060 --> 00:01:00,420

The issue with this approach is that this validation is a technical validation not related to any business



13

00:01:00,420 --> 00:01:00,950

concept.



14

00:01:00,960 --> 00:01:07,740

And so the option number two is to create a value object for validating the email address.



15

00:01:07,770 --> 00:01:13,350

When this option, we will create another object called the email address value object, which will



16

00:01:13,350 --> 00:01:16,680

encapsulate the validation logic for the email address.



17

00:01:16,680 --> 00:01:21,370

And it would not have any business logic from the bomblet context perspective.



18

00:01:21,660 --> 00:01:28,830

As a result, the customer entity will be cleaner and much more simpler in terms of implementation.



19

00:01:29,250 --> 00:01:31,830

This is a simple example of value object.



20

00:01:31,860 --> 00:01:38,730

Another example would be to open a bank account and use a customer has to present some kind of a government



21

00:01:38,730 --> 00:01:41,850

issued document as a proof of identity.



22

00:01:42,150 --> 00:01:48,180

These are some of the commonly used proof of identities, the implementation of the customer object,



23

00:01:48,390 --> 00:01:56,460

maybe such that it just needs to store the string representation of the identity presented by the customer.



24

00:01:56,490 --> 00:02:04,170

For example, there may be a column in the customer table that just has a string representation of the



25

00:02:04,170 --> 00:02:12,120

identity with a format that has the identity type and a unique number identifying the individual.



26

00:02:12,240 --> 00:02:18,180

In the case of US passport, it can be the passport number in case of driver license, it can be the



27

00:02:18,300 --> 00:02:19,470

driver's license number.



28

00:02:20,340 --> 00:02:24,030

This may be achieved by creating a value object.



29

00:02:24,240 --> 00:02:31,110

This value object may be used by the customer entity for creating the string representation for the



30

00:02:31,110 --> 00:02:32,520

government identity.



31

00:02:32,850 --> 00:02:39,780

Disvalue object may also encapsulate the validation logic for different type of identity.



32

00:02:39,790 --> 00:02:46,050

For example, it may validate the passport by using the rules that the passport should not be expired



33

00:02:46,050 --> 00:02:52,650

and the passport held by the customer was issued by a country from the allowed list of countries.



34

00:02:53,240 --> 00:03:01,320

This value object may also expose a function for creating the string representation of the government



35

00:03:01,320 --> 00:03:02,700

issued identity.



36

00:03:03,060 --> 00:03:10,770

The string representation gets assigned to the government identity attribute in the customer entity.



37

00:03:10,950 --> 00:03:18,720

One important thing to bear in mind here is that this value object is not persisted as part of the customer



38

00:03:18,840 --> 00:03:19,460

entity.



39

00:03:19,680 --> 00:03:26,970

In other words, this common identity value object is created in the process memory and then destroyed



40

00:03:27,210 --> 00:03:29,840

after it has served its purpose.



41

00:03:31,240 --> 00:03:38,500

Well, the objects may also be thought of as utility objects, and these utility objects are value objects



42

00:03:38,890 --> 00:03:41,560

do not have a unique identity.



43

00:03:41,890 --> 00:03:48,790

Equality check for two value objects is carried out by the comparison of the attributes.



44

00:03:48,970 --> 00:03:56,890

So in this example, we cannot think of the identity numbers as the unique identity for the value object



45

00:03:57,130 --> 00:04:00,970

to compare to value objects of type government identity.



46

00:04:01,510 --> 00:04:08,830

We'll have to check the identity type and if the type is simple, we will compare the identity numbers.



47

00:04:08,840 --> 00:04:15,160

So as you can see, you'll have to carry out attribute level comparison to make a decision on whether



48

00:04:15,400 --> 00:04:18,340

to value objects are equal or not.



49

00:04:18,670 --> 00:04:26,940

One important distinction between the entities and value objects is that the value object is not persistent



50

00:04:26,950 --> 00:04:27,910

to the database.



51

00:04:28,060 --> 00:04:36,040

As an independent object, the value object has either persisted to the database as part of an entity



52

00:04:36,040 --> 00:04:40,350

object or they are not persisted to the long term storage at all.



53

00:04:40,570 --> 00:04:48,170

In the case of the government identity example, we will not be storing the government identity.



54

00:04:48,310 --> 00:04:50,800

Well, you object to the long term storage.



55

00:04:50,950 --> 00:04:59,350

Let's discuss the example for the value object has a very short lifespan in the case of our customer



56

00:04:59,470 --> 00:05:07,570

entity that needs the government identity attribute to be set, an instance of the value object has



57

00:05:07,570 --> 00:05:16,450

created the identity information is set on the government identity value object validators invoke to



58

00:05:16,720 --> 00:05:24,430

validate all of the information and then create string is executed to create the string representation



59

00:05:24,580 --> 00:05:29,340

of the government identity, which is then set on the customer entity.



60

00:05:29,530 --> 00:05:36,910

At this point, the customer entity is served to the database and in the case of a relational database,



61

00:05:37,240 --> 00:05:45,390

the entity may be added as a rule in the table with all the required information for the customer.



62

00:05:45,670 --> 00:05:54,100

And as you see here, the Gaudron identity object is not getting persisted as part of the customer entity.



63

00:05:54,790 --> 00:05:59,680

Value objects are treated as immutable objects.



64

00:06:00,100 --> 00:06:06,280

All of the attributes put together gives a meaning to an instance of the value object.



65

00:06:06,640 --> 00:06:15,460

As a best practice, it is suggested that you create a new instance of the value object instead of reusing



66

00:06:15,460 --> 00:06:17,510

the existing instances.



67

00:06:18,550 --> 00:06:27,310

Next, let's talk about the value object and bounded context value object in one bounded context, maybe



68

00:06:27,310 --> 00:06:29,920

an entity in another bounded context.



69

00:06:30,340 --> 00:06:31,560

Let me give you an example.



70

00:06:31,930 --> 00:06:34,030

Think about the retail account.



71

00:06:34,150 --> 00:06:36,970

Subdomain in a bank account.



72

00:06:37,120 --> 00:06:38,560

In the retail account.



73

00:06:38,570 --> 00:06:46,930

Subdomain is an entity that has a unique identity and has persisted in some kind of long term storage.



74

00:06:47,170 --> 00:06:53,350

Now think about the compliance and reporting subdomain, the compliance and reporting subdomain.



75

00:06:53,680 --> 00:07:00,660

Use the information from the accounts in the retail account subdomain to generate reports.



76

00:07:00,700 --> 00:07:08,620

These reports have the consolidated information about all of the accounts held in the retail accounts.



77

00:07:08,740 --> 00:07:13,310

Subdomain and individual accounts does not matter.



78

00:07:13,720 --> 00:07:20,590

So in the case of compliance and reporting, the account objects are treated as value objects.



79

00:07:21,910 --> 00:07:23,160

Time for a quick review.



80

00:07:23,350 --> 00:07:26,470

In this lesson you learned about value objects.



81

00:07:27,040 --> 00:07:33,100

Value objects do not have a conceptual identity within a bounded context.



82

00:07:33,280 --> 00:07:39,160

Value objects are not persisted in a database as an independent object.



83

00:07:39,400 --> 00:07:47,680

It is either stored as part of the entity object or it is not even stored in a database, an entity



84

00:07:47,920 --> 00:07:55,180

in one bounded context, maybe a value object in another bounded context and vice versa.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\004 Exercise _ Identify Entity & VO in ACME Sales Model.en.srt -->

1

00:00:00,150 --> 00:00:07,550

The objective in this exercise is to identify the entities and value objects in Achmea sales model.



2

00:00:07,980 --> 00:00:15,390

In one of the previous exercises, we analyze the transcript for an interview with John, who is a travel



3

00:00:15,390 --> 00:00:19,900

adviser and identified these business terms.



4

00:00:20,100 --> 00:00:25,390

Some of these terms will get translated into entities and value objects.



5

00:00:25,920 --> 00:00:32,280

Now, if you have forgotten about that exercise, I suggest that you revisit that lecture or you may



6

00:00:32,280 --> 00:00:35,700

pause the video and read through this interview transcript.



7

00:00:36,120 --> 00:00:39,570

And when you're ready, let's get to the next exercise.



8

00:00:39,720 --> 00:00:43,800

In this exercise, you'll be focusing on these terms.



9

00:00:44,160 --> 00:00:50,670

You will be identifying the entities and value objects in the sales context.



10

00:00:51,130 --> 00:00:54,810

Please keep in mind that the focus is on the sales context.



11

00:00:55,230 --> 00:01:01,800

And the reason we need to have this focus is because entities and value objects are meaningful within



12

00:01:01,980 --> 00:01:03,180

a bounded context.



13

00:01:03,570 --> 00:01:10,110

Another thing that you need to keep in mind is that value objects may not have a conceptual identity.



14

00:01:10,290 --> 00:01:17,850

In the bounded context, you may add new value objects to support your entities as needed.



15

00:01:19,350 --> 00:01:21,090

Let's start with the customer.



16

00:01:21,420 --> 00:01:28,860

Customer is an individual who initiated the sales process, a customer is identified uniquely by an



17

00:01:28,860 --> 00:01:36,510

email or phone number, and limited information about the customer is needed in the sales context to



18

00:01:36,510 --> 00:01:44,160

important aspect about customers in the sales context is that the customer has a unique identity and



19

00:01:44,160 --> 00:01:47,020

a customer is assisted in storage.



20

00:01:47,460 --> 00:01:49,260

So now the question is for you.



21

00:01:49,690 --> 00:01:55,260

Would you mark the customer as a value object or would you mark it as an entity?



22

00:01:55,950 --> 00:02:04,830

If you said entity, you're right, because a customer has a conceptual identity within the sales context



23

00:02:04,830 --> 00:02:10,070

and it needs to be persisted with a unique identity in a long term storage.



24

00:02:10,080 --> 00:02:12,150

So a customer is an entity.



25

00:02:13,020 --> 00:02:22,080

Next question is, a customer needs to have a validated physical address, and this address is not a



26

00:02:22,080 --> 00:02:25,830

core concept in the context of the sales domain.



27

00:02:26,550 --> 00:02:32,850

Typically, the physical address validation or verification is carried out by way of third parties,



28

00:02:32,850 --> 00:02:39,220

for example, making a call to USPSTF API to check if the address is valid or not.



29

00:02:39,480 --> 00:02:45,160

Now, this is a technical requirement, not really a business requirement.



30

00:02:45,270 --> 00:02:53,020

So how would you mark the address entity or will you object if you said, well, you object your right?



31

00:02:53,790 --> 00:02:58,050

The next question I have for you is, does this value object need to be persistent?



32

00:02:58,380 --> 00:03:05,210

The answer is yes as part of the customer entity, not as a standalone object in the database.



33

00:03:05,220 --> 00:03:05,730

And why?



34

00:03:05,730 --> 00:03:12,420

Because it does not have a unique identity like the physical address, customer's email address and



35

00:03:12,420 --> 00:03:15,380

phone number needs to be validated and stored.



36

00:03:15,750 --> 00:03:22,530

This validation is typically carried out by way of the utility objects and hence we can create a value



37

00:03:22,530 --> 00:03:24,420

object email, phone validator.



38

00:03:24,480 --> 00:03:30,330

The purpose of this is just to make sure that the email address and phone number provided by the customer



39

00:03:30,450 --> 00:03:31,050

is good.



40

00:03:31,080 --> 00:03:35,680

The question for you is, does this value object need to be persisted?



41

00:03:35,700 --> 00:03:42,540

The answer is no, as it is just a utility object used for validating the email address and the phone



42

00:03:42,540 --> 00:03:42,870

number.



43

00:03:43,050 --> 00:03:45,870

Let's check out how far are we with our model?



44

00:03:46,020 --> 00:03:53,160

We have the customer entity that has a one to one relationship with the address value object, and the



45

00:03:53,160 --> 00:04:02,430

customer entity is using the email phone validator for validating the email address and phone number.



46

00:04:03,480 --> 00:04:09,900

Next, let's talk about the vacation package, which is the product that sells each of the vacation



47

00:04:09,900 --> 00:04:12,920

package, is uniquely identified by a name.



48

00:04:13,320 --> 00:04:20,040

For example, a three night package for Las Vegas has a name, LV, three night.



49

00:04:20,360 --> 00:04:27,900

There are different type of packages that Acme sells, for example, a package for a resort, a package



50

00:04:27,900 --> 00:04:29,030

for cruise.



51

00:04:29,040 --> 00:04:31,370

And then there are other types as well.



52

00:04:31,770 --> 00:04:39,210

Apart from this, a vacation package has other attributes, like the number of nights, and there is



53

00:04:39,210 --> 00:04:42,900

a retail price associated with vacation package.



54

00:04:43,500 --> 00:04:50,100

So what do you think the vacation package should be marked as an entity or a value object?



55

00:04:51,700 --> 00:04:59,720

The vacation package will be an entity as it has a conceptual identity within the sales domain and it



56

00:04:59,720 --> 00:05:06,350

is uniquely identifiable proposal is created for a customer, for a specific package.



57

00:05:06,380 --> 00:05:10,730

It has all the information that is needed for pricing.



58

00:05:10,730 --> 00:05:15,980

The vacation package proposal is valid for 14 days.



59

00:05:16,150 --> 00:05:22,730

So what that indicates is that it needs to be put in a persistent storage, multiple proposals maybe



60

00:05:22,730 --> 00:05:24,350

created for a customer.



61

00:05:24,590 --> 00:05:28,550

And each of these proposals have a unique identity.



62

00:05:29,000 --> 00:05:30,110

So what is your take?



63

00:05:30,140 --> 00:05:34,210

Is it going to be an entity or is it going to be a value object?



64

00:05:34,820 --> 00:05:37,280

My take it is going to be an entity.



65

00:05:37,730 --> 00:05:38,080

Why?



66

00:05:38,090 --> 00:05:47,600

Because each proposal has a unique identity and the proposals are saved to persistent storage as standalone



67

00:05:47,600 --> 00:05:52,070

objects and offer is a discount applied to the proposals.



68

00:05:52,070 --> 00:06:01,250

Offers are managed by the Acme product team, and these offers are uniquely identified by some kind



69

00:06:01,250 --> 00:06:04,370

of an identity which is assigned by the product.



70

00:06:04,370 --> 00:06:12,290

The offers in the sales domain are applicable only in the context of proposal, and there is a business



71

00:06:12,290 --> 00:06:20,450

rule defined within the sales context that a maximum of two offers can be applied to a proposal.



72

00:06:20,480 --> 00:06:23,420

So what do you think in the sales context?



73

00:06:23,960 --> 00:06:30,110

Will an offer be an entity or would you market as value object?



74

00:06:30,260 --> 00:06:32,330

Now this is a little tricky one.



75

00:06:32,510 --> 00:06:33,590

If you think about it.



76

00:06:34,010 --> 00:06:40,820

The unique identity is assigned by the product team and the offers are actually maintained and managed



77

00:06:41,060 --> 00:06:42,620

by the product team.



78

00:06:43,100 --> 00:06:50,180

So in my opinion, it should be considered as a value object because in the sales context, an offer



79

00:06:50,180 --> 00:06:58,850

is simply applied to the proposal and does not have a standalone, unique identity managed within the



80

00:06:58,880 --> 00:07:00,150

sales context.



81

00:07:00,170 --> 00:07:03,260

So my take offer is a value object.



82

00:07:03,410 --> 00:07:08,120

Pax refers to the shoveler that avails the vacation package.



83

00:07:08,420 --> 00:07:15,490

Is an example, let's say Jane called ACMS sales department to buy a vacation package.



84

00:07:15,500 --> 00:07:17,030

So Jane is the customer.



85

00:07:17,270 --> 00:07:23,930

She has bought this vacation package for her family that consists of Jane, Jack and Peter.



86

00:07:24,080 --> 00:07:32,000

So these three persons will be referred to as the packs or passengers packs does not need to be uniquely



87

00:07:32,030 --> 00:07:34,800

identified in the context of the proposal.



88

00:07:35,480 --> 00:07:42,110

So keep in mind, customer needs to be uniquely identified, but PAX does not need to be uniquely identified.



89

00:07:42,500 --> 00:07:47,220

Packs are an important part of the proposal from the pricing perspective.



90

00:07:47,240 --> 00:07:51,290

So what do you think will be an entity or a value object?



91

00:07:51,320 --> 00:07:59,330

My take is that packs will be a value object and the reason is that it does not have a standalone identity



92

00:07:59,360 --> 00:08:01,730

within the sales context.



93

00:08:02,280 --> 00:08:05,530

Let's revisit the proposal from the big picture perspective.



94

00:08:05,540 --> 00:08:10,550

We have the proposal entity that refers to the vacation package entity.



95

00:08:11,030 --> 00:08:19,160

The proposal entity has one or more Backes value object and appear to offer value.



96

00:08:19,160 --> 00:08:22,240

Objects may be applied to the proposal.



97

00:08:22,550 --> 00:08:26,360

Let's combine the proposal model with the customer model.



98

00:08:26,960 --> 00:08:34,640

The proposal entity refers to the customer entity and this is the holistic model that we have come up



99

00:08:34,640 --> 00:08:39,050

with, with the concept identified in the sales context.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\005 Hands On _ Building the ACME Sales Entities & VO in JAVA.en.srt -->

1

00:00:00,180 --> 00:00:07,490

In this lesson, we will model the entities and value objects that are discussed in the last lecture,



2

00:00:07,500 --> 00:00:15,130

will cover the customer vacation package and proposal entities and will also cover these value objects.



3

00:00:15,360 --> 00:00:21,330

You will also learn about the relationship between these various entities and value objects.



4

00:00:21,780 --> 00:00:28,620

My objective here is to show you how you can model the core objects in the sales domain.



5

00:00:28,920 --> 00:00:34,770

The objects that we will model in this lesson have been discussed in the previous lectures.



6

00:00:35,190 --> 00:00:41,580

All of the code for the model is available in the project repository under the Good Branch Technical.



7

00:00:41,610 --> 00:00:45,190

You will also find the Java code for these core objects.



8

00:00:45,210 --> 00:00:47,250

I will not be walking you through that code.



9

00:00:47,490 --> 00:00:48,560

If you are interested.



10

00:00:48,570 --> 00:00:50,950

You may walk through the code on your own.



11

00:00:51,000 --> 00:00:57,780

It is very straightforward and maps directly to the core object model that you will learn in this lecture.



12

00:00:57,810 --> 00:01:03,720

Another important point I would like to highlight before I move forward with this lesson is that I have



13

00:01:03,720 --> 00:01:08,480

kept these models very simple so that they are easy to follow.



14

00:01:08,580 --> 00:01:16,260

Think of the model that we will develop in this lesson as the first draft version of decided to place



15

00:01:16,260 --> 00:01:22,640

all of the core classes in the package, Kondor Achmad or sales model.



16

00:01:23,190 --> 00:01:27,030

The first class in this package is the customer class.



17

00:01:27,210 --> 00:01:33,330

The next one is the address class and then the email phone validator class.



18

00:01:33,630 --> 00:01:42,000

The relationship between these classes is that customer has one address and customer class uses the



19

00:01:42,000 --> 00:01:48,080

email phone validator to validate the customer's email address and phone number.



20

00:01:48,240 --> 00:01:56,730

A customer has a unique identity and this unique identity is represented for the customer by way of



21

00:01:56,880 --> 00:01:59,760

an attribute that is named reference.



22

00:01:59,790 --> 00:02:02,560

Let's place a couple of more attributes now.



23

00:02:02,640 --> 00:02:09,450

Since the customer has a unique identity and it has persisted, it is an entity so mark the customer



24

00:02:09,450 --> 00:02:10,950

as an entity.



25

00:02:10,950 --> 00:02:14,490

And let's not forget that customer has our address.



26

00:02:14,850 --> 00:02:16,920

So an attribute for address.



27

00:02:16,950 --> 00:02:24,060

The address is a value object and the email phone validator is also a value object.



28

00:02:24,060 --> 00:02:28,410

Since address is a value object, it won't have any unique identity.



29

00:02:28,590 --> 00:02:32,460

Just has the attributes which are typical to address class.



30

00:02:32,460 --> 00:02:38,220

Instance of the address will be persisted as part of the customer object.



31

00:02:38,220 --> 00:02:42,600

The email phone vallenato class will be used just for validation.



32

00:02:42,630 --> 00:02:50,340

It won't be persistent and it'll expose the required functions for the validation of the email and the



33

00:02:50,580 --> 00:02:51,240

phone number.



34

00:02:51,270 --> 00:02:56,490

So this is our customer model in the context of Acme sales.



35

00:02:56,820 --> 00:03:01,950

In the last lecture that are discussed vacation package, I talked about the package type.



36

00:03:01,960 --> 00:03:09,540

Now each of these package types require Achmad to carry out some reservations with the provider.



37

00:03:09,870 --> 00:03:16,200

For example, for some packages, Acme will need to carry on the reservation for the hotel as well as



38

00:03:16,200 --> 00:03:17,610

the airline ticket.



39

00:03:17,660 --> 00:03:23,310

Then there may be other packages where Acme will need to carry out the reservation for, let's say,



40

00:03:23,310 --> 00:03:26,580

a cruise liner, air ticket and a rental car.



41

00:03:26,670 --> 00:03:33,270

So there are various combinations which are defined within the package to represent each of these parts



42

00:03:33,270 --> 00:03:34,930

of the package.



43

00:03:34,950 --> 00:03:39,390

I have decided to create a class hierarchy called reservations.



44

00:03:39,390 --> 00:03:43,080

Next, I'll walk you to the model for the reservations.



45

00:03:44,290 --> 00:03:52,560

I decided to place the reservation class hierarchy in the package com dot dot sales model, dot booking,



46

00:03:52,900 --> 00:03:57,130

the first class that I'll define here as the abstract class reservation.



47

00:03:57,190 --> 00:04:04,240

This class will expose certain functions like cancel and resolve, which will be implemented by the



48

00:04:04,240 --> 00:04:05,650

concrete classes.



49

00:04:05,650 --> 00:04:11,770

So the relationship between the airline reservation and hotel reservation and rental car reservation



50

00:04:11,770 --> 00:04:19,120

is that they all inherit from the abstract reservation class and provide the concrete implementation



51

00:04:19,480 --> 00:04:21,580

for council and resolve functions.



52

00:04:21,580 --> 00:04:29,940

Since the reservation objects will not have a unique conceptual identity, they will be the value objects.



53

00:04:29,950 --> 00:04:33,460

They will be saved or persisted as part of the booking.



54

00:04:33,460 --> 00:04:38,860

From the identity perspective, when they will be a successful reservation, a reservation reference



55

00:04:38,860 --> 00:04:41,370

will be assigned to the reservation object.



56

00:04:41,830 --> 00:04:48,670

It is very much possible that the customer may cancel the booking, in which case a cancellation reference



57

00:04:48,670 --> 00:04:52,450

will also be generated, which will become part of the reservation.



58

00:04:52,570 --> 00:04:56,220

Object to other attributes which are important to consider.



59

00:04:56,220 --> 00:05:05,260

Here are the provider already and the contract provider ID is a unique identity assigned to the provider



60

00:05:05,260 --> 00:05:10,480

such as hotel or airline, and this assignment is carried out by the product team.



61

00:05:10,480 --> 00:05:13,090

So sales team does not have control on it.



62

00:05:13,360 --> 00:05:15,910

They're just a consumer of this provider.



63

00:05:16,480 --> 00:05:23,590

Similarly, there is a contract in the contract code identifies the contract between the provider and



64

00:05:23,590 --> 00:05:24,090

Acme.



65

00:05:24,250 --> 00:05:30,410

This code is assigned and managed by the product team in order to carry out the reservation or cancellation.



66

00:05:30,580 --> 00:05:37,360

These two attributes must be provided by the concrete reservation classes to the service that carries



67

00:05:37,360 --> 00:05:40,740

out the reservation and the cancellation functionality.



68

00:05:40,750 --> 00:05:46,200

Then there are two enumerations reservation types and reservation status.



69

00:05:46,210 --> 00:05:51,170

These two enumerations are defined in the abstract reservation class.



70

00:05:51,190 --> 00:05:57,850

Next, I'll explain the relationship between the vacation package model and the reservation class hierarchy



71

00:05:58,210 --> 00:06:01,810

and create a vacation package clause in the package.



72

00:06:01,810 --> 00:06:04,210

Kondrat Akhmad or sales model.



73

00:06:04,480 --> 00:06:10,800

The vacation package is identified by a unique name, which will be an attribute in the vacation package



74

00:06:10,810 --> 00:06:11,400

class.



75

00:06:11,590 --> 00:06:13,570

Let's put a note as a good practice here.



76

00:06:13,780 --> 00:06:19,450

Since the vacation package need to be persistent on its own, it'll be an entity, not the vacation



77

00:06:19,450 --> 00:06:23,800

package will have the placeholder for reservations.



78

00:06:23,800 --> 00:06:31,840

As discussed earlier, these reservations are a list of reservation objects that represent part of the



79

00:06:31,840 --> 00:06:32,500

package.



80

00:06:32,950 --> 00:06:38,470

And instances of reservations in the vacation package are the placeholders.



81

00:06:38,770 --> 00:06:45,430

And these objects are going to be used for creating the actual instances in the proposal class and the



82

00:06:45,430 --> 00:06:47,200

booking confirmation class.



83

00:06:47,530 --> 00:06:55,840

A function will be exposed for creating the instances of the reservation placeholders of name the function



84

00:06:55,840 --> 00:06:58,900

as generic reservation holders.



85

00:06:59,200 --> 00:07:04,720

So this is the function that will create the reservation placeholder objects.



86

00:07:04,930 --> 00:07:12,970

The relationship between the vacation package class and the reservation class is that the vacation package



87

00:07:12,970 --> 00:07:17,420

class will have one or more of these reservation objects.



88

00:07:17,920 --> 00:07:24,100

Next, I'll walk you through the proposal sequence and the proposal class diagrams here.



89

00:07:24,280 --> 00:07:31,630

As you can see, the customer initiate the contact with the Acme Sales Acme sales team, then create



90

00:07:31,630 --> 00:07:33,240

one or more proposals.



91

00:07:33,520 --> 00:07:35,440

Let's go through the sequence diagram.



92

00:07:35,440 --> 00:07:43,090

First customer, initiate the contact with the sales agent customer, provide their identity by way



93

00:07:43,090 --> 00:07:45,430

of a phone number or an email address.



94

00:07:45,880 --> 00:07:51,430

And they also provide their preferences, budget, desired destination, etc..



95

00:07:51,850 --> 00:07:57,520

And the sales agent, Foster, look up for the customer and the sales system.



96

00:07:57,850 --> 00:08:04,420

If the customer is not found, then the sales agent sets up the customer as a new customer.



97

00:08:04,510 --> 00:08:11,890

At that point, the sales agent is ready to identify the vacation packages that meet the customer's



98

00:08:11,890 --> 00:08:12,610

criteria.



99

00:08:12,760 --> 00:08:20,410

They describe these various vacation packages to the customer and after that they create one or more



100

00:08:20,410 --> 00:08:22,330

proposals for the customer.



101

00:08:23,020 --> 00:08:26,550

These proposals may be thought of as vacation options.



102

00:08:26,740 --> 00:08:31,030

This is a three night Bahamas package or this is a five night Bahamas package.



103

00:08:31,180 --> 00:08:32,390

Which one would you prefer?



104

00:08:32,600 --> 00:08:40,210

That's the kind of proposals or options which the sales agent then provides to the customer.



105

00:08:40,210 --> 00:08:43,840

The customer at that point may decide to pick up one.



106

00:08:43,890 --> 00:08:49,180

Of the proposals and the sales agent then initiate the booking process.



107

00:08:49,290 --> 00:08:54,960

So this is a very simplistic sequence diagram for the proposal creation process.



108

00:08:54,990 --> 00:08:56,960

Let's take a look at the proposal class.



109

00:08:57,100 --> 00:09:01,440

Now, we will define the proposal class and the core model package.



110

00:09:01,440 --> 00:09:07,710

Proposal class will be an entity which will be identified by way of reference number.



111

00:09:07,800 --> 00:09:15,090

It will also have reference to the customer vacation package and an array or list of passengers relationship



112

00:09:15,090 --> 00:09:21,510

between the proposal and the customer classes that the proposal references the customer object.



113

00:09:21,660 --> 00:09:24,930

And similarly, it references the vacation package.



114

00:09:24,940 --> 00:09:32,220

Keep in mind that customer and the vacation package entities have an independent lifecycle, whereas



115

00:09:32,220 --> 00:09:38,280

the passenger object that the proposal has are managed as part of the proposal.



116

00:09:38,280 --> 00:09:46,530

And the proposal has the reservations which are defined in the Conduct Act or sales not model booking



117

00:09:46,530 --> 00:09:47,110

package.



118

00:09:47,130 --> 00:09:55,650

The relationship between the proposal and the reservation is that the proposal may hold one or more



119

00:09:55,650 --> 00:09:58,140

of these reservation value objects.



120

00:09:58,290 --> 00:10:00,250

Then there is an offer object.



121

00:10:00,330 --> 00:10:05,600

This offer object is applied as a discount for pricing the package.



122

00:10:05,610 --> 00:10:11,400

Apart from that, there is also an enumeration defined in the proposal.



123

00:10:11,400 --> 00:10:12,630

Plus this proposal.



124

00:10:12,630 --> 00:10:21,310

Status enumeration is used for assigning a status to the proposal managed in the sale system.



125

00:10:21,330 --> 00:10:24,330

So this is how proposal class looks like.



126

00:10:24,330 --> 00:10:31,820

I suggest that you go to the models on your own and feel free to make changes to it, to make it better.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\006 Aggregate & Factory - Pattern.en.srt -->

1

00:00:00,150 --> 00:00:04,520

In this lesson, you will learn about the aggregate and the factory pattern.



2

00:00:05,000 --> 00:00:07,410

Let's start with the definition of an aggregate.



3

00:00:07,590 --> 00:00:16,590

An aggregate object is a cluster of entities and value objects that are viewed as a unified whole from



4

00:00:16,590 --> 00:00:19,320

the domain concept and data perspective.



5

00:00:19,350 --> 00:00:21,570

Let me explain this with an illustration.



6

00:00:22,050 --> 00:00:28,230

An aggregate consist of an aggregate group also referred to as the root entity.



7

00:00:28,980 --> 00:00:34,860

This root entity has a unique identity from the domain perspective.



8

00:00:35,430 --> 00:00:41,610

The second part of the aggregate is the cluster, which is formed by the boundary for the aggregate.



9

00:00:41,910 --> 00:00:48,660

Within this boundary, there may be zero or more aggregate entities and value objects.



10

00:00:49,110 --> 00:00:57,270

Objects in this cluster or the object within the boundary are referred to as the inner objects or child



11

00:00:57,300 --> 00:00:57,990

objects.



12

00:00:58,170 --> 00:01:00,690

Let's go with an example of the bank account.



13

00:01:01,110 --> 00:01:08,730

The bank account is an aggregate root entity that has a unique identity, but in this aggregate there



14

00:01:08,730 --> 00:01:11,400

are multiple different type of objects.



15

00:01:11,640 --> 00:01:13,920

For example, there are transactions.



16

00:01:13,920 --> 00:01:21,790

Transactions are entity objects as they have a unique identity and are persisted in long term storage.



17

00:01:21,840 --> 00:01:23,690

Then there are not many objects.



18

00:01:23,730 --> 00:01:27,710

These not many objects are managed within the context of the account.



19

00:01:27,720 --> 00:01:31,750

They do not have a unique identity outside of the bank account.



20

00:01:31,770 --> 00:01:33,980

As a result, they are value objects.



21

00:01:33,990 --> 00:01:36,630

So this is an example of an aggregate.



22

00:01:36,870 --> 00:01:41,910

Now let's say you have to operate on one of the objects not to do this.



23

00:01:42,270 --> 00:01:49,100

You may use this mechanism wherein you may call the get function on the aggregate, for example, get



24

00:01:49,110 --> 00:01:55,920

nominee to get the nominee object and then you can invoke functions directly on the object.



25

00:01:56,040 --> 00:01:59,160

This is an example of procedural programming.



26

00:01:59,190 --> 00:02:00,600

Please do not do this.



27

00:02:00,930 --> 00:02:07,080

Aggregate must provide interfaces for operating on the inner objects.



28

00:02:07,410 --> 00:02:10,880

Let me explain this with the bank account example.



29

00:02:11,100 --> 00:02:18,270

We have already discussed that it is not a good practice to directly interact with the inner object,



30

00:02:18,360 --> 00:02:25,740

so the aggregate must expose some functions to operate on the inner object.



31

00:02:25,750 --> 00:02:32,880

The code outside the aggregate will invoke the function and this function encapsulate all of the business



32

00:02:32,880 --> 00:02:36,240

logic for operating on the inner objects.



33

00:02:36,240 --> 00:02:44,430

As a designer of the aggregate, it will be your responsibility to ensure that all of the required behavior



34

00:02:44,580 --> 00:02:51,660

for operating on the inner object is exposed as functions by the aggregate root object.



35

00:02:52,840 --> 00:03:01,420

In general, the aggregate objects are stored in multiple tables in the case of RDBMS and in the case



36

00:03:01,420 --> 00:03:07,900

of no sequel's database, the aggregate object may be stored across multiple collections.



37

00:03:07,930 --> 00:03:17,290

When an aggregate is inserted or updated against these databases, that needs to be done in an atomic



38

00:03:17,290 --> 00:03:17,910

fashion.



39

00:03:18,100 --> 00:03:25,690

Let's say in the case of a count, when the function gets invoked, multiple innot objects get updated



40

00:03:26,170 --> 00:03:33,220

and when the account object is saved to the database across multiple tables or collections, all of



41

00:03:33,220 --> 00:03:35,260

the changes must be made.



42

00:03:35,260 --> 00:03:41,940

Atomically either all the changes are successful or all the changes are rolled back.



43

00:03:42,100 --> 00:03:47,770

So unit of work is an important consideration when you are designing your aggregates.



44

00:03:48,490 --> 00:03:54,240

Factory design pattern is a common pattern for building complex domain aggregates.



45

00:03:54,370 --> 00:04:02,630

The way it works is that you define an object that has all the logic for creating the domain aggregate.



46

00:04:02,680 --> 00:04:08,950

This factory exposes a function that can be invoked by the code and renders function for creation of



47

00:04:08,950 --> 00:04:13,060

the aggregators involved on the factory, the factory reads.



48

00:04:13,060 --> 00:04:19,700

The data for the aggregate from persistent storage, creates the aggregate and returns to the column.



49

00:04:19,780 --> 00:04:26,940

So this is a very common design pattern, not necessarily exclusive to Mikoto services.



50

00:04:27,430 --> 00:04:28,720

Time for a quick question.



51

00:04:28,750 --> 00:04:32,410

What would you call an aggregate with zero input objects?



52

00:04:33,250 --> 00:04:40,000

The answer is that since an aggregate is an entity, an aggregate with zero inner objects will be an



53

00:04:40,030 --> 00:04:40,570

entity.



54

00:04:41,080 --> 00:04:45,970

But keep in mind that it may also be referred to as an aggregate or aggregate group.



55

00:04:46,270 --> 00:04:52,870

The reason I'm bringing this up is because it is very common to see entity aggregate and aggregate root



56

00:04:53,050 --> 00:04:54,840

being used interchangeably.



57

00:04:55,120 --> 00:05:01,870

So please keep that in mind in this case as well as while reading any article or blog you may find on



58

00:05:01,870 --> 00:05:02,690

the Internet.



59

00:05:02,980 --> 00:05:04,270

Time for a quick review.



60

00:05:04,510 --> 00:05:10,150

Aggregate may contain other aggregate entities and value objects.



61

00:05:10,150 --> 00:05:14,890

Aggregate must encapsulate behavior to manage in inner object.



62

00:05:15,160 --> 00:05:17,590

All changes to aggregate are saved.



63

00:05:17,590 --> 00:05:24,640

Atomically and factory partners commonly used for creating complex domain aggregates.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\007 Exercise _ ACME Sales Use Case.en.srt -->

1

00:00:00,460 --> 00:00:07,960

In this exercise, our objective is to first understand the Acme sales use case and then design the



2

00:00:07,960 --> 00:00:14,530

booking confirmation aggregate object customer initiated the contact with the Acme sales team.



3

00:00:15,040 --> 00:00:23,320

The Acme sales team member discusses the various vacation options with the customer and create one or



4

00:00:23,320 --> 00:00:24,310

more proposals.



5

00:00:24,550 --> 00:00:30,520

Customer selects one of the proposals and at that time the team member initiates the payment process,



6

00:00:30,790 --> 00:00:34,000

which leads to the creation of the purchase order.



7

00:00:34,270 --> 00:00:41,230

And once the payment is received, the payment information is generated and the provider reservations



8

00:00:41,410 --> 00:00:42,290

is triggered.



9

00:00:42,310 --> 00:00:49,090

So let's say the vacation package consists of the hotel rental car and airline tickets.



10

00:00:49,330 --> 00:00:56,440

The provider reservation process will lead to the reservation of all of these three parts of the package.



11

00:00:56,440 --> 00:01:02,590

So the hotel will be resolved, the rental car will be reserved and the airline tickets will be reserved.



12

00:01:02,590 --> 00:01:08,290

A successful reservation from all of these will lead to the generation of the booking confirmation,



13

00:01:08,290 --> 00:01:14,730

and this booking confirmation will then be communicated to the customer by way of the Senate confirmation



14

00:01:14,740 --> 00:01:15,430

use case.



15

00:01:15,850 --> 00:01:18,670

Let's take a deeper look at the booking confirmation.



16

00:01:19,000 --> 00:01:23,680

The booking confirmation contains all of the information about the reservation.



17

00:01:24,160 --> 00:01:30,070

It has the information about the payment, it has the information about the passengers, and it has



18

00:01:30,070 --> 00:01:34,000

the information about all of the provider reservations.



19

00:01:34,360 --> 00:01:38,230

This booking confirmation object is an aggregate.



20

00:01:38,230 --> 00:01:45,550

The reason it is an aggregate is because it contains a number of objects that are meaningful only in



21

00:01:45,550 --> 00:01:48,370

the context of the booking confirmation.



22

00:01:48,640 --> 00:01:55,300

Apart from the object that the booking confirmation contains, it also has reference to the customer



23

00:01:55,390 --> 00:01:58,870

as well as to the proposal to which the customer committed.



24

00:01:59,110 --> 00:02:05,680

So this is how the booking confirmation aggregate object will look like it will be identified by the



25

00:02:05,680 --> 00:02:06,700

booking reference.



26

00:02:06,880 --> 00:02:11,410

Then there is a payment confirmation object which has an entity object.



27

00:02:11,530 --> 00:02:14,170

Rest of the object are value objects.



28

00:02:14,710 --> 00:02:20,950

All of the operations on these inner objects will be carried out by way of functions exposed by the



29

00:02:21,250 --> 00:02:23,470

booking confirmation aggregate group.



30

00:02:24,220 --> 00:02:27,820

One such function is the cancel reservation function.



31

00:02:28,180 --> 00:02:35,860

The purpose of this cancel reservation function is to cancel out all of the reservations and refund



32

00:02:35,860 --> 00:02:37,360

the payment to the customer.



33

00:02:37,570 --> 00:02:41,380

Recall that all such changes need to be economic.



34

00:02:41,380 --> 00:02:49,630

In other words, if any of the cancellation for the provider reservation fails, then all changes need



35

00:02:49,630 --> 00:02:50,550

to be rolled back.



36

00:02:50,560 --> 00:02:56,680

Let's see how this cancel reservation function may be coded when the cancel reservation function is



37

00:02:56,680 --> 00:02:57,160

invoked.



38

00:02:57,520 --> 00:03:04,480

The first thing that the implementation may do is trigger the cancellation of all the provider reservations.



39

00:03:04,510 --> 00:03:10,660

Once a response is received from all of the provider reservations, the implementation may check if



40

00:03:10,660 --> 00:03:13,570

all of the cancellations were successful or not.



41

00:03:13,570 --> 00:03:20,200

If the cancellations were not successful even for a single service, then roll back all of the cancellations.



42

00:03:20,200 --> 00:03:25,990

If the cancellations were successful for all of the reservations, then the implementation will trigger



43

00:03:26,200 --> 00:03:31,480

the refund process and then check if the reform process was successful or not.



44

00:03:31,480 --> 00:03:37,000

If the refund process was unsuccessful, then roll back all of the cancellations.



45

00:03:37,240 --> 00:03:44,200

And if the response process was successful, then update the state of the booking confirmation in the



46

00:03:44,320 --> 00:03:45,610

persistent storage.



47

00:03:45,620 --> 00:03:52,780

So this is an example wherein the implementation of the aggregate route is ensuring that all changes



48

00:03:52,780 --> 00:03:53,860

are atomic.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\008 Hands On _ UML for ACME Sales Aggregates.en.srt -->

1

00:00:00,240 --> 00:00:07,200

In this lesson, we will develop the model for the aggregate objects that are discussed in the last



2

00:00:07,200 --> 00:00:07,680

lecture.



3

00:00:07,830 --> 00:00:14,370

I'll also discuss the book in Confirmation State Dargah, which will show the state through which the



4

00:00:14,400 --> 00:00:19,590

booking confirmation object will go through as part of its lifecycle.



5

00:00:19,890 --> 00:00:24,450

My objective here is to go to the core object in the Atmeh sales domain.



6

00:00:24,450 --> 00:00:31,050

Moral code and model files are available under the get branch technical and if you are interested you



7

00:00:31,050 --> 00:00:33,120

can walk through the code on your own.



8

00:00:33,270 --> 00:00:40,260

This part is optional and please keep in mind that the model has been kept simple so that it is easy



9

00:00:40,260 --> 00:00:41,910

to follow by no means.



10

00:00:42,120 --> 00:00:46,980

It's a complete model and you can think of it as the first draft of the model.



11

00:00:47,670 --> 00:00:55,320

The confirmation object will be created in the package Kondor Akhmad or sales dot model dot payment.



12

00:00:55,560 --> 00:01:03,690

The object is of type entity as it will have a unique identity within the sales context and it'll be



13

00:01:03,690 --> 00:01:04,470

persistent.



14

00:01:04,470 --> 00:01:10,380

But the life cycle of this entity will be managed by the booking confirmation object.



15

00:01:10,440 --> 00:01:17,370

As discussed earlier, this object will be created by the booking confirmation when the customer will



16

00:01:17,370 --> 00:01:24,420

pay for the vacation package and the service processing the payment will generate the confirmation reference.



17

00:01:24,450 --> 00:01:26,310

The date of payment will be captured.



18

00:01:26,580 --> 00:01:30,190

Customer Macario, the cancellation of the booking.



19

00:01:30,210 --> 00:01:34,980

Obviously there are certain business rules that we haven't discussed, but cancellation is possible.



20

00:01:35,250 --> 00:01:42,000

So if the customer decides to cancel the reservation, a cancellation reference will be generated by



21

00:01:42,000 --> 00:01:46,860

the payment service and persisted as part of the payment confirmation.



22

00:01:47,130 --> 00:01:52,590

So this is our first version of the payment confirmation object.



23

00:01:53,040 --> 00:01:57,980

The booking confirmation class will be created in the booking package.



24

00:01:58,020 --> 00:02:04,530

The object booking confirmation, as discussed earlier, is an aggregate route which will be identified



25

00:02:04,740 --> 00:02:06,660

by way of a reference.



26

00:02:06,690 --> 00:02:11,550

It will hold a list of reservations which are part of the vacation package.



27

00:02:11,560 --> 00:02:19,170

The lifespan of all the reservation objects will be managed by the booking confirmation as the relationship



28

00:02:19,170 --> 00:02:27,810

between the booking, confirmation and reservations is that the reservations are the inner objects for



29

00:02:27,810 --> 00:02:34,860

the aggregate route, not of the reservation object will be available directly from any other class.



30

00:02:35,340 --> 00:02:41,370

The booking confirmation aggregate will also have the reference to the proposal, and it'll have the



31

00:02:41,370 --> 00:02:41,880

payment.



32

00:02:41,880 --> 00:02:49,140

Confirmation and relationship between the booking confirmation and payment confirmation is that the



33

00:02:49,140 --> 00:02:57,000

booking confirmation will have one instance of the payment confirmation within the booking confirmation.



34

00:02:57,240 --> 00:03:04,350

There will be a enumeration that will define the various stages of the booking confirmation object.



35

00:03:04,380 --> 00:03:09,390

This enumeration is defined as part of the booking confirmation aggregate route.



36

00:03:09,420 --> 00:03:13,920

Next, I'll walk you through the estate diagram for the booking confirmation object.



37

00:03:14,970 --> 00:03:23,220

The booking confirmation object instance is created when the customer selects a proposal but has not



38

00:03:23,220 --> 00:03:24,090

yet paid.



39

00:03:24,090 --> 00:03:29,730

At this point, the status of the booking confirmation is pending payment from here.



40

00:03:29,880 --> 00:03:36,540

The estate can go through the reservation process or it can go through the cancellation process.



41

00:03:36,630 --> 00:03:39,960

The reservation process will begin when the customer will pay.



42

00:03:40,140 --> 00:03:47,280

So the idea here is that once the customer has paid the status of the booking, confirmation object



43

00:03:47,520 --> 00:03:51,330

will change from pending payment to pending reservation.



44

00:03:51,420 --> 00:03:58,440

The reservation process for all the providers will be sorted and the status will then change from pending



45

00:03:58,440 --> 00:04:00,810

reservation to reservation and progress.



46

00:04:01,290 --> 00:04:08,160

At some point, all of the reservations will be successful and the booking status will change to confirm



47

00:04:08,310 --> 00:04:09,450

if everything goes fine.



48

00:04:09,570 --> 00:04:15,720

Customer enjoys the vacation and that's the end of the booking confirmation lifecycle.



49

00:04:15,930 --> 00:04:23,580

But it is very much possible that the customer may not go on vacation and decide to cancel the package



50

00:04:23,580 --> 00:04:25,110

even after the confirmation.



51

00:04:25,140 --> 00:04:28,800

Obviously, there are certain business rules that we haven't discussed yet.



52

00:04:29,490 --> 00:04:36,090

The state will change from conformed to cancellation in progress, although the reservations will need



53

00:04:36,090 --> 00:04:41,460

to be canceled, the payment will be cancelled and the customer will be refunded the money.



54

00:04:41,490 --> 00:04:47,760

At that point, the status will change to cancel and that'll be the end of the booking lifecycle.



55

00:04:47,760 --> 00:04:51,960

No change after this can be made to the booking confirmation object.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\009 Model Behavior _ Anemic & Rich Models.en.srt -->

1

00:00:00,150 --> 00:00:05,670

In this lesson, you will learn about two new tomes, anaemic models and rich models.



2

00:00:05,790 --> 00:00:09,810

These terms are used for describing the model behavior.



3

00:00:10,410 --> 00:00:12,220

I'll start this lesson with a question.



4

00:00:12,390 --> 00:00:15,860

The question is, take a look at this entity object.



5

00:00:16,230 --> 00:00:19,590

Does this object expose any business logic?



6

00:00:19,620 --> 00:00:20,990

The answer is no.



7

00:00:21,210 --> 00:00:24,240

It does not expose any business logic.



8

00:00:24,240 --> 00:00:28,380

And the reason I'm saying that is because it does expose some functions.



9

00:00:28,650 --> 00:00:32,310

But these functions are just gateaux and certains.



10

00:00:32,490 --> 00:00:36,960

And the last function is just to possess the object to a database.



11

00:00:37,290 --> 00:00:43,770

These kind of models that do not expose any business logic are referred to as anemic models.



12

00:00:43,980 --> 00:00:50,610

A more formal definition is a domain model composed of entities that do not exhibit behavior.



13

00:00:50,820 --> 00:00:55,670

That is, operations applicable to the domain concept are missing.



14

00:00:55,950 --> 00:01:04,140

The opposite of anemic model is the rich domain model, and this term anemic model was coined by Martin



15

00:01:04,140 --> 00:01:05,720

Fowler in a blog.



16

00:01:05,730 --> 00:01:12,030

I suggest that if you haven't heard the name Martin Fowler, go ahead and Google his name and you'll



17

00:01:12,030 --> 00:01:15,000

find tons of interesting blogs and articles.



18

00:01:15,990 --> 00:01:20,100

Now, you must be wondering, why is this animal being used here?



19

00:01:20,970 --> 00:01:28,350

Well, anemia is a condition where body does not have enough red blood cells to carry enough oxygen



20

00:01:28,350 --> 00:01:30,260

to various tissues and organs.



21

00:01:30,720 --> 00:01:33,870

And as you can imagine, it's a bad condition.



22

00:01:34,170 --> 00:01:36,770

People with this condition feel weak.



23

00:01:36,780 --> 00:01:40,000

They have a pale skin and they have different diseases.



24

00:01:40,440 --> 00:01:43,020

Well, obviously, I don't want to discuss those diseases here.



25

00:01:43,350 --> 00:01:47,850

And a person who has anemia is referred to as anemic.



26

00:01:48,390 --> 00:01:53,890

Now, Martin is using animals as an analogy to describe a bad model.



27

00:01:54,180 --> 00:02:00,450

The idea here is that he's saying that in anemia, a person lacks the red blood cells.



28

00:02:00,570 --> 00:02:01,760

And so it is not good.



29

00:02:01,920 --> 00:02:06,790

And in the case of a model, if there is no behavior, then it is not a good model.



30

00:02:07,230 --> 00:02:09,960

Well, enough of our discussion on anemia.



31

00:02:10,230 --> 00:02:12,750

Let's go back to the discussion on models.



32

00:02:13,500 --> 00:02:16,980

Let's discuss how you diagnose an anemic model.



33

00:02:16,990 --> 00:02:22,990

In other words, let's say you already have a model and you would like to determine if it is anemic



34

00:02:23,010 --> 00:02:24,370

model or a rich model.



35

00:02:24,690 --> 00:02:28,080

The first thing that you would look at is the obvious one.



36

00:02:28,440 --> 00:02:31,020

Does the entities like the behavior?



37

00:02:31,140 --> 00:02:36,330

If the entities like the behavior, then chances are that it is an anemic model.



38

00:02:36,720 --> 00:02:44,640

And if the entity does have some functions, then the first thing you should look at is that these functions



39

00:02:44,640 --> 00:02:47,130

are not just for current operations.



40

00:02:47,430 --> 00:02:52,440

That is, they are not just getters, setters, update and delete functions.



41

00:02:52,440 --> 00:02:56,570

If they are just not functions, then the model is anemic.



42

00:02:56,940 --> 00:03:03,870

And the third thing that you need to look for is the implementation of business logic outside of the



43

00:03:04,050 --> 00:03:05,610

entity objects.



44

00:03:05,820 --> 00:03:09,280

The symptom number one and symptom number two are very clear.



45

00:03:09,480 --> 00:03:12,380

Let's discuss symptom number three in details.



46

00:03:12,870 --> 00:03:20,250

The idea is that the entity object does not have any kind of business logic implementation, but it



47

00:03:20,250 --> 00:03:22,020

does have the card functions.



48

00:03:22,290 --> 00:03:30,870

The business logic code resides in an external component that invokes the ghettos to get the data from



49

00:03:30,870 --> 00:03:38,580

the entity object uses the data in the business logic code, then calls the setters on the entity object



50

00:03:38,760 --> 00:03:41,250

to set the data back on the entity.



51

00:03:41,280 --> 00:03:49,950

The external component is commonly implemented as shared services or are coded as part of the application



52

00:03:49,950 --> 00:03:50,520

directly.



53

00:03:50,520 --> 00:03:58,260

In the case of services, the domain objects provide the card operations to the services which reside



54

00:03:58,260 --> 00:03:59,360

in a separate layer.



55

00:03:59,640 --> 00:04:06,570

All of the business logic reside in the components or services implemented in the shared services layer.



56

00:04:06,810 --> 00:04:14,490

This kind of an architecture is commonly seen in organizations that have adopted service oriented architecture.



57

00:04:15,450 --> 00:04:22,710

The second way in which the business logic may be externalized is by way of creating applications with



58

00:04:22,710 --> 00:04:27,170

the business logic embedded within the application code.



59

00:04:27,180 --> 00:04:32,580

In this scenario, the business logic gets repeated across multiple applications.



60

00:04:32,580 --> 00:04:39,120

Since there are many applications which are dependent on the domain layer, managing changes in the



61

00:04:39,120 --> 00:04:41,940

domain layer object will be a challenge.



62

00:04:41,970 --> 00:04:45,660

This kind of situation should be avoided at all costs.



63

00:04:45,660 --> 00:04:52,470

But unfortunately I have seen this kind of a pattern implemented in many legacy applications.



64

00:04:53,130 --> 00:04:57,080

Not that you understand the symptoms of the anemic models.



65

00:04:57,090 --> 00:05:04,440

Let's talk about how a rich model looks like rich model implements the model behavior inherently as



66

00:05:04,440 --> 00:05:06,930

part of the entity object.



67

00:05:07,140 --> 00:05:12,720

It is an example of the account object which has all the business logic in one place.



68

00:05:13,210 --> 00:05:18,420

These are the functions that implement the business logic in the account object.



69

00:05:18,600 --> 00:05:24,240

It implements all of the domain concepts, for example, how the withdrawal is carried out or how the



70

00:05:24,240 --> 00:05:30,310

deposits are made and all of the business rules that apply to these functions.



71

00:05:30,360 --> 00:05:36,660

One positive side effect of having all the business logic in one place is that the morals data integrity



72

00:05:36,690 --> 00:05:43,500

is maintained and this is because owner of the object will have full control on how the data is managed



73

00:05:43,560 --> 00:05:48,990

rather than every application implementing the business logic on their own.



74

00:05:49,140 --> 00:05:50,900

At this point, you may have a question.



75

00:05:51,030 --> 00:05:53,820

Is an anemic model always bad?



76

00:05:53,880 --> 00:05:59,910

In other words, if you have an existing model which is anemic, should you go ahead and plan for making



77

00:05:59,910 --> 00:06:00,970

it a rich model?



78

00:06:01,020 --> 00:06:06,180

My response to this question is not really, especially in case of simple domain problems.



79

00:06:06,180 --> 00:06:12,080

You need to think about the scenario, your use case, and then decide, for example, if there is no



80

00:06:12,080 --> 00:06:18,900

or light business logic or if the business logic is changing infrequently, then an anemic model may



81

00:06:18,900 --> 00:06:20,400

not be a big challenge.



82

00:06:20,400 --> 00:06:27,900

If your model is simply providing generic data services that is Criado-Perez, then you're OK with an



83

00:06:27,900 --> 00:06:28,740

anemic model.



84

00:06:28,740 --> 00:06:35,130

And then there are scenarios or use cases where there is a shared logic that does not belong in a single



85

00:06:35,130 --> 00:06:36,260

model entity.



86

00:06:36,270 --> 00:06:37,110

In this scenario.



87

00:06:37,120 --> 00:06:40,130

Also, it may be OK to have an anemic model.



88

00:06:40,140 --> 00:06:43,380

So as you can see, there is no straightforward answer.



89

00:06:43,380 --> 00:06:49,260

Anemic models may be considered and Antipater in some situations, but not all.



90

00:06:49,290 --> 00:06:55,710

You have to look at your specific use case to specific scenario and make a judgement call on whether



91

00:06:55,740 --> 00:07:00,270

you will build a model or if you are OK with an anemic model.



92

00:07:00,540 --> 00:07:06,450

There is a common misconception that in a rich model, every entity should implement the behavior.



93

00:07:06,450 --> 00:07:13,020

And that is not right because in an aggregate object, the aggregate root implements the behavior.



94

00:07:13,380 --> 00:07:17,340

The inner entity object may not have any behavior.



95

00:07:17,400 --> 00:07:18,510

It is an example.



96

00:07:18,930 --> 00:07:24,240

This is the booking confirmation aggregate that are discussed in one of the earlier lectures.



97

00:07:24,240 --> 00:07:32,190

In this, the parent confirmation, which is an entity within this aggregate, exposes the card operations.



98

00:07:32,190 --> 00:07:38,370

Only all of the business logic is implemented in the cancel reservation function.



99

00:07:38,530 --> 00:07:45,000

Important thing to note here is that the payment confirmation object is not getting directly exposed



100

00:07:45,000 --> 00:07:46,200

by this aggregate.



101

00:07:46,500 --> 00:07:53,730

In other words, external components do not have direct access to the payment confirmation entity.



102

00:07:54,360 --> 00:07:59,910

Time to wrap up this lesson in this lesson you learned about anemic models and Eric model refers to



103

00:07:59,910 --> 00:08:03,930

models in which the entities are implemented with no behavior.



104

00:08:04,050 --> 00:08:07,170

The opposite of an anemic model is a rich model.



105

00:08:07,170 --> 00:08:13,560

In order to identify anemic models, you need to look for the symptoms, such as entities not implementing



106

00:08:13,560 --> 00:08:21,390

the behavior, entities implementing only card functions and business logic and external component as



107

00:08:21,390 --> 00:08:23,580

opposed to being in the entities.



108

00:08:23,880 --> 00:08:31,060

One important question that I answered in this lesson was is anemic model always and antiproton.



109

00:08:31,080 --> 00:08:34,290

And my response was more like, it depends.



110

00:08:34,620 --> 00:08:38,160

It depends on the user requirement and other factors.



111

00:08:38,160 --> 00:08:41,010

Please keep in mind that this is my opinion.



112

00:08:41,100 --> 00:08:47,670

My suggestion to you would be that you form your own opinion by carrying out some more research, by



113

00:08:47,670 --> 00:08:54,660

looking at the models that you have developed in the past and your experiences in managing changes to



114

00:08:54,660 --> 00:08:55,380

those models.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\010 Repository Object - Pattern.en.srt -->

1

00:00:00,210 --> 00:00:07,230

In this lesson, I'll describe the repository pattern, the characteristics of repository objects and



2

00:00:07,230 --> 00:00:10,530

some realization options for repositories.



3

00:00:10,950 --> 00:00:14,820

I'll start with the formal definition of the repository object.



4

00:00:14,820 --> 00:00:20,650

A repository object acts as a collection of aggregate objects in memory.



5

00:00:20,670 --> 00:00:28,740

It hides the storage level details needed for managing and quitting the state of the aggregate in the



6

00:00:28,770 --> 00:00:30,480

underlying data to.



7

00:00:30,510 --> 00:00:36,210

Well, it's a long definition, but let's break it down by taking a look at an illustration.



8

00:00:36,600 --> 00:00:41,040

An aggregate root is an entity that is managed in some kind of long term storage.



9

00:00:41,070 --> 00:00:44,930

This can be RDBMS, no sequel or even the filesystem.



10

00:00:45,120 --> 00:00:51,150

All of the logic to interact with the data storage is encapsulated by the repository object.



11

00:00:51,180 --> 00:00:58,170

The details of these interactions are hidden from the client or the callers or the repository object.



12

00:00:58,560 --> 00:01:05,730

The color of the repository object functions use the card operations to manage and query the state of



13

00:01:05,730 --> 00:01:06,590

the aggregate.



14

00:01:06,600 --> 00:01:12,030

The color of these current operations have no knowledge of the underlying data.



15

00:01:12,420 --> 00:01:19,110

For these columns, a repository is acting as a container for a collection of aggregate objects.



16

00:01:20,210 --> 00:01:26,840

Here is an example of the bank account repository, the caller or the client may invoke the various



17

00:01:26,840 --> 00:01:31,180

card operations exposed by the account repository object.



18

00:01:31,190 --> 00:01:39,590

For example, the caller invoke the ADD function to add or update an account aggregate for the implementation



19

00:01:39,590 --> 00:01:41,060

of this act function.



20

00:01:41,060 --> 00:01:47,750

The account repository object men walk the absurd API on the database engine.



21

00:01:47,780 --> 00:01:54,740

Similarly, the caller or the client may invoke the get function to retrieve the account aggregate from



22

00:01:54,740 --> 00:02:01,670

the directive and thus get function may be implemented by the account repository object by way of a



23

00:02:01,670 --> 00:02:04,570

sequel statement or by way of no sequel.



24

00:02:04,640 --> 00:02:05,720

Find Appia.



25

00:02:05,750 --> 00:02:11,960

Important thing to note here is that the client or the caller of the repository object function has



26

00:02:11,960 --> 00:02:14,010

no knowledge of the data to you.



27

00:02:14,540 --> 00:02:19,840

Next, I'll discuss the characteristics of the repository object or repository pattern.



28

00:02:20,210 --> 00:02:28,410

The first one is that for every aggregate defined in the domain model, you have one and only one repository.



29

00:02:28,640 --> 00:02:35,960

So in other words, not a good idea to implement multiple repositories for a single aggregate repository



30

00:02:36,080 --> 00:02:39,050

may expose high level behavior of functions.



31

00:02:39,060 --> 00:02:45,940

And this is apart from the typical card functions that are expected to be implemented by the repository,



32

00:02:45,980 --> 00:02:54,680

the insert update and the delete functions exposed by the repository and shows that all of these operations



33

00:02:54,890 --> 00:02:57,680

are carried out as economic operations.



34

00:02:57,860 --> 00:03:03,070

Let's go through the details of each one of these in the bank account domain model.



35

00:03:03,530 --> 00:03:08,450

They will be our account aggregate and a customer aggregate.



36

00:03:09,200 --> 00:03:15,680

Each of these aggregate will have a corresponding repository, so there will be an account repository



37

00:03:15,680 --> 00:03:17,770

and a customer repository decline.



38

00:03:17,780 --> 00:03:24,410

Court will independently invoke the functions or the operations on the account repository as well as



39

00:03:24,410 --> 00:03:25,730

the customer repository.



40

00:03:26,000 --> 00:03:32,570

For example, if there is a need for creating a holistic view of the account, the client code will



41

00:03:32,570 --> 00:03:39,350

be responsible for merging the data from the two repositories to create the holistic view.



42

00:03:39,710 --> 00:03:44,050

The repository objects are managed as part of the domain layer.



43

00:03:44,660 --> 00:03:52,100

In addition to the typical card functions, a repository may also expose higher level functions, mostly



44

00:03:52,250 --> 00:03:53,060

for queries.



45

00:03:53,060 --> 00:04:01,190

For example, the account repository object may expose a function get inactive for retrieving inactive



46

00:04:01,190 --> 00:04:03,270

accounts since certain date.



47

00:04:03,290 --> 00:04:09,650

So this function may be used by a client that is interested in getting the account on which no activity



48

00:04:09,650 --> 00:04:12,470

has been performed since certain specific date.



49

00:04:12,470 --> 00:04:20,420

In response to the invocation of the get inactive function, the account repository may execute a select



50

00:04:20,420 --> 00:04:27,710

statement with a vague clause, or it may invoke an API on the nonsecure database to retrieve documents



51

00:04:27,710 --> 00:04:30,110

that match the specified criteria.



52

00:04:30,800 --> 00:04:32,870

Next, let's talk about persistance.



53

00:04:33,380 --> 00:04:40,910

Recall from the lecture on aggregates that the aggregate is inserted, updated and deleted atomically.



54

00:04:40,910 --> 00:04:48,020

As part of that lecture, I discussed a function on the account object that required update on the two



55

00:04:48,020 --> 00:04:49,640

tables in the database.



56

00:04:49,970 --> 00:04:55,090

And the idea here is that these two tables will get updated in a unit of work.



57

00:04:55,130 --> 00:04:59,940

This almost aspect of the aggregate is enforced by the repository.



58

00:05:00,170 --> 00:05:08,120

The idea is that all changes to the state of the aggregate that is the aggregate route as well as the



59

00:05:08,120 --> 00:05:11,990

inner object is carried out under a unit of work.



60

00:05:12,140 --> 00:05:19,370

Either all of the changes to the database are successful or no changes made to any of the entities that



61

00:05:19,370 --> 00:05:20,950

are part of the aggregate.



62

00:05:20,960 --> 00:05:27,920

And this may happen if there is any error in the database operation for any of the entities.



63

00:05:27,920 --> 00:05:35,900

In the aggregate, the primary benefit of using a repository is that it keeps the domain model independent



64

00:05:35,900 --> 00:05:37,460

of the storage layer.



65

00:05:37,490 --> 00:05:40,660

The domain model is independent of the storage model.



66

00:05:41,090 --> 00:05:48,950

So for example, if you're using an RDBMS, then the domain model need not be aware of the table and



67

00:05:48,950 --> 00:05:50,180

the column structures.



68

00:05:50,480 --> 00:05:57,590

It keeps the domain model independent of the technology you may be using and RDBMS are not equal or



69

00:05:57,590 --> 00:06:00,620

even a file system for the storage of aggregate.



70

00:06:00,620 --> 00:06:03,150

But the domain model does not need to know about it.



71

00:06:03,170 --> 00:06:10,700

The repository keeps the domain model independent of the infrastructure you may be using busy for issuing



72

00:06:10,700 --> 00:06:18,680

sequel's statements against the RDBMS, or you may be using an SDK to connect with the no sequel's databases.



73

00:06:19,250 --> 00:06:19,460

The.



74

00:06:19,510 --> 00:06:26,410

Your idea is that any change to the database, you will be isolated to the repository object and will



75

00:06:26,410 --> 00:06:33,040

have no impact on your domain model repositories can also help with unit testing and mocking.



76

00:06:33,170 --> 00:06:37,430

The idea is simple for carrying out the testing of the client code.



77

00:06:37,810 --> 00:06:42,350

The database may be replaced with a mockup implementation of the database.



78

00:06:42,370 --> 00:06:47,740

These may be simple pogos or plain old Java objects, for example, that are returning.



79

00:06:47,740 --> 00:06:55,060

Static database responses are extensively used as mechanism for building mockups as it helps me move



80

00:06:55,060 --> 00:06:59,840

faster without any dependency on the availability of a real database.



81

00:07:00,550 --> 00:07:08,230

One common concern race for repositories is that for large aggregate objects, there may be an impact



82

00:07:08,230 --> 00:07:09,430

on the performance.



83

00:07:09,430 --> 00:07:15,990

And the reason for this concern is that for large aggregate objects, there may be a need to execute



84

00:07:16,000 --> 00:07:22,510

multiple database operations, or there may be a need to join across multiple tables, which may lead



85

00:07:22,510 --> 00:07:26,680

to suboptimal performance of the query to address this concern.



86

00:07:26,920 --> 00:07:33,130

One may consider the use of caching solutions such as Radice and Memcache.



87

00:07:34,060 --> 00:07:40,000

Another common concern is related to the use of criteria based queries in repositories.



88

00:07:40,420 --> 00:07:48,940

Typically, the repository exposes retrieval operation that retrieves an entire aggregate object, and



89

00:07:48,940 --> 00:07:50,990

some applications may not need it.



90

00:07:51,250 --> 00:07:58,450

For example, in the case of a mobile application for the bank, it may not need all of the information



91

00:07:58,450 --> 00:07:59,190

for the account.



92

00:07:59,230 --> 00:08:01,410

It may just need the basic information.



93

00:08:01,510 --> 00:08:07,180

So, in other words, only a partial results are as required, which is not supported out of the box



94

00:08:07,180 --> 00:08:09,160

by the repository object.



95

00:08:09,190 --> 00:08:15,320

Also, there may be a scenario where data from multiple aggregates may be needed.



96

00:08:15,340 --> 00:08:24,220

Now this is specifically of importance to a mobile application where slow speed may impact the user's



97

00:08:24,220 --> 00:08:26,110

interest in the application.



98

00:08:26,260 --> 00:08:29,290

There are two ways in which you can address this concern.



99

00:08:29,440 --> 00:08:37,210

The first was to expose high level functions in the repository, and the second is to expose additional



100

00:08:37,210 --> 00:08:39,970

queries outside of the repository.



101

00:08:40,180 --> 00:08:42,640

More on this topic in a later lecture.



102

00:08:43,700 --> 00:08:51,560

The realization of the repository requires the developer to court the mapping between the domain object



103

00:08:51,680 --> 00:08:54,380

and the database and vice versa.



104

00:08:54,440 --> 00:09:00,500

This mapping may be quite complex and according may be quite cumbersome for large objects.



105

00:09:00,530 --> 00:09:01,630

Where does this concern?



106

00:09:01,640 --> 00:09:06,510

You may consider using the mapping frameworks that are available out there.



107

00:09:06,710 --> 00:09:13,820

These mapping frameworks simplify the task of mapping between the domain objects and the databases.



108

00:09:14,420 --> 00:09:22,160

In this lesson, you learned about repository pattern repository objects make the domain model independent



109

00:09:22,160 --> 00:09:24,140

of the database layer.



110

00:09:24,440 --> 00:09:31,940

Database operations on the aggregate must be atomic, the repository object and forces.



111

00:09:31,970 --> 00:09:37,390

The atomic repository objects may also be used for unit testing and mocking.



112

00:09:37,670 --> 00:09:43,730

There are some common concerns related to repository objects, but these common concerns related to



113

00:09:43,730 --> 00:09:50,570

the query function may be addressed by exposing high level query functions in the repository object



114

00:09:50,840 --> 00:09:58,790

by using caching solutions such as Radice and Memcache, and by creating and exposing query functions



115

00:09:59,000 --> 00:10:01,910

outside of the repository object.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\011 Hands On _ ACME model Repository in UML & JAVA.en.srt -->

1

00:00:00,240 --> 00:00:08,670

In this lesson, we will model the repository objects in the Acme model and then I will walk you through



2

00:00:08,670 --> 00:00:15,310

some test code and you will also see the test code in action at the end of this lecture.



3

00:00:16,080 --> 00:00:22,950

My objective behind the model and the code walk through is to give you an idea about a repository,



4

00:00:23,740 --> 00:00:28,150

all of the code and model files available in the get branch spectacle.



5

00:00:28,530 --> 00:00:32,510

I will be walking you through some of the code files, but not all.



6

00:00:32,730 --> 00:00:39,070

You can walk through the other code files on your own and just keep in mind that it is optional.



7

00:00:39,870 --> 00:00:45,480

As I said earlier, the intent is to give you a good understanding of repository.



8

00:00:45,750 --> 00:00:51,120

Rather than teaching you Java, you may implement the models that I have discussed in this course in



9

00:00:51,120 --> 00:00:52,030

any language.



10

00:00:52,260 --> 00:00:57,090

And please note that the court has kept simple so that it is easy to follow.



11

00:00:57,360 --> 00:01:00,570

A couple of quick points before we roll forward with this lesson.



12

00:01:00,570 --> 00:01:08,280

An entity with zero in object is also referred to as an aggregate root, and there is a one to one relationship



13

00:01:08,490 --> 00:01:16,560

between the aggregates and the repositories since there is a one to one relationship between the aggregates



14

00:01:16,830 --> 00:01:20,950

and the repository objects in the acronym model.



15

00:01:20,970 --> 00:01:26,850

We will have multiple repositories, one for each of the aggregate routes.



16

00:01:27,570 --> 00:01:33,240

These repository objects Expo's functions as part of an interface.



17

00:01:33,270 --> 00:01:38,610

They do not carry out the actual realization of the storage system functionality.



18

00:01:39,580 --> 00:01:48,400

All storage system interactions are isolated in a separate set of objects that implement the repository



19

00:01:48,550 --> 00:01:56,620

interface, for example, the customer aggregate route will be associated with the customer interface



20

00:01:57,130 --> 00:02:05,230

and that customer interface will be implemented by the customer report object for, let's say, a database.



21

00:02:05,440 --> 00:02:07,720

It may again be implemented for filesystem.



22

00:02:08,110 --> 00:02:15,550

And the benefit of this approach is that objects in this layer may be replaced without impacting the



23

00:02:15,550 --> 00:02:20,830

clients that are using the interfaces exposed by the repository objects.



24

00:02:22,040 --> 00:02:30,190

What Acme sales model are defined all of the repository object interfaces in the package, Commodore



25

00:02:30,230 --> 00:02:35,700

Achmat model or repo to test out these repository interfaces?



26

00:02:35,720 --> 00:02:43,820

I have decided to create fake implementation of the repository objects and these fake repository objects



27

00:02:43,820 --> 00:02:46,790

will implement the repository interfaces.



28

00:02:46,910 --> 00:02:53,810

The idea is that in future we may decide to create another set of REPL objects, which will implement



29

00:02:53,810 --> 00:03:00,060

the interface functions, but will carry out the interactions with the actual database.



30

00:03:00,080 --> 00:03:07,940

So in effect, the classes in the Commodore Akhmad model report our database package will implement



31

00:03:07,940 --> 00:03:13,060

the corresponding interfaces and the Commodore Achmad or model or triple.



32

00:03:13,100 --> 00:03:16,070

Let's go through the details of the customer repository.



33

00:03:17,020 --> 00:03:23,740

The customer interface will be defined in the package Kamden Achmad or modelled on Triple.



34

00:03:24,690 --> 00:03:28,900

They'll be functional declarations within the customer interface.



35

00:03:28,920 --> 00:03:35,130

There will be an ad function for creating and for updating the customer object, then there will be



36

00:03:35,130 --> 00:03:42,570

a guest function which will take the reference number by which the customer is identified to retrieve



37

00:03:42,570 --> 00:03:43,210

the customer.



38

00:03:43,380 --> 00:03:49,440

Then there may be a function for finding the customers based on the email or phone number.



39

00:03:49,590 --> 00:03:55,530

There's also a remove function that takes the customer reference number for the removal of the customer



40

00:03:55,560 --> 00:03:56,160

object.



41

00:03:56,170 --> 00:04:02,940

The fake implementation of this report interface is in the package Commodore model or test.



42

00:04:02,940 --> 00:04:10,980

Not fake, not repo, but in this there will be a implementation class customer repo fake which implements



43

00:04:10,980 --> 00:04:12,930

the customer interface.



44

00:04:12,960 --> 00:04:17,710

Let's take a look at the Java implementation for these two in the repo package.



45

00:04:18,060 --> 00:04:23,050

Open the customer repo code and here you will find the ad function to get function.



46

00:04:23,070 --> 00:04:27,630

The high level get function for retrieving a customer based on email or phone number.



47

00:04:27,630 --> 00:04:29,370

And then there are some remove functions.



48

00:04:29,370 --> 00:04:32,220

The fake implementation is available under the test.



49

00:04:32,250 --> 00:04:34,530

Fake not repo customer repo fake.



50

00:04:34,530 --> 00:04:39,270

And as you can see here, this class implements the customer repo interface.



51

00:04:39,270 --> 00:04:45,120

Since this is a fake implementation, it is implemented as an array list which is going to retain the



52

00:04:45,120 --> 00:04:47,850

customer object in an in-memory collection.



53

00:04:47,850 --> 00:04:51,840

The ad function is simply adding the customer to the collection.



54

00:04:51,840 --> 00:04:57,000

The good function is going through the objects in the collection, looking for the customer that has



55

00:04:57,000 --> 00:04:59,930

the matching reference number and the high level.



56

00:04:59,940 --> 00:05:07,410

That function by calling the function on the customer object to check if the customer has the specified



57

00:05:07,530 --> 00:05:09,590

email or the phone number.



58

00:05:09,600 --> 00:05:15,120

And then there are these two remove functions which remove the customer from the collection at this



59

00:05:15,120 --> 00:05:15,550

point.



60

00:05:15,570 --> 00:05:22,380

I suggest that you go to the models for a vacation package proposal and the booking confirmation on



61

00:05:22,380 --> 00:05:24,170

your own once you're done with.



62

00:05:24,470 --> 00:05:29,040

Take a quick look at the Java code implementation for these models.



63

00:05:29,040 --> 00:05:36,000

So please pause the video, carry out this activity and join me for seeing some code in action.



64

00:05:37,710 --> 00:05:44,100

All right, hopefully you found the model and the quote, easy to follow, and we are ready to move



65

00:05:44,100 --> 00:05:45,060

on to the next step.



66

00:05:45,450 --> 00:05:51,870

Recall this sequence diagram in the sequence diagram we are depicting that the customer called the Acme



67

00:05:51,870 --> 00:05:52,440

sales.



68

00:05:52,440 --> 00:05:58,700

The sales agent pulls up the customer's information using their phone number or email.



69

00:05:58,800 --> 00:06:04,230

Then they select some vacation packages based on the customer's desires.



70

00:06:04,230 --> 00:06:07,050

Budget, et cetera, creates the proposals.



71

00:06:07,500 --> 00:06:15,140

Customer likes one of the proposal and selects it, and the sales agent creates the booking confirmation.



72

00:06:15,240 --> 00:06:20,320

Next, I'll show you the implementation of this sequence in Java code.



73

00:06:20,340 --> 00:06:24,300

Obviously, it is only meant for testing in the Java code.



74

00:06:24,420 --> 00:06:28,820

I'm using the Acme sales models that we have developed so far.



75

00:06:28,890 --> 00:06:31,140

So let's look at the code.



76

00:06:31,800 --> 00:06:35,390

The code for the test is available under the test package.



77

00:06:35,400 --> 00:06:39,360

The name of the Java file is repo collections test.



78

00:06:39,360 --> 00:06:46,800

Here in this code you will find that I'm creating four fake repositories and carrying out the initialization



79

00:06:46,800 --> 00:06:50,050

of these repositories in the static function.



80

00:06:50,070 --> 00:06:56,010

So, for example, in the generate customer function, I'm creating an instance of the fake repository



81

00:06:56,010 --> 00:07:02,050

for the customers and then creating the customer object and adding to the customer repository.



82

00:07:02,070 --> 00:07:08,610

Similarly, in the generate vacation package function, creating the fake vacation package repository,



83

00:07:08,630 --> 00:07:14,820

then creating the vacation package instances, then adding it to the vacation package repository.



84

00:07:14,940 --> 00:07:21,600

And then there is generate proposal and a generate booking confirmation for generating the fake data



85

00:07:21,600 --> 00:07:28,500

for proposals, as well as for booking confirmation that flow is quoted in the main function here you



86

00:07:28,500 --> 00:07:33,610

will find that we assimilating the end to end sequence that I discussed.



87

00:07:33,720 --> 00:07:37,950

The first thing that's happening is the customer calls the Acme sales.



88

00:07:37,950 --> 00:07:43,350

The sales agent uses the customer's phone number to pull out the record for the customer.



89

00:07:43,350 --> 00:07:50,730

The customer information is printed on the console as an extra sales agent gathers the customer's vacation



90

00:07:50,730 --> 00:07:56,780

preferences and decides to discuss the vacation package for Bahamas.



91

00:07:56,820 --> 00:08:01,320

So he pulls out the information for the three night Bahamas package.



92

00:08:01,440 --> 00:08:05,040

The information about the vacation package will be printed on the console.



93

00:08:05,220 --> 00:08:08,220

Then the agent starts to prepare the proposal.



94

00:08:08,370 --> 00:08:14,120

The proposal object is created and there are two reservation holders for this package.



95

00:08:14,130 --> 00:08:18,480

The first one is for hotel and the second one is for the airlines.



96

00:08:18,480 --> 00:08:23,910

So the agent sets up the check in and check out dates for the hotel reservation.



97

00:08:24,030 --> 00:08:30,420

Then the agent sets up the flight information for the outbound and the inbound fight.



98

00:08:30,420 --> 00:08:36,240

For the sake of this discussion, let's assume that there is a separate system from which the sales



99

00:08:36,240 --> 00:08:39,240

agent is getting the flight information.



100

00:08:39,450 --> 00:08:46,190

The proposal gets added to the proposal repository and the proposal is printed out to the console.



101

00:08:46,590 --> 00:08:50,760

Let's assume that the customer commits to the proposal.



102

00:08:50,910 --> 00:08:57,500

Once the customer commits to the proposal, an instance of the booking confirmation is created and this



103

00:08:57,510 --> 00:09:02,880

booking confirmation object is added to the booking confirmation repository.



104

00:09:02,880 --> 00:09:06,000

And this will be the end of the sequence in this test.



105

00:09:06,280 --> 00:09:08,490

Let's go ahead and run this test right.



106

00:09:08,490 --> 00:09:09,990

Click run.



107

00:09:10,320 --> 00:09:12,000

So here is our output.



108

00:09:12,000 --> 00:09:16,590

We have the information about the customer that the sales agent pulled out.



109

00:09:17,040 --> 00:09:23,160

Here is the information about the vacation package that the sales agent locked up.



110

00:09:23,160 --> 00:09:26,190

It is the information about the proposal.



111

00:09:26,370 --> 00:09:32,040

And interesting thing to notice here is the information about the two reservation holders.



112

00:09:32,040 --> 00:09:39,570

So here, as you can see, the customer will be staying in the best Western Hotel on the dates specified



113

00:09:39,570 --> 00:09:40,500

in the reservation.



114

00:09:40,500 --> 00:09:44,250

And the flights are from United Airlines.



115

00:09:44,760 --> 00:09:49,440

There is information about the flight numbers and the airports for those flights.



116

00:09:49,440 --> 00:09:54,840

And then, as expected, the booking confirmation is an pending payment state.



117

00:09:55,380 --> 00:10:01,380

And there is information about the proposal and the customer and the various reservations.



118

00:10:01,380 --> 00:10:07,980

I suggest that you walk to the score on your own and try it out to get a feel of how the repository



119

00:10:07,980 --> 00:10:11,670

objects and other model elements of working.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\012 Domain Service - Pattern.en.srt -->

1

00:00:00,120 --> 00:00:05,820

In this lesson, you will learn about the domain services and their characteristics, let's say there



2

00:00:05,820 --> 00:00:11,760

is a bank that offers three types of products saving account, checking account and loan account.



3

00:00:12,150 --> 00:00:20,040

Let's say there is a requirement that customers can apply for a loan account only if their combined



4

00:00:20,040 --> 00:00:24,810

balance and savings account and checking account is over ten thousand dollars.



5

00:00:24,840 --> 00:00:31,860

Now, this particular requirement cannot be billed as behavior in any of these entities because it does



6

00:00:31,860 --> 00:00:35,380

not fit naturally in any of these entities.



7

00:00:35,490 --> 00:00:39,150

So the question to you is, where would you build this functionality?



8

00:00:40,020 --> 00:00:44,010

This is where the domain service comes into picture.



9

00:00:44,490 --> 00:00:51,480

The idea is to implement the behavior that does not belong to saving account or the checking account



10

00:00:51,810 --> 00:00:54,770

in this standalone independent service.



11

00:00:55,140 --> 00:01:03,930

The way to work is that the caller or the client code can invoke an operation on the loan eligibility



12

00:01:03,930 --> 00:01:09,030

check service to find out if the customer is eligible for the loan or not.



13

00:01:09,510 --> 00:01:16,260

The loan eligibility check service can then invoke an operation on the saving account entity to get



14

00:01:16,260 --> 00:01:22,080

the balance, carry out the same operation against the checking account, and then execute the required



15

00:01:22,080 --> 00:01:28,110

business logic, which is to add the balance from the saving account and the checking account and check



16

00:01:28,110 --> 00:01:30,100

if it is greater than 10000.



17

00:01:30,120 --> 00:01:36,960

And this is how loan eligibility check service will determine if the customer is eligible for a loan



18

00:01:37,080 --> 00:01:37,640

or not.



19

00:01:38,100 --> 00:01:44,880

A more formal definition of a domain services that it is a domain object that implements the domain



20

00:01:44,880 --> 00:01:53,580

functionality or concept that may not be modeled naturally as a behavior in any domain, entity or value



21

00:01:53,580 --> 00:02:00,130

object domain service as part of the domain model, since there are different types of services.



22

00:02:00,150 --> 00:02:05,280

It is important for you to understand the characteristics of domain services.



23

00:02:05,280 --> 00:02:09,390

Domain services always implement business behavior for the domain.



24

00:02:09,540 --> 00:02:13,920

Domain services are stateless, domain services are highly cohesive.



25

00:02:13,920 --> 00:02:17,830

Domain services may interact with other domain services.



26

00:02:17,880 --> 00:02:20,280

Let's go through the details of each one of these.



27

00:02:20,880 --> 00:02:27,960

Since the domain service has the business behavior, the domain service object is aware of the other



28

00:02:27,960 --> 00:02:29,220

domain objects.



29

00:02:29,790 --> 00:02:36,690

In the case of the loan eligibility check service, the service is aware of the saving account entity



30

00:02:36,690 --> 00:02:38,400

and the checking account entity.



31

00:02:38,550 --> 00:02:46,080

The loan eligibility check has the business rules, but in general, domain services can have calculation's



32

00:02:46,320 --> 00:02:49,580

workflow and decision logic for the domain.



33

00:02:49,800 --> 00:02:55,550

In short, any kind of domain concept may be implemented in the domain service.



34

00:02:55,560 --> 00:03:03,690

The color of the domain service does not have the awareness of the details of the behavior implemented



35

00:03:03,690 --> 00:03:05,190

in the domain service.



36

00:03:05,190 --> 00:03:12,030

So a domain service insulates the caller or the client code from the business logic details.



37

00:03:12,450 --> 00:03:15,670

Domain service does not maintain state between calls.



38

00:03:15,770 --> 00:03:22,200

What that means is that if you're calling the domain service, there is no state variable or direct



39

00:03:22,200 --> 00:03:26,430

persistance mechanism built into the domain service.



40

00:03:26,460 --> 00:03:32,670

Now you may argue that there are instances where the business logic carries out persistence and you



41

00:03:32,670 --> 00:03:33,030

are right.



42

00:03:33,300 --> 00:03:41,070

In that scenario, the domain service depends on the entity objects to take care of the persistance.



43

00:03:41,070 --> 00:03:47,820

So the implication of no state variables or persistance is that there may be calls coming in from multiple



44

00:03:47,820 --> 00:03:54,150

callers or clients, but there is no correlation between these calls and it does not matter whether



45

00:03:54,150 --> 00:03:57,150

the call is coming from the same client or different client.



46

00:03:57,300 --> 00:04:04,280

So the bottom line is that there is no correlation between any calls originating from any domain.



47

00:04:04,290 --> 00:04:06,050

Services are highly cohesive.



48

00:04:06,060 --> 00:04:12,870

What that means is that a domain service does one and only one thing and doesn't value the loan.



49

00:04:12,870 --> 00:04:19,980

Eligibility check service carries out a check on whether a customer is eligible for loan or not.



50

00:04:20,010 --> 00:04:21,420

Here is another example.



51

00:04:21,570 --> 00:04:22,860

Loan approval service.



52

00:04:23,400 --> 00:04:30,530

This loan approval service implements the rules and floor for the loan application.



53

00:04:30,810 --> 00:04:37,260

In other words, when the customer applies for the loan, this is the service that takes care of the



54

00:04:37,260 --> 00:04:42,030

workflow and the rules for approval of the loan application for the customer.



55

00:04:42,930 --> 00:04:46,500

A domain service may interact with other domain services.



56

00:04:46,680 --> 00:04:48,560

Let me explain this with an example.



57

00:04:48,630 --> 00:04:58,110

Let's say there is a domain service upsilon that a client or columnist call to initiate the loan application



58

00:04:58,110 --> 00:04:58,770

process.



59

00:04:59,400 --> 00:05:07,080

The first thing that this application service needs to do is check if the customer is eligible for loan



60

00:05:07,080 --> 00:05:08,470

application or not.



61

00:05:08,490 --> 00:05:14,240

And it can do that by invoking an operation on the loan eligibility check service.



62

00:05:14,250 --> 00:05:18,180

The logic in the apply loan will look similar to this variant.



63

00:05:18,420 --> 00:05:27,330

If the customer is eligible for a loan, then the apply loan service will initiate the loan approval



64

00:05:27,330 --> 00:05:32,190

process by invoking cooperation on the loan approval domain service.



65

00:05:32,670 --> 00:05:39,300

So as you can see here, one domain service can invoke operation on other domain services.



66

00:05:39,930 --> 00:05:44,010

Before I end this lesson, I would like to highlight an important point.



67

00:05:44,010 --> 00:05:47,050

Domain services are technology agnostic.



68

00:05:47,400 --> 00:05:54,930

There is a common misconception that alderman services should be exposed as a business that is not correct.



69

00:05:55,380 --> 00:06:00,830

A domain service is independent of the technology used for the invocation.



70

00:06:00,840 --> 00:06:08,310

For example, a domain service operation, maybe just a plain old Java function call, or it may be



71

00:06:08,430 --> 00:06:12,770

carried out over a network protocol such as SCDP or MQ.



72

00:06:13,170 --> 00:06:16,440

More on this topic as we progress through the course.



73

00:06:16,720 --> 00:06:20,070

Time to go with the key points that we have covered in this lesson.



74

00:06:20,520 --> 00:06:25,830

I talked about domain services and you need to be aware of the characteristics of the domain service



75

00:06:26,250 --> 00:06:29,280

that differentiates it from other types of services.



76

00:06:29,620 --> 00:06:36,930

The first one is that the domain service implements domain behavior that does not fit naturally in other



77

00:06:36,930 --> 00:06:40,740

entities and value objects in the domain model.



78

00:06:41,100 --> 00:06:47,130

The other characteristics are that the domain service is stateless, the domain service is highly Cohasset



79

00:06:47,130 --> 00:06:50,310

and domain service with other domain services.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\013 Application Services - Pattern.en.srt -->

1

00:00:00,180 --> 00:00:05,850

Application services, in this lesson, you will learn how the application services are different from



2

00:00:05,850 --> 00:00:11,920

the domain services and you'll also learn about the characteristics of application services.



3

00:00:12,630 --> 00:00:13,520

Time for a quiz.



4

00:00:13,680 --> 00:00:17,910

Let's say a bank's domain model has these three entities.



5

00:00:17,940 --> 00:00:24,450

You're given the requirement to create a service customer portfolio, which would provide all of the



6

00:00:24,450 --> 00:00:26,820

data from these three entities.



7

00:00:26,850 --> 00:00:31,590

The question for you is, would you implement it as a domain service?



8

00:00:32,960 --> 00:00:40,160

The short answer is that you would not implement this service as a domain service because it does not



9

00:00:40,160 --> 00:00:42,710

have any domain functionality.



10

00:00:43,100 --> 00:00:46,370

Let's revisit the definition of the domain service.



11

00:00:46,580 --> 00:00:52,520

It states that a domain service is a domain object that implements domain functionality.



12

00:00:52,850 --> 00:01:00,280

And since the customer portfolio service will not implement any domain functionality, we cannot implement



13

00:01:00,290 --> 00:01:01,810

it as a domain service.



14

00:01:01,820 --> 00:01:05,690

And this is where the application services come into picture.



15

00:01:05,900 --> 00:01:09,220

It is a more formal definition of an application service.



16

00:01:09,560 --> 00:01:16,250

It's a domain object that does not implement any domain functionality, but depends on other domain



17

00:01:16,250 --> 00:01:22,940

objects for exposing high level domain functionality to the consumer's external to the model.



18

00:01:23,570 --> 00:01:31,370

The key difference between the domain service and application service is that application service does



19

00:01:31,370 --> 00:01:36,110

not implement any kind of business logic or domain functionality.



20

00:01:36,410 --> 00:01:44,480

The other big difference is that the application service is exposed to external consumers such as Web



21

00:01:44,480 --> 00:01:48,330

applications, mobile applications or application service.



22

00:01:48,650 --> 00:01:52,430

Let's go through the characteristics of an application service.



23

00:01:53,060 --> 00:01:59,810

Application services have no domain logic, and this is the main difference between the application



24

00:01:59,810 --> 00:02:02,000

service and the domain service.



25

00:02:02,000 --> 00:02:06,050

Application services like the domain services are stateless.



26

00:02:06,050 --> 00:02:13,400

Application services may define an external interface, application services are exposed or some kind



27

00:02:13,400 --> 00:02:14,660

of network protocol.



28

00:02:14,900 --> 00:02:17,210

Let's go through the details of each of these.



29

00:02:17,480 --> 00:02:20,410

An application service has no domain logic.



30

00:02:20,420 --> 00:02:24,780

It depends on the other domain object for domain logic.



31

00:02:25,220 --> 00:02:31,160

This is the main difference between a domain service and an application service.



32

00:02:31,520 --> 00:02:37,270

The application service orchestrates the execution of the domain logic.



33

00:02:37,700 --> 00:02:44,720

So in the case of the Customer Portfolio Application Service, the orchestration logic will look like



34

00:02:44,720 --> 00:02:45,070

this.



35

00:02:45,440 --> 00:02:50,060

The service will first invoke the get operation on the customer entity.



36

00:02:50,330 --> 00:02:56,960

Then it'll carry out the operation on the saving account entity and then it will execute the get operation



37

00:02:56,960 --> 00:03:03,830

on the checking account entity, combining the data from these three entities and return it back to



38

00:03:03,830 --> 00:03:04,610

the caller.



39

00:03:05,330 --> 00:03:09,360

Like the domain service and application service is also stateless.



40

00:03:09,740 --> 00:03:13,480

There is no state management carried out in the application service.



41

00:03:13,610 --> 00:03:20,780

There is no state variable or persistence of domain objects implemented in the application service.



42

00:03:20,930 --> 00:03:28,430

Application service depends on the domain object for persistence and application service exposes the



43

00:03:28,430 --> 00:03:31,490

interface used by the outside world.



44

00:03:31,820 --> 00:03:39,200

Here, the outside world refers to the external components which are outside of the domain model.



45

00:03:39,230 --> 00:03:46,160

The point to note here is that the interface exposed to the outside world does not need to be an entity



46

00:03:46,160 --> 00:03:47,560

or value object.



47

00:03:47,570 --> 00:03:53,780

In other words, the schema of the request and response for the application service does not need to



48

00:03:53,780 --> 00:03:56,370

be aligned with any other domain object.



49

00:03:56,390 --> 00:04:02,690

So going back to the example of customer portfolio service, the last step will be to transform all



50

00:04:02,690 --> 00:04:08,420

of the data into a desired response message format and send back to the caller.



51

00:04:08,570 --> 00:04:16,130

An application service exposes the external interface or network protocol in a domain model.



52

00:04:16,490 --> 00:04:24,830

The application service may be thought of as a boundary object that protects all of the objects within



53

00:04:24,830 --> 00:04:26,080

the domain model.



54

00:04:26,300 --> 00:04:34,670

The application service may be exposed as an API and this API is consumed by the external components



55

00:04:34,700 --> 00:04:36,320

over network protocol.



56

00:04:36,500 --> 00:04:42,470

This network protocol, maybe SCDP, MQ, or may even be a proprietary protocol.



57

00:04:42,590 --> 00:04:49,180

The format of the data between the external competence and the API is flexible.



58

00:04:49,220 --> 00:04:53,090

It may be Jason Ximo, CSFI or any other format.



59

00:04:53,120 --> 00:04:56,480

Depending on the implementation of the application service.



60

00:04:56,810 --> 00:05:03,920

The external components may or may not have knowledge of the domain object or their structures.



61

00:05:04,160 --> 00:05:10,400

Next, I'll discuss the relationship between the application service and domain service and application



62

00:05:10,400 --> 00:05:15,200

service may expose a domain service to external component.



63

00:05:15,200 --> 00:05:16,160

Head is an example.



64

00:05:16,340 --> 00:05:23,230

Let's say there is a appli loan application servers that need to be exposed to the external components.



65

00:05:23,270 --> 00:05:30,470

Now recall we have already discussed and apply on domain service, so this apply loan application service



66

00:05:30,620 --> 00:05:32,300

may use the apply.



67

00:05:32,710 --> 00:05:37,780

Domain service to provide the interface to the external components.



68

00:05:38,500 --> 00:05:44,680

Time to go to key points in this lesson you learned about applications, services, applications, services



69

00:05:45,100 --> 00:05:47,820

do not implement any domain behavior.



70

00:05:48,010 --> 00:05:56,560

They provide high level services by way of orchestrating execution of the domain logic in the domain



71

00:05:56,590 --> 00:05:57,370

objects.



72

00:05:57,520 --> 00:06:02,650

Application services expose interfaces to external components.



73

00:06:02,920 --> 00:06:11,680

That is, components that are outside of the domain model by way of a network protocol such as HTP and



74

00:06:11,680 --> 00:06:12,070

NQ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\014 Infrastructure Services - Pattern.en.srt -->

1

00:00:00,150 --> 00:00:06,150

Infrastructure services, in this lesson, you learn how the infrastructure services are different from



2

00:00:06,150 --> 00:00:12,870

the domain services and application services, you'll also learn about the characteristics of infrastructure



3

00:00:12,870 --> 00:00:20,070

services and infrastructure service is defined as a service that interacts with an external resource



4

00:00:20,550 --> 00:00:25,530

to address a concern that is not part of the primary problem domain.



5

00:00:25,680 --> 00:00:33,030

It defines a contract used by the domain objects to interact with the outside services.



6

00:00:33,210 --> 00:00:35,840

The key word here is external resource.



7

00:00:36,360 --> 00:00:40,140

Let's go over some examples of commonly used external resources.



8

00:00:40,180 --> 00:00:41,910

First one is logging system.



9

00:00:41,940 --> 00:00:49,200

Domain objects need to log messages and this can be done against any kind of external logging system



10

00:00:49,200 --> 00:00:52,410

such as Florida or ElasticSearch Domain.



11

00:00:52,410 --> 00:00:57,150

Object may need to send out notifications as part of the business process.



12

00:00:57,630 --> 00:01:04,530

For example, email or SMS notifications to the customer's domain objects definitely need some kind



13

00:01:04,530 --> 00:01:05,940

of persistance mechanism.



14

00:01:06,120 --> 00:01:12,360

And this persistance mechanism, maybe an external database or even a file system, it is common for



15

00:01:12,360 --> 00:01:20,250

the domain object to be dependent on external services or apps such as Salesforce APIs or even Google



16

00:01:20,250 --> 00:01:20,570

Map.



17

00:01:20,580 --> 00:01:27,450

And these are just some common examples of external resources like the application services.



18

00:01:27,450 --> 00:01:30,630

Infrastructure services have no domain logic.



19

00:01:30,630 --> 00:01:36,660

Infrastructure services follow the single responsibility principle, infrastructure services, expo's



20

00:01:36,660 --> 00:01:39,350

a standard interface or contract.



21

00:01:39,420 --> 00:01:42,060

Let's go through the details of each one of these.



22

00:01:42,780 --> 00:01:49,110

Infrastructure service has no domain logic because it provides, as the name suggests, infrastructure



23

00:01:49,110 --> 00:01:50,760

service, not a business service.



24

00:01:50,970 --> 00:01:58,200

It does not have any direct dependency on the domain object and the infrastructure service is consumed



25

00:01:58,200 --> 00:02:05,880

by the domain object and services to interact with external resources and infrastructure service follows



26

00:02:05,880 --> 00:02:08,000

the single responsibility principle.



27

00:02:08,040 --> 00:02:12,750

The idea is that the service provides functionality for one and only one thing.



28

00:02:12,780 --> 00:02:18,640

Their intent is to simplify the implementation and make it easy to understand the service.



29

00:02:18,660 --> 00:02:25,050

For example, we have these three services, each specializing in providing a specific functionality.



30

00:02:25,050 --> 00:02:29,100

For example, the email service is only for sending emails.



31

00:02:29,130 --> 00:02:37,140

Logging service is only for logging the messages and database service is for interacting with databases



32

00:02:37,620 --> 00:02:38,520

and infrastructure.



33

00:02:38,520 --> 00:02:44,730

Service defines a standard contract between the model and the external resources.



34

00:02:45,360 --> 00:02:52,140

Think of it like an API, which is meant for consumption by the model objects and services.



35

00:02:52,620 --> 00:03:02,400

The realization of the API is in the infrastructure layer and this makes the model technology and external



36

00:03:02,400 --> 00:03:03,990

services agnostic.



37

00:03:05,050 --> 00:03:12,520

The domain object and the need to interact with the external resources will go through the API or the



38

00:03:12,520 --> 00:03:16,700

standard contract exposed Body Infrastructure Service.



39

00:03:17,410 --> 00:03:24,910

So here, for example, a standard interface for an email service may look like this and there may be



40

00:03:24,910 --> 00:03:27,490

just a single function sent email.



41

00:03:27,550 --> 00:03:35,500

The infrastructure service will interact with the external resource by way of the SDK or APIs exposed



42

00:03:35,500 --> 00:03:37,300

by the external resource.



43

00:03:37,300 --> 00:03:43,840

The Infrastructure Service will carry out the translation of the call from the standard interface to



44

00:03:43,840 --> 00:03:47,110

the interface exposed by the external resource.



45

00:03:47,110 --> 00:03:52,090

And it'll also carry out any kind of transformation needed on the data.



46

00:03:52,870 --> 00:03:59,210

Now let's see how this mechanism makes the domain more independent of the external resource.



47

00:03:59,740 --> 00:04:03,370

Let's say we have to implement an email service.



48

00:04:04,030 --> 00:04:08,900

This e-mail service will provide a standard function for sending out emails.



49

00:04:08,920 --> 00:04:14,250

Initially, the e-mail service was implemented by using the Linux sendmail.



50

00:04:14,260 --> 00:04:20,680

But let's say over a period of time, the number of emails being sent out from the application increased



51

00:04:20,680 --> 00:04:26,410

and hence a more robust solution was needed and Sendmail was replaced by MailChimp.



52

00:04:26,920 --> 00:04:33,880

This change would require a change only in the email service, and there will be no impact on any of



53

00:04:33,880 --> 00:04:41,950

the domain services using the standard contract exposed body email service and hence the domain model



54

00:04:42,160 --> 00:04:45,550

is insulated from the external resource changes.



55

00:04:46,390 --> 00:04:49,990

In this lecture, you learned about the infrastructure services.



56

00:04:49,990 --> 00:04:56,530

Infrastructure services like application services do not implement any domain behavior.



57

00:04:56,530 --> 00:05:04,060

Infrastructure services expose external resources by way of standard interfaces or standard contracts,



58

00:05:04,060 --> 00:05:11,950

and this standard contract mechanism insulates the domain model from changes in external services.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\015 Hands On _ ACME Domain Service, UML & JAVA.en.srt -->

1

00:00:00,610 --> 00:00:07,840

Now we need to develop some services in the Achmea sales model in this lesson, you will learn about



2

00:00:07,990 --> 00:00:14,470

a flaw in the proposal creation sequence that I have discussed in some of the earlier lectures.



3

00:00:14,920 --> 00:00:17,680

Once we understand the flaw, we will fix the flaw.



4

00:00:17,980 --> 00:00:24,610

And by the end of this lecture, we would have developed a service called Proposal Pricing Service as



5

00:00:24,610 --> 00:00:25,300

an I.T. lead.



6

00:00:25,540 --> 00:00:32,230

You prepared the sequence diagram for the proposal creation and it is always a best practice to get



7

00:00:32,230 --> 00:00:38,230

the feedback on all of these business model assets from the business stakeholders.



8

00:00:38,260 --> 00:00:44,740

So you decided to walk through this sequence diagram with John John, like the work you have done.



9

00:00:45,280 --> 00:00:51,540

But he realized that we missed out the proposal pricing step in this sequence diagram.



10

00:00:51,700 --> 00:00:56,900

So obviously your next question was what is involved in the pricing of the proposal?



11

00:00:57,460 --> 00:01:05,020

John tells us that the package price quoted in the vacation package is our personal price.



12

00:01:05,620 --> 00:01:12,880

And this price quoted in the vacation package does not include the taxes and the surcharges.



13

00:01:13,030 --> 00:01:15,670

So at this point, you decide to do two things.



14

00:01:15,940 --> 00:01:24,610

You would add the surcharge and the per person price terms in the business vocabulary that is your ubiquitous



15

00:01:24,610 --> 00:01:27,670

language and some surcharge is a new term.



16

00:01:28,060 --> 00:01:30,070

You would like to understand it better.



17

00:01:30,310 --> 00:01:35,470

So you asked John to provide you the details of how the surcharges calculated.



18

00:01:35,620 --> 00:01:39,430

The surcharge is applied wherever applicable.



19

00:01:39,700 --> 00:01:46,480

It may be applicable to airport resorts, rental cars, state authorities and hotels.



20

00:01:46,840 --> 00:01:50,290

The surcharge amount varies based on the provider.



21

00:01:50,560 --> 00:01:57,850

State and season travel agents typically use spreadsheets to calculate the price of the proposals,



22

00:01:57,850 --> 00:02:02,160

and these spreadsheets get updated every quarter.



23

00:02:02,350 --> 00:02:11,260

So the final price for the proposal is calculated by multiplying the number of passengers with the purpose



24

00:02:11,260 --> 00:02:13,510

and price of the vacation package.



25

00:02:13,510 --> 00:02:18,190

All the surcharges get added and all the state taxes are added.



26

00:02:18,190 --> 00:02:21,280

And this will be the final price for the proposal.



27

00:02:21,550 --> 00:02:26,260

Now that you understand how the proposal pricing works, I have a question for you.



28

00:02:26,440 --> 00:02:29,690

In what model object would you based?



29

00:02:29,950 --> 00:02:31,810

The pricing functionality?



30

00:02:32,200 --> 00:02:40,390

Your choices are in the booking confirmation entity, in a domain service, in an application service



31

00:02:40,840 --> 00:02:43,480

or in an infrastructure service.



32

00:02:43,780 --> 00:02:46,090

Please post a video if you need some time.



33

00:02:46,720 --> 00:02:48,700

Let's discuss these options.



34

00:02:49,210 --> 00:02:52,150

The option A is not applicable.



35

00:02:52,150 --> 00:02:52,540

Why?



36

00:02:52,540 --> 00:02:57,880

Because the price calculation does not fit naturally in the booking.



37

00:02:57,880 --> 00:03:06,970

Confirmation entity CNBC are not applicable because application service and infrastructure service does



38

00:03:06,970 --> 00:03:08,800

not have any business logic.



39

00:03:08,800 --> 00:03:11,710

So the answer is in a domain service.



40

00:03:11,740 --> 00:03:17,830

All of the price calculation, which is the business logic, will be implemented in the domain service.



41

00:03:18,190 --> 00:03:23,440

Now, before we go any further, let's first fix our proposal sequence diagram.



42

00:03:23,560 --> 00:03:29,950

The sequence diagram is geared up to step number five, where we are creating the proposal.



43

00:03:29,950 --> 00:03:37,480

After step number five, we need to insert our interaction with the proposal pricing domain service.



44

00:03:37,570 --> 00:03:39,370

Let me add the step here.



45

00:03:39,880 --> 00:03:47,260

The sales agent will carry out the calculation for the proposal by invoking the pricing service.



46

00:03:47,620 --> 00:03:54,730

The pricing service will carry out the calculation and then update the final price on the proposal.



47

00:03:54,940 --> 00:04:01,630

At that point, this is agent will be able to read out the proposal along with the final price to the



48

00:04:01,630 --> 00:04:02,160

customer.



49

00:04:02,470 --> 00:04:06,730

So this is the change that we need to make to this sequence diagram.



50

00:04:07,180 --> 00:04:14,200

It is common for the business logic to be depicted in a flow diagram or a straight diagram or in an



51

00:04:14,200 --> 00:04:15,400

activity diagram.



52

00:04:15,880 --> 00:04:19,840

Let's go with the proposal pricing domain service activity diagram.



53

00:04:20,020 --> 00:04:26,260

The first thing that the service will do is check the proposals, completeness it look for any missing



54

00:04:26,260 --> 00:04:27,070

information.



55

00:04:27,250 --> 00:04:34,420

If there is missing information, then another will be returned to the column and the pricing process



56

00:04:34,570 --> 00:04:35,320

will complete.



57

00:04:35,590 --> 00:04:43,960

Otherwise, the best price for the proposal will be calculated by using the number of passenger and



58

00:04:43,960 --> 00:04:46,900

the purpose and price of the vacation package.



59

00:04:46,900 --> 00:04:51,970

If applicable, the total surcharge will be calculated and added.



60

00:04:52,240 --> 00:04:59,410

Similarly, the airline and airport surcharge will be calculated and added rental car surcharge if.



61

00:04:59,570 --> 00:05:05,910

Duplicable will be calculated and added same thing for the resort surcharge, and then the sales tax



62

00:05:05,910 --> 00:05:13,380

will be calculated based on the customer's state of residence, the final price will then be returned



63

00:05:13,380 --> 00:05:14,730

back to the caller.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07 Domain Driven Design - Tactical Patterns\016 Hands On _ Application and Infrastructure Services, UML & JAVA.en.srt -->

1

00:00:00,150 --> 00:00:07,050

In this lesson, we will continue to build some services for the Acme sales model will model to services



2

00:00:07,320 --> 00:00:10,530

the credit card service and the customer history service.



3

00:00:11,040 --> 00:00:13,190

I'll start this lecture with a quiz.



4

00:00:13,260 --> 00:00:21,180

Let's say you have to create two services, a service for credit card processing via an external vendor



5

00:00:21,510 --> 00:00:25,260

and another service for providing the customer history.



6

00:00:25,530 --> 00:00:32,130

Your choices are if you can implement these services in an application service, b, you can implement



7

00:00:32,130 --> 00:00:39,780

these services in an infrastructure service, the service with the service type options, and B, please



8

00:00:39,780 --> 00:00:41,710

post a video if you need more time.



9

00:00:41,940 --> 00:00:42,450

All right.



10

00:00:42,720 --> 00:00:50,460

The solution is that since we're talking about an external vendor provided service, it is an infrastructure



11

00:00:50,460 --> 00:00:50,990

service.



12

00:00:51,000 --> 00:00:54,900

So the first one will be created as an infrastructure.



13

00:00:54,930 --> 00:01:02,430

So the second one is for providing the customer history, which is basically a consolidation of multiple



14

00:01:02,430 --> 00:01:03,640

domain elements.



15

00:01:03,660 --> 00:01:06,300

It'll be implemented as an application service.



16

00:01:06,810 --> 00:01:10,800

Let's dive into the details of these two services for Achmat.



17

00:01:11,710 --> 00:01:18,550

The customer history service will consolidate the information for the customer based on the customer's



18

00:01:18,820 --> 00:01:26,230

reference number or by way of email or phone number, the response from the service will consist of



19

00:01:26,230 --> 00:01:34,840

the customer details, the most recent 10 proposals created for the customer and the most recent five



20

00:01:35,170 --> 00:01:36,470

booking confirmations.



21

00:01:36,730 --> 00:01:44,380

Clearly, the customer history service will need to get all of this information from different repository



22

00:01:44,410 --> 00:01:45,130

objects.



23

00:01:46,070 --> 00:01:52,470

The customer history application service will be created in the package calm, not accurate sales model



24

00:01:52,520 --> 00:01:53,430

or services.



25

00:01:53,480 --> 00:02:00,010

This class will expose functions that may be invoked by the callers to get the customer history.



26

00:02:00,290 --> 00:02:06,430

This object may also be wrapped with and appear to expose the same functions or SCDP.



27

00:02:06,650 --> 00:02:13,850

The response to the calls made to the customer history service will be an instance of the customer history



28

00:02:14,000 --> 00:02:21,860

object that holds a reference to the customer proposal instances and the booking confirmation instances.



29

00:02:22,010 --> 00:02:29,570

The Customer History Service will use the repositories to get the information for customer proposals



30

00:02:29,570 --> 00:02:31,280

and booking confirmations.



31

00:02:31,880 --> 00:02:40,100

The Customer History Service Object will expose functions for retrieving the customer data using the



32

00:02:40,100 --> 00:02:41,780

customer's reference number.



33

00:02:41,810 --> 00:02:48,890

It'll also expose functions for retrieving the customer data by using the customer's email address or



34

00:02:48,890 --> 00:02:49,560

phone number.



35

00:02:49,580 --> 00:02:54,390

So this is the model for the Customer History Application Service.



36

00:02:54,800 --> 00:02:59,720

Next, let's talk about the Payment Gateway Service, which is an infrastructure service.



37

00:03:00,020 --> 00:03:04,660

Acme uses third party credit card processing services.



38

00:03:04,670 --> 00:03:12,410

What that means is that when a customer provides their credit card number, the Acme team, the team



39

00:03:12,410 --> 00:03:18,450

makes a call to the third party vendor to process the payment by way of the credit card.



40

00:03:18,830 --> 00:03:24,410

What we have heard from the stakeholders is that a vendor is picked up based on the kind of deal they



41

00:03:24,410 --> 00:03:24,940

are giving.



42

00:03:25,190 --> 00:03:32,270

Obviously, the vendor who charges the least for these payment processing services will be picked up



43

00:03:32,270 --> 00:03:38,060

by Acme and the contract is renewed every year and sometimes even mid-year.



44

00:03:38,210 --> 00:03:43,850

And for this reason, Acme has switched payment vendors three times in the last two years.



45

00:03:43,850 --> 00:03:51,590

And what we have heard is that every time Acme switches to a new vendor, it's a big hassle to change



46

00:03:51,620 --> 00:03:57,470

all the system, to use the new Windows services to address this challenge.



47

00:03:57,470 --> 00:04:04,850

The Payment Gateway Service will be created as an infrastructure service that will define a standard



48

00:04:04,850 --> 00:04:07,640

contract for the client within Acme.



49

00:04:07,670 --> 00:04:13,670

So these are the three kind of interface functions which will be needed in a very simple payment Gateway



50

00:04:13,670 --> 00:04:19,640

Service charge the credit card, reform the credit card and get the details of a transaction.



51

00:04:19,640 --> 00:04:26,840

As long as clients are using these interfaces, it would not matter to them whether vendor A, vendor



52

00:04:26,840 --> 00:04:30,230

B or vendor C is in use.



53

00:04:30,230 --> 00:04:36,950

Any switching of the vendors will lead to a change in the payment gateway service and will have no impact



54

00:04:36,950 --> 00:04:40,130

on the consumers of the payment Gateway Service.



55

00:04:40,420 --> 00:04:42,320

Let's go ahead and model the service.



56

00:04:43,830 --> 00:04:49,330

The Payment Gateway Infrastructure Service will be created under the services package.



57

00:04:49,740 --> 00:04:54,400

The service will expose three functions that I have discussed earlier.



58

00:04:54,840 --> 00:05:00,900

The first function will be the process payment function, which is expected to charge the credit card



59

00:05:00,900 --> 00:05:02,030

for the payment amount.



60

00:05:02,040 --> 00:05:07,830

And there is another function with the name process refund, which will refund the payment back to the



61

00:05:07,830 --> 00:05:08,370

customer.



62

00:05:08,460 --> 00:05:15,180

This can happen due to cancellation or other reasons, but these functions generate a response, which



63

00:05:15,180 --> 00:05:18,420

is an object of type payment gateway transaction.



64

00:05:18,420 --> 00:05:25,830

And so the relationship between the payment gateway and this new object is that payment gateway create



65

00:05:25,860 --> 00:05:29,950

instances of payment gateway transaction objects.



66

00:05:29,970 --> 00:05:36,480

The third function in the Payment Gateway Service is the transaction details function, which creates



67

00:05:36,480 --> 00:05:42,390

a response of the type payment gateway transaction details the relationship between the Payment Gateway



68

00:05:42,390 --> 00:05:45,360

Service and the payment Gateway transaction details.



69

00:05:45,360 --> 00:05:51,190

Is that payment Gateway Service for instances of the payment gateway transaction details.



70

00:05:51,210 --> 00:05:55,920

So this is our model for the Payment Gateway Service at this time.



71

00:05:55,930 --> 00:06:01,650

If you're interested, you may walk through the court for the two services that I have discussed in



72

00:06:01,650 --> 00:06:02,290

this lesson.



73

00:06:02,880 --> 00:06:10,020

There is also a test implementation of the payment gateway interface that shows how the payment gateway



74

00:06:10,410 --> 00:06:12,030

interface may be realized.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000001.srt -->

1
00:00:00,120 --> 00:00:15,560
Các mẫu thiết kế kỹ thuật trong hai phần cuối, bạn học cách sử dụng các mẫu chiến lược để phân tách các miền phức tạp thành các miền nhỏ hơn và để xác định mối quan hệ giữa các miền nhỏ hơn này.

2
00:00:16,080 --> 00:00:25,560
Trọng tâm trong phần này là các mẫu chiến thuật có thể được sử dụng để lập mô hình và hiện thực hóa các dịch vụ vi mô.

3
00:00:26,340 --> 00:00:39,750
Thiết kế hướng mô hình cung cấp một khuôn khổ để hiện thực hóa mô hình hệ thống và sử dụng phương pháp thiết kế hướng miền, các mẫu chiến thuật là các khối xây dựng và thiết kế hướng mô hình.

4
00:00:40,710 --> 00:00:52,650
Các đối tượng và tập hợp giá trị thực thể được gọi là các đối tượng miền, các đối tượng miền này được sử dụng để mô hình hóa dữ liệu trong mô hình miền.

5
00:00:52,980 --> 00:01:02,710
Các nhà máy là để tạo ra miền phức tạp.  Các đối tượng và kho lưu trữ được sử dụng để quản lý tính bền vững của các đối tượng miền.

6
00:01:02,970 --> 00:01:17,420
Và sau đó là các dịch vụ, mẫu mã.  Các dịch vụ được sử dụng để mô hình hóa sự tương tác của các đối tượng miền với các đối tượng miền khác, với cơ sở hạ tầng và với các thành phần bên ngoài khác.

7
00:01:17,910 --> 00:01:26,400
Bạn sẽ tìm hiểu tất cả các mẫu chiến thuật này trong phần này.  Tôi cũng sẽ đề cập đến hai thuật ngữ mới mô hình thiếu máu và giàu có.

8
00:01:27,090 --> 00:01:37,980
Tôi sẽ chỉ cho bạn cách lập mô hình các mẫu này cho các dịch vụ vi mô của bạn nói chung và cách xây dựng các mẫu kỹ thuật này bằng cách sử dụng các lớp Java cũ đơn giản.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000002.srt -->

1
00:00:00,150 --> 00:00:13,890
Trong bài học này, bạn sẽ tìm hiểu về mẫu thực thể khi kết thúc bài giảng này, bạn sẽ có thể thảo luận về các đặc điểm của thực thể và mối quan hệ giữa logic nghiệp vụ và các đối tượng thực thể.

2
00:00:14,070 --> 00:00:23,020
Một thực thể đại diện cho một đối tượng kinh doanh có thể nhận dạng duy nhất, bao gồm các thuộc tính và hành vi miền được xác định rõ ràng.

3
00:00:23,340 --> 00:00:30,360
Ví dụ, trong trường hợp ngân hàng, có các thực thể như tài khoản, thẻ tín dụng và giao dịch.

4
00:00:30,360 --> 00:00:42,270
Trong trường hợp bán lẻ, có các thực thể như đơn hàng, sản phẩm và hóa đơn.  Lần tới tôi sẽ hướng dẫn bạn các đặc điểm của các thực thể giúp phân biệt chúng với các đối tượng kinh doanh khác.

5
00:00:42,570 --> 00:00:56,700
Một thực thể được xác định duy nhất trong một bối cảnh giới hạn.  Vì vậy, trong trường hợp ngân hàng, đối với bối cảnh giới hạn tài khoản bán lẻ, có thể có một tài khoản séc thực thể được xác định duy nhất bằng số tài khoản.

6
00:00:56,940 --> 00:01:06,180
Tương tự, đối với các liên hệ giới hạn khoản vay cá nhân, họ có thể là một thực thể tài khoản khoản vay được xác định duy nhất bằng số tài khoản khoản vay.

7
00:01:06,420 --> 00:01:16,200
Và trong trường hợp thẻ tín dụng, bối cảnh bị giới hạn, chúng có thể là một thực thể thẻ tín dụng được xác định duy nhất bằng số thẻ tín dụng.

8
00:01:16,500 --> 00:01:31,620
Các thực thể này và danh tính của chúng chỉ có ý nghĩa trong bối cảnh giới hạn tương ứng của chúng.  Một thực thể có một tập hợp các thuộc tính được xác định bởi ngôn ngữ phổ biến cho ngữ cảnh bị chặn.

9
00:01:31,930 --> 00:01:41,130
Ví dụ: thực thể tài khoản séc có thể có các thuộc tính như số tài khoản, số dư khách hàng và giao dịch.

10
00:01:41,550 --> 00:01:50,430
Một thực thể có một hành vi, nghĩa là nó đóng gói logic nghiệp vụ.  Và logic kinh doanh này được thể hiện qua cách thức hoạt động.

11
00:01:50,880 --> 00:02:09,180
Khi các hoạt động này được thực hiện đối với thực thể, nó sẽ dẫn đến sự thay đổi trạng thái của thực thể.  Ví dụ: trong trường hợp tài khoản séc, có nhiều thuộc tính và có nhiều thao tác, chẳng hạn như chuyển tiền ký quỹ.

12
00:02:09,540 --> 00:02:22,720
Khi một số thao tác này được thực thi, chúng sẽ thay đổi trạng thái của tài khoản.  Ví dụ: số dư có thể tăng hoặc giảm do thực hiện một số thao tác này.

13
00:02:23,100 --> 00:02:29,160
Hãy xác định logic kinh doanh là gì, không phải kinh doanh.  Logic đôi khi được gọi là logic miền.

14
00:02:29,160 --> 00:02:38,680
Logic nghiệp vụ có thể bao gồm các quy tắc nghiệp vụ.  Ví dụ: việc rút tiền sẽ không thành công nếu số dư nhỏ hơn số tiền rút.

15
00:02:38,850 --> 00:02:55,860
Nó có thể là sự xác nhận.  Ví dụ: số tiền rút không được nhỏ hơn hoặc bằng 0.  Nó có thể là các phép tính, ví dụ, tính chéo thành phần cho tài khoản séc và nó có thể là các hoạt động có thể thay đổi trạng thái của thực thể.

16
00:02:55,860 --> 00:03:05,880
Ví dụ: logic giao dịch rút tiền có thể được kết hợp để thực hiện tất cả những điều này được gọi là logic nghiệp vụ nói chung.

17
00:03:06,330 --> 00:03:15,600
Hãy xem một ví dụ về logic nghiệp vụ hoặc hành vi.  Trong trường hợp tài khoản séc, có thể có hoạt động rút tiền từ tài khoản.

18
00:03:15,900 --> 00:03:28,320
Hoạt động rút tiền này có thể lấy số tiền rút làm đối số.  Việc kiểm tra đầu tiên sẽ được thực hiện khi thực hiện thao tác rút tiền là kiểm tra số dư khả dụng.

19
00:03:28,320 --> 00:03:39,840
Nếu số dư khả dụng nhỏ hơn số tiền rút thì giao dịch sẽ bị từ chối.  Nếu không, giao dịch sẽ được chấp nhận và số dư sẽ bị giảm đi theo số tiền rút.

20
00:03:40,140 --> 00:03:49,020
Đã đến lúc làm một bài kiểm tra nhanh.  Hãy nhìn vào thực thể tài khoản kiểm tra này.  Bạn có nghĩ rằng thực thể này bộc lộ một số logic kinh doanh không?

21
00:03:50,700 --> 00:03:58,350
Câu trả lời là không, không phải vậy, và lý do tôi nói vậy là vì những thao tác này chỉ là getters và setters.

22
00:03:58,350 --> 00:04:08,820
Tương tự, thao tác này là sở hữu đối tượng vào cơ sở dữ liệu.  Vì vậy, nhìn từ bề ngoài, có vẻ như thực thể này không bao gồm bất kỳ hoạt động kinh doanh nào.

23
00:04:08,820 --> 00:04:21,180
Các thực thể logic chỉ có ý nghĩa trong bối cảnh ranh giới mà chúng được xác định.  Người ta thường thấy các tên thực thể giống nhau xuất hiện trên nhiều ngữ cảnh được liên kết.

24
00:04:21,630 --> 00:04:29,200
Nhưng bạn phải nhớ rằng định nghĩa của thực thể trong bối cảnh bị ràng buộc này không được đảm bảo giữ nguyên.

25
00:04:29,310 --> 00:04:39,300
Ví dụ: thực thể khách hàng trong tài khoản bán lẻ có thể trông không giống với thực thể khách hàng trong bối cảnh giới hạn thẻ tín dụng.

26
00:04:39,660 --> 00:04:53,780
Hãy nhớ rằng các thực thể được xác định duy nhất trong một ngữ cảnh bị giới hạn, nhưng đôi khi có thể xảy ra trường hợp cùng một thuộc tính được sử dụng để xác định duy nhất thực thể trong các liên hệ công việc.

27
00:04:53,790 --> 00:05:05,620
Nhưng đó hoàn toàn là sự trùng hợp ngẫu nhiên.  Vì vậy, trong ví dụ này, số An sinh xã hội của khách hàng đang được sử dụng để nhận dạng duy nhất khách hàng trong cả hai địa chỉ liên hệ công việc này.

28
00:05:06,180 --> 00:05:26,420
Hãy nhớ rằng, đó thực sự là sự trùng hợp ngẫu nhiên.  Việc xác định các thực thể này của nhóm sẽ hoạt động độc lập với nhau và xác định các thuộc tính cũng như hoạt động cho các thực thể dựa trên yêu cầu trong từng bối cảnh nghiệp vụ, các thực thể được lưu trữ lâu dài.

29
00:05:26,700 --> 00:05:40,000
Dữ liệu được lưu trữ dài hạn thể hiện trạng thái hiện tại của thực thể.  Điều này phổ biến đối với RDBMS và không có cơ sở dữ liệu đơn lẻ nào được sử dụng để lưu trữ liên tục các thực thể.

30
00:05:40,620 --> 00:05:56,450
Trong trường hợp RDBMS, một bảng biểu thị một tập hợp các thực thể.  Các quy tắc trong bảng biểu thị các thực thể được xác định duy nhất bằng cột khóa chính.

31
00:05:56,700 --> 00:06:06,740
Các cột còn lại có các giá trị cho thuộc tính của từng thực thể.  Đã đến lúc xem lại nhanh những điểm chính của bài giảng này.

32
00:06:06,840 --> 00:06:14,640
Điều đầu tiên là các thực thể là các đối tượng kinh doanh chỉ có ý nghĩa trong một bối cảnh giới hạn.

33
00:06:14,640 --> 00:06:26,760
Nơi chúng được xác định là các thực thể được xác định duy nhất trong bối cảnh bị giới hạn.  Tiếp theo là định nghĩa của thực thể bao gồm thuộc tính và hành vi.

34
00:06:27,060 --> 00:06:35,700
Hành vi này triển khai logic nghiệp vụ có thể thay đổi trạng thái của thực thể.  Các thực thể được lưu trữ lâu dài.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000003.srt -->

1
00:00:00,150 --> 00:00:15,080
Trong bài học này, bạn tìm hiểu về các đối tượng giá trị, đặc điểm của chúng và vòng đời của đối tượng giá trị. Đối tượng giá trị, không giống như thực thể, các đối tượng không có nhận dạng khái niệm trong ngữ cảnh bị ràng buộc.

2
00:00:15,300 --> 00:00:23,900
Nói cách khác, giá trị, thuộc tính đối tượng và hành vi không ánh xạ trực tiếp tới các khái niệm cốt lõi trong bối cảnh bị chặn.

3
00:00:24,450 --> 00:00:38,770
Tôi sẽ bắt đầu bài học này bằng một bài kiểm tra.  Hãy xem xét khách hàng và đối tượng.  Có một địa chỉ email do khách hàng cung cấp và câu hỏi đặt ra là bạn sẽ đặt logic xác thực cho địa chỉ email ở đâu?

4
00:00:39,510 --> 00:00:47,750
Hãy nghĩ đến các tùy chọn, ghi nhớ định nghĩa của đối tượng giá trị.  Vì vậy, đây là lựa chọn số một.

5
00:00:47,760 --> 00:01:00,950
Bạn có thể đặt logic xác thực cho địa chỉ email trong chính thực thể khách hàng.  Vấn đề với cách tiếp cận này là việc xác thực này là xác nhận kỹ thuật không liên quan đến bất kỳ khái niệm kinh doanh nào.

6
00:01:00,960 --> 00:01:16,680
Và do đó, tùy chọn số hai là tạo một đối tượng giá trị để xác thực địa chỉ email.  Khi có tùy chọn này, chúng ta sẽ tạo một đối tượng khác gọi là đối tượng giá trị địa chỉ email, đối tượng này sẽ gói gọn logic xác thực cho địa chỉ email.

7
00:01:16,680 --> 00:01:28,830
Và nó sẽ không có bất kỳ logic kinh doanh nào từ góc độ bối cảnh của quả bom nhỏ.  Kết quả là, thực thể khách hàng sẽ sạch hơn và đơn giản hơn nhiều trong việc thực hiện.

8
00:01:29,250 --> 00:01:41,850
Đây là một ví dụ đơn giản về đối tượng giá trị.  Một ví dụ khác là mở tài khoản ngân hàng và khách hàng phải xuất trình một số loại tài liệu do chính phủ cấp để làm bằng chứng nhận dạng.

9
00:01:42,150 --> 00:01:56,460
Đây là một số bằng chứng nhận dạng thường được sử dụng, việc triển khai đối tượng khách hàng, có thể nó chỉ cần lưu trữ chuỗi biểu diễn danh tính do khách hàng trình bày.

10
00:01:56,490 --> 00:02:12,120
Ví dụ: có thể có một cột trong bảng khách hàng chỉ có một chuỗi biểu thị danh tính với định dạng có loại danh tính và một số duy nhất xác định cá nhân.

11
00:02:12,240 --> 00:02:19,470
Trong trường hợp hộ chiếu Mỹ thì có thể là số hộ chiếu, trường hợp bằng lái xe thì có thể là số bằng lái xe.

12
00:02:20,340 --> 00:02:32,520
Điều này có thể đạt được bằng cách tạo ra một đối tượng giá trị.  Đối tượng giá trị này có thể được thực thể khách hàng sử dụng để tạo biểu diễn chuỗi cho danh tính chính phủ.

13
00:02:32,850 --> 00:02:52,650
Đối tượng giảm giá trị cũng có thể gói gọn logic xác thực cho các loại nhận dạng khác nhau.  Ví dụ: nó có thể xác thực hộ chiếu bằng cách sử dụng các quy tắc rằng hộ chiếu không hết hạn và hộ chiếu mà khách hàng giữ được cấp bởi một quốc gia trong danh sách các quốc gia được phép.

14
00:02:53,240 --> 00:03:02,700
Đối tượng giá trị này cũng có thể hiển thị một hàm để tạo biểu diễn chuỗi về danh tính do chính phủ cấp.

15
00:03:03,060 --> 00:03:10,770
Biểu diễn chuỗi được gán cho thuộc tính nhận dạng chính phủ trong thực thể khách hàng.

16
00:03:10,950 --> 00:03:19,460
Một điều quan trọng cần ghi nhớ ở đây là đối tượng giá trị này không được duy trì như một phần của thực thể khách hàng.

17
00:03:19,680 --> 00:03:29,840
Nói cách khác, đối tượng giá trị nhận dạng chung này được tạo trong bộ nhớ tiến trình và sau đó bị hủy sau khi nó đã phục vụ mục đích của nó.

18
00:03:31,240 --> 00:03:41,560
Chà, các đối tượng cũng có thể được coi là đối tượng tiện ích và các đối tượng tiện ích này là đối tượng giá trị không có danh tính duy nhất.

19
00:03:41,890 --> 00:04:00,970
Kiểm tra sự bằng nhau của hai đối tượng giá trị được thực hiện bằng cách so sánh các thuộc tính.  Vì vậy, trong ví dụ này, chúng ta không thể coi số nhận dạng là danh tính duy nhất cho đối tượng giá trị để so sánh với các đối tượng giá trị thuộc loại danh tính chính phủ.

20
00:04:01,510 --> 00:04:08,830
Chúng tôi sẽ phải kiểm tra loại nhận dạng và nếu loại đơn giản, chúng tôi sẽ so sánh các số nhận dạng.

21
00:04:08,840 --> 00:04:18,340
Vì vậy, như bạn có thể thấy, bạn sẽ phải thực hiện so sánh cấp độ thuộc tính để đưa ra quyết định xem có nên coi trọng các đối tượng bằng nhau hay không.

22
00:04:18,670 --> 00:04:27,910
Một điểm khác biệt quan trọng giữa các thực thể và đối tượng giá trị là đối tượng giá trị không tồn tại lâu dài trong cơ sở dữ liệu.

23
00:04:28,060 --> 00:04:40,350
Là một đối tượng độc lập, đối tượng giá trị đã tồn tại trong cơ sở dữ liệu như một phần của đối tượng thực thể hoặc chúng hoàn toàn không được lưu trữ lâu dài.

24
00:04:40,570 --> 00:04:50,800
Trong trường hợp ví dụ về danh tính chính phủ, chúng tôi sẽ không lưu trữ danh tính chính phủ.  Vâng, bạn phản đối việc lưu trữ lâu dài.

25
00:04:50,950 --> 00:05:29,340
Hãy thảo luận về ví dụ về đối tượng giá trị có tuổi thọ rất ngắn trong trường hợp thực thể khách hàng của chúng ta cần đặt thuộc tính nhận dạng chính phủ, một thể hiện của đối tượng giá trị đã tạo thông tin nhận dạng được đặt trên trình xác thực đối tượng giá trị nhận dạng chính phủ  gọi để xác thực tất cả thông tin và sau đó tạo chuỗi được thực thi để tạo chuỗi biểu diễn danh tính chính phủ, sau đó được đặt trên thực thể khách hàng.

26
00:05:29,530 --> 00:05:45,390
Tại thời điểm này, thực thể khách hàng được cung cấp cho cơ sở dữ liệu và trong trường hợp cơ sở dữ liệu quan hệ, thực thể này có thể được thêm vào dưới dạng quy tắc trong bảng với tất cả thông tin cần thiết cho khách hàng.

27
00:05:45,670 --> 00:05:54,100
Và như bạn thấy ở đây, đối tượng nhận dạng Gaudron không còn tồn tại như một phần của thực thể khách hàng.

28
00:05:54,790 --> 00:06:06,280
Các đối tượng giá trị được coi là đối tượng bất biến.  Tất cả các thuộc tính kết hợp với nhau sẽ mang lại ý nghĩa cho một thể hiện của đối tượng giá trị.

29
00:06:06,640 --> 00:06:17,510
Cách tốt nhất là bạn nên tạo một phiên bản mới của đối tượng giá trị thay vì sử dụng lại các phiên bản hiện có.

30
00:06:18,550 --> 00:06:29,920
Tiếp theo, hãy nói về đối tượng giá trị và đối tượng giá trị ngữ cảnh bị chặn trong một ngữ cảnh bị chặn, có thể là một thực thể trong một ngữ cảnh bị chặn khác.

31
00:06:30,340 --> 00:06:38,560
Tôi sẽ cho bạn một ví dụ.  Hãy suy nghĩ về tài khoản bán lẻ.  Tên miền phụ trong tài khoản ngân hàng.  Trong tài khoản bán lẻ.

32
00:06:38,570 --> 00:06:46,930
Tên miền phụ là một thực thể có danh tính duy nhất và tồn tại trong một số loại lưu trữ lâu dài.

33
00:06:47,170 --> 00:07:00,660
Bây giờ hãy nghĩ về tên miền phụ tuân thủ và báo cáo, tên miền phụ tuân thủ và báo cáo.  Sử dụng thông tin từ các tài khoản trong tên miền phụ tài khoản bán lẻ để tạo báo cáo.

34
00:07:00,700 --> 00:07:08,620
Các báo cáo này có thông tin tổng hợp về tất cả các tài khoản được giữ trong tài khoản bán lẻ.

35
00:07:08,740 --> 00:07:20,590
Tên miền phụ và tài khoản cá nhân không thành vấn đề.  Vì vậy, trong trường hợp tuân thủ và báo cáo, đối tượng tài khoản được coi là đối tượng giá trị.

36
00:07:21,910 --> 00:07:33,100
Đã đến lúc xem xét nhanh.  Trong bài học này bạn đã học về các đối tượng giá trị.  Các đối tượng giá trị không có nhận dạng khái niệm trong bối cảnh bị giới hạn.

37
00:07:33,280 --> 00:07:55,180
Các đối tượng giá trị không được tồn tại trong cơ sở dữ liệu như một đối tượng độc lập.  Nó được lưu trữ như một phần của đối tượng thực thể hoặc thậm chí nó không được lưu trữ trong cơ sở dữ liệu, một thực thể trong một ngữ cảnh bị chặn, có thể là một đối tượng giá trị trong một ngữ cảnh bị chặn khác và ngược lại.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000004.srt -->

1
00:00:00,150 --> 00:00:19,900
Mục tiêu của bài tập này là xác định các thực thể và đối tượng giá trị trong mô hình bán hàng Achmea.  Trong một trong những bài tập trước, chúng tôi phân tích bản ghi của cuộc phỏng vấn với John, một cố vấn du lịch và đã xác định các thuật ngữ kinh doanh này.

2
00:00:20,100 --> 00:00:35,700
Một số thuật ngữ này sẽ được dịch sang các thực thể và đối tượng giá trị.  Bây giờ, nếu bạn đã quên bài tập đó, tôi khuyên bạn nên xem lại bài giảng đó hoặc bạn có thể tạm dừng video và đọc qua bản ghi cuộc phỏng vấn này.

3
00:00:36,120 --> 00:00:43,800
Và khi bạn đã sẵn sàng, hãy chuyển sang bài tập tiếp theo.  Trong bài tập này, bạn sẽ tập trung vào các thuật ngữ này.

4
00:00:44,160 --> 00:00:54,810
Bạn sẽ xác định các thực thể và đối tượng giá trị trong bối cảnh bán hàng.  Xin lưu ý rằng trọng tâm là bối cảnh bán hàng.

5
00:00:55,230 --> 00:01:03,180
Và lý do chúng ta cần tập trung vào điều này là vì các thực thể và đối tượng giá trị có ý nghĩa trong một bối cảnh giới hạn.

6
00:01:03,570 --> 00:01:10,110
Một điều khác mà bạn cần lưu ý là các đối tượng giá trị có thể không có nhận dạng khái niệm.

7
00:01:10,290 --> 00:01:21,090
Trong ngữ cảnh bị chặn, bạn có thể thêm các đối tượng giá trị mới để hỗ trợ các thực thể của mình khi cần.  Hãy bắt đầu với khách hàng.

8
00:01:21,420 --> 00:01:47,020
Khách hàng là cá nhân bắt đầu quá trình bán hàng, khách hàng được xác định duy nhất bằng email hoặc số điện thoại và cần có thông tin hạn chế về khách hàng trong bối cảnh bán hàng đến khía cạnh quan trọng về khách hàng trong bối cảnh bán hàng là khách hàng có đặc điểm riêng biệt.  danh tính và khách hàng được hỗ trợ trong việc lưu trữ.

9
00:01:47,460 --> 00:01:55,260
Vì vậy, bây giờ câu hỏi là dành cho bạn.  Bạn sẽ đánh dấu khách hàng là đối tượng giá trị hay bạn sẽ đánh dấu khách hàng là một thực thể?

10
00:01:55,950 --> 00:02:10,070
Nếu bạn nói thực thể, bạn đã đúng, bởi vì khách hàng có danh tính khái niệm trong bối cảnh bán hàng và nó cần được duy trì với danh tính duy nhất trong kho lưu trữ lâu dài.

11
00:02:10,080 --> 00:02:25,830
Vì vậy, một khách hàng là một thực thể.  Câu hỏi tiếp theo là, khách hàng cần có địa chỉ vật lý được xác thực và địa chỉ này không phải là khái niệm cốt lõi trong bối cảnh miền bán hàng.

12
00:02:26,550 --> 00:02:39,220
Thông thường, việc xác thực hoặc xác minh địa chỉ vật lý được thực hiện bởi các bên thứ ba, chẳng hạn như thực hiện lệnh gọi tới API USPSTF để kiểm tra xem địa chỉ đó có hợp lệ hay không.

13
00:02:39,480 --> 00:02:53,020
Bây giờ, đây là yêu cầu kỹ thuật, không thực sự là yêu cầu kinh doanh.  Vậy bạn sẽ đánh dấu thực thể địa chỉ như thế nào hoặc bạn sẽ phản đối nếu bạn nói, à, bạn phản đối quyền của mình?

14
00:02:53,790 --> 00:03:05,210
Câu hỏi tiếp theo tôi dành cho bạn là, đối tượng giá trị này có cần phải bền bỉ không?  Câu trả lời là có với tư cách là một phần của thực thể khách hàng, không phải là một đối tượng độc lập trong cơ sở dữ liệu.

15
00:03:05,220 --> 00:03:15,380
Và tại sao?  Vì nó không có danh tính duy nhất như địa chỉ thực nên địa chỉ email và số điện thoại của khách hàng cần phải được xác thực và lưu trữ.

16
00:03:15,750 --> 00:03:24,420
Việc xác thực này thường được thực hiện thông qua các đối tượng tiện ích và do đó chúng ta có thể tạo một đối tượng giá trị email, trình xác thực điện thoại.

17
00:03:24,480 --> 00:03:31,050
Mục đích của việc này chỉ là để đảm bảo rằng địa chỉ email và số điện thoại do khách hàng cung cấp là chính xác.

18
00:03:31,080 --> 00:03:42,870
Câu hỏi dành cho bạn là, đối tượng giá trị này có cần được duy trì không?  Câu trả lời là không, vì nó chỉ là một đối tượng tiện ích dùng để xác thực địa chỉ email và số điện thoại.

19
00:03:43,050 --> 00:04:02,430
Hãy kiểm tra xem chúng ta đã tiến được bao xa với mô hình của mình?  Chúng tôi có thực thể khách hàng có mối quan hệ 1-1 với đối tượng giá trị địa chỉ và thực thể khách hàng đang sử dụng trình xác thực điện thoại email để xác thực địa chỉ email và số điện thoại.

20
00:04:03,480 --> 00:04:12,920
Tiếp theo, hãy nói về gói kỳ nghỉ, là sản phẩm bán từng gói kỳ nghỉ, được xác định duy nhất bằng một tên.

21
00:04:13,320 --> 00:04:29,030
Ví dụ: gói ba đêm dành cho Las Vegas có tên là LV, ba đêm.  Có nhiều loại gói khác nhau mà Acme bán, ví dụ: gói dành cho khu nghỉ dưỡng, gói dành cho du lịch.

22
00:04:29,040 --> 00:04:42,900
Và sau đó còn có các loại khác.  Ngoài ra, gói kỳ nghỉ còn có các thuộc tính khác, như số đêm và có giá bán lẻ liên quan đến gói kỳ nghỉ.

23
00:04:43,500 --> 00:05:06,350
Vậy bạn nghĩ gói kỳ nghỉ nên được đánh dấu là một thực thể hay một đối tượng giá trị?  Gói kỳ nghỉ sẽ là một thực thể vì nó có nhận dạng khái niệm trong miền bán hàng và đó là đề xuất có thể nhận dạng duy nhất được tạo cho khách hàng, cho một gói cụ thể.

24
00:05:06,380 --> 00:05:15,980
Nó có tất cả thông tin cần thiết để định giá.  Đề xuất gói kỳ nghỉ có giá trị trong 14 ngày.

25
00:05:16,150 --> 00:05:24,350
Vì vậy, điều đó cho thấy rằng nó cần phải được lưu trữ liên tục, nhiều đề xuất có thể được tạo cho khách hàng.

26
00:05:24,590 --> 00:05:34,210
Và mỗi đề xuất này có một bản sắc riêng.  Vậy ý kiến ​​của bạn là gì?  Nó sẽ là một thực thể hay nó sẽ là một đối tượng giá trị?

27
00:05:34,820 --> 00:05:52,070
Tôi cho rằng nó sẽ là một thực thể.  Tại sao?  Bởi vì mỗi đề xuất có một danh tính duy nhất và các đề xuất được lưu vào bộ lưu trữ liên tục dưới dạng các đối tượng độc lập và ưu đãi là mức giảm giá áp dụng cho các đề xuất.

28
00:05:52,070 --> 00:06:04,370
Các ưu đãi được quản lý bởi nhóm sản phẩm Acme và những ưu đãi này được xác định duy nhất bằng một loại nhận dạng nào đó do sản phẩm chỉ định.

29
00:06:04,370 --> 00:06:20,450
Các ưu đãi trong miền bán hàng chỉ được áp dụng trong bối cảnh đề xuất và có một quy tắc kinh doanh được xác định trong bối cảnh bán hàng mà tối đa hai ưu đãi có thể được áp dụng cho một đề xuất.

30
00:06:20,480 --> 00:06:30,110
Vậy bạn nghĩ gì trong bối cảnh bán hàng?  Ưu đãi sẽ là một thực thể hay bạn sẽ tiếp thị như một đối tượng có giá trị?

31
00:06:30,260 --> 00:06:42,620
Bây giờ đây là một chút khó khăn.  Nếu bạn nghĩ về nó.  Danh tính duy nhất do nhóm sản phẩm chỉ định và các ưu đãi thực sự được nhóm sản phẩm duy trì và quản lý.

32
00:06:43,100 --> 00:07:00,150
Vì vậy, theo ý kiến ​​​​của tôi, nó nên được coi là một đối tượng có giá trị vì trong bối cảnh bán hàng, một ưu đãi chỉ được áp dụng cho đề xuất và không có danh tính độc lập, duy nhất được quản lý trong bối cảnh bán hàng.

33
00:07:00,170 --> 00:07:15,490
Vì vậy, lời đề nghị của tôi là một đối tượng có giá trị.  Pax đề cập đến chiếc xẻng dùng trong gói kỳ nghỉ.  Là một ví dụ, giả sử Jane gọi cho bộ phận bán hàng ACMS để mua gói kỳ nghỉ.

34
00:07:15,500 --> 00:07:23,930
Vậy Jane là khách hàng.  Cô ấy đã mua gói kỳ nghỉ này cho gia đình gồm có Jane, Jack và Peter.

35
00:07:24,080 --> 00:07:34,800
Vì vậy, ba người này sẽ được gọi là gói hoặc gói hành khách không cần phải được xác định duy nhất trong bối cảnh đề xuất.

36
00:07:35,480 --> 00:07:42,110
Vì vậy, hãy nhớ rằng khách hàng cần được nhận dạng duy nhất nhưng PAX không cần được nhận dạng duy nhất.

37
00:07:42,500 --> 00:07:51,290
Các gói là một phần quan trọng của đề xuất từ ​​góc độ định giá.  Vậy bạn nghĩ cái gì sẽ là một thực thể hay một đối tượng giá trị?

38
00:07:51,320 --> 00:08:01,730
Tôi nghĩ rằng các gói sẽ là một đối tượng có giá trị và lý do là nó không có danh tính độc lập trong bối cảnh bán hàng.

39
00:08:02,280 --> 00:08:10,550
Chúng ta hãy xem lại đề xuất từ ​​góc độ bức tranh lớn.  Chúng tôi có thực thể đề xuất đề cập đến thực thể gói kỳ nghỉ.

40
00:08:11,030 --> 00:08:22,240
Thực thể đề xuất có một hoặc nhiều đối tượng giá trị Backes và dường như cung cấp giá trị.  Các đối tượng có thể được áp dụng cho đề xuất.

41
00:08:22,550 --> 00:08:39,050
Hãy kết hợp mô hình đề xuất với mô hình khách hàng.  Thực thể đề xuất đề cập đến thực thể khách hàng và đây là mô hình tổng thể mà chúng tôi đã đưa ra, với khái niệm được xác định trong bối cảnh bán hàng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000005.srt -->

1
00:00:00,180 --> 00:00:15,130
Trong bài học này, chúng ta sẽ mô hình hóa các thực thể và đối tượng giá trị được thảo luận trong bài giảng trước, sẽ đề cập đến gói kỳ nghỉ của khách hàng và các thực thể đề xuất, đồng thời cũng sẽ đề cập đến các đối tượng giá trị này.

2
00:00:15,360 --> 00:00:28,620
Bạn cũng sẽ tìm hiểu về mối quan hệ giữa các thực thể và đối tượng giá trị khác nhau này.  Mục tiêu của tôi ở đây là chỉ cho bạn cách bạn có thể lập mô hình các đối tượng cốt lõi trong miền bán hàng.

3
00:00:28,920 --> 00:00:41,580
Các đối tượng mà chúng ta sẽ làm mẫu trong bài học này đã được thảo luận trong các bài giảng trước.  Tất cả mã cho mô hình đều có sẵn trong kho dự án thuộc Good Branch Technique.

4
00:00:41,610 --> 00:00:47,250
Bạn cũng sẽ tìm thấy mã Java cho các đối tượng cốt lõi này.  Tôi sẽ không hướng dẫn bạn qua mã đó.

5
00:00:47,490 --> 00:00:57,780
Nếu bạn quan tâm đến.  Bạn có thể tự mình xem qua mã.  Nó rất đơn giản và ánh xạ trực tiếp đến mô hình đối tượng cốt lõi mà bạn sẽ học trong bài giảng này.

6
00:00:57,810 --> 00:01:08,480
Một điểm quan trọng khác mà tôi muốn nhấn mạnh trước khi tiếp tục bài học này là tôi đã giữ các mô hình này rất đơn giản để dễ theo dõi.

7
00:01:08,580 --> 00:01:22,640
Hãy coi mô hình mà chúng ta sẽ phát triển trong bài học này là phiên bản phác thảo đầu tiên của việc quyết định đặt tất cả các lớp cốt lõi vào gói, Kondor Achmad hoặc mô hình bán hàng.

8
00:01:23,190 --> 00:01:33,330
Lớp đầu tiên trong gói này là lớp khách hàng.  Lớp tiếp theo là lớp địa chỉ và sau đó là lớp trình xác thực điện thoại email.

9
00:01:33,630 --> 00:01:48,080
Mối quan hệ giữa các lớp này là khách hàng có một địa chỉ và lớp khách hàng sử dụng trình xác thực điện thoại email để xác thực địa chỉ email và số điện thoại của khách hàng.

10
00:01:48,240 --> 00:01:59,760
Một khách hàng có một danh tính duy nhất và danh tính duy nhất này được thể hiện cho khách hàng bằng một thuộc tính được đặt tên tham chiếu.

11
00:01:59,790 --> 00:02:10,950
Bây giờ chúng ta hãy đặt thêm một vài thuộc tính nữa.  Vì khách hàng có một danh tính duy nhất và nó vẫn tồn tại nên đó là một thực thể nên hãy đánh dấu khách hàng là một thực thể.

12
00:02:10,950 --> 00:02:24,060
Và đừng quên rằng khách hàng có địa chỉ của chúng ta.  Vì vậy, một thuộc tính cho địa chỉ.  Địa chỉ là một đối tượng giá trị và trình xác thực số điện thoại email cũng là một đối tượng giá trị.

13
00:02:24,060 --> 00:02:32,460
Vì địa chỉ là một đối tượng giá trị nên nó sẽ không có bất kỳ danh tính duy nhất nào.  Chỉ có các thuộc tính điển hình cho lớp địa chỉ.

14
00:02:32,460 --> 00:02:42,600
Phiên bản của địa chỉ sẽ được duy trì như một phần của đối tượng khách hàng.  Lớp vallenato qua điện thoại email sẽ chỉ được sử dụng để xác thực.

15
00:02:42,630 --> 00:02:51,240
Nó sẽ không tồn tại lâu dài và sẽ hiển thị các chức năng cần thiết để xác thực email và số điện thoại.

16
00:02:51,270 --> 00:03:01,950
Đây là mô hình khách hàng của chúng tôi trong bối cảnh bán hàng của Acme.  Trong bài giảng cuối cùng thảo luận về gói kỳ nghỉ, tôi đã nói về loại gói.

17
00:03:01,960 --> 00:03:17,610
Giờ đây, mỗi loại gói này đều yêu cầu Achmad thực hiện một số yêu cầu đặt trước với nhà cung cấp.  Ví dụ: đối với một số gói, Acme sẽ cần thực hiện việc đặt phòng khách sạn cũng như vé máy bay.

18
00:03:17,660 --> 00:03:26,580
Sau đó, có thể có các gói khác mà Acme sẽ cần phải tiến hành đặt chỗ, chẳng hạn như tàu du lịch, vé máy bay và ô tô cho thuê.

19
00:03:26,670 --> 00:03:34,930
Vì vậy, có nhiều sự kết hợp khác nhau được xác định trong gói để thể hiện từng phần của gói.

20
00:03:34,950 --> 00:03:43,080
Tôi đã quyết định tạo một hệ thống phân cấp lớp được gọi là đặt chỗ.  Tiếp theo, tôi sẽ hướng dẫn bạn đến mô hình để đặt chỗ.

21
00:03:44,290 --> 00:03:57,130
Tôi quyết định đặt hệ thống phân cấp lớp đặt trước trong mô hình bán hàng trọn gói com dot dot, dot booking, lớp đầu tiên mà tôi sẽ định nghĩa ở đây là lớp đặt trước trừu tượng.

22
00:03:57,190 --> 00:04:05,650
Lớp này sẽ hiển thị một số chức năng nhất định như hủy và giải quyết, sẽ được các lớp cụ thể thực hiện.

23
00:04:05,650 --> 00:04:21,580
Vì vậy, mối quan hệ giữa đặt vé máy bay, đặt phòng khách sạn và đặt thuê xe là tất cả chúng đều kế thừa từ lớp đặt chỗ trừu tượng và cung cấp việc triển khai cụ thể cho các chức năng hội đồng và giải quyết.

24
00:04:21,580 --> 00:04:29,940
Vì các đối tượng đặt trước sẽ không có nhận dạng khái niệm duy nhất nên chúng sẽ là các đối tượng giá trị.

25
00:04:29,950 --> 00:04:41,370
Chúng sẽ được lưu hoặc duy trì như một phần của quá trình đặt chỗ.  Từ góc độ nhận dạng, khi chúng được đặt trước thành công, một tham chiếu đặt trước sẽ được gán cho đối tượng đặt trước.

26
00:04:41,830 --> 00:04:52,450
Rất có thể khách hàng có thể hủy đặt phòng, trong trường hợp đó, tham chiếu hủy cũng sẽ được tạo ra và tham chiếu này sẽ trở thành một phần của đặt phòng.

27
00:04:52,570 --> 00:05:10,480
Đối tượng với các thuộc tính khác quan trọng cần xem xét.  Đây là nhà cung cấp và ID nhà cung cấp hợp đồng là danh tính duy nhất được chỉ định cho nhà cung cấp, chẳng hạn như khách sạn hoặc hãng hàng không và việc chỉ định này được thực hiện bởi nhóm sản phẩm.

28
00:05:10,480 --> 00:05:24,090
Vì vậy đội ngũ bán hàng không có quyền kiểm soát nó.  Họ chỉ là người tiêu dùng của nhà cung cấp này.  Tương tự, có một hợp đồng trong mã hợp đồng xác định hợp đồng giữa nhà cung cấp và Acme.

29
00:05:24,250 --> 00:05:30,410
Mã này được nhóm sản phẩm gán và quản lý để thực hiện việc đặt chỗ hoặc hủy bỏ.

30
00:05:30,580 --> 00:05:40,740
Hai thuộc tính này phải được cung cấp bởi các lớp đặt trước cụ thể cho dịch vụ thực hiện chức năng đặt trước và hủy bỏ.

31
00:05:40,750 --> 00:05:51,170
Sau đó, có hai kiểu đặt trước liệt kê và trạng thái đặt trước.  Hai bảng liệt kê này được định nghĩa trong lớp đặt trước trừu tượng.

32
00:05:51,190 --> 00:06:01,810
Tiếp theo, tôi sẽ giải thích mối quan hệ giữa mô hình gói kỳ nghỉ và hệ thống phân cấp lớp đặt trước và tạo mệnh đề gói kỳ nghỉ trong gói.

33
00:06:01,810 --> 00:06:11,400
Kondrat Akhmad hoặc người mẫu bán hàng.  Gói kỳ nghỉ được xác định bằng một tên duy nhất, tên này sẽ là một thuộc tính trong lớp gói kỳ nghỉ.

34
00:06:11,590 --> 00:06:23,800
Hãy ghi lại như một cách thực hành tốt ở đây.  Vì gói kỳ nghỉ cần phải tồn tại lâu dài nên nó sẽ là một thực thể chứ không phải gói kỳ nghỉ sẽ có phần giữ chỗ để đặt trước.

35
00:06:23,800 --> 00:06:32,500
Như đã thảo luận trước đó, các đặt chỗ này là danh sách các đối tượng đặt trước đại diện cho một phần của gói.

36
00:06:32,950 --> 00:06:47,200
Và các trường hợp đặt chỗ trong gói kỳ nghỉ là phần giữ chỗ.  Và những đối tượng này sẽ được sử dụng để tạo các phiên bản thực tế trong lớp đề xuất và lớp xác nhận đặt chỗ.

37
00:06:47,530 --> 00:06:58,900
Một hàm sẽ được hiển thị để tạo các phiên bản của phần giữ chỗ đặt trước đặt tên cho hàm là chủ sở hữu đặt chỗ chung.

38
00:06:59,200 --> 00:07:17,420
Vì vậy, đây là chức năng sẽ tạo ra các đối tượng giữ chỗ đặt trước.  Mối quan hệ giữa lớp gói kỳ nghỉ và lớp đặt trước là lớp gói kỳ nghỉ sẽ có một hoặc nhiều đối tượng đặt trước này.

39
00:07:17,920 --> 00:07:33,240
Tiếp theo, tôi sẽ hướng dẫn bạn trình tự đề xuất và sơ đồ lớp đề xuất tại đây.  Như bạn có thể thấy, khách hàng bắt đầu liên hệ với nhóm bán hàng Acme Sales Acme, sau đó tạo một hoặc nhiều đề xuất.

40
00:07:33,520 --> 00:07:45,430
Chúng ta hãy đi qua sơ đồ trình tự.  Khách hàng đầu tiên, bắt đầu liên hệ với khách hàng đại lý bán hàng, cung cấp danh tính của họ bằng số điện thoại hoặc địa chỉ email.

41
00:07:45,880 --> 00:07:57,520
Và họ cũng cung cấp các sở thích, ngân sách, điểm đến mong muốn, v.v. Và đại lý bán hàng, Foster, sẽ tìm kiếm khách hàng và hệ thống bán hàng.

42
00:07:57,850 --> 00:08:12,610
Nếu không tìm thấy khách hàng thì đại lý bán hàng sẽ thiết lập khách hàng đó làm khách hàng mới.  Khi đó, đại lý bán hàng đã sẵn sàng xác định các gói kỳ nghỉ đáp ứng tiêu chí của khách hàng.

43
00:08:12,760 --> 00:08:22,330
Họ mô tả các gói kỳ nghỉ khác nhau này cho khách hàng và sau đó họ tạo ra một hoặc nhiều đề xuất cho khách hàng.

44
00:08:23,020 --> 00:08:31,030
Những đề xuất này có thể được coi là những lựa chọn cho kỳ nghỉ.  Đây là gói Bahamas ba đêm hoặc đây là gói Bahamas năm đêm.

45
00:08:31,180 --> 00:08:40,210
Bạn thích cái nào hơn?  Đó là loại đề xuất hoặc lựa chọn mà đại lý bán hàng sau đó cung cấp cho khách hàng.

46
00:08:40,210 --> 00:08:49,180
Khách hàng tại thời điểm đó có thể quyết định chọn một chiếc.  Trong số các đề xuất và đại lý bán hàng sau đó bắt đầu quá trình đặt chỗ.

47
00:08:49,290 --> 00:08:56,960
Vì vậy, đây là một sơ đồ trình tự rất đơn giản cho quá trình tạo đề xuất.  Chúng ta hãy nhìn vào lớp đề xuất.

48
00:08:57,100 --> 00:09:07,710
Bây giờ, chúng ta sẽ xác định lớp đề xuất và gói mô hình cốt lõi.  Lớp đề xuất sẽ là một thực thể được xác định bằng số tham chiếu.

49
00:09:07,800 --> 00:09:21,510
Nó cũng sẽ có tham chiếu đến gói kỳ nghỉ của khách hàng và một mảng hoặc danh sách mối quan hệ hành khách giữa đề xuất và các lớp khách hàng mà đề xuất tham chiếu đến đối tượng khách hàng.

50
00:09:21,660 --> 00:09:38,280
Và tương tự, nó đề cập đến gói kỳ nghỉ.  Hãy nhớ rằng khách hàng và các thực thể gói kỳ nghỉ có vòng đời độc lập, trong khi đối tượng hành khách mà đề xuất có được quản lý như một phần của đề xuất.

51
00:09:38,280 --> 00:09:47,110
Và đề xuất có các đặt chỗ được xác định trong Đạo luật ứng xử hoặc gói đặt phòng không theo mô hình bán hàng.

52
00:09:47,130 --> 00:09:58,140
Mối quan hệ giữa đề xuất và đặt chỗ là đề xuất có thể chứa một hoặc nhiều đối tượng có giá trị đặt trước này.

53
00:09:58,290 --> 00:10:11,400
Sau đó có một đối tượng cung cấp.  Đối tượng ưu đãi này được áp dụng như một khoản giảm giá khi định giá gói.  Ngoài ra, còn có một bảng liệt kê được xác định trong đề xuất.

54
00:10:11,400 --> 00:10:21,310
Cộng với đề xuất này.  Bảng liệt kê trạng thái được sử dụng để chỉ định trạng thái cho đề xuất được quản lý trong hệ thống bán hàng.

55
00:10:21,330 --> 00:10:31,820
Vì vậy, đây là cách lớp đề xuất trông như thế nào.  Tôi khuyên bạn nên tự mình xem các mô hình và thoải mái thực hiện các thay đổi để làm cho nó tốt hơn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000006.srt -->

1
00:00:00,150 --> 00:00:07,410
Trong bài học này, bạn sẽ tìm hiểu về tổng hợp và mẫu nhà máy.  Hãy bắt đầu với định nghĩa về tổng hợp.

2
00:00:07,590 --> 00:00:19,320
Đối tượng tổng hợp là một nhóm các thực thể và đối tượng giá trị được xem như một tổng thể thống nhất từ ​​góc độ dữ liệu và khái niệm miền.

3
00:00:19,350 --> 00:00:28,230
Hãy để tôi giải thích điều này bằng một minh họa.  Một tập hợp bao gồm một nhóm tổng hợp còn được gọi là thực thể gốc.

4
00:00:28,980 --> 00:00:41,610
Thực thể gốc này có một danh tính duy nhất từ ​​phối cảnh miền.  Phần thứ hai của tập hợp là cụm, được hình thành bởi ranh giới của tập hợp.

5
00:00:41,910 --> 00:00:57,990
Trong ranh giới này, có thể không có hoặc nhiều thực thể tổng hợp và đối tượng giá trị.  Các đối tượng trong cụm này hoặc đối tượng trong ranh giới được gọi là đối tượng bên trong hoặc đối tượng con.

6
00:00:58,170 --> 00:01:11,400
Hãy lấy một ví dụ về tài khoản ngân hàng.  Tài khoản ngân hàng là một thực thể gốc tổng hợp có một danh tính duy nhất, nhưng trong tổng hợp này có nhiều loại đối tượng khác nhau.

7
00:01:11,640 --> 00:01:21,790
Ví dụ, có những giao dịch.  Giao dịch là các đối tượng thực thể vì chúng có một danh tính duy nhất và được lưu trữ lâu dài.

8
00:01:21,840 --> 00:01:27,710
Sau đó không có nhiều đồ vật.  Không có nhiều đối tượng này được quản lý trong ngữ cảnh của tài khoản.

9
00:01:27,720 --> 00:01:33,980
Họ không có danh tính duy nhất bên ngoài tài khoản ngân hàng.  Kết quả là chúng là những đối tượng có giá trị.

10
00:01:33,990 --> 00:01:41,910
Vì vậy, đây là một ví dụ về tổng hợp.  Bây giờ giả sử bạn phải thao tác trên một trong các đối tượng để không thực hiện việc này.

11
00:01:42,270 --> 00:01:55,920
Bạn có thể sử dụng cơ chế này trong đó bạn có thể gọi hàm get trên tổng hợp, ví dụ: get người được đề cử để lấy đối tượng được đề cử và sau đó bạn có thể gọi hàm trực tiếp trên đối tượng.

12
00:01:56,040 --> 00:02:07,080
Đây là một ví dụ về lập trình thủ tục.  Vui lòng đừng làm vậy.  Aggregate phải cung cấp các giao diện để vận hành trên các đối tượng bên trong.

13
00:02:07,410 --> 00:02:25,740
Hãy để tôi giải thích điều này với ví dụ về tài khoản ngân hàng.  Chúng ta đã thảo luận rằng việc tương tác trực tiếp với đối tượng bên trong không phải là một phương pháp hay, do đó, tổng hợp phải đưa ra một số chức năng để hoạt động trên đối tượng bên trong.

14
00:02:25,750 --> 00:02:36,240
Mã bên ngoài tổng hợp sẽ gọi hàm và hàm này gói gọn tất cả logic nghiệp vụ để vận hành trên các đối tượng bên trong.

15
00:02:36,240 --> 00:02:51,660
Với tư cách là người thiết kế tổng hợp, bạn có trách nhiệm đảm bảo rằng tất cả hành vi cần thiết để vận hành trên đối tượng bên trong được hiển thị dưới dạng các hàm của đối tượng gốc tổng hợp.

16
00:02:52,840 --> 00:03:07,900
Nói chung, các đối tượng tổng hợp được lưu trữ trong nhiều bảng trong trường hợp RDBMS và trong trường hợp không có cơ sở dữ liệu tiếp theo, đối tượng tổng hợp có thể được lưu trữ trên nhiều bộ sưu tập.

17
00:03:07,930 --> 00:03:17,910
Khi một tập hợp được chèn hoặc cập nhật dựa trên các cơ sở dữ liệu này, việc đó cần phải được thực hiện theo kiểu nguyên tử.

18
00:03:18,100 --> 00:03:35,260
Giả sử trong trường hợp đếm, khi hàm được gọi, nhiều đối tượng innot sẽ được cập nhật và khi đối tượng account được lưu vào cơ sở dữ liệu trên nhiều bảng hoặc bộ sưu tập, tất cả các thay đổi phải được thực hiện.

19
00:03:35,260 --> 00:03:47,770
Về mặt nguyên tử, tất cả các thay đổi đều thành công hoặc tất cả các thay đổi đều được khôi phục.  Vì vậy, đơn vị công việc là yếu tố quan trọng cần cân nhắc khi bạn thiết kế các tập hợp của mình.

20
00:03:48,490 --> 00:04:02,630
Mẫu thiết kế nhà máy là một mẫu phổ biến để xây dựng các tập hợp miền phức tạp.  Cách thức hoạt động là bạn xác định một đối tượng có tất cả logic để tạo tổng hợp miền.

21
00:04:02,680 --> 00:04:13,060
Nhà máy này hiển thị một chức năng có thể được gọi bằng mã và hiển thị chức năng để tạo các bộ tổng hợp có liên quan trong nhà máy, nhà máy đọc.

22
00:04:13,060 --> 00:04:19,700
Dữ liệu tổng hợp từ bộ lưu trữ liên tục sẽ tạo tổng hợp và trả về cột.

23
00:04:19,780 --> 00:04:28,720
Vì vậy đây là mẫu thiết kế rất phổ biến, không nhất thiết chỉ dành riêng cho các dịch vụ của Mikoto.  Thời gian cho một câu hỏi nhanh chóng.

24
00:04:28,750 --> 00:04:40,570
Bạn sẽ gọi một tập hợp không có đối tượng đầu vào là gì?  Câu trả lời là vì một tập hợp là một thực thể, nên một tập hợp không có đối tượng bên trong sẽ là một thực thể.

25
00:04:41,080 --> 00:04:54,840
Nhưng hãy nhớ rằng nó cũng có thể được gọi là nhóm tổng hợp hoặc nhóm tổng hợp.  Lý do tôi đưa ra vấn đề này là vì người ta thường thấy gốc tổng hợp thực thể và gốc tổng hợp được sử dụng thay thế cho nhau.

26
00:04:55,120 --> 00:05:02,690
Vì vậy, hãy ghi nhớ điều đó trong trường hợp này cũng như khi đọc bất kỳ bài viết hoặc blog nào bạn có thể tìm thấy trên Internet.

27
00:05:02,980 --> 00:05:14,890
Đã đến lúc xem xét nhanh.  Tổng hợp có thể chứa các thực thể tổng hợp và đối tượng giá trị khác.  Tổng hợp phải gói gọn hành vi để quản lý trong đối tượng bên trong.

28
00:05:15,160 --> 00:05:24,640
Tất cả các thay đổi đối với tổng hợp đều được lưu.  Các đối tác nguyên tử và nhà máy thường được sử dụng để tạo các tập hợp miền phức tạp.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000007.srt -->

1
00:00:00,460 --> 00:00:14,530
Trong bài tập này, mục tiêu của chúng tôi trước tiên là tìm hiểu trường hợp sử dụng bán hàng của Acme, sau đó thiết kế đối tượng tổng hợp xác nhận đặt phòng mà khách hàng bắt đầu liên hệ với nhóm bán hàng Acme.

2
00:00:15,040 --> 00:00:24,310
Thành viên nhóm bán hàng Acme thảo luận về các lựa chọn kỳ nghỉ khác nhau với khách hàng và tạo một hoặc nhiều đề xuất.

3
00:00:24,550 --> 00:00:34,000
Khách hàng chọn một trong các đề xuất và tại thời điểm đó, thành viên trong nhóm sẽ bắt đầu quá trình thanh toán, dẫn đến việc tạo đơn đặt hàng.

4
00:00:34,270 --> 00:00:42,290
Và sau khi nhận được khoản thanh toán, thông tin thanh toán sẽ được tạo và việc đặt chỗ của nhà cung cấp sẽ được kích hoạt.

5
00:00:42,310 --> 00:00:56,440
Vì vậy, giả sử gói kỳ nghỉ bao gồm tiền thuê xe của khách sạn và vé máy bay.  Quá trình đặt trước của nhà cung cấp sẽ dẫn đến việc đặt trước cả ba phần này của gói.

6
00:00:56,440 --> 00:01:02,590
Vậy là khách sạn sẽ được giải quyết, thuê xe sẽ được giữ trước và vé máy bay sẽ được giữ trước.

7
00:01:02,590 --> 00:01:15,430
Việc đặt chỗ thành công từ tất cả những điều này sẽ dẫn đến việc tạo ra xác nhận đặt chỗ và xác nhận đặt chỗ này sau đó sẽ được thông báo tới khách hàng thông qua trường hợp sử dụng xác nhận của Thượng viện.

8
00:01:15,850 --> 00:01:23,680
Chúng ta hãy xem xét sâu hơn về xác nhận đặt phòng.  Xác nhận đặt phòng chứa tất cả thông tin về việc đặt phòng.

9
00:01:24,160 --> 00:01:34,000
Nó có thông tin về khoản thanh toán, thông tin về hành khách và thông tin về tất cả các đặt chỗ của nhà cung cấp.

10
00:01:34,360 --> 00:01:48,370
Đối tượng xác nhận đặt phòng này là một tổng hợp.  Lý do nó là tổng hợp vì nó chứa một số đối tượng chỉ có ý nghĩa trong bối cảnh xác nhận đặt phòng.

11
00:01:48,640 --> 00:01:58,870
Ngoài nội dung của xác nhận đặt phòng, nó còn đề cập đến khách hàng cũng như đề xuất mà khách hàng đã cam kết.

12
00:01:59,110 --> 00:02:06,700
Vì vậy, đây là cách đối tượng tổng hợp xác nhận đặt phòng sẽ trông giống như được xác định bởi tham chiếu đặt phòng.

13
00:02:06,880 --> 00:02:14,170
Sau đó, có một đối tượng xác nhận thanh toán có một đối tượng thực thể.  Phần còn lại của đối tượng là các đối tượng giá trị.

14
00:02:14,710 --> 00:02:23,470
Tất cả các hoạt động trên các đối tượng bên trong này sẽ được thực hiện bằng các chức năng do nhóm tổng hợp xác nhận đặt chỗ cung cấp.

15
00:02:24,220 --> 00:02:37,360
Một chức năng như vậy là chức năng hủy đặt chỗ.  Mục đích của chức năng hủy đặt chỗ này là hủy bỏ tất cả các đặt phòng và hoàn trả khoản thanh toán cho khách hàng.

16
00:02:37,570 --> 00:02:50,550
Hãy nhớ lại rằng tất cả những thay đổi như vậy cần phải mang tính kinh tế.  Nói cách khác, nếu bất kỳ thao tác hủy đặt chỗ nào của nhà cung cấp không thành công thì tất cả thay đổi cần được khôi phục.

17
00:02:50,560 --> 00:02:57,160
Hãy xem chức năng hủy đặt chỗ này có thể được mã hóa như thế nào khi gọi hàm hủy đặt chỗ.

18
00:02:57,520 --> 00:03:04,480
Điều đầu tiên mà việc triển khai có thể làm là kích hoạt việc hủy tất cả các đặt chỗ của nhà cung cấp.

19
00:03:04,510 --> 00:03:13,570
Sau khi nhận được phản hồi từ tất cả các lượt đặt trước của nhà cung cấp, việc triển khai có thể kiểm tra xem tất cả các lần hủy có thành công hay không.

20
00:03:13,570 --> 00:03:20,200
Nếu việc hủy không thành công ngay cả đối với một dịch vụ, thì hãy khôi phục tất cả các lần hủy.

21
00:03:20,200 --> 00:03:31,480
Nếu việc hủy thành công đối với tất cả các đặt phòng thì việc thực hiện sẽ kích hoạt quy trình hoàn tiền và sau đó kiểm tra xem quy trình cải cách có thành công hay không.

22
00:03:31,480 --> 00:03:45,610
Nếu quá trình hoàn tiền không thành công, hãy khôi phục tất cả các lần hủy.  Và nếu quá trình phản hồi thành công thì hãy cập nhật trạng thái xác nhận đặt chỗ trong bộ lưu trữ liên tục.

23
00:03:45,620 --> 00:03:53,860
Vì vậy, đây là một ví dụ trong đó việc triển khai lộ trình tổng hợp nhằm đảm bảo rằng tất cả các thay đổi đều mang tính nguyên tử.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000008.srt -->

1
00:00:00,240 --> 00:00:07,680
Trong bài học này, chúng ta sẽ phát triển mô hình cho các đối tượng tổng hợp đã được thảo luận trong bài giảng trước.

2
00:00:07,830 --> 00:00:19,590
Tôi cũng sẽ thảo luận về cuốn sách trong Trạng thái xác nhận Dargah, trong đó sẽ hiển thị trạng thái mà đối tượng xác nhận đặt chỗ sẽ trải qua như một phần trong vòng đời của nó.

3
00:00:19,890 --> 00:00:33,120
Mục tiêu của tôi ở đây là đi đến đối tượng cốt lõi trong miền bán hàng Atmeh.  Các tệp mô hình và mã đạo đức có sẵn trong nhánh kỹ thuật get và nếu quan tâm, bạn có thể tự mình xem qua mã.

4
00:00:33,270 --> 00:00:41,910
Phần này là tùy chọn và xin lưu ý rằng mô hình đã được giữ đơn giản để bạn có thể dễ dàng làm theo.

5
00:00:42,120 --> 00:00:55,320
Đây là một mô hình hoàn chỉnh và bạn có thể coi nó như bản phác thảo đầu tiên của mô hình.  Đối tượng xác nhận sẽ được tạo trong gói Kondor Akhmad hoặc mô hình thanh toán chấm bán hàng.

6
00:00:55,560 --> 00:01:04,470
Đối tượng thuộc loại thực thể vì nó sẽ có một danh tính duy nhất trong ngữ cảnh bán hàng và nó sẽ tồn tại lâu dài.

7
00:01:04,470 --> 00:01:24,420
Nhưng vòng đời của thực thể này sẽ do đối tượng xác nhận đặt chỗ quản lý.  Như đã thảo luận trước đó, đối tượng này sẽ được tạo bằng xác nhận đặt phòng khi khách hàng thanh toán cho gói kỳ nghỉ và dịch vụ xử lý khoản thanh toán sẽ tạo ra tham chiếu xác nhận.

8
00:01:24,450 --> 00:01:34,980
Ngày thanh toán sẽ được ghi lại.  Khách hàng Macario, việc hủy đặt phòng.  Rõ ràng là có một số quy tắc kinh doanh nhất định mà chúng ta chưa thảo luận, nhưng việc hủy bỏ là có thể.

9
00:01:35,250 --> 00:01:46,860
Vì vậy, nếu khách hàng quyết định hủy đặt chỗ, tham chiếu hủy sẽ được dịch vụ thanh toán tạo ra và tồn tại như một phần của xác nhận thanh toán.

10
00:01:47,130 --> 00:01:57,980
Vì vậy, đây là phiên bản đầu tiên của đối tượng xác nhận thanh toán.  Hạng xác nhận đặt chỗ sẽ được tạo trong gói đặt chỗ.

11
00:01:58,020 --> 00:02:06,660
Xác nhận đăng ký đối tượng, như đã thảo luận trước đó, là một lộ trình tổng hợp sẽ được xác định bằng cách tham chiếu.

12
00:02:06,690 --> 00:02:34,860
Nó sẽ chứa một danh sách các đặt phòng nằm trong gói kỳ nghỉ.  Tuổi thọ của tất cả các đối tượng đặt chỗ sẽ được quản lý bởi xác nhận đặt chỗ vì mối quan hệ giữa đặt chỗ, xác nhận và đặt chỗ là các đối tượng đặt chỗ là đối tượng bên trong của tuyến đường tổng hợp, không phải đối tượng đặt chỗ sẽ có sẵn trực tiếp từ bất kỳ lớp nào khác  .

13
00:02:35,340 --> 00:02:41,880
Tổng hợp xác nhận đặt phòng cũng sẽ có tham chiếu đến đề xuất và sẽ có khoản thanh toán.

14
00:02:41,880 --> 00:02:57,000
Xác nhận và mối quan hệ giữa xác nhận đặt phòng và xác nhận thanh toán là xác nhận đặt phòng sẽ có một trường hợp xác nhận thanh toán trong xác nhận đặt phòng.

15
00:02:57,240 --> 00:03:09,390
Sẽ có một bảng liệt kê xác định các giai đoạn khác nhau của đối tượng xác nhận đặt phòng.  Việc liệt kê này được xác định như một phần của lộ trình tổng hợp xác nhận đặt chỗ.

16
00:03:09,420 --> 00:03:24,090
Tiếp theo, tôi sẽ hướng dẫn bạn sơ đồ bất động sản cho đối tượng xác nhận đặt phòng.  Phiên bản đối tượng xác nhận đặt phòng được tạo khi khách hàng chọn đề xuất nhưng chưa thanh toán.

17
00:03:24,090 --> 00:03:36,540
Lúc này trạng thái xác nhận đặt phòng đang chờ thanh toán từ đây.  Di sản có thể trải qua quá trình đặt chỗ hoặc có thể trải qua quá trình hủy bỏ.

18
00:03:36,630 --> 00:03:51,330
Quá trình đặt chỗ sẽ bắt đầu khi khách hàng thanh toán.  Vì vậy, ý tưởng ở đây là khi khách hàng đã thanh toán trạng thái đặt chỗ, đối tượng xác nhận sẽ thay đổi từ trạng thái chờ thanh toán sang trạng thái chờ đặt chỗ.

19
00:03:51,420 --> 00:04:00,810
Quá trình đặt chỗ cho tất cả các nhà cung cấp sẽ được sắp xếp và trạng thái sau đó sẽ thay đổi từ đặt chỗ đang chờ xử lý sang đặt chỗ và tiến độ.

20
00:04:01,290 --> 00:04:09,450
Tại một thời điểm nào đó, tất cả các lượt đặt chỗ sẽ thành công và trạng thái đặt chỗ sẽ thay đổi để xác nhận xem mọi việc có ổn không.

21
00:04:09,570 --> 00:04:25,110
Khách hàng tận hưởng kỳ nghỉ và đó là sự kết thúc của vòng đời xác nhận đặt phòng.  Nhưng rất có thể khách hàng không đi nghỉ và quyết định hủy gói hàng ngay cả sau khi đã xác nhận.

22
00:04:25,140 --> 00:04:41,460
Rõ ràng là có một số quy tắc kinh doanh nhất định mà chúng ta chưa thảo luận.  Trạng thái sẽ thay đổi từ tuân thủ sang hủy đang diễn ra, mặc dù việc đặt chỗ sẽ cần phải bị hủy, khoản thanh toán sẽ bị hủy và khách hàng sẽ được hoàn lại tiền.

23
00:04:41,490 --> 00:04:51,960
Khi đó, trạng thái sẽ thay đổi thành hủy và đó sẽ là sự kết thúc của vòng đời đặt chỗ. Sau đó, không thể thực hiện thay đổi nào đối với đối tượng xác nhận đặt phòng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000009.srt -->

1
00:00:00,150 --> 00:00:09,810
Trong bài học này, bạn sẽ tìm hiểu về hai tập sách mới, mô hình thiếu máu và mô hình phong phú.  Những thuật ngữ này được sử dụng để mô tả hành vi của mô hình.

2
00:00:10,410 --> 00:00:19,590
Tôi sẽ bắt đầu bài học này bằng một câu hỏi.  Câu hỏi là, hãy nhìn vào đối tượng thực thể này.  Đối tượng này có bộc lộ bất kỳ logic nghiệp vụ nào không?

3
00:00:19,620 --> 00:00:28,380
Câu trả lời là không.  Nó không phơi bày bất kỳ logic kinh doanh nào.  Và lý do tôi nói vậy là vì nó bộc lộ một số chức năng.

4
00:00:28,650 --> 00:00:36,960
Nhưng những chức năng này chỉ là cổng và xác nhận.  Và chức năng cuối cùng chỉ là sở hữu đối tượng vào cơ sở dữ liệu.

5
00:00:37,290 --> 00:00:50,610
Những loại mô hình không bộc lộ bất kỳ logic kinh doanh nào được gọi là mô hình thiếu máu.  Một định nghĩa chính thức hơn là một mô hình miền bao gồm các thực thể không thể hiện hành vi.

6
00:00:50,820 --> 00:01:05,720
Nghĩa là, các hoạt động áp dụng cho khái niệm miền bị thiếu.  Đối lập với mô hình thiếu máu là mô hình miền phong phú và thuật ngữ mô hình thiếu máu này được Martin Fowler đặt ra trong một blog.

7
00:01:05,730 --> 00:01:15,000
Tôi đề nghị rằng nếu bạn chưa từng nghe đến cái tên Martin Fowler, hãy tiếp tục tra Google tên của anh ấy và bạn sẽ tìm thấy rất nhiều blog và bài báo thú vị.

8
00:01:15,990 --> 00:01:30,260
Bây giờ, chắc hẳn bạn đang thắc mắc, tại sao con vật này lại được sử dụng ở đây?  Vâng, thiếu máu là tình trạng cơ thể không có đủ hồng cầu để mang đủ oxy đến các mô và cơ quan khác nhau.

9
00:01:30,720 --> 00:01:40,000
Và như bạn có thể tưởng tượng, đó là một tình trạng tồi tệ.  Những người mắc bệnh này cảm thấy yếu đuối.  Họ có làn da nhợt nhạt và mắc nhiều bệnh khác nhau.

10
00:01:40,440 --> 00:01:47,850
À, hiển nhiên là tôi không muốn bàn đến những căn bệnh đó ở đây.  Và một người bị thiếu máu được gọi là thiếu máu.

11
00:01:48,390 --> 00:02:00,450
Bây giờ, Martin đang sử dụng động vật như một phép loại suy để mô tả một mô hình tồi.  Ý tưởng ở đây là anh ấy đang nói rằng khi bị thiếu máu, một người bị thiếu hồng cầu.

12
00:02:00,570 --> 00:02:06,790
Và vì vậy nó không tốt.  Và trong trường hợp một mô hình, nếu không có hành vi ứng xử thì đó không phải là một mô hình tốt.

13
00:02:07,230 --> 00:02:16,980
Vâng, cuộc thảo luận của chúng ta về bệnh thiếu máu đã đủ rồi.  Hãy quay trở lại cuộc thảo luận về các mô hình.  Hãy thảo luận về cách bạn chẩn đoán một mô hình thiếu máu.

14
00:02:16,990 --> 00:02:24,370
Nói cách khác, giả sử bạn đã có một mô hình và bạn muốn xác định xem đó là mô hình thiếu máu hay mô hình phong phú.

15
00:02:24,690 --> 00:02:36,330
Điều đầu tiên bạn sẽ xem xét là điều hiển nhiên.  Các thực thể có thích hành vi này không?  Nếu các thực thể thích hành vi đó thì rất có thể đó là một mô hình thiếu máu.

16
00:02:36,720 --> 00:02:47,130
Và nếu thực thể có một số chức năng thì điều đầu tiên bạn nên xem xét là các chức năng này không chỉ dành cho các hoạt động hiện tại.

17
00:02:47,430 --> 00:02:56,570
Nghĩa là, chúng không chỉ là các hàm getters, setters, cập nhật và xóa.  Nếu chúng không có chức năng thì mô hình bị thiếu máu.

18
00:02:56,940 --> 00:03:05,610
Và điều thứ ba bạn cần tìm là việc triển khai logic nghiệp vụ bên ngoài các đối tượng thực thể.

19
00:03:05,820 --> 00:03:12,380
Triệu chứng số một và triệu chứng số hai rất rõ ràng.  Hãy thảo luận chi tiết về triệu chứng số ba.

20
00:03:12,870 --> 00:03:22,020
Ý tưởng là đối tượng thực thể không có bất kỳ loại triển khai logic nghiệp vụ nào nhưng nó có các chức năng thẻ.

21
00:03:22,290 --> 00:03:41,250
Mã logic nghiệp vụ nằm trong một thành phần bên ngoài gọi ra các khu ổ chuột để lấy dữ liệu từ đối tượng thực thể, sử dụng dữ liệu trong mã logic nghiệp vụ, sau đó gọi các phương thức setters trên đối tượng thực thể để đặt dữ liệu trở lại thực thể.

22
00:03:41,280 --> 00:03:50,520
Thành phần bên ngoài thường được triển khai dưới dạng dịch vụ chia sẻ hoặc được mã hóa trực tiếp như một phần của ứng dụng.

23
00:03:50,520 --> 00:03:59,360
Trong trường hợp dịch vụ, các đối tượng miền cung cấp các hoạt động thẻ cho các dịch vụ nằm trong một lớp riêng biệt.

24
00:03:59,640 --> 00:04:06,570
Tất cả logic nghiệp vụ đều nằm trong các thành phần hoặc dịch vụ được triển khai trong lớp dịch vụ dùng chung.

25
00:04:06,810 --> 00:04:14,490
Loại kiến ​​trúc này thường thấy ở các tổ chức áp dụng kiến ​​trúc hướng dịch vụ.

26
00:04:15,450 --> 00:04:27,170
Cách thứ hai mà logic nghiệp vụ có thể được thể hiện ra bên ngoài là tạo ra các ứng dụng có logic nghiệp vụ được nhúng trong mã ứng dụng.

27
00:04:27,180 --> 00:04:41,940
Trong trường hợp này, logic nghiệp vụ được lặp lại trên nhiều ứng dụng.  Vì có nhiều ứng dụng phụ thuộc vào lớp miền nên việc quản lý các thay đổi trong đối tượng lớp miền sẽ là một thách thức.

28
00:04:41,970 --> 00:04:52,470
Loại tình huống này nên tránh bằng mọi giá.  Nhưng thật không may, tôi đã thấy kiểu mẫu này được triển khai trong nhiều ứng dụng cũ.

29
00:04:53,130 --> 00:05:06,930
Không phải là bạn hiểu triệu chứng của người mẫu thiếu máu.  Hãy nói về cách một mô hình phong phú trông giống như mô hình phong phú triển khai hành vi của mô hình vốn là một phần của đối tượng thực thể.

30
00:05:07,140 --> 00:05:18,420
Đây là một ví dụ về đối tượng tài khoản có tất cả logic nghiệp vụ ở một nơi.  Đây là các hàm triển khai logic nghiệp vụ trong đối tượng tài khoản.

31
00:05:18,600 --> 00:05:30,310
Nó triển khai tất cả các khái niệm miền, ví dụ: cách thực hiện việc rút tiền hoặc cách thực hiện gửi tiền và tất cả các quy tắc kinh doanh áp dụng cho các chức năng này.

32
00:05:30,360 --> 00:05:48,990
Một tác dụng phụ tích cực của việc có tất cả logic nghiệp vụ ở một nơi là tính toàn vẹn của dữ liệu đạo đức được duy trì và điều này là do chủ sở hữu đối tượng sẽ có toàn quyền kiểm soát cách quản lý dữ liệu thay vì mọi ứng dụng tự triển khai logic nghiệp vụ  .

33
00:05:49,140 --> 00:06:00,970
Tại thời điểm này, bạn có thể có một câu hỏi.  Có phải mô hình thiếu máu luôn xấu?  Nói cách khác, nếu bạn có một mô hình hiện tại đang thiếu máu, bạn có nên tiếp tục và lên kế hoạch biến nó thành một mô hình phong phú không?

34
00:06:01,020 --> 00:06:20,400
Câu trả lời của tôi cho câu hỏi này là không thực sự, đặc biệt trong trường hợp các vấn đề tên miền đơn giản.  Bạn cần suy nghĩ về kịch bản, trường hợp sử dụng của mình và sau đó quyết định, chẳng hạn như nếu không có hoặc thiếu logic kinh doanh hoặc nếu logic kinh doanh thay đổi không thường xuyên, thì một mô hình yếu kém có thể không phải là một thách thức lớn.

35
00:06:20,400 --> 00:06:28,740
Nếu mô hình của bạn chỉ đơn giản cung cấp các dịch vụ dữ liệu chung là Criado-Perez, thì bạn đồng ý với mô hình thiếu máu.

36
00:06:28,740 --> 00:06:36,260
Và sau đó, có những tình huống hoặc trường hợp sử dụng trong đó có logic chung không thuộc về một thực thể mô hình duy nhất.

37
00:06:36,270 --> 00:06:43,380
Trong kịch bản này.  Ngoài ra, có thể có một mô hình thiếu máu.  Vì vậy, như bạn có thể thấy, không có câu trả lời đơn giản.

38
00:06:43,380 --> 00:07:00,270
Các mô hình thiếu máu có thể được xem xét và Antipater trong một số trường hợp, nhưng không phải tất cả.  Bạn phải xem xét trường hợp sử dụng cụ thể của mình theo kịch bản cụ thể và đưa ra phán quyết về việc liệu bạn sẽ xây dựng một mô hình hay liệu bạn có đồng ý với một mô hình thiếu máu hay không.

39
00:07:00,540 --> 00:07:13,020
Có một quan niệm sai lầm phổ biến rằng trong một mô hình phong phú, mọi thực thể nên thực hiện hành vi đó.  Và điều đó không đúng vì trong một đối tượng tổng hợp, gốc tổng hợp sẽ thực hiện hành vi đó.

40
00:07:13,380 --> 00:07:24,240
Đối tượng thực thể bên trong có thể không có bất kỳ hành vi nào.  Đó là một ví dụ.  Đây là tổng hợp xác nhận đặt phòng đã được thảo luận trong một trong những bài giảng trước đó.

41
00:07:24,240 --> 00:07:32,190
Trong trường hợp này, xác nhận gốc, là một thực thể trong tổng hợp này, sẽ tiết lộ các hoạt động thẻ.

42
00:07:32,190 --> 00:07:46,200
Chỉ tất cả logic nghiệp vụ được triển khai trong chức năng hủy đặt trước.  Điều quan trọng cần lưu ý ở đây là đối tượng xác nhận thanh toán sẽ không bị tổng hợp này tiếp xúc trực tiếp.

43
00:07:46,500 --> 00:08:03,930
Nói cách khác, các thành phần bên ngoài không có quyền truy cập trực tiếp vào thực thể xác nhận thanh toán.  Đã đến lúc kết thúc bài học này trong bài học này bạn đã học về các mô hình thiếu máu và mô hình Eric đề cập đến các mô hình trong đó các thực thể được triển khai mà không có hành vi.

44
00:08:04,050 --> 00:08:23,580
Đối lập với mô hình thiếu máu là mô hình giàu có.  Để xác định các mô hình thiếu máu, bạn cần tìm kiếm các triệu chứng, chẳng hạn như các thực thể không thực hiện hành vi, các thực thể chỉ thực hiện các chức năng thẻ và logic nghiệp vụ cũng như thành phần bên ngoài thay vì có trong các thực thể.

45
00:08:23,880 --> 00:08:34,290
Một câu hỏi quan trọng mà tôi đã trả lời trong bài học này là mô hình luôn luôn thiếu máu và phản proton.  Và câu trả lời của tôi giống như thế nào, điều đó còn tùy.

46
00:08:34,620 --> 00:08:55,380
Nó phụ thuộc vào yêu cầu của người dùng và các yếu tố khác.  Xin lưu ý rằng đây là ý kiến ​​​​của tôi.  Đề nghị của tôi dành cho bạn là bạn nên hình thành quan điểm của riêng mình bằng cách thực hiện thêm một số nghiên cứu, bằng cách xem xét các mô hình mà bạn đã phát triển trong quá khứ và kinh nghiệm của bạn trong việc quản lý các thay đổi đối với các mô hình đó.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000010.srt -->

1
00:00:00,210 --> 00:00:10,530
Trong bài học này, tôi sẽ mô tả mẫu kho lưu trữ, các đặc điểm của đối tượng kho lưu trữ và một số tùy chọn hiện thực hóa cho kho lưu trữ.

2
00:00:10,950 --> 00:00:20,650
Tôi sẽ bắt đầu với định nghĩa chính thức của đối tượng kho lưu trữ.  Đối tượng kho lưu trữ hoạt động như một tập hợp các đối tượng tổng hợp trong bộ nhớ.

3
00:00:20,670 --> 00:00:30,480
Nó ẩn các chi tiết về mức lưu trữ cần thiết để quản lý và loại bỏ trạng thái tổng hợp trong dữ liệu cơ bản.

4
00:00:30,510 --> 00:00:41,040
Chà, đây là một định nghĩa dài, nhưng chúng ta hãy chia nhỏ nó bằng cách xem một hình minh họa.  Gốc tổng hợp là một thực thể được quản lý trong một số loại lưu trữ dài hạn.

5
00:00:41,070 --> 00:00:51,150
Đây có thể là RDBMS, không có phần tiếp theo hoặc thậm chí là hệ thống tập tin.  Tất cả logic để tương tác với bộ lưu trữ dữ liệu được gói gọn bởi đối tượng kho lưu trữ.

6
00:00:51,180 --> 00:00:58,170
Thông tin chi tiết về các tương tác này được ẩn khỏi máy khách, người gọi hoặc đối tượng kho lưu trữ.

7
00:00:58,560 --> 00:01:06,590
Màu sắc của các hàm đối tượng kho lưu trữ sử dụng các thao tác thẻ để quản lý và truy vấn trạng thái tổng hợp.

8
00:01:06,600 --> 00:01:19,110
Màu sắc của các hoạt động hiện tại này không có kiến ​​thức về dữ liệu cơ bản.  Đối với các cột này, kho lưu trữ đóng vai trò là nơi chứa tập hợp các đối tượng tổng hợp.

9
00:01:20,210 --> 00:01:31,180
Dưới đây là một ví dụ về kho lưu trữ tài khoản ngân hàng, người gọi hoặc khách hàng có thể gọi các hoạt động thẻ khác nhau do đối tượng kho lưu trữ tài khoản hiển thị.

10
00:01:31,190 --> 00:01:41,060
Ví dụ: người gọi gọi hàm ADD để thêm hoặc cập nhật tổng hợp tài khoản nhằm triển khai hàm hành động này.

11
00:01:41,060 --> 00:02:04,570
Đối tượng kho lưu trữ tài khoản thực hiện API vô lý trên công cụ cơ sở dữ liệu.  Tương tự, người gọi hoặc máy khách có thể gọi hàm get để truy xuất tổng hợp tài khoản từ lệnh và do đó, hàm get có thể được đối tượng kho tài khoản triển khai bằng một câu lệnh tiếp theo hoặc không có phần tiếp theo.

12
00:02:04,640 --> 00:02:14,010
Tìm Appia.  Điều quan trọng cần lưu ý ở đây là máy khách hoặc người gọi hàm đối tượng kho lưu trữ không biết gì về dữ liệu của bạn.

13
00:02:14,540 --> 00:02:28,410
Tiếp theo, tôi sẽ thảo luận về các đặc điểm của đối tượng kho lưu trữ hoặc mẫu kho lưu trữ.  Điều đầu tiên là đối với mỗi tổng hợp được xác định trong mô hình miền, bạn có một và chỉ một kho lưu trữ.

14
00:02:28,640 --> 00:02:39,050
Vì vậy, nói cách khác, việc triển khai nhiều kho lưu trữ cho một kho lưu trữ tổng hợp không phải là một ý tưởng hay có thể làm lộ ra hành vi cấp cao của các chức năng.

15
00:02:39,060 --> 00:02:57,680
Và điều này nằm ngoài các chức năng thẻ điển hình dự kiến ​​sẽ được kho triển khai, các chức năng chèn cập nhật và xóa được kho lưu trữ hiển thị và cho thấy rằng tất cả các hoạt động này được thực hiện như các hoạt động kinh tế.

16
00:02:57,860 --> 00:03:08,450
Chúng ta hãy xem chi tiết từng cái trong mô hình miền tài khoản ngân hàng.  Chúng sẽ là tổng hợp tài khoản của chúng tôi và tổng hợp khách hàng.

17
00:03:09,200 --> 00:03:17,770
Mỗi tổng hợp này sẽ có một kho lưu trữ tương ứng nên sẽ có một kho tài khoản và một kho lưu trữ khách hàng từ chối.

18
00:03:17,780 --> 00:03:25,730
Tòa án sẽ độc lập viện dẫn các chức năng hoặc hoạt động trên kho lưu trữ tài khoản cũng như kho lưu trữ của khách hàng.

19
00:03:26,000 --> 00:03:39,350
Ví dụ: nếu có nhu cầu tạo chế độ xem toàn diện về tài khoản, mã khách hàng sẽ chịu trách nhiệm hợp nhất dữ liệu từ hai kho lưu trữ để tạo chế độ xem tổng thể.

20
00:03:39,710 --> 00:03:53,060
Các đối tượng kho lưu trữ được quản lý như một phần của lớp miền.  Ngoài các chức năng thẻ điển hình, kho lưu trữ cũng có thể hiển thị các chức năng cấp cao hơn, chủ yếu dành cho truy vấn.

21
00:03:53,060 --> 00:04:03,270
Ví dụ: đối tượng kho lưu trữ tài khoản có thể hiển thị một chức năng không hoạt động để truy xuất các tài khoản không hoạt động kể từ ngày nhất định.

22
00:04:03,290 --> 00:04:12,470
Vì vậy, chức năng này có thể được sử dụng bởi khách hàng muốn có được tài khoản mà không có hoạt động nào được thực hiện kể từ ngày cụ thể nhất định.

23
00:04:12,470 --> 00:04:30,110
Để đáp lại lệnh gọi hàm get inactive, kho lưu trữ tài khoản có thể thực thi một câu lệnh chọn với một mệnh đề mơ hồ hoặc có thể gọi một API trên cơ sở dữ liệu không an toàn để truy xuất các tài liệu phù hợp với tiêu chí đã chỉ định.

24
00:04:30,800 --> 00:04:40,910
Tiếp theo, hãy nói về sự kiên trì.  Hãy nhớ lại bài giảng về tập hợp rằng tập hợp được chèn, cập nhật và xóa một cách nguyên tử.

25
00:04:40,910 --> 00:04:49,640
Là một phần của bài giảng đó, tôi đã thảo luận về một hàm trên đối tượng tài khoản yêu cầu cập nhật trên hai bảng trong cơ sở dữ liệu.

26
00:04:49,970 --> 00:04:59,940
Và ý tưởng ở đây là hai bảng này sẽ được cập nhật trong một đơn vị công việc.  Khía cạnh gần như này của tổng hợp được thực thi bởi kho lưu trữ.

27
00:05:00,170 --> 00:05:11,990
Ý tưởng là tất cả những thay đổi về trạng thái của tập hợp là lộ trình tổng hợp cũng như đối tượng bên trong đều được thực hiện theo một đơn vị công việc.

28
00:05:12,140 --> 00:05:20,950
Tất cả các thay đổi đối với cơ sở dữ liệu đều thành công hoặc không có thay đổi nào được thực hiện đối với bất kỳ thực thể nào là một phần của tổng hợp.

29
00:05:20,960 --> 00:05:37,460
Và điều này có thể xảy ra nếu có bất kỳ lỗi nào trong hoạt động cơ sở dữ liệu đối với bất kỳ thực thể nào.  Nhìn chung, lợi ích chính của việc sử dụng kho lưu trữ là nó giữ cho mô hình miền độc lập với lớp lưu trữ.

30
00:05:37,490 --> 00:05:50,180
Mô hình miền độc lập với mô hình lưu trữ.  Vì vậy, ví dụ: nếu bạn đang sử dụng RDBMS thì mô hình miền không cần phải biết về cấu trúc bảng và cột.

31
00:05:50,480 --> 00:06:00,620
Nó giữ cho mô hình miền độc lập với công nghệ bạn có thể đang sử dụng và RDBMS không bằng nhau hoặc thậm chí là một hệ thống tệp để lưu trữ tổng hợp.

32
00:06:00,620 --> 00:06:18,680
Nhưng mô hình miền không cần biết về nó.  Kho lưu trữ giữ cho mô hình miền độc lập với cơ sở hạ tầng mà bạn có thể đang sử dụng để bận rộn đưa ra các câu lệnh của phần tiếp theo đối với RDBMS hoặc bạn có thể đang sử dụng SDK để kết nối với cơ sở dữ liệu không có phần tiếp theo.

33
00:06:19,250 --> 00:06:33,040
Các.  Ý tưởng của bạn là bất kỳ thay đổi nào đối với cơ sở dữ liệu, bạn sẽ bị cô lập với đối tượng kho lưu trữ và sẽ không có tác động đến kho lưu trữ mô hình miền của bạn cũng có thể giúp kiểm tra và mô phỏng đơn vị.

34
00:06:33,170 --> 00:06:42,350
Ý tưởng rất đơn giản để thực hiện kiểm tra mã máy khách.  Cơ sở dữ liệu có thể được thay thế bằng cách triển khai mô hình cơ sở dữ liệu.

35
00:06:42,370 --> 00:06:59,840
Ví dụ: đây có thể là các pogo đơn giản hoặc các đối tượng Java đơn giản đang quay trở lại.  Phản hồi cơ sở dữ liệu tĩnh được sử dụng rộng rãi làm cơ chế xây dựng mô hình vì nó giúp tôi di chuyển nhanh hơn mà không phụ thuộc vào sự sẵn có của cơ sở dữ liệu thực.

36
00:07:00,550 --> 00:07:09,430
Một mối quan tâm chung đối với các kho lưu trữ là đối với các đối tượng tổng hợp lớn, có thể có tác động đến hiệu suất.

37
00:07:09,430 --> 00:07:26,680
Và lý do cho mối lo ngại này là đối với các đối tượng tổng hợp lớn, có thể cần phải thực thi nhiều thao tác cơ sở dữ liệu hoặc có thể cần phải nối trên nhiều bảng, điều này có thể dẫn đến hiệu suất truy vấn dưới mức tối ưu để giải quyết mối lo ngại này.

38
00:07:26,920 --> 00:07:40,000
Người ta có thể cân nhắc việc sử dụng các giải pháp bộ nhớ đệm như Radice và Memcache.  Một mối quan tâm chung khác liên quan đến việc sử dụng các truy vấn dựa trên tiêu chí trong kho.

39
00:07:40,420 --> 00:07:50,990
Thông thường, kho lưu trữ hiển thị thao tác truy xuất để truy xuất toàn bộ đối tượng tổng hợp và một số ứng dụng có thể không cần đến nó.

40
00:07:51,250 --> 00:07:59,190
Ví dụ: trong trường hợp ứng dụng di động dành cho ngân hàng, nó có thể không cần tất cả thông tin về tài khoản.

41
00:07:59,230 --> 00:08:09,160
Nó có thể chỉ cần những thông tin cơ bản.  Vì vậy, nói cách khác, chỉ một phần kết quả là được yêu cầu, không được đối tượng kho lưu trữ hỗ trợ ngay lập tức.

42
00:08:09,190 --> 00:08:26,110
Ngoài ra, có thể có trường hợp cần dữ liệu từ nhiều tập hợp.  Điều này đặc biệt quan trọng đối với ứng dụng di động nơi tốc độ chậm có thể ảnh hưởng đến sự quan tâm của người dùng đối với ứng dụng.

43
00:08:26,260 --> 00:08:39,970
Có hai cách để bạn có thể giải quyết mối lo ngại này.  Đầu tiên là hiển thị các hàm cấp cao trong kho lưu trữ và thứ hai là hiển thị các truy vấn bổ sung bên ngoài kho lưu trữ.

44
00:08:40,180 --> 00:08:54,380
Thêm về chủ đề này trong một bài giảng sau.  Việc hiện thực hóa kho lưu trữ yêu cầu nhà phát triển phải ánh xạ giữa đối tượng miền và cơ sở dữ liệu và ngược lại.

45
00:08:54,440 --> 00:09:01,630
Việc ánh xạ này có thể khá phức tạp và có thể khá cồng kềnh đối với các đối tượng lớn.  Điều này liên quan đến đâu?

46
00:09:01,640 --> 00:09:13,820
Bạn có thể cân nhắc sử dụng các khung ánh xạ có sẵn ở đó.  Các khung ánh xạ này đơn giản hóa nhiệm vụ ánh xạ giữa các đối tượng miền và cơ sở dữ liệu.

47
00:09:14,420 --> 00:09:24,140
Trong bài học này, bạn đã tìm hiểu về các đối tượng kho lưu trữ mẫu kho lưu trữ làm cho mô hình miền độc lập với lớp cơ sở dữ liệu.

48
00:09:24,440 --> 00:09:37,390
Các hoạt động cơ sở dữ liệu trên tổng hợp phải là nguyên tử, đối tượng kho lưu trữ và các lực lượng.  Các đối tượng kho lưu trữ nguyên tử cũng có thể được sử dụng để thử nghiệm và mô phỏng đơn vị.

49
00:09:37,670 --> 00:10:01,910
Có một số mối quan tâm chung liên quan đến các đối tượng kho lưu trữ, nhưng những mối quan tâm chung này liên quan đến chức năng truy vấn có thể được giải quyết bằng cách hiển thị các hàm truy vấn cấp cao trong đối tượng kho lưu trữ bằng cách sử dụng các giải pháp bộ nhớ đệm như Radice và Memcache cũng như bằng cách tạo và hiển thị các hàm truy vấn bên ngoài  của đối tượng kho lưu trữ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000011.srt -->

1
00:00:00,240 --> 00:00:15,310
Trong bài học này, chúng ta sẽ lập mô hình các đối tượng kho lưu trữ trong mô hình Acme, sau đó tôi sẽ hướng dẫn bạn một số mã kiểm tra và bạn cũng sẽ thấy mã kiểm tra hoạt động ở cuối bài giảng này.

2
00:00:16,080 --> 00:00:28,150
Mục tiêu của tôi đằng sau mô hình và hướng dẫn mã là cung cấp cho bạn ý tưởng về kho lưu trữ, tất cả các tệp mã và mô hình có sẵn trong cảnh tượng nhánh get.

3
00:00:28,530 --> 00:00:39,070
Tôi sẽ hướng dẫn bạn một số tệp mã, nhưng không phải tất cả.  Bạn có thể tự mình xem qua các tệp mã khác và chỉ cần lưu ý rằng đó là tùy chọn.

4
00:00:39,870 --> 00:00:52,030
Như tôi đã nói trước đó, mục đích là giúp bạn hiểu rõ về kho lưu trữ.  Thay vì dạy bạn Java, bạn có thể triển khai các mô hình mà tôi đã thảo luận trong khóa học này bằng bất kỳ ngôn ngữ nào.

5
00:00:52,260 --> 00:01:00,570
Và xin lưu ý rằng tòa án đã trình bày đơn giản để mọi người dễ theo dõi.  Một vài điểm nhanh trước khi chúng ta tiếp tục với bài học này.

6
00:01:00,570 --> 00:01:20,950
Một thực thể có đối tượng bằng 0 cũng được gọi là gốc tổng hợp và có mối quan hệ 1-1 giữa các tập hợp và kho lưu trữ vì có mối quan hệ 1-1 giữa các tập hợp và đối tượng kho lưu trữ trong mô hình viết tắt.

7
00:01:20,970 --> 00:01:33,240
Chúng tôi sẽ có nhiều kho lưu trữ, một kho lưu trữ cho mỗi tuyến đường tổng hợp.  Các đối tượng kho lưu trữ này có chức năng của Expo như một phần của giao diện.

8
00:01:33,270 --> 00:02:05,230
Họ không thực hiện việc thực hiện chức năng thực tế của hệ thống lưu trữ.  Tất cả các tương tác của hệ thống lưu trữ được tách biệt trong một tập hợp các đối tượng riêng biệt triển khai giao diện kho lưu trữ, ví dụ: tuyến tổng hợp khách hàng sẽ được liên kết với giao diện khách hàng và giao diện khách hàng đó sẽ được đối tượng báo cáo khách hàng triển khai, chẳng hạn như một  cơ sở dữ liệu.

9
00:02:05,440 --> 00:02:20,830
Nó có thể được triển khai lại cho hệ thống tập tin.  Và lợi ích của phương pháp này là các đối tượng trong lớp này có thể được thay thế mà không ảnh hưởng đến các máy khách đang sử dụng giao diện do các đối tượng kho lưu trữ cung cấp.

10
00:02:22,040 --> 00:02:35,700
Mô hình bán hàng Acme nào được xác định cho tất cả các giao diện đối tượng kho lưu trữ trong gói, mô hình Commodore Achmat hoặc kho lưu trữ để kiểm tra các giao diện kho lưu trữ này?

11
00:02:35,720 --> 00:02:46,790
Tôi đã quyết định tạo triển khai giả mạo các đối tượng kho lưu trữ và các đối tượng kho lưu trữ giả mạo này sẽ triển khai các giao diện kho lưu trữ.

12
00:02:46,910 --> 00:03:00,060
Ý tưởng là trong tương lai chúng ta có thể quyết định tạo một tập hợp đối tượng REPL khác, sẽ triển khai các chức năng giao diện nhưng sẽ thực hiện các tương tác với cơ sở dữ liệu thực tế.

13
00:03:00,080 --> 00:03:13,060
Vì vậy, trên thực tế, các lớp trong mô hình Commodore Akhmad báo cáo gói cơ sở dữ liệu của chúng tôi sẽ triển khai các giao diện tương ứng và Commodore Achmad hoặc mô hình hoặc bộ ba.

14
00:03:13,100 --> 00:03:23,740
Chúng ta hãy đi qua các chi tiết của kho lưu trữ của khách hàng.  Giao diện khách hàng sẽ được xác định trong gói Kamden Achmad hoặc được mô hình hóa trên Triple.

15
00:03:24,690 --> 00:03:43,210
Chúng sẽ là các khai báo chức năng trong giao diện khách hàng.  Sẽ có một chức năng quảng cáo để tạo và cập nhật đối tượng khách hàng, sau đó sẽ có một chức năng khách sẽ lấy số tham chiếu mà khách hàng được xác định để truy xuất khách hàng.

16
00:03:43,380 --> 00:03:56,160
Sau đó có thể có chức năng tìm kiếm khách hàng dựa trên email hoặc số điện thoại.  Ngoài ra còn có chức năng xóa lấy số tham chiếu của khách hàng để xóa đối tượng khách hàng.

17
00:03:56,170 --> 00:04:12,930
Việc triển khai giả mạo giao diện báo cáo này nằm trong gói mô hình hoặc thử nghiệm Commodore.  Không phải giả mạo, không phải repo, nhưng trong này sẽ có một lớp triển khai repo khách hàng giả mạo thực hiện giao diện khách hàng.

18
00:04:12,960 --> 00:04:23,050
Chúng ta hãy xem cách triển khai Java cho hai phần mềm này trong gói repo.  Mở mã repo khách hàng và tại đây bạn sẽ tìm thấy chức năng quảng cáo để lấy chức năng.

19
00:04:23,070 --> 00:04:29,370
Chức năng nhận cấp cao để truy xuất khách hàng dựa trên email hoặc số điện thoại.  Và sau đó có một số chức năng loại bỏ.

20
00:04:29,370 --> 00:04:39,270
Việc triển khai giả mạo có sẵn trong quá trình thử nghiệm.  Fake không repo khách hàng repo giả.  Và như bạn có thể thấy ở đây, lớp này triển khai giao diện repo khách hàng.

21
00:04:39,270 --> 00:04:47,850
Vì đây là cách triển khai giả mạo nên nó được triển khai dưới dạng danh sách mảng sẽ giữ lại đối tượng khách hàng trong bộ sưu tập trong bộ nhớ.

22
00:04:47,850 --> 00:04:59,930
Chức năng quảng cáo chỉ đơn giản là thêm khách hàng vào bộ sưu tập.  Chức năng tốt là duyệt qua các đối tượng trong bộ sưu tập, tìm kiếm khách hàng có số tham chiếu phù hợp và cấp độ cao.

23
00:04:59,940 --> 00:05:09,590
Chức năng đó bằng cách gọi hàm trên đối tượng khách hàng để kiểm tra xem khách hàng có email hoặc số điện thoại được chỉ định hay không.

24
00:05:09,600 --> 00:05:15,550
Và sau đó có hai chức năng xóa này để xóa khách hàng khỏi bộ sưu tập tại thời điểm này.

25
00:05:15,570 --> 00:05:24,170
Tôi khuyên bạn nên xem các mô hình để đề xuất gói kỳ nghỉ và tự mình xác nhận đặt phòng sau khi hoàn tất.

26
00:05:24,470 --> 00:05:36,000
Hãy xem nhanh cách triển khai mã Java cho các mô hình này.  Vì vậy, vui lòng tạm dừng video, thực hiện hoạt động này và cùng tôi xem một số mã đang hoạt động.

27
00:05:37,710 --> 00:05:45,060
Được rồi, hy vọng bạn đã tìm thấy mô hình và báo giá, dễ làm theo và chúng ta đã sẵn sàng chuyển sang bước tiếp theo.

28
00:05:45,450 --> 00:05:52,440
Hãy nhớ lại sơ đồ trình tự này trong sơ đồ trình tự mà chúng ta đang mô tả mà khách hàng gọi là bộ phận bán hàng Acme.

29
00:05:52,440 --> 00:06:04,230
Đại lý bán hàng lấy thông tin của khách hàng bằng số điện thoại hoặc email của họ.  Sau đó, họ chọn một số gói kỳ nghỉ dựa trên mong muốn của khách hàng.

30
00:06:04,230 --> 00:06:15,140
Ngân sách, v.v., tạo ra các đề xuất.  Khách hàng thích một trong những đề xuất và chọn nó, sau đó đại lý bán hàng sẽ tạo xác nhận đặt phòng.

31
00:06:15,240 --> 00:06:24,300
Tiếp theo, tôi sẽ chỉ cho bạn cách triển khai trình tự này trong mã Java.  Rõ ràng, nó chỉ nhằm mục đích thử nghiệm mã Java.

32
00:06:24,420 --> 00:06:35,390
Tôi đang sử dụng các mô hình bán hàng Acme mà chúng tôi đã phát triển cho đến nay.  Vì vậy, hãy nhìn vào mã.  Mã kiểm tra có sẵn trong gói kiểm tra.

33
00:06:35,400 --> 00:06:50,050
Tên của tệp Java là repo bộ sưu tập test.  Ở đây trong đoạn mã này, bạn sẽ thấy rằng tôi đang tạo bốn kho lưu trữ giả và tiến hành khởi tạo các kho lưu trữ này trong hàm tĩnh.

34
00:06:50,070 --> 00:07:02,050
Vì vậy, ví dụ, trong hàm tạo khách hàng, tôi đang tạo một phiên bản của kho lưu trữ giả cho khách hàng, sau đó tạo đối tượng khách hàng và thêm vào kho lưu trữ của khách hàng.

35
00:07:02,070 --> 00:07:14,820
Tương tự, trong hàm tạo gói kỳ nghỉ, tạo kho lưu trữ gói kỳ nghỉ giả, sau đó tạo các phiên bản gói kỳ nghỉ, sau đó thêm nó vào kho lưu trữ gói kỳ nghỉ.

36
00:07:14,940 --> 00:07:33,610
Và sau đó là tạo đề xuất và tạo xác nhận đặt chỗ để tạo dữ liệu giả cho các đề xuất, cũng như để xác nhận đặt chỗ, luồng đó được trích dẫn trong chức năng chính ở đây, bạn sẽ thấy rằng chúng tôi đang đồng hóa trình tự từ đầu đến cuối mà tôi đã thảo luận.

37
00:07:33,720 --> 00:07:43,350
Điều đầu tiên xảy ra là khách hàng gọi đến bộ phận bán hàng của Acme.  Nhân viên bán hàng sử dụng số điện thoại của khách hàng để rút hồ sơ cho khách hàng.

38
00:07:43,350 --> 00:07:56,780
Thông tin khách hàng được in trên bảng điều khiển khi một đại lý bán hàng bổ sung thu thập các sở thích về kỳ nghỉ của khách hàng và quyết định thảo luận về gói kỳ nghỉ ở Bahamas.

39
00:07:56,820 --> 00:08:05,040
Thế là anh ấy lấy ra thông tin về gói du lịch Bahamas ba đêm.  Thông tin về gói kỳ nghỉ sẽ được in trên bảng điều khiển.

40
00:08:05,220 --> 00:08:14,120
Sau đó người đại diện bắt đầu chuẩn bị đề xuất.  Đối tượng đề xuất được tạo và có hai người giữ chỗ cho gói này.

41
00:08:14,130 --> 00:08:23,910
Cái đầu tiên dành cho khách sạn và cái thứ hai dành cho các hãng hàng không.  Vì vậy, đại lý thiết lập ngày nhận phòng và trả phòng để đặt phòng khách sạn.

42
00:08:24,030 --> 00:08:39,240
Sau đó, đặc vụ thiết lập thông tin chuyến bay cho cuộc chiến đi và đến.  Vì lợi ích của cuộc thảo luận này, hãy giả sử rằng có một hệ thống riêng biệt mà đại lý bán hàng nhận được thông tin chuyến bay.

43
00:08:39,450 --> 00:08:50,760
Đề xuất được thêm vào kho lưu trữ đề xuất và đề xuất được in ra bảng điều khiển.  Giả sử rằng khách hàng cam kết với đề xuất.

44
00:08:50,910 --> 00:09:02,880
Sau khi khách hàng cam kết với đề xuất, một phiên bản xác nhận đặt chỗ sẽ được tạo và đối tượng xác nhận đặt chỗ này sẽ được thêm vào kho lưu trữ xác nhận đặt chỗ.

45
00:09:02,880 --> 00:09:09,990
Và đây sẽ là phần cuối của chuỗi bài kiểm tra này.  Hãy tiếp tục và chạy thử nghiệm này ngay.  Bấm chạy.

46
00:09:10,320 --> 00:09:23,160
Vì vậy, đây là đầu ra của chúng tôi.  Chúng tôi có thông tin về khách hàng mà đại lý bán hàng rút ra.  Dưới đây là thông tin về gói nghỉ dưỡng mà đại lý bán hàng đã khóa.

47
00:09:23,160 --> 00:09:32,040
Đó là thông tin về đề xuất.  Và điều thú vị cần chú ý ở đây chính là thông tin về 2 người giữ chỗ.

48
00:09:32,040 --> 00:09:40,500
Vì vậy, ở đây, như bạn có thể thấy, khách hàng sẽ lưu trú tại Khách sạn Western tốt nhất vào những ngày được chỉ định trong đặt phòng.

49
00:09:40,500 --> 00:09:49,440
Và các chuyến bay đều từ United Airlines.  Có thông tin về số chuyến bay và sân bay cho những chuyến bay đó.

50
00:09:49,440 --> 00:10:01,380
Và sau đó, như mong đợi, xác nhận đặt phòng ở trạng thái chờ thanh toán.  Và có thông tin về đề xuất, khách hàng và các đặt chỗ khác nhau.

51
00:10:01,380 --> 00:10:11,670
Tôi khuyên bạn nên tự mình đi đến điểm số và dùng thử để cảm nhận cách hoạt động của các đối tượng kho lưu trữ và các thành phần mô hình khác.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000012.srt -->

1
00:00:00,120 --> 00:00:11,760
Trong bài học này, bạn sẽ tìm hiểu về các dịch vụ miền và đặc điểm của chúng, giả sử có một ngân hàng cung cấp ba loại sản phẩm tài khoản tiết kiệm, tài khoản séc và tài khoản vay.

2
00:00:12,150 --> 00:00:24,810
Giả sử có yêu cầu là khách hàng chỉ có thể đăng ký tài khoản vay nếu số dư tổng hợp, tài khoản tiết kiệm và tài khoản séc của họ lớn hơn mười nghìn đô la.

3
00:00:24,840 --> 00:00:35,380
Hiện tại, yêu cầu cụ thể này không thể được coi là hành vi trong bất kỳ thực thể nào trong số này vì nó không phù hợp một cách tự nhiên với bất kỳ thực thể nào trong số này.

4
00:00:35,490 --> 00:00:44,010
Vì vậy, câu hỏi dành cho bạn là bạn sẽ xây dựng chức năng này ở đâu?  Đây là nơi dịch vụ tên miền xuất hiện.

5
00:00:44,490 --> 00:00:54,770
Ý tưởng là thực hiện hành vi không thuộc về tài khoản tiết kiệm hoặc tài khoản séc trong dịch vụ độc lập độc lập này.

6
00:00:55,140 --> 00:01:09,030
Cách thức hoạt động là người gọi hoặc mã khách hàng có thể thực hiện một thao tác trên dịch vụ kiểm tra tính đủ điều kiện cho khoản vay để tìm hiểu xem khách hàng có đủ điều kiện cho khoản vay hay không.

7
00:01:09,510 --> 00:01:30,100
Sau đó, dịch vụ kiểm tra tính đủ điều kiện cho khoản vay có thể thực hiện một thao tác trên thực thể tài khoản tiết kiệm để lấy số dư, thực hiện thao tác tương tự đối với tài khoản séc và sau đó thực hiện logic nghiệp vụ cần thiết, đó là thêm số dư từ tài khoản tiết kiệm và  kiểm tra tài khoản và kiểm tra xem nó có lớn hơn 10000 không.

8
00:01:30,120 --> 00:01:37,640
Và đây chính là cách dịch vụ kiểm tra điều kiện vay sẽ xác định xem khách hàng có đủ điều kiện vay hay không.

9
00:01:38,100 --> 00:02:00,130
Một định nghĩa chính thức hơn về dịch vụ miền là đối tượng miền thực hiện chức năng hoặc khái niệm miền có thể không được mô hình hóa một cách tự nhiên như một hành vi trong bất kỳ dịch vụ miền, thực thể hoặc đối tượng giá trị nào như một phần của mô hình miền, vì có  các loại dịch vụ khác nhau.

10
00:02:00,150 --> 00:02:09,390
Điều quan trọng là bạn phải hiểu các đặc điểm của dịch vụ tên miền.  Dịch vụ miền luôn thực hiện hành vi kinh doanh cho miền.

11
00:02:09,540 --> 00:02:17,830
Dịch vụ miền không có trạng thái, dịch vụ miền có tính gắn kết cao.  Dịch vụ miền có thể tương tác với các dịch vụ miền khác.

12
00:02:17,880 --> 00:02:29,220
Chúng ta hãy đi qua các chi tiết của từng một trong số này.  Vì dịch vụ miền có hành vi kinh doanh nên đối tượng dịch vụ miền nhận thức được các đối tượng miền khác.

13
00:02:29,790 --> 00:02:38,400
Trong trường hợp dịch vụ kiểm tra tính đủ điều kiện cho khoản vay, dịch vụ này sẽ biết về thực thể tài khoản tiết kiệm và thực thể tài khoản séc.

14
00:02:38,550 --> 00:02:49,580
Việc kiểm tra khả năng đủ điều kiện cho vay có các quy tắc kinh doanh nhưng nhìn chung, các dịch vụ miền có thể có quy trình làm việc và logic quyết định tính toán cho miền.

15
00:02:49,800 --> 00:03:05,190
Nói tóm lại, bất kỳ loại khái niệm miền nào cũng có thể được triển khai trong dịch vụ miền.  Màu sắc của dịch vụ miền không nhận biết được chi tiết về hành vi được triển khai trong dịch vụ miền.

16
00:03:05,190 --> 00:03:15,670
Vì vậy, dịch vụ miền cách ly người gọi hoặc mã máy khách khỏi các chi tiết logic nghiệp vụ.  Dịch vụ miền không duy trì trạng thái giữa các cuộc gọi.

17
00:03:15,770 --> 00:03:26,430
Điều đó có nghĩa là nếu bạn đang gọi dịch vụ miền thì không có biến trạng thái hoặc cơ chế duy trì trực tiếp nào được tích hợp trong dịch vụ miền.

18
00:03:26,460 --> 00:03:33,030
Bây giờ bạn có thể lập luận rằng có những trường hợp logic kinh doanh thực hiện tính bền bỉ và bạn đã đúng.

19
00:03:33,300 --> 00:03:57,150
Trong trường hợp đó, dịch vụ miền phụ thuộc vào các đối tượng thực thể để đảm bảo tính bền vững.  Vì vậy, hàm ý của việc không có biến trạng thái hoặc độ bền là có thể có các cuộc gọi đến từ nhiều người gọi hoặc khách hàng, nhưng không có mối tương quan giữa các cuộc gọi này và việc cuộc gọi đến từ cùng một khách hàng hay khách hàng khác không thành vấn đề.

20
00:03:57,300 --> 00:04:06,050
Vì vậy, điểm mấu chốt là không có mối tương quan giữa bất kỳ cuộc gọi nào bắt nguồn từ bất kỳ tên miền nào.  Các dịch vụ có tính gắn kết cao.

21
00:04:06,060 --> 00:04:19,980
Điều đó có nghĩa là dịch vụ tên miền thực hiện một và chỉ một việc và không coi trọng khoản vay.  Dịch vụ kiểm tra đủ điều kiện thực hiện việc kiểm tra xem khách hàng có đủ điều kiện vay vốn hay không.

22
00:04:20,010 --> 00:04:30,530
Đây là một ví dụ khác.  Dịch vụ phê duyệt khoản vay.  Dịch vụ xét duyệt khoản vay này thực hiện các quy định và mức sàn cho hồ sơ vay.

23
00:04:30,810 --> 00:04:42,030
Nói cách khác, khi khách hàng đăng ký vay, đây là dịch vụ đảm nhận quy trình làm việc và các quy định phê duyệt hồ sơ vay cho khách hàng.

24
00:04:42,930 --> 00:04:58,770
Một dịch vụ miền có thể tương tác với các dịch vụ miền khác.  Hãy để tôi giải thích điều này bằng một ví dụ.  Giả sử có một dịch vụ hỗ trợ tên miền mà khách hàng hoặc người phụ trách chuyên mục gọi để bắt đầu quy trình đăng ký khoản vay.

25
00:04:59,400 --> 00:05:08,470
Việc đầu tiên mà dịch vụ đăng ký vay này cần làm là kiểm tra xem khách hàng có đủ điều kiện đăng ký vay hay không.

26
00:05:08,490 --> 00:05:18,180
Và nó có thể làm điều đó bằng cách thực hiện một thao tác trên dịch vụ kiểm tra khả năng đủ điều kiện cho vay.  Logic trong khoản vay áp dụng sẽ tương tự như biến thể này.

27
00:05:18,420 --> 00:05:32,190
Nếu khách hàng đủ điều kiện vay, dịch vụ đăng ký khoản vay sẽ bắt đầu quy trình phê duyệt khoản vay bằng cách kêu gọi hợp tác về dịch vụ miền phê duyệt khoản vay.

28
00:05:32,670 --> 00:05:44,010
Vì vậy, như bạn có thể thấy ở đây, một dịch vụ miền có thể gọi hoạt động trên các dịch vụ miền khác.  Trước khi kết thúc bài học này, tôi muốn nhấn mạnh một điểm quan trọng.

29
00:05:44,010 --> 00:05:54,930
Dịch vụ tên miền là bất khả tri về công nghệ.  Có một quan niệm sai lầm phổ biến rằng dịch vụ của người bán hàng rong nên được coi là một hoạt động kinh doanh là không đúng.

30
00:05:55,380 --> 00:06:12,770
Dịch vụ miền độc lập với công nghệ được sử dụng để gọi.  Ví dụ: hoạt động dịch vụ miền, có thể chỉ là lệnh gọi hàm Java đơn giản hoặc có thể được thực hiện qua giao thức mạng như SCDP hoặc MQ.

31
00:06:13,170 --> 00:06:20,070
Thông tin thêm về chủ đề này khi chúng ta tiến bộ trong suốt khóa học.  Đã đến lúc bắt đầu với những điểm chính mà chúng ta đã đề cập trong bài học này.

32
00:06:20,520 --> 00:06:29,280
Tôi đã nói về dịch vụ miền và bạn cần phải biết những đặc điểm của dịch vụ miền giúp phân biệt nó với các loại dịch vụ khác.

33
00:06:29,620 --> 00:06:40,740
Đầu tiên là dịch vụ miền thực hiện hành vi miền không phù hợp một cách tự nhiên với các thực thể và đối tượng giá trị khác trong mô hình miền.

34
00:06:41,100 --> 00:06:50,310
Các đặc điểm khác là dịch vụ miền không có trạng thái, dịch vụ miền có tính Cohasset cao và dịch vụ miền với các dịch vụ miền khác.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000013.srt -->

1
00:00:00,180 --> 00:00:11,920
Dịch vụ ứng dụng, trong bài học này, bạn sẽ tìm hiểu dịch vụ ứng dụng khác với dịch vụ miền như thế nào và bạn cũng sẽ tìm hiểu về các đặc điểm của dịch vụ ứng dụng.

2
00:00:12,630 --> 00:00:26,820
Đã đến lúc cho một bài kiểm tra.  Giả sử mô hình miền của ngân hàng có ba thực thể này.  Bạn được yêu cầu tạo danh mục khách hàng dịch vụ, danh mục này sẽ cung cấp tất cả dữ liệu từ ba thực thể này.

3
00:00:26,850 --> 00:00:42,710
Câu hỏi dành cho bạn là liệu bạn có triển khai nó như một dịch vụ miền không?  Câu trả lời ngắn gọn là bạn sẽ không triển khai dịch vụ này dưới dạng dịch vụ miền vì nó không có bất kỳ chức năng miền nào.

4
00:00:43,100 --> 00:00:52,520
Chúng ta hãy xem lại định nghĩa về dịch vụ tên miền.  Nó tuyên bố rằng dịch vụ miền là một đối tượng miền thực hiện chức năng miền.

5
00:00:52,850 --> 00:01:01,810
Và vì dịch vụ danh mục khách hàng sẽ không triển khai bất kỳ chức năng miền nào nên chúng tôi không thể triển khai nó dưới dạng dịch vụ miền.

6
00:01:01,820 --> 00:01:09,220
Và đây là nơi các dịch vụ ứng dụng xuất hiện.  Đó là một định nghĩa chính thức hơn về một dịch vụ ứng dụng.

7
00:01:09,560 --> 00:01:22,940
Nó là một đối tượng miền không triển khai bất kỳ chức năng miền nào mà phụ thuộc vào các đối tượng miền khác để hiển thị chức năng miền cấp cao cho bên ngoài của người tiêu dùng đối với mô hình.

8
00:01:23,570 --> 00:01:36,110
Sự khác biệt chính giữa dịch vụ miền và dịch vụ ứng dụng là dịch vụ ứng dụng không triển khai bất kỳ loại logic nghiệp vụ hoặc chức năng miền nào.

9
00:01:36,410 --> 00:01:48,330
Sự khác biệt lớn khác là dịch vụ ứng dụng được tiếp xúc với người tiêu dùng bên ngoài như ứng dụng Web, ứng dụng di động hoặc dịch vụ ứng dụng.

10
00:01:48,650 --> 00:02:02,000
Chúng ta hãy đi qua các đặc điểm của một dịch vụ ứng dụng.  Dịch vụ ứng dụng không có logic miền và đây là điểm khác biệt chính giữa dịch vụ ứng dụng và dịch vụ miền.

11
00:02:02,000 --> 00:02:14,660
Các dịch vụ ứng dụng như dịch vụ miền đều không có trạng thái.  Các dịch vụ ứng dụng có thể xác định giao diện bên ngoài, các dịch vụ ứng dụng được hiển thị hoặc một số loại giao thức mạng.

12
00:02:14,900 --> 00:02:24,780
Chúng ta hãy đi qua các chi tiết của từng trong số này.  Một dịch vụ ứng dụng không có logic miền.  Nó phụ thuộc vào đối tượng miền khác cho logic miền.

13
00:02:25,220 --> 00:02:37,270
Đây là điểm khác biệt chính giữa dịch vụ miền và dịch vụ ứng dụng.  Dịch vụ ứng dụng điều phối việc thực thi logic miền.

14
00:02:37,700 --> 00:02:45,070
Vì vậy, trong trường hợp Dịch vụ ứng dụng danh mục khách hàng, logic điều phối sẽ như thế này.

15
00:02:45,440 --> 00:03:04,610
Trước tiên, dịch vụ sẽ gọi thao tác get trên thực thể khách hàng.  Sau đó, nó sẽ thực hiện thao tác trên thực thể tài khoản tiết kiệm và sau đó nó sẽ thực hiện thao tác nhận trên thực thể tài khoản séc, kết hợp dữ liệu từ ba thực thể này và trả lại cho người gọi.

16
00:03:05,330 --> 00:03:13,480
Giống như dịch vụ miền và dịch vụ ứng dụng cũng không có trạng thái.  Không có quản lý nhà nước được thực hiện trong dịch vụ ứng dụng.

17
00:03:13,610 --> 00:03:31,490
Không có biến trạng thái hoặc sự tồn tại lâu dài của các đối tượng miền được triển khai trong dịch vụ ứng dụng.  Dịch vụ ứng dụng phụ thuộc vào đối tượng miền để tồn tại lâu dài và dịch vụ ứng dụng hiển thị giao diện được thế giới bên ngoài sử dụng.

18
00:03:31,820 --> 00:03:47,560
Ở đây, thế giới bên ngoài đề cập đến các thành phần bên ngoài nằm ngoài mô hình miền.  Điểm cần lưu ý ở đây là giao diện tiếp xúc với thế giới bên ngoài không cần phải là một thực thể hoặc đối tượng giá trị.

19
00:03:47,570 --> 00:03:56,370
Nói cách khác, lược đồ yêu cầu và phản hồi cho dịch vụ ứng dụng không cần phải liên kết với bất kỳ đối tượng miền nào khác.

20
00:03:56,390 --> 00:04:08,420
Vì vậy, quay lại ví dụ về dịch vụ danh mục khách hàng, bước cuối cùng sẽ là chuyển đổi tất cả dữ liệu sang định dạng tin nhắn phản hồi mong muốn và gửi lại cho người gọi.

21
00:04:08,570 --> 00:04:26,080
Dịch vụ ứng dụng hiển thị giao diện bên ngoài hoặc giao thức mạng trong mô hình miền.  Dịch vụ ứng dụng có thể được coi như một đối tượng ranh giới bảo vệ tất cả các đối tượng trong mô hình miền.

22
00:04:26,300 --> 00:04:36,320
Dịch vụ ứng dụng có thể được hiển thị dưới dạng API và API này được các thành phần bên ngoài sử dụng qua giao thức mạng.

23
00:04:36,500 --> 00:04:49,180
Giao thức mạng này, có thể là SCDP, MQ hoặc thậm chí có thể là giao thức độc quyền.  Định dạng dữ liệu giữa năng lực bên ngoài và API rất linh hoạt.

24
00:04:49,220 --> 00:04:56,480
Nó có thể là Jason Ximo, CSFI hoặc bất kỳ định dạng nào khác.  Tùy thuộc vào việc thực hiện dịch vụ ứng dụng.

25
00:04:56,810 --> 00:05:15,200
Các thành phần bên ngoài có thể có hoặc không có kiến ​​thức về đối tượng miền hoặc cấu trúc của chúng.  Tiếp theo, tôi sẽ thảo luận về mối quan hệ giữa dịch vụ ứng dụng và dịch vụ miền và dịch vụ ứng dụng có thể hiển thị dịch vụ miền với thành phần bên ngoài.

26
00:05:15,200 --> 00:05:23,230
Đầu là một ví dụ.  Giả sử có một máy chủ ứng dụng cho vay appli cần được tiếp xúc với các thành phần bên ngoài.

27
00:05:23,270 --> 00:05:32,300
Bây giờ hãy nhớ lại chúng ta đã thảo luận và đăng ký trên dịch vụ miền, vì vậy dịch vụ đăng ký khoản vay này có thể sử dụng ứng dụng.

28
00:05:32,710 --> 00:05:47,820
Dịch vụ miền để cung cấp giao diện cho các thành phần bên ngoài.  Đã đến lúc đi vào những điểm chính trong bài học này bạn đã học về các ứng dụng, dịch vụ, ứng dụng, dịch vụ không triển khai bất kỳ hành vi miền nào.

29
00:05:48,010 --> 00:05:57,370
Chúng cung cấp các dịch vụ cấp cao bằng cách phối hợp thực thi logic miền trong các đối tượng miền.

30
00:05:57,520 --> 00:06:12,070
Các dịch vụ ứng dụng hiển thị giao diện cho các thành phần bên ngoài.  Nghĩa là, các thành phần nằm ngoài mô hình miền thông qua giao thức mạng như HTP và NQ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000014.srt -->

1
00:00:00,150 --> 00:00:25,530
Dịch vụ cơ sở hạ tầng, trong bài học này, bạn tìm hiểu xem dịch vụ cơ sở hạ tầng khác với dịch vụ miền và dịch vụ ứng dụng như thế nào, bạn cũng sẽ tìm hiểu về các đặc điểm của dịch vụ cơ sở hạ tầng và dịch vụ cơ sở hạ tầng được định nghĩa là dịch vụ tương tác với tài nguyên bên ngoài để giải quyết một vấn đề  mối quan tâm không thuộc phạm vi vấn đề chính.

2
00:00:25,680 --> 00:00:35,840
Nó xác định một hợp đồng được các đối tượng miền sử dụng để tương tác với các dịch vụ bên ngoài.  Từ khóa ở đây là nguồn lực bên ngoài.

3
00:00:36,360 --> 00:00:52,410
Chúng ta hãy xem qua một số ví dụ về các tài nguyên bên ngoài thường được sử dụng.  Đầu tiên là hệ thống đăng nhập.  Các đối tượng miền cần ghi nhật ký thông báo và điều này có thể được thực hiện đối với bất kỳ loại hệ thống ghi nhật ký bên ngoài nào như Florida hoặc ElasticSearch Domain.

4
00:00:52,410 --> 00:01:05,940
Đối tượng có thể cần gửi thông báo như một phần của quy trình kinh doanh.  Ví dụ: thông báo qua email hoặc SMS tới đối tượng miền của khách hàng chắc chắn cần một số loại cơ chế duy trì lâu dài.

5
00:01:06,120 --> 00:01:20,570
Và cơ chế bền vững này, có thể là cơ sở dữ liệu bên ngoài hoặc thậm chí là hệ thống tệp, đối tượng miền thường phụ thuộc vào các dịch vụ hoặc ứng dụng bên ngoài như API Salesforce hoặc thậm chí Google Map.

6
00:01:20,580 --> 00:01:30,630
Và đây chỉ là một số ví dụ phổ biến về các tài nguyên bên ngoài như dịch vụ ứng dụng.  Dịch vụ cơ sở hạ tầng không có logic miền.

7
00:01:30,630 --> 00:01:39,350
Dịch vụ cơ sở hạ tầng tuân theo nguyên tắc trách nhiệm duy nhất, dịch vụ cơ sở hạ tầng, giao diện hoặc hợp đồng tiêu chuẩn của hội chợ.

8
00:01:39,420 --> 00:01:50,760
Chúng ta hãy đi qua các chi tiết của từng một trong số này.  Dịch vụ cơ sở hạ tầng không có logic miền vì nó cung cấp, như tên cho thấy, dịch vụ cơ sở hạ tầng chứ không phải dịch vụ kinh doanh.

9
00:01:50,970 --> 00:02:08,000
Nó không có bất kỳ sự phụ thuộc trực tiếp nào vào đối tượng miền và dịch vụ cơ sở hạ tầng được đối tượng miền và các dịch vụ sử dụng để tương tác với các tài nguyên bên ngoài và dịch vụ cơ sở hạ tầng tuân theo nguyên tắc trách nhiệm duy nhất.

10
00:02:08,040 --> 00:02:18,640
Ý tưởng là dịch vụ này cung cấp chức năng cho một và chỉ một thứ.  Mục đích của họ là đơn giản hóa việc triển khai và làm cho dịch vụ trở nên dễ hiểu.

11
00:02:18,660 --> 00:02:29,100
Ví dụ: chúng tôi có ba dịch vụ này, mỗi dịch vụ chuyên cung cấp một chức năng cụ thể.  Ví dụ: dịch vụ email chỉ để gửi email.

12
00:02:29,130 --> 00:02:38,520
Dịch vụ ghi nhật ký chỉ để ghi nhật ký tin nhắn và dịch vụ cơ sở dữ liệu là để tương tác với cơ sở dữ liệu và cơ sở hạ tầng.

13
00:02:38,520 --> 00:02:52,140
Dịch vụ xác định một hợp đồng tiêu chuẩn giữa mô hình và các tài nguyên bên ngoài.  Hãy nghĩ về nó giống như một API, dành cho các đối tượng và dịch vụ mô hình sử dụng.

14
00:02:52,620 --> 00:03:03,990
Việc triển khai API nằm trong lớp cơ sở hạ tầng và điều này làm cho công nghệ mô hình và các dịch vụ bên ngoài trở nên bất khả tri.

15
00:03:05,050 --> 00:03:16,700
Đối tượng miền và nhu cầu tương tác với các tài nguyên bên ngoài sẽ thông qua API hoặc Dịch vụ cơ sở hạ tầng cơ thể được cung cấp theo hợp đồng tiêu chuẩn.

16
00:03:17,410 --> 00:03:27,490
Vì vậy, ở đây, ví dụ, một giao diện tiêu chuẩn cho một dịch vụ email có thể trông như thế này và có thể chỉ có một chức năng duy nhất là gửi email.

17
00:03:27,550 --> 00:03:37,300
Dịch vụ cơ sở hạ tầng sẽ tương tác với tài nguyên bên ngoài thông qua SDK hoặc API do tài nguyên bên ngoài cung cấp.

18
00:03:37,300 --> 00:03:47,110
Dịch vụ cơ sở hạ tầng sẽ thực hiện chuyển đổi cuộc gọi từ giao diện tiêu chuẩn sang giao diện được hiển thị bởi tài nguyên bên ngoài.

19
00:03:47,110 --> 00:03:59,210
Và nó cũng sẽ thực hiện bất kỳ loại chuyển đổi nào cần thiết trên dữ liệu.  Bây giờ hãy xem cơ chế này làm cho miền độc lập hơn với tài nguyên bên ngoài như thế nào.

20
00:03:59,740 --> 00:04:08,900
Giả sử chúng ta phải triển khai một dịch vụ email.  Dịch vụ e-mail này sẽ cung cấp chức năng tiêu chuẩn để gửi email.

21
00:04:08,920 --> 00:04:26,410
Ban đầu, dịch vụ e-mail được triển khai bằng cách sử dụng sendmail của Linux.  Nhưng giả sử trong một khoảng thời gian, số lượng email được gửi đi từ ứng dụng tăng lên và do đó cần có một giải pháp mạnh mẽ hơn và Sendmail đã được thay thế bằng MailChimp.

22
00:04:26,920 --> 00:04:45,550
Thay đổi này sẽ chỉ yêu cầu thay đổi trong dịch vụ email và sẽ không có tác động đến bất kỳ dịch vụ miền nào sử dụng dịch vụ email nội dung hiển thị theo hợp đồng tiêu chuẩn và do đó mô hình miền được cách ly khỏi các thay đổi tài nguyên bên ngoài.

23
00:04:46,390 --> 00:04:56,530
Trong bài giảng này, bạn đã tìm hiểu về các dịch vụ cơ sở hạ tầng.  Các dịch vụ cơ sở hạ tầng như dịch vụ ứng dụng không thực hiện bất kỳ hành vi miền nào.

24
00:04:56,530 --> 00:05:11,950
Các dịch vụ cơ sở hạ tầng cung cấp các tài nguyên bên ngoài thông qua giao diện tiêu chuẩn hoặc hợp đồng tiêu chuẩn và cơ chế hợp đồng tiêu chuẩn này bảo vệ mô hình miền khỏi những thay đổi trong dịch vụ bên ngoài.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000015.srt -->

1
00:00:00,610 --> 00:00:14,470
Bây giờ chúng ta cần phát triển một số dịch vụ trong mô hình bán hàng Achmea trong bài học này, bạn sẽ tìm hiểu về một lỗ hổng trong trình tự tạo đề xuất mà tôi đã thảo luận trong một số bài giảng trước đó.

2
00:00:14,920 --> 00:00:25,300
Khi đã hiểu được khuyết điểm thì chúng ta sẽ khắc phục được khuyết điểm đó.  Và vào cuối bài giảng này, chúng ta sẽ phát triển một dịch vụ có tên là Dịch vụ định giá đề xuất với tư cách là một dịch vụ CNTT.  chỉ huy.

3
00:00:25,540 --> 00:00:38,230
Bạn đã chuẩn bị sơ đồ trình tự cho quá trình tạo đề xuất và cách tốt nhất là nhận phản hồi về tất cả nội dung mô hình kinh doanh này từ các bên liên quan trong kinh doanh.

4
00:00:38,260 --> 00:00:51,540
Vì vậy, bạn quyết định cùng John John xem qua sơ đồ trình tự này, giống như công việc bạn đã làm.  Nhưng anh ấy nhận ra rằng chúng tôi đã bỏ lỡ bước định giá đề xuất trong sơ đồ trình tự này.

5
00:00:51,700 --> 00:01:05,020
Vì vậy, rõ ràng câu hỏi tiếp theo của bạn là điều gì liên quan đến việc định giá đề xuất?  John nói với chúng tôi rằng giá trọn gói được nêu trong gói kỳ nghỉ là giá cá nhân của chúng tôi.

6
00:01:05,620 --> 00:01:15,670
Và mức giá nêu trong gói kỳ nghỉ này chưa bao gồm thuế và phụ phí.  Vì vậy, tại thời điểm này, bạn quyết định làm hai việc.

7
00:01:15,940 --> 00:01:27,670
Bạn sẽ thêm phụ phí và các điều khoản về giá mỗi người vào từ vựng kinh doanh vốn là ngôn ngữ phổ biến của bạn và một số phụ phí là một thuật ngữ mới.

8
00:01:28,060 --> 00:01:35,470
Bạn muốn hiểu nó tốt hơn.  Vì vậy, bạn đã yêu cầu John cung cấp cho bạn thông tin chi tiết về cách tính các khoản phụ phí.

9
00:01:35,620 --> 00:01:46,480
Phụ phí được áp dụng bất cứ nơi nào có áp dụng.  Nó có thể được áp dụng cho các khu nghỉ dưỡng sân bay, ô tô cho thuê, cơ quan nhà nước và khách sạn.

10
00:01:46,840 --> 00:02:02,160
Số tiền phụ phí thay đổi tùy theo nhà cung cấp.  Các đại lý du lịch theo mùa và tiểu bang thường sử dụng bảng tính để tính giá của các đề xuất và các bảng tính này được cập nhật hàng quý.

11
00:02:02,350 --> 00:02:13,510
Vì vậy, mức giá cuối cùng cho đề xuất được tính bằng cách nhân số lượng hành khách với mục đích và giá cả của gói kỳ nghỉ.

12
00:02:13,510 --> 00:02:21,280
Tất cả các khoản phụ phí đều được cộng thêm và tất cả các loại thuế của tiểu bang đều được cộng thêm.  Và đây sẽ là mức giá cuối cùng cho lời đề xuất.

13
00:02:21,550 --> 00:02:29,690
Bây giờ bạn đã hiểu cách hoạt động của giá đề xuất, tôi có một câu hỏi dành cho bạn.  Bạn sẽ dựa vào đối tượng mô hình nào?

14
00:02:29,950 --> 00:02:43,480
Chức năng định giá?  Các lựa chọn của bạn nằm ở thực thể xác nhận đặt chỗ, dịch vụ miền, dịch vụ ứng dụng hoặc dịch vụ cơ sở hạ tầng.

15
00:02:43,780 --> 00:02:52,150
Vui lòng đăng video nếu bạn cần chút thời gian.  Hãy thảo luận về các lựa chọn này.  Phương án A không áp dụng được.

16
00:02:52,150 --> 00:03:08,800
Tại sao?  Bởi vì việc tính giá không phù hợp một cách tự nhiên trong việc đặt phòng.  Thực thể xác nhận CNBC không được áp dụng vì dịch vụ ứng dụng và dịch vụ cơ sở hạ tầng không có bất kỳ logic kinh doanh nào.

17
00:03:08,800 --> 00:03:17,830
Vì vậy, câu trả lời là ở một dịch vụ tên miền.  Tất cả việc tính toán giá, vốn là logic nghiệp vụ, sẽ được triển khai trong dịch vụ miền.

18
00:03:18,190 --> 00:03:29,950
Bây giờ, trước khi chúng ta tiến xa hơn, trước tiên hãy sửa sơ đồ trình tự đề xuất của chúng ta.  Sơ đồ trình tự được hướng tới bước số năm, nơi chúng ta tạo ra đề xuất.

19
00:03:29,950 --> 00:03:39,370
Sau bước số năm, chúng ta cần chèn tương tác của mình với dịch vụ miền định giá đề xuất.  Hãy để tôi thêm bước ở đây.

20
00:03:39,880 --> 00:03:54,730
Đại lý bán hàng sẽ thực hiện tính toán cho đề xuất bằng cách gọi dịch vụ định giá.  Dịch vụ định giá sẽ tiến hành tính toán và sau đó cập nhật mức giá cuối cùng trên đề xuất.

21
00:03:54,940 --> 00:04:02,160
Khi đó, đại lý sẽ có thể đọc đề xuất cùng với mức giá cuối cùng cho khách hàng.

22
00:04:02,470 --> 00:04:15,400
Vì vậy, đây là sự thay đổi mà chúng ta cần thực hiện đối với sơ đồ trình tự này.  Logic nghiệp vụ thông thường được mô tả dưới dạng sơ đồ luồng, sơ đồ thẳng hoặc sơ đồ hoạt động.

23
00:04:15,880 --> 00:04:27,070
Hãy cùng thực hiện với sơ đồ hoạt động dịch vụ miền định giá đề xuất.  Điều đầu tiên mà dịch vụ sẽ làm là kiểm tra các đề xuất, tính đầy đủ của nó để tìm bất kỳ thông tin còn thiếu nào.

24
00:04:27,250 --> 00:04:35,320
Nếu thiếu thông tin thì thông tin khác sẽ được trả về cột và quá trình định giá sẽ hoàn tất.

25
00:04:35,590 --> 00:04:46,900
Nếu không, mức giá tốt nhất cho đề xuất sẽ được tính bằng cách sử dụng số lượng hành khách cũng như mục đích và giá cả của gói kỳ nghỉ.

26
00:04:46,900 --> 00:04:59,410
Nếu có, tổng phụ phí sẽ được tính toán và cộng thêm.  Tương tự, hãng hàng không và phụ phí sân bay sẽ được tính và cộng thêm phụ phí thuê xe nếu có.

27
00:04:59,570 --> 00:05:14,730
Việc trùng lặp sẽ được tính toán và cộng thêm khoản phụ phí tương tự vào khoản phụ phí của khu nghỉ dưỡng, sau đó thuế bán hàng sẽ được tính dựa trên quốc gia cư trú của khách hàng, giá cuối cùng sau đó sẽ được trả lại cho người gọi.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\07DomainDrivenDesignTacticalPatterns_VVN\000000016.srt -->

1
00:00:00,150 --> 00:00:10,530
Trong bài học này chúng ta sẽ tiếp tục xây dựng một số dịch vụ cho mô hình bán hàng Acme sẽ mô hình hóa các dịch vụ như dịch vụ thẻ tín dụng và dịch vụ lịch sử khách hàng.

2
00:00:11,040 --> 00:00:25,260
Tôi sẽ bắt đầu bài giảng này bằng một câu đố.  Giả sử bạn phải tạo hai dịch vụ, một dịch vụ xử lý thẻ tín dụng thông qua nhà cung cấp bên ngoài và một dịch vụ khác để cung cấp lịch sử khách hàng.

3
00:00:25,530 --> 00:00:41,710
Lựa chọn của bạn là liệu bạn có thể triển khai các dịch vụ này trong một dịch vụ ứng dụng hay không, b, bạn có thể triển khai các dịch vụ này trong một dịch vụ cơ sở hạ tầng, dịch vụ có các tùy chọn loại dịch vụ và B, vui lòng đăng video nếu bạn cần thêm thời gian.

4
00:00:41,940 --> 00:00:50,990
Được rồi.  Giải pháp là vì chúng ta đang nói về dịch vụ do một nhà cung cấp bên ngoài cung cấp nên đó là dịch vụ cơ sở hạ tầng.

5
00:00:51,000 --> 00:01:03,640
Vì vậy, cái đầu tiên sẽ được tạo ra như một cơ sở hạ tầng.  Vì vậy, mục thứ hai là cung cấp lịch sử khách hàng, về cơ bản là sự hợp nhất của nhiều thành phần miền.

6
00:01:03,660 --> 00:01:10,800
Nó sẽ được triển khai như một dịch vụ ứng dụng.  Hãy cùng đi sâu vào chi tiết về hai dịch vụ này của Achmat.

7
00:01:11,710 --> 00:01:36,470
Dịch vụ lịch sử khách hàng sẽ tổng hợp thông tin cho khách hàng dựa trên số tham chiếu của khách hàng hoặc qua email hoặc số điện thoại, phản hồi từ dịch vụ sẽ bao gồm thông tin chi tiết về khách hàng, 10 đề xuất gần đây nhất được tạo cho khách hàng và nhiều nhất  năm xác nhận đặt phòng gần đây.

8
00:01:36,730 --> 00:01:45,130
Rõ ràng, dịch vụ lịch sử khách hàng sẽ cần lấy tất cả thông tin này từ các đối tượng kho lưu trữ khác nhau.

9
00:01:46,070 --> 00:01:53,430
Dịch vụ ứng dụng lịch sử khách hàng sẽ được tạo theo gói bình tĩnh, không phải mô hình hoặc dịch vụ bán hàng chính xác.

10
00:01:53,480 --> 00:02:06,430
Lớp này sẽ hiển thị các hàm mà người gọi có thể gọi để lấy lịch sử khách hàng.  Đối tượng này cũng có thể được bao bọc và có vẻ như thể hiện các chức năng tương tự hoặc SCDP.

11
00:02:06,650 --> 00:02:21,860
Phản hồi cho các cuộc gọi được thực hiện tới dịch vụ lịch sử khách hàng sẽ là một phiên bản của đối tượng lịch sử khách hàng chứa tham chiếu đến các phiên bản đề xuất của khách hàng và các phiên bản xác nhận đặt chỗ.

12
00:02:22,010 --> 00:02:31,280
Dịch vụ Lịch sử Khách hàng sẽ sử dụng kho lưu trữ để lấy thông tin cho các đề xuất của khách hàng và xác nhận đặt phòng.

13
00:02:31,880 --> 00:02:41,780
Đối tượng Dịch vụ Lịch sử Khách hàng sẽ hiển thị các chức năng truy xuất dữ liệu khách hàng bằng số tham chiếu của khách hàng.

14
00:02:41,810 --> 00:02:49,560
Nó cũng sẽ hiển thị các chức năng truy xuất dữ liệu khách hàng bằng cách sử dụng địa chỉ email hoặc số điện thoại của khách hàng.

15
00:02:49,580 --> 00:02:59,720
Vì vậy, đây là mô hình cho Dịch vụ Ứng dụng Lịch sử Khách hàng.  Tiếp theo, hãy nói về Dịch vụ cổng thanh toán, một dịch vụ cơ sở hạ tầng.

16
00:03:00,020 --> 00:03:18,450
Acme sử dụng dịch vụ xử lý thẻ tín dụng của bên thứ ba.  Điều đó có nghĩa là khi khách hàng cung cấp số thẻ tín dụng của họ, nhóm Acme sẽ thực hiện cuộc gọi đến nhà cung cấp bên thứ ba để xử lý thanh toán bằng thẻ tín dụng.

17
00:03:18,830 --> 00:03:24,940
Những gì chúng tôi đã nghe từ các bên liên quan là một nhà cung cấp được chọn dựa trên loại thỏa thuận mà họ đưa ra.

18
00:03:25,190 --> 00:03:38,060
Rõ ràng, nhà cung cấp tính phí ít nhất cho các dịch vụ xử lý thanh toán này sẽ được Acme chọn và hợp đồng sẽ được gia hạn hàng năm và đôi khi thậm chí là giữa năm.

19
00:03:38,210 --> 00:03:57,470
Và vì lý do này, Acme đã chuyển đổi nhà cung cấp dịch vụ thanh toán ba lần trong hai năm qua.  Và những gì chúng tôi được biết là mỗi khi Acme chuyển sang một nhà cung cấp mới, việc thay đổi toàn bộ hệ thống, sử dụng các dịch vụ Windows mới để giải quyết thách thức này là một rắc rối lớn.

20
00:03:57,470 --> 00:04:07,640
Dịch vụ Cổng thanh toán sẽ được tạo dưới dạng dịch vụ cơ sở hạ tầng nhằm xác định hợp đồng tiêu chuẩn cho khách hàng trong Acme.

21
00:04:07,670 --> 00:04:19,640
Vì vậy, đây là ba loại chức năng giao diện cần thiết trong Dịch vụ cổng thanh toán rất đơn giản tính phí thẻ tín dụng, cải cách thẻ tín dụng và nhận thông tin chi tiết về giao dịch.

22
00:04:19,640 --> 00:04:30,230
Miễn là khách hàng đang sử dụng các giao diện này thì việc nhà cung cấp A, nhà cung cấp B hay nhà cung cấp C đang được sử dụng sẽ không thành vấn đề đối với họ.

23
00:04:30,230 --> 00:04:40,130
Bất kỳ sự chuyển đổi nào của nhà cung cấp sẽ dẫn đến thay đổi về dịch vụ cổng thanh toán và sẽ không ảnh hưởng đến người tiêu dùng Dịch vụ cổng thanh toán.

24
00:04:40,420 --> 00:04:49,330
Hãy tiếp tục và mô hình hóa dịch vụ.  Dịch vụ cơ sở hạ tầng cổng thanh toán sẽ được tạo theo gói dịch vụ.

25
00:04:49,740 --> 00:05:02,030
Dịch vụ sẽ hiển thị ba chức năng mà tôi đã thảo luận trước đó.  Chức năng đầu tiên sẽ là chức năng thanh toán quy trình, dự kiến ​​​​sẽ tính phí vào thẻ tín dụng cho số tiền thanh toán.

26
00:05:02,040 --> 00:05:08,370
Và có một chức năng khác với quá trình hoàn trả tên, sẽ hoàn lại khoản thanh toán cho khách hàng.

27
00:05:08,460 --> 00:05:18,420
Điều này có thể xảy ra do hủy hoặc lý do khác, nhưng các chức năng này tạo ra phản hồi, là một đối tượng thuộc loại giao dịch cổng thanh toán.

28
00:05:18,420 --> 00:05:29,950
Và do đó, mối quan hệ giữa cổng thanh toán và đối tượng mới này là cổng thanh toán tạo ra các phiên bản của đối tượng giao dịch cổng thanh toán.

29
00:05:29,970 --> 00:05:45,360
Chức năng thứ ba trong Dịch vụ Cổng thanh toán là chức năng chi tiết giao dịch, chức năng này tạo ra phản hồi thuộc loại chi tiết giao dịch cổng thanh toán, mối quan hệ giữa Dịch vụ cổng thanh toán và chi tiết giao dịch Cổng thanh toán.

30
00:05:45,360 --> 00:05:55,920
Đó có phải là Dịch vụ cổng thanh toán dành cho các trường hợp chi tiết giao dịch của cổng thanh toán không.  Vì vậy, đây là mô hình của chúng tôi cho Dịch vụ Cổng thanh toán tại thời điểm này.

31
00:05:55,930 --> 00:06:02,290
Nếu bạn quan tâm, bạn có thể đi qua tòa án để thực hiện hai dịch vụ mà tôi đã thảo luận trong bài học này.

32
00:06:02,880 --> 00:06:12,030
Ngoài ra còn có bản triển khai thử nghiệm giao diện cổng thanh toán để cho thấy cách thực hiện giao diện cổng thanh toán.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\001 Intro to Events in Microservices.en.srt -->

1

00:00:00,240 --> 00:00:06,330

So far, you have learned that there are relationships between bonded contacts, these bonded contacts



2

00:00:06,330 --> 00:00:13,590

gets translated into micro services, and these relationships get translated into interactions between



3

00:00:13,800 --> 00:00:14,790

micro services.



4

00:00:15,120 --> 00:00:22,800

Last over SCDP apps are a common Synchronoss mechanism by which micro services interact in the section.



5

00:00:22,800 --> 00:00:28,570

You will learn that micro services also produce different types of events.



6

00:00:28,590 --> 00:00:35,160

These events are consumed by other micro services as well as the components within the bonded context



7

00:00:35,160 --> 00:00:36,630

where the event was produced.



8

00:00:36,990 --> 00:00:42,660

Now let's talk about what is the relationship between even driven architecture and micro services.



9

00:00:42,660 --> 00:00:46,080

Even driven architecture is an architecture paradigm.



10

00:00:46,380 --> 00:00:53,550

Promoting the production, detection, consumption of and reaction to the events and micro services



11

00:00:53,580 --> 00:00:56,890

are natural producers and consumers of.



12

00:00:56,910 --> 00:01:04,170

Even as a result, even driven architecture is commonly used for building applications with micro services.



13

00:01:04,680 --> 00:01:13,050

Events are asynchronous in nature and realization of events based interactions require the use of some



14

00:01:13,050 --> 00:01:14,270

messaging technology.



15

00:01:14,610 --> 00:01:18,000

There are multiple messaging technologies available for this purpose.



16

00:01:18,150 --> 00:01:21,240

In this section you will see the use of Rabbitt.



17

00:01:21,240 --> 00:01:27,380

MQ COFCO is also very popular and you will see the use of Kafka in a later section.



18

00:01:28,320 --> 00:01:34,230

Let's go over the learning objectives for the section you'll learn about the micro services, communication



19

00:01:34,230 --> 00:01:36,660

patterns, event driven architecture.



20

00:01:36,960 --> 00:01:40,370

You learn about different types of micro services events.



21

00:01:40,800 --> 00:01:47,820

I'll give you an overview of the AQAP concept related to the basic implementation of events, and you



22

00:01:47,820 --> 00:01:54,480

will also see the sales model events in action using Java and Rabbit MQ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\002 Monolithic & Distributed Communication Patterns.en.srt -->

1

00:00:00,120 --> 00:00:05,940

Foundational communication patterns, by the end of this lecture, you should be able to explain the



2

00:00:05,940 --> 00:00:09,920

common Synchronoss and asynchronous communication patterns.



3

00:00:10,200 --> 00:00:15,270

You should be able to describe the difference between single versus multiple receivers.



4

00:00:15,540 --> 00:00:22,650

And at the end of this lesson, I'll also go with some technology examples for the realization of the



5

00:00:22,650 --> 00:00:25,300

patterns that I'll discuss in this lecture.



6

00:00:25,620 --> 00:00:33,240

The first pattern is the monolithic object communication pattern in which the object called methods



7

00:00:33,240 --> 00:00:34,560

on other objects.



8

00:00:35,010 --> 00:00:42,900

So in this example, a banking application is calling methods on other objects and those methods are



9

00:00:42,900 --> 00:00:46,350

leading to calls, to functions on other objects.



10

00:00:46,590 --> 00:00:52,620

Now, all of this is happening within a common memory space of within a common process.



11

00:00:52,890 --> 00:00:59,610

This is typical of a monolithic application, and that is the reason I'm referring to it as a monolithic



12

00:00:59,820 --> 00:01:01,550

object communication pattern.



13

00:01:02,400 --> 00:01:09,290

In the case of distributed applications or systems, the components reside in their own process space.



14

00:01:09,690 --> 00:01:15,620

In other words, there is no sharing of compute or memory resources between the components.



15

00:01:16,230 --> 00:01:21,650

These components communicate with each other by way of some kind of a network protocol.



16

00:01:22,050 --> 00:01:27,300

Does this network communication protocol may be synchronous or asynchronous in nature?



17

00:01:27,810 --> 00:01:34,170

By synchronous, it means that the caller stays blocked until it receives a response from the other



18

00:01:34,170 --> 00:01:34,770

component.



19

00:01:34,980 --> 00:01:42,270

Examples of synchronous communication protocols are SCDP and any kind of proprietary remote procedure



20

00:01:42,270 --> 00:01:43,170

called mechanism.



21

00:01:43,290 --> 00:01:47,670

By asynchronous, it means that the caller does not wait for a response.



22

00:01:47,670 --> 00:01:56,040

Example of asynchronous communication is some kind of messaging protocol, such as M Cupie, which stands



23

00:01:56,040 --> 00:01:58,410

for advanced message protocol.



24

00:01:58,800 --> 00:02:04,080

If you're interested in knowing more about M cupie, just visit and cupie dot org.



25

00:02:04,080 --> 00:02:09,030

And that is a good write up on AM Cupie on Wikipedia as well.



26

00:02:10,470 --> 00:02:17,040

One important thing to keep in mind is that the use of synchronous and asynchronous network protocols



27

00:02:17,040 --> 00:02:18,930

is not mutually exclusive.



28

00:02:19,320 --> 00:02:25,620

What that means is that in a distributed systems, there may be some communication that may be using



29

00:02:25,830 --> 00:02:33,780

synchronous network protocols such as HTP, and there may be other components that are communicating



30

00:02:33,810 --> 00:02:37,080

over asynchronous protocols such as M Cupie.



31

00:02:37,740 --> 00:02:45,390

The use of Synchronoss and asynchronous protocols depend on the use case and the requirements.



32

00:02:45,960 --> 00:02:49,240

The communication may be between two endpoints.



33

00:02:49,260 --> 00:02:54,810

This is referred to as one to one communication, also known as single receiver communication.



34

00:02:54,960 --> 00:03:01,010

Common example is HTP, wherein the communication is between two endpoints.



35

00:03:01,110 --> 00:03:02,100

Here is an example.



36

00:03:02,100 --> 00:03:06,700

The bank application invokes an API on the customer component over HTP.



37

00:03:06,760 --> 00:03:11,610

Now this call is going to be independent of the extra DEPI call.



38

00:03:11,610 --> 00:03:15,150

The bank application will make to the account component.



39

00:03:15,150 --> 00:03:22,140

But asynchronous protocol like SCDP, you will always have one to one communication this one to one



40

00:03:22,140 --> 00:03:22,980

communication.



41

00:03:22,980 --> 00:03:27,990

Parathion may also be realized by using the asynchronous messaging mechanism.



42

00:03:28,620 --> 00:03:30,410

Let me explain how this works.



43

00:03:31,320 --> 00:03:41,100

Let's say the bank application has to Invoker API in the account component and this API is using messaging



44

00:03:41,100 --> 00:03:41,660

protocol.



45

00:03:42,300 --> 00:03:46,650

In that case, the bank application can put a message in the queue.



46

00:03:46,680 --> 00:03:49,260

This message represents the request message.



47

00:03:49,680 --> 00:03:56,610

The account component can read this message processor, create the response message and put it in a



48

00:03:56,610 --> 00:03:56,970

queue.



49

00:03:57,150 --> 00:04:02,730

The bank application can then read the message as a response to its request.



50

00:04:02,850 --> 00:04:08,040

So this scenario looks like a synchronous request response pattern.



51

00:04:08,340 --> 00:04:14,580

But the underlying protocol is asynchronous in a one to many communication pattern.



52

00:04:14,730 --> 00:04:19,470

There are multiple components that are interested in receiving messages from the sender.



53

00:04:19,680 --> 00:04:23,280

This is commonly achieved by way of pops of messaging pattern.



54

00:04:23,520 --> 00:04:25,530

Let me explain this with an example.



55

00:04:25,680 --> 00:04:32,640

Let's say there is an account component that takes care of setting up new accounts for bank customers.



56

00:04:32,640 --> 00:04:37,380

And then there are these other components that are interested in getting notified.



57

00:04:37,380 --> 00:04:43,500

When a new customer account is set up for the realization of this pattern, a topic will be set up on



58

00:04:43,500 --> 00:04:44,640

the messaging system.



59

00:04:44,670 --> 00:04:50,730

The account component will publish a message to this topic every time a new account has created.



60

00:04:50,850 --> 00:04:57,420

These other components will subscribe to this common topic and receive the messages on receiving the



61

00:04:57,420 --> 00:04:57,990

message.



62

00:04:58,200 --> 00:04:59,640

Each of these components.



63

00:04:59,930 --> 00:05:03,000

Will carry out a specific task assigned to it.



64

00:05:03,020 --> 00:05:07,670

So, for example, the e-mail component will send out an e-mail to the customer.



65

00:05:07,910 --> 00:05:15,980

The order team component will order the ATM card and the update executer dashboard will update the number



66

00:05:15,980 --> 00:05:18,980

of accounts on the executer dashboard.



67

00:05:19,430 --> 00:05:25,850

Next, I'll go with some example technologies that may be used for the realization of these communication



68

00:05:25,850 --> 00:05:26,570

patterns.



69

00:05:27,470 --> 00:05:32,870

GDP is a common way by which Microsoft has exposed apps.



70

00:05:33,230 --> 00:05:41,220

There are multiple frameworks for different languages that may be used for building these apps for messaging.



71

00:05:41,270 --> 00:05:48,320

There are two types of products, products that are MQ compliant, such as active MQ and Rabbitt MQ.



72

00:05:48,710 --> 00:05:55,760

And then there are products that are known to be compliant, such as Kafka, Amazon Skier's, Amazon



73

00:05:55,760 --> 00:05:56,470

S.A..



74

00:05:56,490 --> 00:05:59,110

Please note that these are just some of the examples.



75

00:05:59,120 --> 00:06:05,300

In fact, there are many more products and frameworks that may be used for these different communication



76

00:06:05,300 --> 00:06:06,090

patterns.



77

00:06:06,140 --> 00:06:11,870

You will see some of these technologies in action in later lectures in this course.



78

00:06:12,620 --> 00:06:13,880

Time for a quick review.



79

00:06:13,880 --> 00:06:18,440

In this lesson, I covered the foundational communication patterns.



80

00:06:18,740 --> 00:06:25,880

Synchronous patterns are the ones in which the caller sends a request and waits for the response to



81

00:06:25,880 --> 00:06:32,270

come back as to what actually is an example of a synchronous communication pattern.



82

00:06:32,660 --> 00:06:39,770

In the case of asynchronous communication pattern, the caller sends a message and does not wait for



83

00:06:39,770 --> 00:06:43,400

a response and continues to carry out the processing.



84

00:06:43,820 --> 00:06:45,320

That is, it is not blocked.



85

00:06:46,100 --> 00:06:54,950

Messaging platforms such as Kafka, Rabbit, MQ and Active Amcu are commonly used for building asynchronous



86

00:06:54,950 --> 00:06:56,420

communication patterns.



87

00:06:57,080 --> 00:07:02,540

Pops up is commonly used when there are multiple receivers for the message.



88

00:07:02,840 --> 00:07:07,130

In the next lecture you will learn how micro services use these patterns.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\003 Microservices Interaction Patterns.en.srt -->

1

00:00:00,150 --> 00:00:06,930

Microsoft says interactions in this lecture, I'll cover the patterns of communication within the Microsoft



2

00:00:06,930 --> 00:00:13,680

Office between Microsoft ISS and between Microsoft Services and external services, micro services and



3

00:00:13,680 --> 00:00:21,480

Crossover's Communication refers to the function calls made between the components within the same bonded



4

00:00:21,480 --> 00:00:22,140

context.



5

00:00:22,380 --> 00:00:28,520

The idea is that a Microsoft office is implemented within a single deployment unit.



6

00:00:28,920 --> 00:00:35,850

That means the components at runtime within the Microsoft is shared a common process space.



7

00:00:36,000 --> 00:00:40,140

All interactions happen by way of direct function calls.



8

00:00:40,650 --> 00:00:48,780

Sometime, Microsoft says, designers decide to replace these function calls with some network protocols,



9

00:00:48,900 --> 00:00:54,570

such as APIs over HDB or messaging cues and topics.



10

00:00:54,870 --> 00:01:03,160

This decision is made in order to achieve high levels of decoupling and for future extensibility.



11

00:01:03,180 --> 00:01:09,420

In other words, if you have, let's say, a component within the micro service which you expect to



12

00:01:09,420 --> 00:01:16,470

move out of the Microsoft Office at a later date, then you may implement the interactions with that



13

00:01:16,470 --> 00:01:18,660

component by way of a network protocol.



14

00:01:19,020 --> 00:01:25,560

The idea is that when the service will be pulled out of the Microsoft Office, there will be no code



15

00:01:25,560 --> 00:01:28,510

change required in the collar components.



16

00:01:28,920 --> 00:01:36,960

The downside of replacing these direct function calls with network protocols is that there will be some



17

00:01:36,960 --> 00:01:40,500

levels of network overhead that you will have to deal with.



18

00:01:40,720 --> 00:01:42,630

So that is the price you will pay.



19

00:01:43,530 --> 00:01:51,210

Inter-Service communication here refers to the communication between different micro services or between



20

00:01:51,210 --> 00:01:57,750

different bonded contacts, you would always use network protocols for the realization of these kind



21

00:01:57,750 --> 00:01:58,900

of communications.



22

00:01:58,920 --> 00:02:07,200

Keep in mind that the use of messaging or HTP will depend on the use case and other requirements.



23

00:02:07,510 --> 00:02:14,820

The decision will be based on whether the communication is required to be synchronous or asynchronous,



24

00:02:15,120 --> 00:02:21,330

or whether you are looking to distribute the message to multiple receivers, or if there is going to



25

00:02:21,330 --> 00:02:24,560

be only a single receiver of the message.



26

00:02:24,600 --> 00:02:30,070

So in the case of Synchronoss, you would always go with a synchronous network protocol such as Resto



27

00:02:30,090 --> 00:02:31,110

or HTP.



28

00:02:31,530 --> 00:02:36,960

In the case of multiple receivers, you would always go with pops up kind of a pattern.



29

00:02:37,800 --> 00:02:40,850

Next, Alcoa external services interaction.



30

00:02:41,130 --> 00:02:47,100

It is common for micro services to communicate with external services.



31

00:02:47,220 --> 00:02:55,710

The network protocol and the format of messages used by these external services is outside the control



32

00:02:55,890 --> 00:02:58,460

of the Micro Services Development Team.



33

00:02:58,770 --> 00:03:06,540

As a result, Micro Services Development Team need to comply with the interface and the network protocol



34

00:03:06,540 --> 00:03:09,270

requirements of these external services.



35

00:03:09,570 --> 00:03:16,950

For example, there may be a payment gateway which exposes its interface by way of HTP, a logging service



36

00:03:17,160 --> 00:03:23,820

which is exposing its interfaces by way of messaging and then commonly used databases have their own



37

00:03:23,820 --> 00:03:27,240

TCP IP based proprietary network protocols.



38

00:03:27,960 --> 00:03:35,010

From the micro services perspective, the details of these network protocol and the messaging format



39

00:03:35,190 --> 00:03:39,180

will be encapsulated within the infrastructure services.



40

00:03:39,450 --> 00:03:47,160

As discussed earlier, these infrastructure services will be responsible for keeping the rest of the



41

00:03:47,160 --> 00:03:54,270

micro service code independent of the External Services Protocol, as well as message formats.



42

00:03:55,460 --> 00:04:03,320

For Interservice Communication in Micro Services, the micro services developer need to decide on the



43

00:04:03,500 --> 00:04:08,820

structure of the request and response messages, and they also need to decide on the format.



44

00:04:08,960 --> 00:04:17,780

Typically, a micro service exposing an interface would use the model objects for defining the structure



45

00:04:17,780 --> 00:04:21,650

of the request and response messages from the forward perspective.



46

00:04:21,800 --> 00:04:23,690

Jason is a popular formic.



47

00:04:24,050 --> 00:04:31,250

But please keep in mind that other formats, such as XML and CSFI are also used in other not so common



48

00:04:31,250 --> 00:04:33,950

format as the protocol buffer format.



49

00:04:33,950 --> 00:04:37,070

Coupled with the PC protocol protocol.



50

00:04:37,070 --> 00:04:42,720

Baphomet is a highly performant serialisation mechanism developed by Google.



51

00:04:42,740 --> 00:04:46,640

If you are interested in learning more about it, please check out the link here.



52

00:04:46,850 --> 00:04:53,810

Keep in mind that protocol buffer and your privacy based communication mechanism is suitable for micro



53

00:04:53,810 --> 00:04:58,430

services interfaces that require high performance and throughput.



54

00:05:00,090 --> 00:05:06,270

Time for a quiz now, let's say there are two Microsoft sets, A and B, which need to interact with



55

00:05:06,270 --> 00:05:06,820

each other.



56

00:05:07,290 --> 00:05:14,610

These two micro services are managed by two independent teams, and each of these teams develop their



57

00:05:14,610 --> 00:05:16,980

own models for A and B.



58

00:05:17,700 --> 00:05:22,390

As a result, there is no relationship between A and business models.



59

00:05:23,040 --> 00:05:30,360

So another question for you is which model should be used for the communication between A and B?



60

00:05:32,530 --> 00:05:40,600

The answer is it depends it depends on how you would like to manage the dependencies between A and B.



61

00:05:42,110 --> 00:05:49,220

This dependency management for micro services is carried out by way of well-defined boundaries, context,



62

00:05:49,430 --> 00:05:50,900

integration patterns.



63

00:05:51,230 --> 00:05:57,230

I covered these integration patterns in earlier lectures and if you have forgotten about it, I would



64

00:05:57,230 --> 00:06:00,180

suggest that you please watch those videos again.



65

00:06:00,410 --> 00:06:04,530

I will be covering these integration patterns in a short summary.



66

00:06:04,580 --> 00:06:11,990

Next, the first bonded context integration pattern for dependency management is the shared kernel pattern.



67

00:06:12,170 --> 00:06:19,670

In this, a common set of morals and code for the microsurgeons is shared between the microcircuits.



68

00:06:19,970 --> 00:06:27,530

So ahead in this example theme for Microsoft is it is responsible for creating and managing the shared



69

00:06:27,530 --> 00:06:33,650

kernel, which is consumed by both A and B, although the shared kernel part on may also be implemented



70

00:06:33,650 --> 00:06:41,580

as an SDK or a library, it is preferred to use the network protocol as depicted in this illustration.



71

00:06:41,840 --> 00:06:45,020

The second part is the customer supplier pattern.



72

00:06:45,290 --> 00:06:53,090

In this kind of an integration, the supplier or the provider of the interface at just the interface



73

00:06:53,210 --> 00:06:57,270

format and network protocol to the needs of the customer.



74

00:06:57,710 --> 00:07:04,340

So even though the supplier may have a different model for some of the common entities, they will be



75

00:07:04,340 --> 00:07:10,010

responsible for adjusting the format of the message aspart the customer's module.



76

00:07:10,790 --> 00:07:16,430

Next one is the conformist pattern, as the name suggests in this pattern.



77

00:07:16,740 --> 00:07:21,780

One, Microsoft conforms to the model defined in another micro service.



78

00:07:21,920 --> 00:07:30,230

So here in this example, time for Microsoft is a has decided to adopt the models defined by Dean for



79

00:07:30,230 --> 00:07:36,320

Microsoft's B, but there are certain challenges with this pattern and the challenges that any time



80

00:07:36,320 --> 00:07:43,790

there is a change in model for Microsoft is B, they will be an impact on Microsoft's A and the team



81

00:07:43,790 --> 00:07:48,440

for Microsoft is A will need to adjust to minimize such impact.



82

00:07:48,590 --> 00:07:54,020

The team for Microsoft is a can adopt the anti-corruption layer pattern in this.



83

00:07:54,470 --> 00:08:02,690

They can create a layer that isolates all the code for the translation from models from B to it and



84

00:08:02,690 --> 00:08:03,340

vice versa.



85

00:08:03,890 --> 00:08:11,510

Advantage of using the anti-corruption layer pattern is that changes in the model for B will have no



86

00:08:11,510 --> 00:08:19,160

impact on the core implementation of Microsoft Office and any changes that will be needed will be isolated



87

00:08:19,490 --> 00:08:21,080

to the anti-corruption layer.



88

00:08:22,060 --> 00:08:29,140

Let's go over the key points from this lesson for building interactions within a bonded context or a



89

00:08:29,530 --> 00:08:36,280

or service that is interservice communication, you may use function called API and messaging in the



90

00:08:36,280 --> 00:08:44,020

case of external services, Microsoft, this depends on the external services interface and the network



91

00:08:44,020 --> 00:08:44,640

protocol.



92

00:08:44,680 --> 00:08:50,980

As a designer or the micro services, you would use infrastructure services for mapping the interfaces



93

00:08:50,980 --> 00:08:56,980

exposed by the external service for the realization of communication between micro services.



94

00:08:56,980 --> 00:08:59,230

That is, service communication.



95

00:08:59,560 --> 00:09:02,130

You would always use apps and messaging.



96

00:09:03,040 --> 00:09:09,130

Most important thing to keep in mind is that you need to make decisions on managing the dependencies



97

00:09:09,310 --> 00:09:14,530

between the micro services by using the bounded context integration patterns.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\004 Event Driven Architecture.en.srt -->

1

00:00:00,240 --> 00:00:07,800

Even driven architecture provides the foundation for designing the micro services interactions in this



2

00:00:07,800 --> 00:00:14,670

lecture, you learn about events, you learn about the even driven architecture, and I'll compare apples



3

00:00:14,700 --> 00:00:16,620

with even relevant architecture.



4

00:00:17,430 --> 00:00:21,410

I'll start this lesson by discussing a common online shopping scenario.



5

00:00:21,540 --> 00:00:24,980

Customer pays for the products in the basket.



6

00:00:25,170 --> 00:00:28,200

At that point, various actions are taken.



7

00:00:28,200 --> 00:00:32,610

An email is sent to the customer informing the confirmation of the order.



8

00:00:32,790 --> 00:00:40,170

The shipping department ships out the order and at the same time the inventory system updates the number



9

00:00:40,170 --> 00:00:42,680

of products available in the inventory.



10

00:00:42,810 --> 00:00:50,050

So this customer checks out is of interest to multiple subsystems in the online shopping system.



11

00:00:50,070 --> 00:00:55,350

There's something of interest, which is the customer checks out is referred to as an event.



12

00:00:55,350 --> 00:01:02,730

And all of the subsystems that are interested in getting notified about this event are referred to as



13

00:01:02,730 --> 00:01:08,400

the consumer's events occur naturally in all business scenarios.



14

00:01:09,030 --> 00:01:12,930

Let me give you a more formal definition of events.



15

00:01:13,630 --> 00:01:22,440

Events are an indication of something of significance that has happened at a point in time so that something



16

00:01:22,440 --> 00:01:24,240

has happened in the past.



17

00:01:24,390 --> 00:01:30,490

There are consumers who are interested in knowing about the events, so they would like to be notified.



18

00:01:30,720 --> 00:01:37,740

So when an event occurs, one or more consumers are notified about this event.



19

00:01:38,130 --> 00:01:40,020

On receiving the event.



20

00:01:40,050 --> 00:01:48,270

The Consumer Macario processing and the processing of the event is independent of the producer of the



21

00:01:48,270 --> 00:01:51,390

event and other consumers of the event.



22

00:01:51,870 --> 00:01:59,340

And even driven architecture is a software architecture paradigm that promotes the designing of systems



23

00:01:59,640 --> 00:02:07,290

as a collection of loosely copper components that act as even producers and even consumers.



24

00:02:08,180 --> 00:02:16,490

Central to the event driven architecture is an event backbone now this event's backbone is a infrastructure



25

00:02:16,490 --> 00:02:17,190

component.



26

00:02:17,330 --> 00:02:19,590

You may think of it as a material component.



27

00:02:19,940 --> 00:02:27,290

It is referred to by multiple names, even Busse, even Broca, even Serota events, mediator events



28

00:02:27,290 --> 00:02:27,630

hub.



29

00:02:27,830 --> 00:02:30,990

These are some of the common terms used for this component.



30

00:02:31,130 --> 00:02:37,500

The name depends on the product features and functions and the vendor marketing these products.



31

00:02:37,580 --> 00:02:40,400

I suggest that you carry out your own research on Google.



32

00:02:40,400 --> 00:02:42,410

You will find tons of information.



33

00:02:43,160 --> 00:02:47,760

The important thing to keep in mind is that conceptually they are similar.



34

00:02:47,990 --> 00:02:54,740

They all provide a way for routing of the events, from producers to the consumer.



35

00:02:55,010 --> 00:03:01,760

Producers of the event inform the events backbone of something of interest happening.



36

00:03:01,970 --> 00:03:09,320

And they do this by way of a synchronous mechanism exposed by the events, backbone and the events backbone



37

00:03:09,650 --> 00:03:10,740

receive the event.



38

00:03:10,940 --> 00:03:17,570

It figures out where that even need to be routed, depending on the consumers that are interested in



39

00:03:17,570 --> 00:03:18,320

that event.



40

00:03:18,620 --> 00:03:26,480

So, for example, the event will be rolled to the consumers who have subscribed for event.



41

00:03:26,900 --> 00:03:28,360

Similarly event.



42

00:03:28,370 --> 00:03:33,350

We will be routed to the consumers who have subscribed for even be.



43

00:03:33,590 --> 00:03:35,810

And same thing happens for other events.



44

00:03:35,990 --> 00:03:41,480

The important thing to keep in mind here, from the even consumer perspective, is that they are not



45

00:03:41,480 --> 00:03:43,240

falling for these events.



46

00:03:43,280 --> 00:03:44,600

They get notified.



47

00:03:45,750 --> 00:03:49,810

Let's take a look at a specific example of even driven architecture.



48

00:03:50,310 --> 00:03:58,920

Let's assume that Kafka is in use for even routing, recalled the example of a bank where when the new



49

00:03:58,920 --> 00:04:05,300

bank account is created, there are multiple components that get notified and carry out the processing.



50

00:04:05,340 --> 00:04:12,150

So here in this scenario, these three components will subscribe to Kafka for the events related to



51

00:04:12,150 --> 00:04:13,860

the creation of new account.



52

00:04:13,980 --> 00:04:20,040

When a new account will be created in the account component, it will connect with Kafka and publish



53

00:04:20,040 --> 00:04:22,430

a message to the new account topic.



54

00:04:22,530 --> 00:04:29,240

Kafka at that point will notify all of these subscriber for the new account event.



55

00:04:29,490 --> 00:04:35,340

Now, if you're thinking that this is the same as the popular messaging pattern, then you are right.



56

00:04:35,760 --> 00:04:36,210

Pops up.



57

00:04:36,210 --> 00:04:41,820

Messaging pattern is commonly used for the realization of even driven architectures.



58

00:04:42,300 --> 00:04:51,420

Next, let's talk about the data in the event messages, the content of the message, maybe the state



59

00:04:51,420 --> 00:04:53,460

data or the metadata.



60

00:04:53,700 --> 00:05:00,030

In the case of the new bank account example, the state data will be all of the information related



61

00:05:00,030 --> 00:05:01,470

to the new account.



62

00:05:01,650 --> 00:05:08,730

So the consumers receiving the message representing the event will get all of the relevant state data



63

00:05:08,970 --> 00:05:16,170

and they can carry out the processing using the state data that they will receive in the event message.



64

00:05:16,770 --> 00:05:23,010

It is also possible to design the event structure such that it contains only the metadata.



65

00:05:23,010 --> 00:05:29,550

In the case of the bank account example, it may just have the account number for the new account.



66

00:05:30,120 --> 00:05:37,320

The consumer will receive this metadata and some of the consumers that may need detailed information



67

00:05:37,320 --> 00:05:45,180

about the account may have to reach out to the producer to get all of the data needed for their processing.



68

00:05:45,310 --> 00:05:50,760

You would use both the state data and metadata in you, even messages.



69

00:05:50,790 --> 00:05:54,060

There is no hard and fast rule, but certain considerations.



70

00:05:54,060 --> 00:06:00,320

If the method size is too big, then there may be challenges related to latency.



71

00:06:00,330 --> 00:06:04,950

So in that scenario, you may consider to use only metadata in your messages.



72

00:06:05,100 --> 00:06:10,980

If the consumers are leading to a lot of chattiness in your application because they are reaching out



73

00:06:10,980 --> 00:06:18,480

to the producer for getting the state data, then maybe it'll be a good idea to go over the state data



74

00:06:18,600 --> 00:06:19,840

in the event message.



75

00:06:20,700 --> 00:06:25,590

Next, I'll discuss the API versus even driven architecture.



76

00:06:25,950 --> 00:06:30,930

APIs are directed commands, whereas events are observables.



77

00:06:31,260 --> 00:06:38,640

The central theme in an architecture that depends on EPA is an orchestrator and orchestrator may be



78

00:06:38,640 --> 00:06:44,970

thought of as a centralized component that holds the business logic and the floor decisions.



79

00:06:45,510 --> 00:06:53,490

When the orchestrator needs to do something, it invokes an API, which, for the response that invoke



80

00:06:53,610 --> 00:06:57,240

other, appears to carry out the required business processing.



81

00:06:57,540 --> 00:07:05,430

In the case of Edir, the orchestrator is replaced with even producer and even consumers.



82

00:07:06,060 --> 00:07:12,920

These, even consumers, are the observers of the events which are produced by the event producer.



83

00:07:13,500 --> 00:07:20,130

One big difference between these two architectures is that the even producers and even consumers all



84

00:07:20,130 --> 00:07:26,970

have business logic and are responsible for achieving the desired results from the business process.



85

00:07:27,510 --> 00:07:33,600

The even producer does not make a direct invocation on any component.



86

00:07:33,600 --> 00:07:40,740

Rather, it simply triggers an event, a message that is passed on to all the consumers.



87

00:07:41,280 --> 00:07:49,110

Keep in mind that even producers may also be even consumers and even consumers may also be even producers.



88

00:07:49,960 --> 00:07:56,620

Let's let's talk the differences between APA and even driven architecture, in the case of apes, the



89

00:07:56,620 --> 00:08:04,480

caller has a knowledge of the API endpoint, whereas in the case of even's producer doesn't know any



90

00:08:04,480 --> 00:08:12,120

consumer APIs are synchronous, meaning that the caller has to wait for the response to come back.



91

00:08:12,160 --> 00:08:20,350

The caller is blocked, whereas in the case of events, a producer just Emmet's an event and moves on.



92

00:08:21,040 --> 00:08:24,820

Now, it does not even depend on the availability of the consumers.



93

00:08:24,940 --> 00:08:31,110

So what that means is that it can lead to higher availability in case the consumer is not available.



94

00:08:31,810 --> 00:08:39,790

The producer moves on and when the consumer comes up, it receives, the data appears are based on the



95

00:08:39,790 --> 00:08:41,770

request response paradigm.



96

00:08:42,010 --> 00:08:48,370

Whereas in the case of events, the message consists of event data, which can be the state data or



97

00:08:48,550 --> 00:08:53,750

the metadata in the case of API, even with the distributed architecture.



98

00:08:53,770 --> 00:09:00,970

There is a relatively high level of coupling between the API caller and the API endpoint, whereas in



99

00:09:00,970 --> 00:09:07,630

the case of events, the even producers and the even consumers are highly decoupled and the architecture



100

00:09:07,630 --> 00:09:09,870

itself is extensible.



101

00:09:09,880 --> 00:09:16,520

And the reason is that you may add or remove consumers without impacting the producer in any way.



102

00:09:16,690 --> 00:09:24,310

Typically with APIs, the business logic is centralized, whereas in the case of events, the business



103

00:09:24,310 --> 00:09:27,430

logic may be spread across multiple components.



104

00:09:27,430 --> 00:09:34,060

And each of these components, the producers and the consumers, have the autonomy to make business



105

00:09:34,060 --> 00:09:35,650

decisions with their peers.



106

00:09:35,680 --> 00:09:42,310

It is easy to understand the flaw because the business logic is centralized, but even driven architecture,



107

00:09:42,670 --> 00:09:46,640

it is relatively difficult to follow the business logic.



108

00:09:47,170 --> 00:09:48,310

Time for a quick quiz.



109

00:09:48,490 --> 00:09:52,150

Which architecture would you use for your micro services?



110

00:09:52,510 --> 00:10:02,440

The answer is that EDI is preferred for micro services, but you may use both apps and events in your



111

00:10:02,440 --> 00:10:08,920

micro services and the decision will depend on the use case and your requirements that go over.



112

00:10:08,920 --> 00:10:14,710

The key points from this lesson Even's indicate that something of significance has happened.



113

00:10:14,740 --> 00:10:21,610

Even driven architecture is a software architecture paradigm which is based on even's by nature.



114

00:10:22,030 --> 00:10:27,400

Edir uses asynchronous communication between producers and consumers.



115

00:10:27,580 --> 00:10:35,140

EDI is highly decoupled and extensible, and the business logic and the business processes in the case



116

00:10:35,140 --> 00:10:37,360

of Edir are decentralized.



117

00:10:37,520 --> 00:10:45,220

That means all of the components in the system have some business logic which may be managed independent



118

00:10:45,250 --> 00:10:47,550

of other components in the system.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\005 Hands On _ Pub Sub with AMQP_RabbitMQ.en.srt -->

1

00:00:00,270 --> 00:00:06,430

In this lecture hour, demonstrate the public subscribe pattern using rabbit MQ.



2

00:00:07,110 --> 00:00:11,630

I'll start this lecture by discussing the basic AQAP concept.



3

00:00:11,640 --> 00:00:17,070

Then we will create a free rabbit and kill Broecker instance on AQAP dot com.



4

00:00:17,280 --> 00:00:24,820

After that, we will use the rabbit mq UI to set up the components on Rabbit MQ to carry out public



5

00:00:24,840 --> 00:00:25,410

subscribe.



6

00:00:25,410 --> 00:00:28,790

Please note that this lecture will not teach you rabbit MQ.



7

00:00:28,830 --> 00:00:33,960

My intent is to provide you a high level overview of the essential concepts.



8

00:00:34,560 --> 00:00:40,320

The concepts that I'm covering in this lecture are covered in details at this link.



9

00:00:40,780 --> 00:00:47,250

If you're interested in learning more about it, MQ or M Cupie, I highly recommend that you go through



10

00:00:47,250 --> 00:00:50,030

the content available at this link.



11

00:00:50,310 --> 00:00:56,940

After going to this lecture, I'll start this lecture with some basic terminology that I've covered



12

00:00:57,090 --> 00:00:57,630

earlier.



13

00:00:58,110 --> 00:01:05,730

And AM Cupie message broker receives messages from the publisher and it wrote these messages to the



14

00:01:05,730 --> 00:01:06,480

consumers.



15

00:01:06,570 --> 00:01:13,290

Rabbitt Amcu is an implementation of the Amcu Protocol, which is the network protocol.



16

00:01:13,470 --> 00:01:20,070

In other words, it allows the publishers and consumers to connect to the message broker over a network.



17

00:01:20,430 --> 00:01:22,520

Amcu is programmable.



18

00:01:22,680 --> 00:01:29,460

What that means is that developers make the routing decision in earlier messaging middleware such as



19

00:01:29,460 --> 00:01:30,120

IBM.



20

00:01:30,120 --> 00:01:38,970

Amcu administrators control the routing setup and the developers had little to no control on those routing



21

00:01:38,970 --> 00:01:39,590

decisions.



22

00:01:39,810 --> 00:01:47,250

This flexibility in making the routing decision give developers more freedom, but it also raises potential



23

00:01:47,250 --> 00:01:48,170

for conflicts.



24

00:01:48,720 --> 00:01:54,810

This flexibility in routing control is achieved by way of a component called exchange.



25

00:01:55,110 --> 00:01:58,110

Exchange has the routing logic.



26

00:01:58,410 --> 00:02:05,610

Let's dig deeper into how the exchange work exchange exposes APIs for the consumers and the publishers



27

00:02:06,090 --> 00:02:13,740

consumer create either a temporary queue or a permanent queue by way of the broker APIs or by using



28

00:02:13,740 --> 00:02:15,120

the broker UI.



29

00:02:15,600 --> 00:02:22,230

A name is given for the permanent queue, whereas a temporary queue is generated by the broker.



30

00:02:22,770 --> 00:02:28,290

The consumer then binds the queue with binding rules to the exchange.



31

00:02:28,530 --> 00:02:32,820

A binding key is provided as part of this binding process.



32

00:02:33,270 --> 00:02:39,210

Publisher can publish the message by using the API as exposed by the exchange.



33

00:02:39,630 --> 00:02:45,900

As part of the published API, the publisher has to provide a routing key message data and the metadata.



34

00:02:45,990 --> 00:02:53,490

The exchange uses the binding key, the routing key and the metadata for making the routing decisions.



35

00:02:53,640 --> 00:02:57,150

The published message will end up in the consumer's queue.



36

00:02:57,390 --> 00:03:03,660

Depending on the routing logic, multiple consumers can bind to a single exchange.



37

00:03:03,720 --> 00:03:08,790

Similarly, multiple publishers can publish by way of a single exchange.



38

00:03:09,420 --> 00:03:11,580

There are four types of exchanges.



39

00:03:11,580 --> 00:03:15,570

Each of these exchange type provides a different routing logic.



40

00:03:15,570 --> 00:03:21,180

The first type is the direct exchange and the logic is pretty straightforward in this approach.



41

00:03:21,180 --> 00:03:28,590

The messages received from the publisher to the queue that has the same binding key as the routing key



42

00:03:28,590 --> 00:03:30,470

provided by the publisher.



43

00:03:30,600 --> 00:03:34,500

The direct exchange is good for only once processing.



44

00:03:34,500 --> 00:03:41,550

In other words, you may have multiple queues bound with the same binding key, but the message will



45

00:03:41,550 --> 00:03:49,740

be altered to only one of the Qs so you can distribute the workload among multiple workers across different



46

00:03:49,740 --> 00:03:50,310

queues.



47

00:03:50,310 --> 00:03:57,330

And a direct exchange type will use Round-Robin to distribute the load across multiple queues with the



48

00:03:57,360 --> 00:03:58,470

same binding key.



49

00:03:58,830 --> 00:04:01,410

Next time is the final exchange.



50

00:04:01,470 --> 00:04:05,760

The fadeout exchange ignores the routing and the binding key.



51

00:04:06,090 --> 00:04:12,960

What that means is that when a publisher publishes a message to the final exchange, the routing is



52

00:04:12,960 --> 00:04:18,960

ignored and the message is broadcast to all of the queues there are bound to the exchange.



53

00:04:19,080 --> 00:04:24,720

Next type is the of exchange that uses the message header data for routing.



54

00:04:24,720 --> 00:04:32,640

Consumer can bind the queue to this type of exchange by specifying the matching route for the data in



55

00:04:32,640 --> 00:04:33,120

the header.



56

00:04:33,420 --> 00:04:35,940

The next one is the topic exchange.



57

00:04:36,330 --> 00:04:40,950

The topic exchange uses pattern matching for the routing key.



58

00:04:41,370 --> 00:04:49,500

The idea is that the consumer must specify a routing pattern in the binding key for the accused.



59

00:04:49,890 --> 00:04:54,270

When the publisher publishes a message with the routing key.



60

00:04:54,510 --> 00:04:59,520

The routing key is compared with the binding key, which is the.



61

00:04:59,760 --> 00:05:07,050

Holding pattern for all of the queues bound to the exchange, the message is delivered to all the queues



62

00:05:07,260 --> 00:05:13,380

for which the routing pattern is matched with the routing key specified in the published message.



63

00:05:13,410 --> 00:05:19,140

Example of the routing pattern is where the binding key is set to the routing key.



64

00:05:19,230 --> 00:05:23,190

So the consumer in this case is looking for a direct match.



65

00:05:24,100 --> 00:05:31,450

As a first step, we need to create an instance of the Broca, so go to cloud MQ dot com, click on



66

00:05:31,450 --> 00:05:36,390

sign up, follow the instructions to create an account on cloud and cupie dot com.



67

00:05:36,400 --> 00:05:39,100

Once you have created the account, click on login.



68

00:05:39,100 --> 00:05:44,910

And as you can see here, I have already created an instance of the broker to create a new instant.



69

00:05:44,920 --> 00:05:47,250

You can click on the create new instance.



70

00:05:47,260 --> 00:05:49,020

Here you need to provide a name.



71

00:05:49,030 --> 00:05:51,310

Let's call the broker Acme Travel.



72

00:05:51,310 --> 00:05:53,980

Make sure that you have the free plan selected.



73

00:05:53,980 --> 00:05:57,500

As you can see, there are other plans which are going to cost you big bucks.



74

00:05:57,500 --> 00:06:00,550

So just select the Three-tier and then select the region.



75

00:06:00,550 --> 00:06:03,640

I will go with us e one click on review.



76

00:06:03,640 --> 00:06:09,820

And at this point you are ready to create the instant the creation of the instance may take a few minutes.



77

00:06:11,550 --> 00:06:18,420

To get the details on the instance, click on the instant name and hear the one important thing I want



78

00:06:18,420 --> 00:06:26,520

to show you is the MQ Eurail that we are going to use in a later lecture for interacting with the broker



79

00:06:26,520 --> 00:06:31,690

from our Java code to carry out the administration of the broker.



80

00:06:31,980 --> 00:06:34,460

Click on the Robert MQ manager.



81

00:06:34,710 --> 00:06:38,940

And this is the year that we can use to test out the exchanges.



82

00:06:39,000 --> 00:06:45,480

Click on the exchanges and these are the different exchanges that are available to you out of the box.



83

00:06:45,510 --> 00:06:48,020

We won't use these default exchanges.



84

00:06:48,210 --> 00:06:50,300

We are going to create a new exchange.



85

00:06:50,400 --> 00:06:56,880

So click on ADD new exchange, provide a name I'll call it Akhmad or test the topic, select the type



86

00:06:56,880 --> 00:06:59,270

as topic and click on ADD Exchange.



87

00:06:59,280 --> 00:07:05,970

At this time, our test topic exchange is created and as you can see here, there is no queue bound



88

00:07:05,970 --> 00:07:06,330

to it.



89

00:07:06,360 --> 00:07:09,270

Next, we will create a queue and bind to this exchange.



90

00:07:09,270 --> 00:07:12,870

So click on Kyuss, click on add a new queue, give it a name.



91

00:07:12,870 --> 00:07:14,940

Let's call it Q1 and Q2.



92

00:07:14,940 --> 00:07:18,300

Let's add another queue will call it Q2 at queue.



93

00:07:18,300 --> 00:07:20,610

And now we have these two queues as a next step.



94

00:07:20,610 --> 00:07:25,440

We've got to go back to the exchanges, open up our achmad or test our topic exchange.



95

00:07:25,440 --> 00:07:32,550

And now we are going to add the bindings to let's add the binding for Q1 and we are to provide the binding



96

00:07:32,550 --> 00:07:34,140

key, which is specified here.



97

00:07:34,170 --> 00:07:37,320

I'll call it test dot key and bind.



98

00:07:37,320 --> 00:07:43,350

At this point, we have Q1 bound with the test date key as the binding key.



99

00:07:43,350 --> 00:07:48,150

Let's do the same thing for Q2 that the key is test dart key and bind.



100

00:07:48,170 --> 00:07:51,690

Now both of our queues are bound to the Akhmadov test topic.



101

00:07:51,690 --> 00:07:57,270

Now, to test out the working of this exchange, we will publish a message, click on publish message,



102

00:07:57,270 --> 00:08:01,920

provide the routing he has taught key and then provide a payload.



103

00:08:01,920 --> 00:08:04,230

I'll call it Test Haloed Publish Message.



104

00:08:04,350 --> 00:08:05,610

The message is published.



105

00:08:05,880 --> 00:08:07,290

Let's go back to accuse.



106

00:08:07,530 --> 00:08:12,210

And as you can see here, we have one message in each of these Qs.



107

00:08:12,540 --> 00:08:17,850

So if you want to read the message, just go to CU, click on Get Message.



108

00:08:18,660 --> 00:08:20,940

And here is our test payload.



109

00:08:21,720 --> 00:08:26,400

Now, another test that will carry out is we will change the binding for Q2.



110

00:08:27,060 --> 00:08:32,820

So let's go back to the exchange, click on Achmad or test our topic.



111

00:08:33,360 --> 00:08:35,190

Q2 will be unbound.



112

00:08:35,880 --> 00:08:41,020

Let's bind the Q2 again with a different binding key.



113

00:08:41,040 --> 00:08:44,410

So let's call this key test out.



114

00:08:44,460 --> 00:08:45,450

New key.



115

00:08:45,540 --> 00:08:50,040

Now we have to Qs, Bonwit, different routing keys.



116

00:08:50,040 --> 00:08:56,700

So at this point, if the publisher publishes a message, the test not key, it'll end up in Q1, but



117

00:08:56,700 --> 00:08:57,570

not in Q2.



118

00:08:57,900 --> 00:09:04,710

And if the publisher publishes the message with Test Dot Newquay, then it'll end up in Q2, but not



119

00:09:04,710 --> 00:09:05,400

in Q1.



120

00:09:05,460 --> 00:09:10,150

Let's go ahead and try to test the new key as the routing key is.



121

00:09:10,350 --> 00:09:15,240

I'll just put in a payload which will indicate that this is for the new key and publish the message



122

00:09:15,240 --> 00:09:16,260

message published.



123

00:09:16,320 --> 00:09:20,040

Let's go back to accuse and check how many messages we have.



124

00:09:20,040 --> 00:09:27,750

So in Q1 we have only one message and in Q2 we have two messages as we expect a click on the queue and



125

00:09:27,750 --> 00:09:30,210

then you'll get messages in the first message.



126

00:09:30,210 --> 00:09:34,830

Let's read message number two, and this is the message number two, test Dort Newquay.



127

00:09:35,010 --> 00:09:37,500

And this message is to the Newquay.



128

00:09:37,500 --> 00:09:44,490

I suggest that you try out the exchanges and the queue bindings on your own to get a better feel of



129

00:09:44,490 --> 00:09:45,840

how Rabbit Amcu works.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\006 Domain Events - Pattern.en.srt -->

1

00:00:00,210 --> 00:00:05,430

In this lecture, you learn about different types of events in domain design.



2

00:00:05,790 --> 00:00:10,300

Then we'll dig deeper into the domain events and domain, even handlers.



3

00:00:10,350 --> 00:00:15,570

After that, I'll talk about the transactional nature of the domain events.



4

00:00:15,930 --> 00:00:21,860

Events are an integral part of the model defined for the boundary context.



5

00:00:22,260 --> 00:00:29,970

In this example here, each of the 100 contacts will have well-defined events, and since events are



6

00:00:29,970 --> 00:00:37,110

part of the model that is applicable within the bounded context, the even definition is always managed



7

00:00:37,470 --> 00:00:40,920

in the ubiquitous language for that boundary context.



8

00:00:41,040 --> 00:00:48,540

As an expert, it is your responsibility to ensure that you are capturing all of the relevant events



9

00:00:48,900 --> 00:00:53,440

within the bounded context as part of the model and the ubiquitous language.



10

00:00:53,940 --> 00:01:00,470

These events are raised by the model components when there is some kind of a state change.



11

00:01:00,810 --> 00:01:02,190

Let's look at an example.



12

00:01:02,400 --> 00:01:10,800

Personal loans implemented as micro service will have application services, domain services and aggregates,



13

00:01:11,250 --> 00:01:17,500

and each of these components can raise events to indicate some kind of a state change.



14

00:01:17,940 --> 00:01:23,550

Keep in mind that there may be other sources of even within a micro service, for example, there may



15

00:01:23,550 --> 00:01:30,800

be application monitoring, but app monitoring is not mitting events related to the bounded context.



16

00:01:31,110 --> 00:01:34,970

These are technical events and are not part of the domain driven design.



17

00:01:35,010 --> 00:01:41,580

My discussion in this course is about events omitted by the components within the bounded context.



18

00:01:42,330 --> 00:01:50,910

Components that are omitting events are referred to as the event sources and even consumers are the



19

00:01:50,910 --> 00:01:52,830

consumers of those events.



20

00:01:53,340 --> 00:01:56,940

These even consumers, may be part of the same microcircuits.



21

00:01:56,940 --> 00:02:04,020

So in that case, the events omitted by the event source are referred to as the domain events.



22

00:02:04,290 --> 00:02:09,990

Events omitted by the event source may be consumed by other MICROS services.



23

00:02:10,020 --> 00:02:17,070

So what that means is that an event defined in one bounded context is getting consumed in a different



24

00:02:17,070 --> 00:02:18,300

bounded context.



25

00:02:18,610 --> 00:02:23,520

In such cases, the event is referred to as the integration event.



26

00:02:23,910 --> 00:02:27,960

Even consumer may also be part of an external service.



27

00:02:28,320 --> 00:02:36,750

I'll think of the external service as legacy services APIs or any other service not implemented as a



28

00:02:36,750 --> 00:02:38,580

micro service in such cases.



29

00:02:38,580 --> 00:02:42,150

Also, the event is referred to as the integration.



30

00:02:42,150 --> 00:02:50,940

Even keep in mind that semantically there is no difference between domain events and integration events.



31

00:02:51,100 --> 00:02:58,200

It's just a consumer that decides whether the event will be referred to as the domain even or the integration



32

00:02:58,200 --> 00:02:58,620

even.



33

00:02:59,250 --> 00:03:03,070

Let's dig deeper into domain and integration events.



34

00:03:03,270 --> 00:03:05,940

I'll start with the formal definition of domain.



35

00:03:05,940 --> 00:03:13,590

Even a domain event is a message that informs other parts within the same bounded context that something



36

00:03:13,590 --> 00:03:15,310

of significance has happened.



37

00:03:15,540 --> 00:03:18,990

This is the key part within the same bounded context.



38

00:03:19,200 --> 00:03:27,570

Now, when a domain event is triggered, it indicates a state change within the bounded context and



39

00:03:27,570 --> 00:03:35,460

the consumers of the event receive the event message and execute some business logic within the same



40

00:03:35,460 --> 00:03:36,630

bounded context.



41

00:03:36,660 --> 00:03:43,800

So the key here is to remember that domain event is triggered within a bounded context and it is consumed



42

00:03:43,950 --> 00:03:46,190

within that same bounded context.



43

00:03:46,890 --> 00:03:55,050

The reason why events have become an integral part of the domain driven design is that events occur



44

00:03:55,080 --> 00:03:55,800

naturally.



45

00:03:56,130 --> 00:03:59,170

That is aldermen's have the concept of events.



46

00:03:59,790 --> 00:04:07,710

Think about the online shopping store customer adds merchandise to the court and then checks out when



47

00:04:07,710 --> 00:04:08,920

the customer checks out.



48

00:04:09,180 --> 00:04:14,640

That is an indication of a state change, which is an event customer checked out.



49

00:04:14,820 --> 00:04:20,640

This even will lead to other processing and as part of the order processing, the order will be shipped



50

00:04:20,640 --> 00:04:23,670

out, which is again an indication of a state change.



51

00:04:24,090 --> 00:04:26,770

And as a result, it is an event authorship.



52

00:04:26,940 --> 00:04:29,790

Other components may react to this new event.



53

00:04:29,790 --> 00:04:35,550

For example, an email may be sent to the customer informing the customer that order is on the way.



54

00:04:35,700 --> 00:04:38,880

So events occur naturally in all domains.



55

00:04:39,210 --> 00:04:47,910

A quick way to identify events in a domain is to look for statements like when this has happened, then



56

00:04:47,910 --> 00:04:48,840

do so.



57

00:04:48,840 --> 00:04:54,390

This part represents the event and this part represents the reaction to the event.



58

00:04:54,570 --> 00:04:56,550

That is the business logic.



59

00:04:56,550 --> 00:04:59,460

Please note that this reaction is also known as.



60

00:04:59,720 --> 00:05:07,310

Side effect by now, I'm sure you understand that language plays a very important role in Demand-Driven



61

00:05:07,310 --> 00:05:12,010

design, so you have to be very careful when you are naming your events.



62

00:05:12,470 --> 00:05:16,430

Always use past tense, as even has already happened.



63

00:05:16,580 --> 00:05:19,480

Here are some best practices for naming the events.



64

00:05:19,490 --> 00:05:27,350

You must use ubiquitous language so that there is no need of translation between the business and the



65

00:05:27,350 --> 00:05:28,930

IT team's example.



66

00:05:29,240 --> 00:05:36,500

Are these events which are part of the retail domain, do not add even as a suffix to the even name.



67

00:05:36,560 --> 00:05:40,370

This is a common practice that we all have used as developers.



68

00:05:40,370 --> 00:05:43,580

Similarly, do not add the operation as a suffix.



69

00:05:43,580 --> 00:05:49,520

So created here is the operation and the suggestion is to use the business language.



70

00:05:49,790 --> 00:05:54,830

So user registered is preferred over user created domain.



71

00:05:54,830 --> 00:05:59,600

Even Handler refers to the implementation of the even consumer logic.



72

00:06:00,110 --> 00:06:08,060

In the case of the domain, even the handler is part of the same micro service code base as the even



73

00:06:08,060 --> 00:06:08,650

producer.



74

00:06:08,840 --> 00:06:15,980

These handlers subscribe to the events of interest and there may be zero or more handlers per event.



75

00:06:16,490 --> 00:06:23,930

Like the events, the event handlers must be named appropriately use of ubiquitous language as suggested



76

00:06:24,140 --> 00:06:25,280

as a best practice.



77

00:06:25,640 --> 00:06:31,190

You can name the handler the same as the event that the handler is handling.



78

00:06:31,190 --> 00:06:38,630

For example, Order Shib will be the name of the object that will handle the order of events.



79

00:06:38,630 --> 00:06:41,750

Do not add handler or receiver as a suffix.



80

00:06:41,780 --> 00:06:43,730

So this is a bad name.



81

00:06:43,730 --> 00:06:46,640

Instead of this name, you should go with order.



82

00:06:47,660 --> 00:06:53,600

Let's go with the example of personal loan, micro service, the domain, even source and the domain



83

00:06:53,600 --> 00:06:56,800

event handler are both in the same process.



84

00:06:57,230 --> 00:07:00,380

Let's say there is an aggregate loan application.



85

00:07:00,410 --> 00:07:09,770

This loan application aggregate gets called when the customer creates a loan application online on submission



86

00:07:09,770 --> 00:07:11,660

of the application online.



87

00:07:11,990 --> 00:07:18,110

The loan application aggregate will create the loan application and the persistent storage.



88

00:07:18,350 --> 00:07:20,540

That is an indication of an event.



89

00:07:20,580 --> 00:07:23,150

Let's call this even application received.



90

00:07:23,330 --> 00:07:29,900

Now, there may be a handler within this same micro service which is interested in responding to the



91

00:07:29,900 --> 00:07:31,750

application received events.



92

00:07:31,850 --> 00:07:38,630

When this event is omitted, the handler receives it and invokes an operation on the loan review.



93

00:07:38,900 --> 00:07:40,670

Aggregate this loan review.



94

00:07:40,670 --> 00:07:45,200

Aggregate manages the review process for the loan application.



95

00:07:45,200 --> 00:07:53,030

As part of this processing, the handler may also initiate the application review process by informing



96

00:07:53,030 --> 00:07:54,170

the loan officer.



97

00:07:54,350 --> 00:08:02,600

The loan officer may reject or approve the loan application, which may lead to new events such as application



98

00:08:02,600 --> 00:08:03,230

approved.



99

00:08:03,230 --> 00:08:10,070

Handler for the application approved will then invoke an operation on the account aggregate, which



100

00:08:10,070 --> 00:08:15,050

will be responsible for setting up the new loan account and the persistent storage.



101

00:08:15,830 --> 00:08:22,280

One common misconception about event realization is that events have to be managed with messaging,



102

00:08:22,280 --> 00:08:24,530

but that is not true for domain events.



103

00:08:24,530 --> 00:08:31,490

Domain events may be admitted and consumed synchronously, for example, by way of direct function calls.



104

00:08:31,490 --> 00:08:36,290

Remember that domain event producer and the handler are in the same process.



105

00:08:36,290 --> 00:08:43,100

But you may also use asynchronous mechanism such as in memory messaging or even an external message.



106

00:08:43,100 --> 00:08:43,580

Broca.



107

00:08:44,440 --> 00:08:51,640

State changes and racing of the events need to happen, atomically in the case of Synchronoss calls



108

00:08:51,820 --> 00:08:58,690

it's easier to implement such mechanisms, whereas with asynchronous, you will need to use appropriate



109

00:08:58,690 --> 00:08:59,330

patterns.



110

00:08:59,440 --> 00:09:01,480

Let me explain this with an example.



111

00:09:02,170 --> 00:09:09,190

In the personal loans micro service, the loan application aggregate is responsible for managing the



112

00:09:09,190 --> 00:09:10,770

state of loan applications.



113

00:09:11,050 --> 00:09:17,620

So when a customer applies for the loan, the loan application aggregate will save the state of the



114

00:09:17,620 --> 00:09:20,860

new loan application in the database.



115

00:09:20,920 --> 00:09:27,400

Now, let's say the aggregate fail to raise the event application received in the scenario the next



116

00:09:27,400 --> 00:09:28,860

steps will not execute.



117

00:09:28,870 --> 00:09:29,260

Why?



118

00:09:29,260 --> 00:09:34,600

Because the handler will never get notified to initiate the loan review process.



119

00:09:34,610 --> 00:09:40,630

Another failure scenario is where the customer applies for the loan and the loan application.



120

00:09:40,630 --> 00:09:47,710

Aggregate failed to save the application to the database, but it raised the application received.



121

00:09:48,040 --> 00:09:54,940

Even in this case, the handler will receive the notification, but it will not find the loan application



122

00:09:54,940 --> 00:09:55,840

in the database.



123

00:09:56,050 --> 00:10:03,550

This second scenario may be addressed by simply checking if all the operations before the raising of



124

00:10:03,550 --> 00:10:09,340

the event was successful or not, and then raised the event only if the prior operations were successful.



125

00:10:09,520 --> 00:10:12,970

Let me explain how you may address scenario number one.



126

00:10:13,400 --> 00:10:19,450

Please note that I will be explaining one of the many patterns available for building transactional



127

00:10:19,450 --> 00:10:21,790

behavior for domain events.



128

00:10:22,180 --> 00:10:30,340

So in this example, loan application aggregate will not the event right away on receiving the application.



129

00:10:30,340 --> 00:10:36,250

It it'll save the even to a storage, the storage, maybe just in memory storage.



130

00:10:36,620 --> 00:10:41,140

Then the loan application aggregate can try to save the application to database.



131

00:10:41,470 --> 00:10:44,740

If there is a failure, then the event will not be erased.



132

00:10:44,950 --> 00:10:52,820

If the sale to the database is successful, then the event will be erased and the handlers will be notified.



133

00:10:53,230 --> 00:10:58,980

So this way the state change and the raising of the event will happen atomically.



134

00:11:00,130 --> 00:11:02,250

Let's go over the key points from this lecture.



135

00:11:02,260 --> 00:11:05,860

There are two types of events domain and integration events.



136

00:11:06,130 --> 00:11:14,350

Domain events are omitted and handled within the same bounded context, whereas integration events are



137

00:11:14,350 --> 00:11:16,810

handled outside of the bounded context.



138

00:11:16,810 --> 00:11:21,160

Domain events may be handled synchronously as well as asynchronously.



139

00:11:21,250 --> 00:11:27,550

Appropriate naming conventions should be used for naming the events and the event handlers.



140

00:11:27,550 --> 00:11:33,400

State update and raising of the event must be done in a unit of work or in a transaction.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\007 Hands On _ Static Class Broker Pattern.en.srt -->

1

00:00:00,120 --> 00:00:04,680

In this lecture, we'll go deeper into the static class, Broecker, even pattern.



2

00:00:05,200 --> 00:00:10,180

First, I'll walk you through the classes in the broken pattern framework that I have put together.



3

00:00:10,230 --> 00:00:16,330

Then I'll show you the sequence diagrams for registering and raising the Even's as part of this lecture.



4

00:00:16,350 --> 00:00:22,560

I'll also walk you through the code and you will see this pattern in action in the static class even



5

00:00:22,620 --> 00:00:27,240

broke a pattern, a single class X as the event broke.



6

00:00:27,630 --> 00:00:32,170

This class exposes static functions for events management.



7

00:00:32,280 --> 00:00:34,320

There's a function for raising the events.



8

00:00:34,620 --> 00:00:38,220

There's a function for registering and deregistering handle.



9

00:00:38,400 --> 00:00:41,220

All of the calls are direct function calls.



10

00:00:41,220 --> 00:00:42,810

Hence they're all synchronous.



11

00:00:42,810 --> 00:00:49,470

And since all of the calls are in process, direct function calls, this pattern may only be applied



12

00:00:49,470 --> 00:00:50,790

for domain events.



13

00:00:50,790 --> 00:00:55,420

It cannot be used for integration even before proceeding with this lecture.



14

00:00:55,530 --> 00:00:58,800

Please make sure that you have checked out the events branch.



15

00:00:59,400 --> 00:01:03,540

All of the models are available under the UML utils.



16

00:01:03,550 --> 00:01:11,640

Not even the implementation classes are in the model, not utilized or even packaged, and the task



17

00:01:11,640 --> 00:01:16,560

classes are under the test, not even not static.



18

00:01:16,560 --> 00:01:17,640

Broca package.



19

00:01:18,030 --> 00:01:21,480

The even framework that I have put together, will have four classes.



20

00:01:21,480 --> 00:01:28,800

The first class is the static class that exposes the three functions needed for even management.



21

00:01:29,160 --> 00:01:35,490

For each event, there will be a collection of handlers which will be managed in the even despatcher



22

00:01:35,490 --> 00:01:35,880

class.



23

00:01:36,070 --> 00:01:43,980

This even despatcher class will be responsible for dispatching the event to the handlers registered



24

00:01:43,980 --> 00:01:45,030

for that event.



25

00:01:45,240 --> 00:01:49,670

All event handlers must implement the interface event handler.



26

00:01:49,890 --> 00:01:56,010

This interface has one function handle that takes the event as an argument.



27

00:01:56,010 --> 00:02:03,240

All events must extend the event abstract class and you will see that there is an attribute for the



28

00:02:03,240 --> 00:02:04,250

name name.



29

00:02:04,560 --> 00:02:09,120

This is what identifies the specific event type concrete.



30

00:02:09,120 --> 00:02:16,760

Even classes may introduce additional attributes to meet the needs of the specific events.



31

00:02:16,950 --> 00:02:22,160

Please check out the full blown class diagram available in the project under this folder.



32

00:02:22,590 --> 00:02:27,660

Next, I'll walk you through the sequence diagram for event handler registration.



33

00:02:27,660 --> 00:02:32,280

The first component in the sequence will be the interest rate component, which is a control.



34

00:02:32,280 --> 00:02:37,290

Then we have the event handler event bus and a collection of even dispatching.



35

00:02:37,350 --> 00:02:40,770

These are the main components in the registration sequence.



36

00:02:40,770 --> 00:02:45,240

The industrial component will create an instance of the event handler.



37

00:02:45,240 --> 00:02:52,920

Then it'll call registrar function on the event bus with the event team and the handler, for instance.



38

00:02:52,920 --> 00:03:00,360

Even bus will look for the dispatcher for the event name received in the register function.



39

00:03:00,550 --> 00:03:01,500

Two things can happen.



40

00:03:01,620 --> 00:03:07,410

Either the event bus will finally even dispatch a collection for the event or it will not find.



41

00:03:07,440 --> 00:03:10,530

Let's look at the first scenario and the event dispatcher is found.



42

00:03:10,560 --> 00:03:16,710

If the event dispatcher is phone, then even bus will invoke the register function on the event.



43

00:03:16,710 --> 00:03:23,850

Dispatcher even dispatcher will return a boolean true to the event bus and the event bus will return



44

00:03:23,850 --> 00:03:25,950

true to the interest at component.



45

00:03:25,950 --> 00:03:29,910

And at this point the handler is registered with the event.



46

00:03:29,910 --> 00:03:36,990

But if the dispatcher is not followed, then the first thing that the bus does is create a dispatcher



47

00:03:37,350 --> 00:03:44,250

for that event name and then register the dispatcher for the event name, which leads to the call to



48

00:03:44,250 --> 00:03:48,000

the event dispatcher for registering the handler.



49

00:03:48,030 --> 00:03:53,950

Dispatcher returns Boolean True, which then the event bus returns to the entrusted component.



50

00:03:54,000 --> 00:03:56,610

So at this point, the handler is registered.



51

00:03:57,010 --> 00:04:02,340

Let's take a quick look at the even bus class register function in the register function.



52

00:04:02,340 --> 00:04:07,320

The first thing is check the event dispatchers collection to see if there is a dispatcher for the given



53

00:04:07,320 --> 00:04:08,160

even name.



54

00:04:08,190 --> 00:04:14,640

If the dispatcher does not exist in the collection that create one and then call the event dispatcher



55

00:04:14,640 --> 00:04:18,180

register a function in the event dispatcher register a function.



56

00:04:18,180 --> 00:04:21,600

We are simply checking if the handler already exists.



57

00:04:21,600 --> 00:04:27,570

If it exists, just return false because you don't want same handler to be registered twice.



58

00:04:27,570 --> 00:04:32,370

Otherwise it may lead to duplication and then add the handler to the collection.



59

00:04:32,520 --> 00:04:36,320

As you can see, this implementation is quite straightforward.



60

00:04:36,480 --> 00:04:43,500

Next, I'll walk you through the receiving sequence in which the aggregate route will act as a source



61

00:04:43,500 --> 00:04:44,700

of the event.



62

00:04:44,940 --> 00:04:49,380

The aggregate route will interact with even boss to raise the event.



63

00:04:49,590 --> 00:04:55,980

The event boss will then interact with even dispatcher, which then in turn will interact with event



64

00:04:55,980 --> 00:04:56,460

handler.



65

00:04:56,610 --> 00:04:59,520

So the first thing that happens is that aggregate route will.



66

00:04:59,690 --> 00:05:08,000

All the race function on the bus, even bus, will look for the dispatcher for the evening name, not



67

00:05:08,010 --> 00:05:09,170

two things can happen.



68

00:05:09,170 --> 00:05:12,500

Either the dispatcher will be followed or it would not be found.



69

00:05:12,680 --> 00:05:19,790

If the dispatcher is not found for the event, then the bus simply returns false, which indicates no



70

00:05:19,790 --> 00:05:22,060

action was taken as there is no handler.



71

00:05:22,190 --> 00:05:28,700

Otherwise, the event bus invokes the dispatch function on the even dispatcher instance.



72

00:05:28,700 --> 00:05:34,040

The even dispatcher then calls handle function on all of the handlers.



73

00:05:34,040 --> 00:05:40,280

After that it returns true to even boss indicating that the event has been handled.



74

00:05:40,610 --> 00:05:44,140

The even bus returns are true to the aggregate route.



75

00:05:44,150 --> 00:05:47,570

Please note that all of these function calls are synchronous.



76

00:05:47,840 --> 00:05:49,460

In the even bus class.



77

00:05:49,490 --> 00:05:55,610

You will find the race function and you will find the three steps that I have discussed in the sequence



78

00:05:55,610 --> 00:05:56,120

diagram.



79

00:05:56,240 --> 00:06:00,170

We first try to get the dispatcher for the event that is getting raised.



80

00:06:00,380 --> 00:06:03,260

If the dispatcher is not found, no action is taken.



81

00:06:03,260 --> 00:06:10,010

Otherwise, the dispatch function is called on the even dispatcher instance and the even dispatcher



82

00:06:10,010 --> 00:06:10,700

class.



83

00:06:10,730 --> 00:06:12,590

The dispatch function checks.



84

00:06:12,590 --> 00:06:19,070

If the size of the handlers collection is zero, return false because there is no handler to take care



85

00:06:19,070 --> 00:06:19,700

of the event.



86

00:06:20,030 --> 00:06:27,320

Otherwise loop to the handler instances and call handler even on each of the handler.



87

00:06:27,800 --> 00:06:31,910

I have put together a test case to see the even boss and action.



88

00:06:32,300 --> 00:06:36,050

All the test classes are available under the test.



89

00:06:36,530 --> 00:06:38,750

Even static broke up package.



90

00:06:39,020 --> 00:06:41,540

The main test class has the test case code.



91

00:06:41,780 --> 00:06:46,910

Some action is an evil class and some action happen is the handler class.



92

00:06:47,010 --> 00:06:52,970

Let me quickly walk you through the code and show you that even boss in action, for the sake of this



93

00:06:52,970 --> 00:06:57,720

testing, let's assume that aggregate root is the source of the event.



94

00:06:57,740 --> 00:07:06,200

And this is the name of the event which will be raised by this class when some action is executed here



95

00:07:06,530 --> 00:07:13,880

you would see that we are simply printing out the message and then raising the event not to raise the



96

00:07:13,880 --> 00:07:14,360

event.



97

00:07:14,360 --> 00:07:17,810

We are passing an instance of the some action.



98

00:07:17,930 --> 00:07:23,510

The some action is actually an event class that extends the abstract.



99

00:07:23,510 --> 00:07:27,140

Even as you can see, there is nothing special in this class.



100

00:07:27,140 --> 00:07:28,850

In the main test class.



101

00:07:28,850 --> 00:07:35,630

What we are doing in the main function is we are creating a handler and then registering that handler



102

00:07:35,630 --> 00:07:40,210

with the even boss and with the even name from the aggregate route.



103

00:07:40,220 --> 00:07:43,100

Let's take a quick look at the event handler.



104

00:07:43,100 --> 00:07:44,570

So some action happened.



105

00:07:44,570 --> 00:07:49,910

Is that even a handler and it is simply putting a message out saying handler executed.



106

00:07:50,240 --> 00:07:52,280

So let's go back to the main test here.



107

00:07:52,790 --> 00:08:01,610

And so to carry out the test, we will create a new aggregate route and then execute some action on



108

00:08:01,610 --> 00:08:04,280

it, which will lead to the raising of the event.



109

00:08:04,430 --> 00:08:06,530

So let's go ahead and test this out.



110

00:08:06,650 --> 00:08:06,980

Right.



111

00:08:06,980 --> 00:08:10,040

Click on Main Post and run main test.



112

00:08:10,040 --> 00:08:11,630

And here are our results.



113

00:08:11,630 --> 00:08:18,020

The aggregate route carried out the action successfully and then the handler executed as a result of



114

00:08:18,020 --> 00:08:18,650

the event.



115

00:08:18,650 --> 00:08:22,130

The boss daughter is in the aggregate route.



116

00:08:22,370 --> 00:08:27,050

Suggest that you walk to the court and try it out on your own.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\008 Exercise _ ACME Sales Domain Events.en.srt -->

1

00:00:00,150 --> 00:00:05,790

Like any other domains, Acme sales also have events in this lecture.



2

00:00:06,090 --> 00:00:13,980

I'll go over certain events in the sales domain model and we will also work on modeling these events



3

00:00:14,160 --> 00:00:18,410

and the handlers for these events as part of the discovery process.



4

00:00:18,420 --> 00:00:19,620

We interviewed John.



5

00:00:19,650 --> 00:00:26,010

And what John said is that I know there are multiple regulatory and compliance requirements, but since



6

00:00:26,010 --> 00:00:30,800

I'm not an expert, let's engage with or and from the legal team.



7

00:00:31,380 --> 00:00:36,960

So we invited or into the meeting and this is what oint told us.



8

00:00:37,090 --> 00:00:39,090

We are in a regulated industry.



9

00:00:39,090 --> 00:00:45,600

We need to ensure that we are in compliance with all regulations, although there are multiple regulations,



10

00:00:45,990 --> 00:00:52,890

but specifically related to the payment, it is a must that when a customer payment is received, it



11

00:00:52,890 --> 00:00:58,100

needs to be maintained and payment ordered for a minimum of seven years.



12

00:00:58,590 --> 00:01:02,840

So there is a new term that has come up here, payment ordered.



13

00:01:03,180 --> 00:01:08,580

So as an IT expert, make sure you add this term to the ubiquitous language.



14

00:01:09,000 --> 00:01:09,870

At this point.



15

00:01:10,170 --> 00:01:17,040

John mentioned that after we received the payment received message, the reservations are started.



16

00:01:17,070 --> 00:01:19,700

After all, the reservations have been made successfully.



17

00:01:20,070 --> 00:01:22,410

We mark the booking as confirmed.



18

00:01:22,710 --> 00:01:29,700

Time for a quiz, go through the transcript and identify an event and a side effect.



19

00:01:31,210 --> 00:01:33,630

If you need more time, please pass the video.



20

00:01:33,910 --> 00:01:40,180

In the last lecture, I mentioned that you need to look for statements that sounds like when something



21

00:01:40,180 --> 00:01:40,830

has happened.



22

00:01:40,840 --> 00:01:47,410

So if you look at this transcript, you can easily see that when a customer payment is received, the



23

00:01:47,410 --> 00:01:48,340

reservations are.



24

00:01:49,090 --> 00:01:55,750

So this is the event and this is the action or the side effect next.



25

00:01:55,930 --> 00:01:59,290

Let's think about how we will model these new requirements.



26

00:01:59,860 --> 00:02:07,030

All payment information must be retained for seven years when mention about payment audit.



27

00:02:07,150 --> 00:02:15,280

No payment order is the record of all payments made by the customer, since it's an entity will also



28

00:02:15,280 --> 00:02:16,530

need a repository.



29

00:02:16,660 --> 00:02:24,220

This payment order entity can expose an operation process payment and to carry out the processing of



30

00:02:24,220 --> 00:02:24,880

the payment.



31

00:02:25,060 --> 00:02:26,860

We will invoke this function.



32

00:02:26,860 --> 00:02:33,850

Any time this function is invoked and the payment is successful, a new entity will be created and added



33

00:02:33,850 --> 00:02:37,210

to the payment collection by way of payment repository.



34

00:02:37,360 --> 00:02:42,790

And the successful payments will also result in the raising of the payment received.



35

00:02:42,790 --> 00:02:48,370

Even when this event will be raised, it'll be handled by way of a payment received handler which will



36

00:02:48,370 --> 00:02:50,470

initiate the reservation process.



37

00:02:50,470 --> 00:02:56,260

And once all of the reservations are successful, it'll change the status of the booking confirmation



38

00:02:56,410 --> 00:03:03,790

to confirmed it is the class diagram that depicts all of the new classes introduced in the model to



39

00:03:03,790 --> 00:03:06,910

fulfill the new requirements that we have discovered.



40

00:03:07,270 --> 00:03:11,050

This model is available in this model file.



41

00:03:11,410 --> 00:03:18,280

As you can see here, I've introduced payment received even in the payment package and this payment



42

00:03:18,280 --> 00:03:22,980

received even is omitted by this class payment audit.



43

00:03:23,230 --> 00:03:28,570

The handler is in the booking package and it extends the event handler class.



44

00:03:28,840 --> 00:03:32,980

All of the Java code for these classes is available in the project.



45

00:03:33,400 --> 00:03:36,580

If you are interested, you can go to the code at this time.



46

00:03:37,270 --> 00:03:41,020

Next, I'll walk you through the payment received domain, even sequence.



47

00:03:41,200 --> 00:03:43,900

This model is available in this file.



48

00:03:44,200 --> 00:03:48,400

Sales agent receives the credit card information from the customer.



49

00:03:48,700 --> 00:03:54,430

They input this credit card information in some kind of an application, which I'm referring to as the



50

00:03:54,430 --> 00:03:55,690

sales interface.



51

00:03:55,720 --> 00:04:03,640

The sales interface or application then executes the process payment on the payment order.



52

00:04:03,670 --> 00:04:09,970

The payment order uses the Payment Gateway Infrastructure Service to carry out the actual payment processing.



53

00:04:09,970 --> 00:04:14,530

This payment Gateway Service was discussed in one of the earlier lectures.



54

00:04:14,560 --> 00:04:18,700

The Payment Gateway Service interacts with the external payment service.



55

00:04:18,700 --> 00:04:23,530

The payment confirmation is received by the Payment Gateway, which is then passed over to the payment



56

00:04:23,530 --> 00:04:30,040

audit, the payment audit on receiving the payment, confirmation access to the persistent storage and



57

00:04:30,040 --> 00:04:33,190

then raises the payment received event.



58

00:04:33,700 --> 00:04:38,550

Next, let's look at the activity diagram for the payment received handler.



59

00:04:39,280 --> 00:04:41,860

The model depicted here is available in this file.



60

00:04:42,370 --> 00:04:51,190

The payment handler receives the payment received event and initiated the various reservations, such



61

00:04:51,190 --> 00:04:56,680

as the Hotel Reservation, Airline Reservation and the rental car reservation, which are part of the



62

00:04:56,680 --> 00:04:57,730

vacation package.



63

00:04:57,860 --> 00:05:03,670

This will lead to the execution of the infrastructure services for these reservations.



64

00:05:03,940 --> 00:05:10,600

The idea is that external services will be invoked and confirmation will be received.



65

00:05:10,600 --> 00:05:16,600

For each of these reservations, the handler will ensure that all of the reservations are successful.



66

00:05:16,930 --> 00:05:22,360

If any reservation is not successful, then the booking will be marked as failed.



67

00:05:22,750 --> 00:05:28,930

If all the reservations are successful, then the status of the booking confirmation will be changed



68

00:05:29,170 --> 00:05:30,340

to booking confirmed.



69

00:05:31,300 --> 00:05:35,080

In this lesson I showed to you how you can use this tactic.



70

00:05:35,090 --> 00:05:39,700

Class Braco pattern for building handlers for the domain event.



71

00:05:39,820 --> 00:05:43,510

Please keep in mind that this is a very simple pattern.



72

00:05:44,170 --> 00:05:51,220

In fact, you can use third party libraries and frameworks and carry out the even processing in an asynchronous



73

00:05:51,220 --> 00:05:51,700

manner.



74

00:05:52,300 --> 00:05:55,240

Please do your own research and do share your findings.



75

00:05:55,570 --> 00:06:01,750

In the next lecture, you will see the test implementation of these new requirements.



76

00:06:02,290 --> 00:06:08,290

If you're not interested in going through the code and seeing it in action, you may skip the next lecture.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\009 Hands On _ Realization of ACME Domain Events.en.srt -->

1

00:00:00,300 --> 00:00:08,010

The intent behind this lesson is to demonstrate the walking of the payment received, even processing



2

00:00:08,340 --> 00:00:09,160

in this lecture.



3

00:00:09,510 --> 00:00:16,490

I'll walk you through the test code and then we'll see the execution of the payment received handler



4

00:00:16,500 --> 00:00:22,110

in action in order to demonstrate the mitting and the handling of payment received.



5

00:00:22,110 --> 00:00:26,510

Even I've put together this class payment order test as the next step.



6

00:00:26,520 --> 00:00:33,210

I'll walk you through the code in this class and we will also see the payment received, even processing



7

00:00:33,210 --> 00:00:34,130

in action.



8

00:00:34,470 --> 00:00:40,470

Please note that for the implementation of the payment received processing, I am using this tactic



9

00:00:40,470 --> 00:00:47,790

Class Brocco pattern that are discussed in the earlier lecture in the main function as a first step



10

00:00:48,360 --> 00:00:52,060

in creating the booking confirmation repo object.



11

00:00:52,110 --> 00:01:00,840

This is the fake repo object that we use in the earlier tests and the second step on creating an instance



12

00:01:00,840 --> 00:01:09,750

of the payment received handler passing in the booking confirmation repo and then registering the handler



13

00:01:09,930 --> 00:01:11,430

for the payment received.



14

00:01:11,430 --> 00:01:18,750

Even in step number three, I'm getting an existing booking confirmation with the reference number nine



15

00:01:18,750 --> 00:01:19,500

to eight.



16

00:01:19,620 --> 00:01:26,010

Recall that this booking confirmation data is part of the fake booking confirmation repo.



17

00:01:26,250 --> 00:01:32,040

If you would like to see the details of it, just take a look at the booking confirmation repo object



18

00:01:32,310 --> 00:01:38,690

under the fake note repo package as a next step, creating the payment gateway process.



19

00:01:38,970 --> 00:01:42,090

This is the test implementation of the payment gateway.



20

00:01:42,240 --> 00:01:44,990

Next, we are creating the fake payment order triple.



21

00:01:45,000 --> 00:01:48,720

This again is available under the fake repo packages.



22

00:01:48,720 --> 00:01:53,940

And as you will see, the implementation for this is very similar to the other fake repos.



23

00:01:53,970 --> 00:01:59,160

Once you have created the payment ordered repo, we are creating the payment audit entity.



24

00:01:59,550 --> 00:02:04,140

This payment audit entity is available under the payment package.



25

00:02:04,140 --> 00:02:07,110

It exposes a process payment function.



26

00:02:07,350 --> 00:02:13,260

We are passing at some fake data and then we are simply printing the booking confirmation.



27

00:02:13,260 --> 00:02:21,840

The idea will be that we will compare the status of the booking confirmation before and after the processing



28

00:02:21,840 --> 00:02:24,540

to see if the status has changed or not.



29

00:02:24,840 --> 00:02:27,720

So let's go ahead and execute this class.



30

00:02:27,720 --> 00:02:29,280

Right, click, run.



31

00:02:29,400 --> 00:02:30,990

And here are the results.



32

00:02:30,990 --> 00:02:34,830

As you can see here, the booking reference is nine twenty eight.



33

00:02:35,070 --> 00:02:39,870

And the starters in the beginning was pending payment.



34

00:02:40,230 --> 00:02:46,050

The processing of the payment was carried out in the payment audit and then the handler was kicked off



35

00:02:46,260 --> 00:02:49,200

as a result of the omitting of the payment received.



36

00:02:49,200 --> 00:02:57,120

Even the handler then updated the booking reference nine to eight and the status was changed to conform.



37

00:02:57,390 --> 00:03:02,160

My suggestion to you would be that you go through this code on your own, check out the code and the



38

00:03:02,160 --> 00:03:05,640

related classes and let me know if you have any question.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\010 Integration Events - Pattern.en.srt -->

1

00:00:00,180 --> 00:00:06,600

In this lecture on integration, even's, Alpha's career, the comparison of integration events and



2

00:00:06,600 --> 00:00:13,860

the domain, then we will discuss integration, even handling from the consumer micro services perspective.



3

00:00:13,870 --> 00:00:20,340

At the end of this lesson, we will enhance the model for the loan management bounded context that are



4

00:00:20,340 --> 00:00:23,070

discussed in an earlier lecture manner.



5

00:00:23,080 --> 00:00:29,790

Now, you are already aware that domain events are raised and consumed within the same bounded context



6

00:00:29,790 --> 00:00:30,900

of the micro service.



7

00:00:31,410 --> 00:00:39,090

Integration events, on the other hand, are consumed by other micro services outside of the source



8

00:00:39,090 --> 00:00:40,110

bomblet context.



9

00:00:40,530 --> 00:00:45,930

And these integration events may also be consumed by external services.



10

00:00:46,080 --> 00:00:52,920

A more formal definition of the integration even is that it is a message that informs the components



11

00:00:53,220 --> 00:01:00,600

outside of the source bounded context that something of significance has happened and integration even



12

00:01:00,600 --> 00:01:05,850

does not lead to any kind of change in the source bounded context.



13

00:01:06,160 --> 00:01:10,320

Let's go through the differences between the domain and the integration events.



14

00:01:10,350 --> 00:01:12,720

The first one is an obvious one, the domain.



15

00:01:12,720 --> 00:01:20,640

You are raised and consumed within the same bounded context or a micro service, whereas the integration



16

00:01:20,760 --> 00:01:30,120

events are raised in one bounded context but may be consumed in another bounded context or by an external



17

00:01:30,120 --> 00:01:38,610

service domain event leads to state changes in the source bounded context, whereas no state change



18

00:01:38,610 --> 00:01:41,400

occurs in the source bounded context.



19

00:01:41,550 --> 00:01:48,150

As a result of the reaction to the integration events, domain events are implemented by way of direct



20

00:01:48,150 --> 00:01:55,020

function calls and integration events must be consumed over a network protocol.



21

00:01:55,200 --> 00:02:02,610

In other words, in the case of integration events, if you end up using direct function calls, then



22

00:02:02,610 --> 00:02:03,210

guess what?



23

00:02:03,210 --> 00:02:05,730

You are creating a monolithic application.



24

00:02:05,850 --> 00:02:12,780

In the case of domain events, the consumption of the event may be synchronous, as with direct function



25

00:02:12,780 --> 00:02:13,140

calls.



26

00:02:13,290 --> 00:02:18,790

But in the case of integration events, asynchronous mechanisms are preffered.



27

00:02:19,110 --> 00:02:25,580

Both domain events and integration events are part of the source mongered context model.



28

00:02:25,590 --> 00:02:32,820

In the case of integration events, the consumer bounded contacts must decide on an integration pattern



29

00:02:33,180 --> 00:02:36,330

that it will use for consuming the events.



30

00:02:36,660 --> 00:02:38,490

More on this in a few minutes.



31

00:02:38,850 --> 00:02:46,950

Although technically it is possible to use Synchronoss mechanism for integration events, communication,



32

00:02:47,370 --> 00:02:51,960

asynchronous network protocols are preferred for obvious reasons.



33

00:02:51,960 --> 00:02:57,540

The first one is that you can achieve high levels of decoupling with asynchronous mechanisms.



34

00:02:58,080 --> 00:03:00,300

Future extensibility is easier.



35

00:03:00,330 --> 00:03:07,680

For example, you can add new consumers without impacting the event source or the micro service that



36

00:03:07,680 --> 00:03:10,740

is raising the integration events.



37

00:03:10,920 --> 00:03:17,940

It makes it easier to establish one to many relationship between the bounded contacts or the micro services.



38

00:03:17,970 --> 00:03:20,270

Messaging technology is commonly used.



39

00:03:20,550 --> 00:03:26,430

These are some of the messaging engines, which are very popular for building micro services.



40

00:03:26,760 --> 00:03:30,670

Domain event may also be published as an integration event.



41

00:03:30,780 --> 00:03:37,740

In other words, for the same event, there may be consumer within the bounded context as well as outside



42

00:03:37,740 --> 00:03:38,820

the bounded context.



43

00:03:39,180 --> 00:03:43,650

Both the events are part of the model for the longer context.



44

00:03:44,100 --> 00:03:46,910

Semantically, the two events are the same.



45

00:03:47,190 --> 00:03:52,230

The difference is in the way these events are published and consumed.



46

00:03:52,620 --> 00:03:59,550

But if the micro services designer has decided to use the same asynchronous mechanism for both type



47

00:03:59,550 --> 00:04:06,360

of events, then the publishing and the triggering mechanism will be the same for domain and integration



48

00:04:06,360 --> 00:04:06,900

events.



49

00:04:07,350 --> 00:04:13,710

Now let's look at the integration events from the consumer's perspective, the consumer or the integration,



50

00:04:13,720 --> 00:04:15,750

even maybe a conformists.



51

00:04:15,900 --> 00:04:24,270

So in this scenario where A is the event sort and B is the even consumer being conformists will mean



52

00:04:24,270 --> 00:04:32,490

that the team that is responsible for Microsoft's B will need to have a knowledge of the models used



53

00:04:32,490 --> 00:04:33,660

in the bonder context.



54

00:04:34,050 --> 00:04:36,030

In other words, the Microsoft is it.



55

00:04:36,240 --> 00:04:41,920

And any time there is a change in the even structure or the model structure, the team for Microsoft



56

00:04:42,030 --> 00:04:46,860

B will have to adjust to minimize the impact of such changes.



57

00:04:47,190 --> 00:04:51,350

The team for Microsoft is V may use anti-corruption layer.



58

00:04:51,570 --> 00:04:59,730

In this case, all of the changes in the event originating from Microsoft, it will be isolated to the.



59

00:04:59,840 --> 00:05:07,020

Anti-Corruption, hence keeping the moral and code base for Microsoft's be independent of the model



60

00:05:07,170 --> 00:05:08,520

for Microsoft is a.



61

00:05:09,400 --> 00:05:14,090

Let's revisit the example of our personal loans, account management, micro service.



62

00:05:14,110 --> 00:05:16,780

Let's say there are two new requirements.



63

00:05:16,960 --> 00:05:23,950

The first requirement is not the compliance bounded context implemented as a micro service need to be



64

00:05:23,950 --> 00:05:31,240

informed when a new application is received and the customer need to be notified by way of an email



65

00:05:31,510 --> 00:05:33,700

when the loan account is set up.



66

00:05:33,850 --> 00:05:39,790

Now, in order to meet these two requirements, we will need to emit integration even for the first



67

00:05:39,790 --> 00:05:42,730

requirement wherein we need to inform the compliance.



68

00:05:43,060 --> 00:05:49,230

We can publish the domain even application received as an integration.



69

00:05:49,240 --> 00:05:55,840

Even the micro service for compliance will be able to receive the even and carry out the appropriate



70

00:05:55,960 --> 00:05:58,660

processing within its bounded context.



71

00:05:58,660 --> 00:06:05,950

For the customer notification, we can set up the account aggregate to publish a new event and this



72

00:06:05,950 --> 00:06:08,620

new even can be an account established.



73

00:06:08,620 --> 00:06:14,710

A notification service can subscribe to this new event and on receiving the loan account established



74

00:06:14,710 --> 00:06:18,270

even it can send an email to the customer.



75

00:06:18,550 --> 00:06:26,230

So within existing domain, even published as an integration event and with a new integration event,



76

00:06:26,230 --> 00:06:32,710

will be able to enhance our loan account management service model to fulfill the two new requirements.



77

00:06:32,990 --> 00:06:35,140

Let's go over the key points from this lesson.



78

00:06:35,530 --> 00:06:39,370

Domain events may be published as integration events.



79

00:06:39,790 --> 00:06:44,980

It is preferred that the integration events are published asynchronously.



80

00:06:45,430 --> 00:06:52,300

Messaging technology is commonly used for the publishing and subscription of the integration events.



81

00:06:52,510 --> 00:07:00,790

The consumer micro services for the integration events may use Atheel or the anti-corruption layer to



82

00:07:00,790 --> 00:07:05,620

isolate the knowledge of the source bounded context in the earlier.



83

00:07:05,920 --> 00:07:12,040

This will minimize the impact of event related changes on the consumer bounded context.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\011 Exercise _ ACME Sales Integration Events.en.srt -->

1

00:00:00,180 --> 00:00:09,120

In this lesson, we will extend the Acme sales model by introducing a new integration event and by adding



2

00:00:09,120 --> 00:00:11,250

a message infrastructure service.



3

00:00:12,430 --> 00:00:20,470

In our last interaction with John and Ian from the legal department, we learned that once the customer



4

00:00:20,680 --> 00:00:27,150

has successfully paid the status of the booking changes to conformed.



5

00:00:27,370 --> 00:00:30,320

So the question is what happens next?



6

00:00:30,970 --> 00:00:38,170

Our objective in this lesson is to understand the actions taken after the booking is confirmed.



7

00:00:38,410 --> 00:00:42,430

So we asked this question to John, and this is what John tells us.



8

00:00:42,760 --> 00:00:45,310

When the booking is confirmed, we do two things.



9

00:00:45,370 --> 00:00:52,630

The first is we send an email to the customer with the booking confirmation details, and we also update



10

00:00:52,630 --> 00:00:56,470

our daily and weekly reports for different achmad departments.



11

00:00:56,920 --> 00:00:58,530

Do you see something interesting here?



12

00:00:59,460 --> 00:01:06,390

There is an event when the booking is confirmed, so looks like we have just discovered a new event



13

00:01:06,600 --> 00:01:11,410

booking confirmed requiring no one seemed to be pretty straightforward.



14

00:01:11,460 --> 00:01:15,160

Let's ask John about requirement number two.



15

00:01:15,600 --> 00:01:21,450

So John is telling us that creating reports is a tiring book, as every department wants these reports



16

00:01:21,450 --> 00:01:23,250

to be in a certain format.



17

00:01:23,400 --> 00:01:26,550

But certain data, we are always trying to catch up.



18

00:01:26,730 --> 00:01:33,420

Sometimes we get blamed by other departments for things that go wrong in those departments, mainly



19

00:01:33,420 --> 00:01:40,170

for either not sending the reports on time or missing or bad data in the reports.



20

00:01:40,800 --> 00:01:42,450

Here are some example reports.



21

00:01:42,450 --> 00:01:46,230

We need to provide the booking report on a daily basis.



22

00:01:46,690 --> 00:01:50,580

Then there is a revenue report which again is needed on a daily basis.



23

00:01:50,940 --> 00:01:53,510

Forecasting report is on a weekly basis.



24

00:01:53,940 --> 00:01:59,550

All of this require us to look at the data we have gathered for all the bookings.



25

00:01:59,550 --> 00:02:06,720

And then sometimes these department ask for ad hoc data which require us to dig into all of the data



26

00:02:06,870 --> 00:02:09,770

that we are gathering from these proposals and bookings.



27

00:02:09,990 --> 00:02:11,850

It is a tiring job.



28

00:02:11,860 --> 00:02:14,610

Hope there was a better way to deal with all of this.



29

00:02:14,730 --> 00:02:21,960

As the IT expert, it is our responsibility to simplify this process and make John's life easier.



30

00:02:22,110 --> 00:02:23,140

Let's get to work now.



31

00:02:23,610 --> 00:02:28,680

How would you meet these requirements using this model as the starting point?



32

00:02:28,950 --> 00:02:36,240

Recall that we came up with this model in our last conversation with John and would please pass the



33

00:02:36,240 --> 00:02:42,570

video, put your thoughts on a piece of paper, and next I'll share my thoughts on the solution.



34

00:02:43,050 --> 00:02:50,250

We may address these requirements by introducing a new integration, even booking confirmed in the booking



35

00:02:50,250 --> 00:02:52,020

confirmation repository.



36

00:02:52,320 --> 00:02:57,240

Every time a booking is confirmed, a booking confirmed even will be released.



37

00:02:57,240 --> 00:03:03,960

And this evening will then be received by the various subscribers, such as other Metro services and



38

00:03:03,960 --> 00:03:08,370

the notification service on receiving the event as a message.



39

00:03:08,520 --> 00:03:15,450

The notification service will send out the email and other services can carry out their required processing



40

00:03:15,570 --> 00:03:20,220

to generate the reports and to use the data for whatever purpose they need.



41

00:03:20,220 --> 00:03:27,050

This data for the benefit of this approach will be that all of these events will be triggered in realtime.



42

00:03:27,450 --> 00:03:33,270

So these other services will have all of the current data they need for their processing.



43

00:03:34,580 --> 00:03:42,020

Next, I'll walk you to this component diagram from the events perspective, this note and this persistence



44

00:03:42,020 --> 00:03:45,830

layer depicted here is for the sales micro service.



45

00:03:45,860 --> 00:03:54,740

Let's assume that the messaging backbone is built on Rabbit MQ and the subscriber's are external services



46

00:03:55,010 --> 00:03:56,780

and the other micro services.



47

00:03:57,050 --> 00:04:03,200

As you can see here, we have the notification service here as well as discussed in an earlier lecture



48

00:04:03,650 --> 00:04:12,050

the parent ordered after receiving a successful payment confirmation update, the payment ordered entity



49

00:04:12,050 --> 00:04:16,490

in the persistent storage and then raises the payment received domain.



50

00:04:16,490 --> 00:04:18,020

Even this payment received.



51

00:04:18,020 --> 00:04:25,670

The main event is consumed by the payment received Hannelore and the status of the booking confirmation



52

00:04:25,880 --> 00:04:31,060

after the reservations is updated to conform so to meet the new requirement.



53

00:04:31,580 --> 00:04:38,180

Now, once the booking confirmation status is updated, the booking confirmation aggregate will raise



54

00:04:38,180 --> 00:04:39,530

the booking confirmed.



55

00:04:39,530 --> 00:04:45,290

Even this will lead to a publishing of a message to a topic shown here.



56

00:04:45,440 --> 00:04:51,830

As these components have subscribed to the topic, they will all receive the event as a message, and



57

00:04:51,830 --> 00:04:56,620

each of these components can then process the message as per their needs.



58

00:04:57,670 --> 00:05:04,150

As a best practice, we need to ensure that our model is not tied to any specific technology.



59

00:05:04,510 --> 00:05:11,290

As a result, we will define an infrastructure service that will insulate the model from the underlying



60

00:05:11,290 --> 00:05:12,410

messaging technology.



61

00:05:12,730 --> 00:05:17,800

This infrastructure service will be implemented as an interface messaging service.



62

00:05:18,340 --> 00:05:25,870

This messaging service interface will expose functions for the various moral components to interact



63

00:05:25,870 --> 00:05:27,990

with the underlying messaging technology.



64

00:05:28,150 --> 00:05:32,950

The subscribe function will require an instance of the message handler.



65

00:05:33,250 --> 00:05:39,070

The message handler will have a single function handle which will be executed when the subscriber will



66

00:05:39,070 --> 00:05:39,910

receive a message.



67

00:05:40,060 --> 00:05:44,970

All functions in the messaging service will throw an exception with the name message exception.



68

00:05:45,310 --> 00:05:53,470

This messaging service interface will be implemented by concrete classes for specific messaging technologies.



69

00:05:53,620 --> 00:06:00,790

For example, I've created an implementation for the messaging service for Robert MQ.



70

00:06:01,300 --> 00:06:08,440

The purpose of service here implements the messaging service and the code in the service uses the Rabbit



71

00:06:08,440 --> 00:06:09,780

NQ apps.



72

00:06:10,150 --> 00:06:17,710

I've also put together the purpose of service test class that we will use later to test out this FOB



73

00:06:17,950 --> 00:06:18,490

service.



74

00:06:19,500 --> 00:06:26,550

Now that you understand the overall solution and the messaging infrastructure service, let's put everything



75

00:06:26,550 --> 00:06:30,480

together to understand how the booking confirmed event will work out.



76

00:06:30,510 --> 00:06:34,000

The sequence diagram that I'm going to discuss is available in this file.



77

00:06:34,020 --> 00:06:39,330

Since the booking confirmation repo object will interact with the messaging service, we will set up



78

00:06:39,480 --> 00:06:43,590

the messaging service on the booking confirmation report object.



79

00:06:43,590 --> 00:06:50,310

The booking confirmation aggregate will execute the update status on the booking confirmation repo to



80

00:06:50,310 --> 00:06:52,880

update the status of the booking confirmation.



81

00:06:52,890 --> 00:06:59,100

At this point, the booking confirmation report will update the booking confirmation status in the persistent



82

00:06:59,100 --> 00:07:06,150

storage and if that is successful, it will publish the booking confirmed even by way of the Messaging



83

00:07:06,150 --> 00:07:07,260

Infrastructure Service.



84

00:07:07,710 --> 00:07:14,460

The Messaging Infrastructure Service will then publish the booking confirmed even to the underlying



85

00:07:14,610 --> 00:07:15,510

infrastructure.



86

00:07:15,720 --> 00:07:22,980

In our case, it has a rabbit MQ then Rabbit and Q broker will distribute the event as a message to



87

00:07:22,980 --> 00:07:29,340

all of the even subscribers and even subscribers will then carry out their desired processing using



88

00:07:29,340 --> 00:07:30,690

the data in the event.



89

00:07:31,200 --> 00:07:33,350

Time to review the key points from this lecture.



90

00:07:33,720 --> 00:07:40,200

The first one is that repository is a good place to raise events and the reason for that is because



91

00:07:40,200 --> 00:07:46,580

the updates to the aggregate and the raising of the event need to be carried out in an atomic fashion.



92

00:07:46,590 --> 00:07:52,890

So even will be raised only if the object to storage is successful in the repro implementation.



93

00:07:52,900 --> 00:07:55,050

You will learn more about it in a later lecture.



94

00:07:55,260 --> 00:08:02,070

The second key point is that the model should not have any details of the underlying messaging technology,



95

00:08:02,340 --> 00:08:04,770

or for that matter, any technology.



96

00:08:05,010 --> 00:08:10,290

So to protect the model from having the knowledge of these underlying infrastructure technologies,



97

00:08:10,290 --> 00:08:12,890

you must use infrastructure services.



98

00:08:13,290 --> 00:08:16,350

So we created the message infrastructure service.



99

00:08:16,650 --> 00:08:21,330

In the next lecture you will see the booking confirmed event in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\012 Hands On _ Realization of ACME Integration Events (1 of 2).en.srt -->

1

00:00:00,270 --> 00:00:06,690

In this lesson, you will learn about the implementation of the integration events, specifically the



2

00:00:06,690 --> 00:00:12,340

booking confirmed even by way of code walkthrough and two lectures in this lecture.



3

00:00:12,570 --> 00:00:19,830

I'll cover the set up of the exchange and the Q on Rabbitt MQ and then I'll give you a walkthrough of



4

00:00:19,830 --> 00:00:26,820

the messaging infrastructure service and will test the infrastructure service against the exchange and



5

00:00:26,820 --> 00:00:28,970

the Q set up on MQ.



6

00:00:29,250 --> 00:00:32,190

How divided the code walk through activity into three parts.



7

00:00:32,190 --> 00:00:39,120

In part one, we will set up the exchange and topic on Rabbitt MQ Broca, then we'll test it in part



8

00:00:39,120 --> 00:00:42,300

to will test the infrastructure messaging service.



9

00:00:42,300 --> 00:00:48,630

And then in part three I'll walk you through the code for implementing the booking confirmed event and



10

00:00:48,640 --> 00:00:49,890

will also test that out.



11

00:00:50,040 --> 00:00:55,830

In this lecture I'll be covering only part one and part two and in the next lecture I'll cover part



12

00:00:55,830 --> 00:00:56,160

three.



13

00:00:56,460 --> 00:00:58,830

In Part one will carry out four steps.



14

00:00:58,830 --> 00:01:05,070

And step number one, we will set up an exchange with the name Achmad or salesclerk topic.



15

00:01:05,370 --> 00:01:12,840

And this exchange will be of by topic in step two will set up a Q with the name email or notifications



16

00:01:13,140 --> 00:01:20,130

in step three, will Bindi's new Q with the routing key achmad or sales or booking confirmed.



17

00:01:21,000 --> 00:01:26,700

And in step four will test this set up by publishing the message to the exchange.



18

00:01:27,000 --> 00:01:31,500

This message should end up in the e-mail notifications que.



19

00:01:32,400 --> 00:01:40,560

As a first step, logon to the cloud MQ portal, I already have the instant Acme travel, click on the



20

00:01:40,590 --> 00:01:47,210

Rabbit Amcu manager, go to exchanges and the first thing you need to do is create an exchange.



21

00:01:47,420 --> 00:01:51,080

We are going to give a name to the exchange Acme Auto Sales topic.



22

00:01:51,090 --> 00:01:56,230

Make sure you change the title to Papic and add exchange or exchange is created.



23

00:01:56,250 --> 00:02:02,280

Now here is the exchange next filtrate that you click on the Qs said the name for the queue as email



24

00:02:02,610 --> 00:02:05,370

notifications and just hit at cue.



25

00:02:05,520 --> 00:02:12,840

Click on Go back to the exchanges and all we need to bindis queue to the Akhmad or sales or topic exchange



26

00:02:12,840 --> 00:02:14,790

or click on the exchange.



27

00:02:14,800 --> 00:02:18,390

So we need to provide the name of the queue email notifications.



28

00:02:18,600 --> 00:02:23,640

The routing queue will be Achmad or sales start booking confirmed and just hit binde.



29

00:02:24,000 --> 00:02:32,330

At this point our exchange has one queue which is bound by this routing qinawi ready to test to test.



30

00:02:32,340 --> 00:02:39,120

Just scroll down, provide the routing key achmad all sales start booking confirmed this is a test and



31

00:02:39,120 --> 00:02:41,780

published a message message published.



32

00:02:42,120 --> 00:02:45,270

Let's go back to the Cuno email or notifications.



33

00:02:45,270 --> 00:02:48,390

And as you can see here, there is one message.



34

00:02:48,810 --> 00:02:51,930

Let's scroll down and we'll get a message on it.



35

00:02:51,930 --> 00:02:54,120

And here is our message.



36

00:02:54,120 --> 00:02:57,180

So Sarah has worked out OK at this point.



37

00:02:57,540 --> 00:03:00,450

Let's go to Pakta before proceeding.



38

00:03:00,450 --> 00:03:06,870

Please make sure that you have set up the right MQ Purell in the pub sub service test.



39

00:03:07,140 --> 00:03:10,200

Failure to do so will lead to Conexion failures.



40

00:03:10,680 --> 00:03:17,970

So copy the MQ Purell from the details page and paste it in the pops up service test.



41

00:03:18,150 --> 00:03:25,650

MQ b underscore you are a variable in part two will test the messaging infrastructure service at step



42

00:03:25,650 --> 00:03:33,930

one will push the Q email notifications and step two will set up the pops up test class to publish a



43

00:03:33,930 --> 00:03:36,300

message and then will run the class.



44

00:03:36,300 --> 00:03:37,830

Then we will run this class.



45

00:03:38,070 --> 00:03:45,660

It'll publish a message to the exchange and that message should appear in the email notifications.



46

00:03:45,660 --> 00:03:52,920

Keep in step three will serve the purpose of test class to subscribe for messages and then will run



47

00:03:52,920 --> 00:03:53,460

the class.



48

00:03:53,610 --> 00:04:01,830

This will create a subscription to the topic and we will use the UI to publish a message to the exchange



49

00:04:01,830 --> 00:04:06,870

achmad or sales the topic with the routing key achmad or sales not booking confirm.



50

00:04:07,080 --> 00:04:14,230

And this will lead to our subscriber receiving a message and our subscriber will simply print that message



51

00:04:14,230 --> 00:04:21,220

to the console as a first step will pass the messages from the Q email or notifications.



52

00:04:21,220 --> 00:04:28,220

So click on cues, click on email or notifications, scroll down and click on the button for purging.



53

00:04:29,390 --> 00:04:33,950

And as you can see now, there are zero messages in the queue as a next step, I'll walk you through



54

00:04:33,950 --> 00:04:40,520

the messaging service infrastructure class and the concrete implementation, select the package conduct,



55

00:04:40,870 --> 00:04:45,210

not sales, not moral utility or even messaging.



56

00:04:45,890 --> 00:04:49,460

This is our messaging service interface.



57

00:04:49,670 --> 00:04:57,350

You will find simple pops of functions here and you will observe that all of these functions are throwing



58

00:04:57,350 --> 00:04:59,510

the messaging exception defined here.



59

00:04:59,660 --> 00:05:06,590

The subscribe function here requires an instance of the message handler and this is the message handler,



60

00:05:06,590 --> 00:05:08,560

which has only one function in it.



61

00:05:08,570 --> 00:05:13,880

So these interfaces and classes are our infrastructure service definition.



62

00:05:14,060 --> 00:05:22,340

The actual implementation for Rabbit MQ is available under the package Kondor Acme Dot Dot, Rabbit



63

00:05:22,340 --> 00:05:28,760

MQ and the messaging service is implemented by the class pops of service.



64

00:05:28,760 --> 00:05:34,990

As you can see here, the implementation of this class is using the Rabbit MQ apps.



65

00:05:35,360 --> 00:05:37,160

No, I won't walk you through.



66

00:05:37,190 --> 00:05:45,140

All of the API is used in this implementation, but you will find that I have put in links to the apps



67

00:05:45,140 --> 00:05:45,950

that I have used.



68

00:05:45,950 --> 00:05:52,610

If you're interested in digging deeper into Rabbit MPU, I suggest that you look at this API guide and



69

00:05:52,610 --> 00:05:58,520

then as you are walking through the code in this class, look for these links that I have put in the



70

00:05:58,550 --> 00:06:02,660

comments to test out the implementation of our messaging service.



71

00:06:02,960 --> 00:06:07,010

We will use the class of sub service test in this class.



72

00:06:07,010 --> 00:06:14,470

You will find that it is all set to be executed to test out the public function, just uncovering the



73

00:06:14,480 --> 00:06:19,100

pops of service, not publish and comment the subscriber test.



74

00:06:19,100 --> 00:06:23,120

And now we are able to test out the service to test out simply right.



75

00:06:23,120 --> 00:06:24,200

Click and run.



76

00:06:24,620 --> 00:06:28,460

So this is going to publish a message to the topic, Achmad.



77

00:06:28,470 --> 00:06:30,670

Not sales, not booking confirmed.



78

00:06:31,010 --> 00:06:36,980

Let's go ahead and check the Q And as expected, we see a message here to check out the content of the



79

00:06:36,980 --> 00:06:37,460

message.



80

00:06:37,700 --> 00:06:39,620

Just scroll down, get message.



81

00:06:39,620 --> 00:06:43,850

And here is the content of the message to run the test for subscription.



82

00:06:43,970 --> 00:06:50,360

Go back to the main function, command the purpose of service, don't published and Unkovic this line



83

00:06:50,780 --> 00:06:56,480

at this time we are ready to test now before that, just stop the earlier test again.



84

00:06:56,480 --> 00:06:57,980

Run for this test.



85

00:06:57,980 --> 00:07:03,770

You will see that in this test we have subscribe to the Achmad or sale start booking confirm topic.



86

00:07:03,780 --> 00:07:11,780

So what that means is that if I publish a message to the exchange Achmad sales the topic, our subscriber



87

00:07:11,780 --> 00:07:12,890

should be able to receive it.



88

00:07:12,890 --> 00:07:16,370

And as you can see here, there are two subscribers at this time.



89

00:07:16,380 --> 00:07:22,220

One is a static subscriber that we created, and this subscriber is the one for the code that is running



90

00:07:22,220 --> 00:07:22,940

in the console.



91

00:07:22,940 --> 00:07:25,010

Let's go ahead and publish a message.



92

00:07:25,010 --> 00:07:28,430

We need to provide the routing key achmad sales, start booking.



93

00:07:28,460 --> 00:07:34,550

And I'll just say from your published message message published, let's go back to the console and here



94

00:07:34,550 --> 00:07:35,750

is our message.



95

00:07:35,750 --> 00:07:37,040

Let's try one more time.



96

00:07:37,040 --> 00:07:42,200

I'll just put second test published message, and here is our second test.



97

00:07:42,200 --> 00:07:46,760

And at this time, we should also see messages in the email notifications.



98

00:07:46,760 --> 00:07:48,860

Q And here is the email notifications.



99

00:07:48,860 --> 00:07:51,020

Q Which has three messages in it.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08 Events Driven Architecture & Domain Events\013 Hands On _ Realization of ACME Integration Events (2 of 2).en.srt -->

1

00:00:00,150 --> 00:00:05,800

This is part two of the code walkthrough of integration events in this lesson.



2

00:00:05,850 --> 00:00:11,340

I'll walk you through the repository implementation for booking confirmation.



3

00:00:11,370 --> 00:00:17,120

Then I'll walk you through the code that we will use for testing the integration event.



4

00:00:17,310 --> 00:00:21,970

And at the end, we will see the booking confirmed event in action.



5

00:00:22,380 --> 00:00:27,330

Quick reminder, the code that I am walking you through in this lecture is available under the gate



6

00:00:27,330 --> 00:00:28,500

branch even's.



7

00:00:29,040 --> 00:00:35,700

Recall from the previous lecture that the booking confirmation repo is the one that raises the booking



8

00:00:35,700 --> 00:00:36,240

confirmed.



9

00:00:36,420 --> 00:00:42,990

Even so, in order to raise the event, I have adjusted the booking confirmation repo fake by adding



10

00:00:42,990 --> 00:00:46,700

two new functions to first function is the setup messaging service.



11

00:00:47,220 --> 00:00:53,860

This is the function that will be used for setting up the instance of the messaging service on the booking



12

00:00:53,860 --> 00:00:56,250

confirmation people fake object.



13

00:00:56,640 --> 00:01:02,700

And the second function is the update state function, which will be called from the booking confirmation



14

00:01:02,850 --> 00:01:10,500

aggregate to update the status of the booking confirmation upon the class booking confirmation repo



15

00:01:10,510 --> 00:01:16,980

faith and you will find the up messaging service function that takes an instance of the messaging service



16

00:01:17,130 --> 00:01:25,110

as an argument and it on the instance variable messaging service in the update step function.



17

00:01:25,110 --> 00:01:30,930

If the state is getting updated to conform to then the event metadata is created.



18

00:01:31,140 --> 00:01:37,200

This metadata just has the customer reference and the booking reference and then the messaging service



19

00:01:37,470 --> 00:01:39,670

publishes the data as an event.



20

00:01:39,840 --> 00:01:47,190

So in this setup, we are not sending all of the data in the payload, but we can very well do that



21

00:01:47,190 --> 00:01:48,660

by replacing this code here.



22

00:01:48,780 --> 00:01:53,610

Once the repressors, the event, it prints out this message on the console.



23

00:01:53,970 --> 00:01:56,190

Let me explain how we'll carry out the test.



24

00:01:56,370 --> 00:02:01,290

We will use the class payment order test that we use for earlier testing.



25

00:02:01,510 --> 00:02:04,900

Earlier, we ran the test with messaging disabled.



26

00:02:05,070 --> 00:02:09,210

Now we are going to enable the messaging service in payment order.



27

00:02:09,210 --> 00:02:13,230

Test class will create an instance of pops up service.



28

00:02:13,440 --> 00:02:18,880

Then we will start the pops up service instance on the fake booking confirmation repo.



29

00:02:19,080 --> 00:02:25,140

After that we are going to run the payment order test class and then we should see the booking confirmed,



30

00:02:25,140 --> 00:02:29,750

even published to grab it in the email or notifications.



31

00:02:29,760 --> 00:02:36,220

Q As a first step, we need to make sure that we have the right incorporeal setup and the payment or



32

00:02:36,240 --> 00:02:37,050

test class.



33

00:02:37,380 --> 00:02:46,980

So please go ahead, copy the M Kupwara from the details page and paste it in the payment order test



34

00:02:46,980 --> 00:02:55,020

queue in the variable Amcu underscore Eurail open the payment audit asset class which is under Kamelot



35

00:02:55,020 --> 00:02:57,960

Ackmann sales model test.



36

00:02:57,990 --> 00:03:05,880

Even under the audit and this is our payment order test class called to main function and you will see



37

00:03:06,000 --> 00:03:09,420

a call to the set up messaging on this line.



38

00:03:09,720 --> 00:03:11,640

This is a local function.



39

00:03:11,790 --> 00:03:14,610

Let's take a quick look at this function and this function.



40

00:03:14,730 --> 00:03:22,850

You will see that I am creating pops up service class instance, sending in the properties for the Amcu



41

00:03:22,860 --> 00:03:25,410

P, then starting the messaging service.



42

00:03:25,770 --> 00:03:31,950

If you haven't said the Eurail or if there is any connectivity issue, then there will be an exception



43

00:03:31,950 --> 00:03:34,050

at this point and the test will stop.



44

00:03:34,050 --> 00:03:39,270

Otherwise the messaging service will be set on the booking confirmation repo object.



45

00:03:39,270 --> 00:03:45,690

Now we ready to run the test, but before that, let's push the queue, go to Qs emailed or notifications,



46

00:03:45,690 --> 00:03:47,520

scroll down and purge messages.



47

00:03:47,640 --> 00:03:50,040

No, we have zero messages in the queue.



48

00:03:50,040 --> 00:03:51,780

Let's go ahead and run the test.



49

00:03:51,780 --> 00:03:52,890

Run the tests right.



50

00:03:52,890 --> 00:03:53,970

Click and run.



51

00:03:54,180 --> 00:03:55,410

Then you will run this test.



52

00:03:55,410 --> 00:04:00,140

It'll carry out quite a few activities by way of the fake repositories.



53

00:04:00,180 --> 00:04:07,000

This test is similar to the earlier test, except that this time the fake repository is raising an event.



54

00:04:07,000 --> 00:04:12,900

Here is the message that is coming from the fake repository implementation for booking confirmation.



55

00:04:13,290 --> 00:04:15,900

As you can see here, an event was raised.



56

00:04:16,200 --> 00:04:22,860

Let's check the Q and in the Q, as expected, we see one message and if we get the message, we should



57

00:04:22,860 --> 00:04:25,830

see the message content for the event.



58

00:04:25,830 --> 00:04:31,710

So this is the content of the message coming from our payment order test class.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000001.srt -->

1
00:00:00,240 --> 00:00:14,790
Cho đến nay, bạn đã biết rằng có các mối quan hệ giữa các liên hệ được liên kết, các liên hệ được liên kết này được chuyển thành các dịch vụ vi mô và các mối quan hệ này được chuyển thành các tương tác giữa các dịch vụ vi mô.

2
00:00:15,120 --> 00:00:22,800
Các ứng dụng SCDP cuối cùng là một cơ chế Đồng bộ hóa phổ biến mà qua đó các dịch vụ vi mô tương tác trong phần này.

3
00:00:22,800 --> 00:00:36,630
Bạn sẽ biết rằng các dịch vụ vi mô cũng tạo ra nhiều loại sự kiện khác nhau.  Những sự kiện này được sử dụng bởi các dịch vụ vi mô khác cũng như các thành phần trong bối cảnh liên kết nơi sự kiện được tạo ra.

4
00:00:36,990 --> 00:00:46,080
Bây giờ hãy nói về mối quan hệ giữa kiến ​​trúc điều khiển chẵn và các dịch vụ vi mô.  Kiến trúc thậm chí được định hướng cũng là một mô hình kiến ​​trúc.

5
00:00:46,380 --> 00:00:56,890
Thúc đẩy việc sản xuất, phát hiện, tiêu thụ và phản ứng với các sự kiện và dịch vụ vi mô là những nhà sản xuất và tiêu dùng tự nhiên.

6
00:00:56,910 --> 00:01:04,170
Do đó, kiến ​​trúc điều khiển đồng đều thường được sử dụng để xây dựng các ứng dụng có dịch vụ vi mô.

7
00:01:04,680 --> 00:01:14,270
Các sự kiện có bản chất không đồng bộ và việc thực hiện các tương tác dựa trên sự kiện đòi hỏi phải sử dụng một số công nghệ nhắn tin.

8
00:01:14,610 --> 00:01:21,240
Có nhiều công nghệ nhắn tin có sẵn cho mục đích này.  Trong phần này bạn sẽ thấy cách sử dụng Rabbitt.

9
00:01:21,240 --> 00:01:36,660
MQ COFCO cũng rất phổ biến và bạn sẽ thấy cách sử dụng Kafka ở phần sau.  Chúng ta hãy xem qua các mục tiêu học tập trong phần bạn sẽ tìm hiểu về các dịch vụ vi mô, các kiểu giao tiếp, kiến ​​trúc hướng sự kiện.

10
00:01:36,960 --> 00:01:54,480
Bạn tìm hiểu về các loại sự kiện dịch vụ vi mô khác nhau.  Tôi sẽ cung cấp cho bạn cái nhìn tổng quan về khái niệm AQAP liên quan đến việc triển khai cơ bản các sự kiện và bạn cũng sẽ thấy các sự kiện mô hình bán hàng đang hoạt động bằng cách sử dụng Java và Rabbit MQ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000002.srt -->

1
00:00:00,120 --> 00:00:09,920
Các mẫu giao tiếp cơ bản, đến cuối bài giảng này, bạn sẽ có thể giải thích các mẫu giao tiếp Đồng bộ và không đồng bộ phổ biến.

2
00:00:10,200 --> 00:00:25,300
Bạn sẽ có thể mô tả sự khác biệt giữa một máy thu và nhiều máy thu.  Và ở cuối bài học này, tôi cũng sẽ đưa ra một số ví dụ công nghệ để hiện thực hóa các mẫu mà tôi sẽ thảo luận trong bài giảng này.

3
00:00:25,620 --> 00:00:34,560
Mẫu đầu tiên là mẫu giao tiếp đối tượng nguyên khối trong đó đối tượng gọi là các phương thức trên các đối tượng khác.

4
00:00:35,010 --> 00:00:46,350
Vì vậy, trong ví dụ này, một ứng dụng ngân hàng đang gọi các phương thức trên các đối tượng khác và các phương thức đó đang dẫn đến các cuộc gọi, các hàm trên các đối tượng khác.

5
00:00:46,590 --> 00:01:01,550
Bây giờ, tất cả những điều này đang diễn ra trong một không gian bộ nhớ chung của một quy trình chung.  Đây là điển hình của một ứng dụng nguyên khối và đó là lý do tôi gọi nó là mẫu giao tiếp đối tượng nguyên khối.

6
00:01:02,400 --> 00:01:09,290
Trong trường hợp các ứng dụng hoặc hệ thống phân tán, các thành phần nằm trong không gian xử lý riêng của chúng.

7
00:01:09,690 --> 00:01:21,650
Nói cách khác, không có sự chia sẻ tài nguyên điện toán hoặc bộ nhớ giữa các thành phần.  Các thành phần này giao tiếp với nhau bằng một loại giao thức mạng nào đó.

8
00:01:22,050 --> 00:01:34,770
Giao thức truyền thông mạng này có thể có tính chất đồng bộ hoặc không đồng bộ?  Theo tính đồng bộ, điều đó có nghĩa là người gọi vẫn bị chặn cho đến khi nhận được phản hồi từ thành phần khác.

9
00:01:34,980 --> 00:01:43,170
Ví dụ về các giao thức truyền thông đồng bộ là SCDP và bất kỳ loại thủ tục từ xa độc quyền nào được gọi là cơ chế.

10
00:01:43,290 --> 00:01:58,410
Bởi không đồng bộ, điều đó có nghĩa là người gọi không chờ phản hồi.  Ví dụ về giao tiếp không đồng bộ là một số loại giao thức nhắn tin, chẳng hạn như M Cupie, viết tắt của giao thức tin nhắn nâng cao.

11
00:01:58,800 --> 00:02:09,030
Nếu bạn muốn biết thêm về M cupie, chỉ cần truy cập và cupie dot org.  Và đó cũng là một bài viết hay về AM Cupie trên Wikipedia.

12
00:02:10,470 --> 00:02:18,930
Một điều quan trọng cần ghi nhớ là việc sử dụng các giao thức mạng đồng bộ và không đồng bộ không loại trừ lẫn nhau.

13
00:02:19,320 --> 00:02:37,080
Điều đó có nghĩa là trong các hệ thống phân tán, có thể có một số giao tiếp sử dụng các giao thức mạng đồng bộ như HTP và có thể có các thành phần khác đang giao tiếp qua các giao thức không đồng bộ như M Cupie.

14
00:02:37,740 --> 00:02:49,240
Việc sử dụng các giao thức Đồng bộ và không đồng bộ tùy thuộc vào trường hợp sử dụng và yêu cầu.  Giao tiếp có thể là giữa hai điểm cuối.

15
00:02:49,260 --> 00:03:01,010
Điều này được gọi là giao tiếp một-một, còn được gọi là giao tiếp một người nhận.  Ví dụ phổ biến là HTP, trong đó giao tiếp giữa hai điểm cuối.

16
00:03:01,110 --> 00:03:11,610
Đây là một ví dụ.  Ứng dụng ngân hàng gọi API trên thành phần khách hàng qua HTP.  Bây giờ lệnh gọi này sẽ độc lập với lệnh gọi DEPI bổ sung.

17
00:03:11,610 --> 00:03:22,980
Ứng dụng ngân hàng sẽ tạo thành phần tài khoản.  Nhưng giao thức không đồng bộ như SCDP, bạn sẽ luôn có giao tiếp 1-1, giao tiếp 1-1.

18
00:03:22,980 --> 00:03:30,410
Parathion cũng có thể được thực hiện bằng cách sử dụng cơ chế nhắn tin không đồng bộ.  Hãy để tôi giải thích cách thức hoạt động của nó.

19
00:03:31,320 --> 00:03:41,660
Giả sử ứng dụng ngân hàng có API Invoker trong thành phần tài khoản và API này đang sử dụng giao thức nhắn tin.

20
00:03:42,300 --> 00:03:49,260
Trong trường hợp đó, ứng dụng ngân hàng có thể đưa một tin nhắn vào hàng đợi.  Thông báo này đại diện cho thông báo yêu cầu.

21
00:03:49,680 --> 00:03:56,970
Thành phần tài khoản có thể đọc bộ xử lý tin nhắn này, tạo tin nhắn phản hồi và đưa nó vào hàng đợi.

22
00:03:57,150 --> 00:04:08,040
Sau đó, ứng dụng ngân hàng có thể đọc tin nhắn dưới dạng phản hồi cho yêu cầu của nó.  Vì vậy, kịch bản này trông giống như một mẫu phản hồi yêu cầu đồng bộ.

23
00:04:08,340 --> 00:04:19,470
Nhưng giao thức cơ bản không đồng bộ theo kiểu giao tiếp một đến nhiều.  Có nhiều thành phần quan tâm đến việc nhận tin nhắn từ người gửi.

24
00:04:19,680 --> 00:04:32,640
Điều này thường đạt được bằng cách bật lên mẫu tin nhắn.  Hãy để tôi giải thích điều này bằng một ví dụ.  Giả sử có một thành phần tài khoản đảm nhiệm việc thiết lập tài khoản mới cho khách hàng của ngân hàng.

25
00:04:32,640 --> 00:04:44,640
Và sau đó có những thành phần khác quan tâm đến việc nhận thông báo.  Khi một tài khoản khách hàng mới được thiết lập để thực hiện mẫu này, một chủ đề sẽ được thiết lập trên hệ thống nhắn tin.

26
00:04:44,670 --> 00:04:57,990
Thành phần tài khoản sẽ xuất bản một thông báo về chủ đề này mỗi khi tài khoản mới được tạo.  Các thành phần khác này sẽ đăng ký chủ đề chung này và nhận tin nhắn khi nhận được tin nhắn.

27
00:04:58,200 --> 00:05:07,670
Mỗi thành phần này.  Sẽ thực hiện một nhiệm vụ cụ thể được giao cho nó.  Vì vậy, ví dụ, thành phần e-mail sẽ gửi e-mail cho khách hàng.

28
00:05:07,910 --> 00:05:18,980
Thành phần nhóm đặt hàng sẽ đặt mua thẻ ATM và bảng thông tin người thực hiện cập nhật sẽ cập nhật số lượng tài khoản trên bảng thông tin người thực hiện.

29
00:05:19,430 --> 00:05:26,570
Tiếp theo, tôi sẽ đề cập đến một số công nghệ mẫu có thể được sử dụng để hiện thực hóa các kiểu giao tiếp này.

30
00:05:27,470 --> 00:05:41,220
GDP là một cách phổ biến mà Microsoft sử dụng để hiển thị các ứng dụng.  Có nhiều khung cho các ngôn ngữ khác nhau có thể được sử dụng để xây dựng các ứng dụng nhắn tin này.

31
00:05:41,270 --> 00:05:56,470
Có 2 loại sản phẩm, sản phẩm tuân thủ MQ là MQ hoạt động và MQ Rabbitt.  Và sau đó có những sản phẩm được biết là tuân thủ, chẳng hạn như Kafka, Amazon Skier's, Amazon S.A..

32
00:05:56,490 --> 00:06:06,090
Xin lưu ý rằng đây chỉ là một số ví dụ.  Trên thực tế, còn có nhiều sản phẩm và khuôn khổ khác có thể được sử dụng cho các kiểu giao tiếp khác nhau này.

33
00:06:06,140 --> 00:06:13,880
Bạn sẽ thấy một số công nghệ này hoạt động trong các bài giảng sau của khóa học này.  Đã đến lúc xem xét nhanh.

34
00:06:13,880 --> 00:06:32,270
Trong bài học này, tôi đã đề cập đến các mẫu giao tiếp cơ bản.  Các mẫu đồng bộ là những mẫu trong đó người gọi gửi yêu cầu và chờ phản hồi quay trở lại như một ví dụ thực sự về mẫu giao tiếp đồng bộ.

35
00:06:32,660 --> 00:06:43,400
Trong trường hợp kiểu liên lạc không đồng bộ, người gọi sẽ gửi tin nhắn và không đợi phản hồi mà tiếp tục thực hiện quá trình xử lý.

36
00:06:43,820 --> 00:06:56,420
Tức là nó không bị chặn.  Các nền tảng nhắn tin như Kafka, Rabbit, MQ và Active Amcu thường được sử dụng để xây dựng các mẫu giao tiếp không đồng bộ.

37
00:06:57,080 --> 00:07:07,130
Cửa sổ bật lên thường được sử dụng khi có nhiều người nhận tin nhắn.  Trong bài giảng tiếp theo, bạn sẽ tìm hiểu cách các dịch vụ vi mô sử dụng các mẫu này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000003.srt -->

1
00:00:00,150 --> 00:00:22,140
Microsoft cho biết các tương tác trong bài giảng này, tôi sẽ đề cập đến các mô hình giao tiếp trong Microsoft Office giữa Microsoft ISS và giữa Dịch vụ của Microsoft và các dịch vụ bên ngoài, các dịch vụ vi mô và Giao tiếp của Crossover đề cập đến các lệnh gọi chức năng được thực hiện giữa các thành phần trong cùng một bối cảnh liên kết.

2
00:00:22,380 --> 00:00:35,850
Ý tưởng là một văn phòng Microsoft được triển khai trong một đơn vị triển khai duy nhất.  Điều đó có nghĩa là các thành phần trong thời gian chạy trong Microsoft được chia sẻ một không gian xử lý chung.

3
00:00:36,000 --> 00:00:54,570
Tất cả các tương tác xảy ra bằng cách gọi hàm trực tiếp.  Đôi khi, Microsoft cho biết, các nhà thiết kế quyết định thay thế các lệnh gọi hàm này bằng một số giao thức mạng, chẳng hạn như API qua HDB hoặc các tín hiệu và chủ đề nhắn tin.

4
00:00:54,870 --> 00:01:18,660
Quyết định này được đưa ra nhằm đạt được mức độ tách rời cao và khả năng mở rộng trong tương lai.  Nói cách khác, giả sử nếu bạn có một thành phần trong dịch vụ vi mô mà bạn dự kiến ​​sẽ chuyển ra khỏi Microsoft Office sau này thì bạn có thể triển khai các tương tác với thành phần đó bằng giao thức mạng.

5
00:01:19,020 --> 00:01:28,510
Ý tưởng là khi dịch vụ này bị rút khỏi Microsoft Office, sẽ không có yêu cầu thay đổi mã trong các thành phần cổ áo.

6
00:01:28,920 --> 00:01:40,500
Nhược điểm của việc thay thế các lệnh gọi hàm trực tiếp này bằng các giao thức mạng là sẽ có một số mức chi phí mạng mà bạn sẽ phải giải quyết.

7
00:01:40,720 --> 00:01:58,900
Vì vậy, đó là cái giá bạn sẽ phải trả.  Giao tiếp giữa các dịch vụ ở đây đề cập đến giao tiếp giữa các dịch vụ vi mô khác nhau hoặc giữa các địa chỉ liên hệ được liên kết khác nhau, bạn sẽ luôn sử dụng các giao thức mạng để thực hiện các loại giao tiếp này.

8
00:01:58,920 --> 00:02:24,560
Hãy nhớ rằng việc sử dụng tính năng nhắn tin hoặc HTP sẽ tùy thuộc vào trường hợp sử dụng và các yêu cầu khác.  Quyết định sẽ dựa trên việc giao tiếp được yêu cầu đồng bộ hay không đồng bộ hay bạn đang muốn phân phối tin nhắn đến nhiều người nhận hay chỉ có một người nhận tin nhắn.

9
00:02:24,600 --> 00:02:31,110
Vì vậy, trong trường hợp Synchronoss, bạn sẽ luôn sử dụng giao thức mạng đồng bộ như Resto hoặc HTP.

10
00:02:31,530 --> 00:02:40,850
Trong trường hợp có nhiều bộ thu, bạn sẽ luôn sử dụng kiểu mẫu bật lên.  Tiếp theo, tương tác các dịch vụ bên ngoài của Alcoa.

11
00:02:41,130 --> 00:02:58,460
Việc các dịch vụ vi mô giao tiếp với các dịch vụ bên ngoài là điều bình thường.  Giao thức mạng và định dạng của tin nhắn được sử dụng bởi các dịch vụ bên ngoài này nằm ngoài tầm kiểm soát của Nhóm Phát triển Dịch vụ Vi mô.

12
00:02:58,770 --> 00:03:09,270
Do đó, Nhóm phát triển dịch vụ vi mô cần tuân thủ các yêu cầu về giao diện và giao thức mạng của các dịch vụ bên ngoài này.

13
00:03:09,570 --> 00:03:27,240
Ví dụ: có thể có một cổng thanh toán hiển thị giao diện của nó bằng HTP, một dịch vụ ghi nhật ký hiển thị giao diện của nó bằng cách nhắn tin và sau đó các cơ sở dữ liệu thường được sử dụng có giao thức mạng độc quyền dựa trên TCP IP của riêng chúng.

14
00:03:27,960 --> 00:03:39,180
Từ góc độ dịch vụ vi mô, chi tiết về giao thức mạng và định dạng nhắn tin này sẽ được gói gọn trong các dịch vụ cơ sở hạ tầng.

15
00:03:39,450 --> 00:03:54,270
Như đã thảo luận trước đó, các dịch vụ cơ sở hạ tầng này sẽ chịu trách nhiệm giữ phần còn lại của mã dịch vụ vi mô độc lập với Giao thức dịch vụ bên ngoài cũng như các định dạng tin nhắn.

16
00:03:55,460 --> 00:04:08,820
Đối với Giao tiếp giữa các dịch vụ trong Dịch vụ vi mô, nhà phát triển dịch vụ vi mô cần quyết định cấu trúc của thông báo yêu cầu và phản hồi, đồng thời họ cũng cần quyết định về định dạng.

17
00:04:08,960 --> 00:04:21,650
Thông thường, một dịch vụ vi mô hiển thị giao diện sẽ sử dụng các đối tượng mô hình để xác định cấu trúc của thông báo yêu cầu và phản hồi từ phối cảnh chuyển tiếp.

18
00:04:21,800 --> 00:04:33,950
Jason là một hình thức phổ biến.  Nhưng xin lưu ý rằng các định dạng khác, chẳng hạn như XML và CSFI cũng được sử dụng ở định dạng không phổ biến khác như định dạng bộ đệm giao thức.

19
00:04:33,950 --> 00:04:42,720
Kết hợp với giao thức giao thức PC.  Baphomet là một cơ chế tuần tự hóa có hiệu suất cao được phát triển bởi Google.

20
00:04:42,740 --> 00:04:58,430
Nếu bạn muốn tìm hiểu thêm về nó, vui lòng xem liên kết tại đây.  Hãy nhớ rằng bộ đệm giao thức và cơ chế giao tiếp dựa trên quyền riêng tư của bạn phù hợp với các giao diện dịch vụ vi mô yêu cầu hiệu suất và thông lượng cao.

21
00:05:00,090 --> 00:05:06,820
Bây giờ là lúc dành cho câu đố, giả sử có hai bộ Microsoft, A và B, cần tương tác với nhau.

22
00:05:07,290 --> 00:05:16,980
Hai dịch vụ vi mô này được quản lý bởi hai nhóm độc lập và mỗi nhóm này phát triển mô hình riêng cho A và B.

23
00:05:17,700 --> 00:05:30,360
Kết quả là không có mối quan hệ nào giữa A và mô hình kinh doanh.  Vì vậy, một câu hỏi khác dành cho bạn là nên sử dụng mô hình nào để liên lạc giữa A và B?

24
00:05:32,530 --> 00:05:40,600
Câu trả lời là tùy thuộc vào cách bạn muốn quản lý sự phụ thuộc giữa A và B.

25
00:05:42,110 --> 00:05:50,900
Việc quản lý phụ thuộc cho các dịch vụ vi mô này được thực hiện theo các ranh giới, bối cảnh, mô hình tích hợp được xác định rõ ràng.

26
00:05:51,230 --> 00:06:00,180
Tôi đã đề cập đến các mô hình tích hợp này trong các bài giảng trước và nếu bạn quên nó, tôi khuyên bạn nên xem lại các video đó.

27
00:06:00,410 --> 00:06:11,990
Tôi sẽ trình bày các mô hình tích hợp này trong một bản tóm tắt ngắn gọn.  Tiếp theo, mẫu tích hợp ngữ cảnh liên kết đầu tiên để quản lý phần phụ thuộc là mẫu hạt nhân dùng chung.

28
00:06:12,170 --> 00:06:41,580
Trong đó, một bộ quy tắc đạo đức và quy tắc chung dành cho các bác sĩ vi phẫu được chia sẻ giữa các vi mạch.  Vì vậy, trước tiên trong chủ đề ví dụ này của Microsoft, nó chịu trách nhiệm tạo và quản lý hạt nhân dùng chung, được cả A và B sử dụng, mặc dù phần hạt nhân dùng chung trên cũng có thể được triển khai dưới dạng SDK hoặc thư viện, nhưng tốt hơn là nên sử dụng nó.  sử dụng giao thức mạng như được mô tả trong hình minh họa này.

29
00:06:41,840 --> 00:06:57,270
Phần thứ hai là mô hình nhà cung cấp khách hàng.  Trong kiểu tích hợp này, nhà cung cấp hoặc nhà cung cấp giao diện chỉ định dạng giao diện và giao thức mạng theo nhu cầu của khách hàng.

30
00:06:57,710 --> 00:07:10,010
Vì vậy, mặc dù nhà cung cấp có thể có mô hình khác cho một số thực thể thông thường, họ sẽ chịu trách nhiệm điều chỉnh định dạng của thông báo ngoài mô-đun của khách hàng.

31
00:07:10,790 --> 00:07:21,780
Tiếp theo là mẫu tuân thủ, như tên gợi ý trong mẫu này.  Thứ nhất, Microsoft tuân thủ mô hình được xác định trong một dịch vụ vi mô khác.

32
00:07:21,920 --> 00:07:48,440
Vì vậy, ở đây trong ví dụ này, thời gian dành cho Microsoft là a đã quyết định áp dụng các mô hình do Dean xác định cho B của Microsoft, nhưng có một số thách thức nhất định với mô hình này và những thách thức mà bất cứ khi nào có sự thay đổi trong mô hình đối với Microsoft là B, chúng sẽ  sẽ có tác động đến Microsoft A và nhóm Microsoft là A sẽ cần điều chỉnh để giảm thiểu tác động đó.

33
00:07:48,590 --> 00:08:03,340
Nhóm của Microsoft có thể áp dụng mô hình lớp chống tham nhũng trong việc này.  Họ có thể tạo một lớp tách biệt tất cả mã dịch từ các mô hình từ B sang nó và ngược lại.

34
00:08:03,890 --> 00:08:21,080
Ưu điểm của việc sử dụng mẫu lớp chống tham nhũng là những thay đổi trong mô hình của B sẽ không ảnh hưởng đến việc triển khai cốt lõi của Microsoft Office và mọi thay đổi cần thiết sẽ được tách biệt với lớp chống tham nhũng.

35
00:08:22,060 --> 00:08:44,640
Chúng ta hãy điểm qua những điểm chính từ bài học này để xây dựng các tương tác trong bối cảnh liên kết hoặc một hoặc dịch vụ là giao tiếp giữa các dịch vụ, bạn có thể sử dụng chức năng gọi là API và nhắn tin trong trường hợp các dịch vụ bên ngoài, Microsoft, điều này phụ thuộc vào giao diện dịch vụ bên ngoài và  giao thức mạng.

36
00:08:44,680 --> 00:08:56,980
Với tư cách là nhà thiết kế hoặc các dịch vụ vi mô, bạn sẽ sử dụng các dịch vụ cơ sở hạ tầng để ánh xạ các giao diện do dịch vụ bên ngoài cung cấp nhằm thực hiện giao tiếp giữa các dịch vụ vi mô.

37
00:08:56,980 --> 00:09:14,530
Đó là, giao tiếp dịch vụ.  Bạn sẽ luôn sử dụng các ứng dụng và nhắn tin.  Điều quan trọng nhất cần ghi nhớ là bạn cần đưa ra quyết định về việc quản lý sự phụ thuộc giữa các dịch vụ vi mô bằng cách sử dụng các mẫu tích hợp ngữ cảnh giới hạn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000004.srt -->

1
00:00:00,240 --> 00:00:16,620
Kiến trúc được định hướng chẵn cung cấp nền tảng để thiết kế các tương tác dịch vụ vi mô trong bài giảng này, bạn tìm hiểu về các sự kiện, bạn tìm hiểu về kiến ​​trúc được định hướng chẵn và tôi sẽ so sánh những quả táo với kiến ​​trúc thậm chí có liên quan.

2
00:00:17,430 --> 00:00:24,980
Tôi sẽ bắt đầu bài học này bằng cách thảo luận về một tình huống mua sắm trực tuyến phổ biến.  Khách hàng thanh toán sản phẩm trong giỏ hàng.

3
00:00:25,170 --> 00:00:32,610
Tại thời điểm đó, các hành động khác nhau được thực hiện.  Một email được gửi đến khách hàng thông báo xác nhận đơn hàng.

4
00:00:32,790 --> 00:00:42,680
Bộ phận vận chuyển xuất đơn hàng, đồng thời hệ thống kho hàng cập nhật số lượng sản phẩm có trong kho.

5
00:00:42,810 --> 00:00:55,350
Vì vậy, việc khách hàng thanh toán này được nhiều hệ thống con trong hệ thống mua sắm trực tuyến quan tâm.  Có một điều đáng quan tâm, đó là việc khách hàng trả phòng được coi là một sự kiện.

6
00:00:55,350 --> 00:01:08,400
Và tất cả các hệ thống con quan tâm đến việc nhận thông báo về sự kiện này đều được gọi là sự kiện của người tiêu dùng xảy ra một cách tự nhiên trong mọi tình huống kinh doanh.

7
00:01:09,030 --> 00:01:24,240
Hãy để tôi cung cấp cho bạn một định nghĩa chính thức hơn về các sự kiện.  Sự kiện là dấu hiệu cho thấy điều gì đó có ý nghĩa đã xảy ra tại một thời điểm so với điều gì đó đã xảy ra trong quá khứ.

8
00:01:24,390 --> 00:01:30,490
Có những người tiêu dùng muốn biết về các sự kiện nên muốn được thông báo.

9
00:01:30,720 --> 00:01:40,020
Vì vậy, khi một sự kiện xảy ra, một hoặc nhiều người tiêu dùng sẽ được thông báo về sự kiện này.  Khi nhận được sự kiện.

10
00:01:40,050 --> 00:01:51,390
Quá trình xử lý Consumer Macario và xử lý sự kiện độc lập với người tạo sự kiện và những người tiêu dùng khác của sự kiện.

11
00:01:51,870 --> 00:02:07,290
Và kiến ​​trúc điều khiển chẵn là một mô hình kiến ​​trúc phần mềm nhằm thúc đẩy việc thiết kế các hệ thống như một tập hợp các thành phần đồng lỏng lẻo đóng vai trò đồng đều như nhà sản xuất và thậm chí cả người tiêu dùng.

12
00:02:08,180 --> 00:02:17,190
Trọng tâm của kiến ​​trúc hướng sự kiện là xương sống sự kiện, giờ đây xương sống của sự kiện này là một thành phần cơ sở hạ tầng.

13
00:02:17,330 --> 00:02:27,630
Bạn có thể nghĩ về nó như một thành phần vật chất.  Nó được gọi bằng nhiều tên, thậm chí Busse, thậm chí Broca, thậm chí cả sự kiện Serota, trung tâm sự kiện hòa giải.

14
00:02:27,830 --> 00:02:37,500
Đây là một số thuật ngữ phổ biến được sử dụng cho thành phần này.  Tên gọi phụ thuộc vào tính năng, chức năng của sản phẩm và nhà cung cấp tiếp thị các sản phẩm này.

15
00:02:37,580 --> 00:02:47,760
Tôi khuyên bạn nên thực hiện nghiên cứu của riêng mình trên Google.  Bạn sẽ tìm thấy rất nhiều thông tin.  Điều quan trọng cần ghi nhớ là về mặt khái niệm chúng giống nhau.

16
00:02:47,990 --> 00:03:01,760
Tất cả đều cung cấp một cách để định tuyến các sự kiện, từ nhà sản xuất đến người tiêu dùng.  Các nhà sản xuất sự kiện sẽ thông báo cho người đứng đầu sự kiện về điều gì đó đáng quan tâm đang xảy ra.

17
00:03:01,970 --> 00:03:10,740
Và họ thực hiện điều này bằng cơ chế đồng bộ được cung cấp bởi các sự kiện, đường trục và đường trục sự kiện nhận sự kiện.

18
00:03:10,940 --> 00:03:18,320
Nó chỉ ra nơi thậm chí cần được định tuyến, tùy thuộc vào người tiêu dùng quan tâm đến sự kiện đó.

19
00:03:18,620 --> 00:03:28,360
Vì vậy, ví dụ: sự kiện sẽ được triển khai cho những người tiêu dùng đã đăng ký tham gia sự kiện.  Sự kiện tương tự.

20
00:03:28,370 --> 00:03:35,810
Chúng tôi sẽ được chuyển đến những người tiêu dùng đã đăng ký.  Và điều tương tự cũng xảy ra với các sự kiện khác.

21
00:03:35,990 --> 00:03:43,240
Điều quan trọng cần ghi nhớ ở đây, từ góc độ bình đẳng của người tiêu dùng, là họ không rơi vào những sự kiện này.

22
00:03:43,280 --> 00:04:05,300
Họ nhận được thông báo.  Chúng ta hãy xem một ví dụ cụ thể về kiến ​​trúc điều khiển chẵn.  Giả sử rằng Kafka đang được sử dụng để định tuyến đồng đều, hãy nhớ lại ví dụ về một ngân hàng khi tài khoản ngân hàng mới được tạo, có nhiều thành phần nhận được thông báo và tiến hành xử lý.

23
00:04:05,340 --> 00:04:13,860
Vì vậy, trong kịch bản này, ba thành phần này sẽ đăng ký Kafka cho các sự kiện liên quan đến việc tạo tài khoản mới.

24
00:04:13,980 --> 00:04:22,430
Khi một tài khoản mới được tạo trong thành phần tài khoản, nó sẽ kết nối với Kafka và xuất bản một thông báo tới chủ đề tài khoản mới.

25
00:04:22,530 --> 00:04:35,340
Khi đó Kafka sẽ thông báo cho tất cả những người đăng ký này về sự kiện tài khoản mới.  Bây giờ, nếu bạn đang nghĩ rằng kiểu nhắn tin này giống với kiểu nhắn tin phổ biến thì bạn đã đúng.

26
00:04:35,760 --> 00:04:53,460
Bật lên.  Mẫu tin nhắn thường được sử dụng để hiện thực hóa các kiến ​​trúc điều khiển chẵn.  Tiếp theo, hãy nói về dữ liệu trong thông báo sự kiện, nội dung của thông báo, có thể là dữ liệu trạng thái hoặc siêu dữ liệu.

27
00:04:53,700 --> 00:05:01,470
Trong trường hợp ví dụ về tài khoản ngân hàng mới, dữ liệu trạng thái sẽ là tất cả thông tin liên quan đến tài khoản mới.

28
00:05:01,650 --> 00:05:16,170
Vì vậy, người tiêu dùng nhận được thông báo đại diện cho sự kiện sẽ nhận được tất cả dữ liệu trạng thái liên quan và họ có thể tiến hành xử lý bằng cách sử dụng dữ liệu trạng thái mà họ sẽ nhận được trong thông báo sự kiện.

29
00:05:16,770 --> 00:05:29,550
Cũng có thể thiết kế cấu trúc sự kiện sao cho nó chỉ chứa siêu dữ liệu.  Trong trường hợp ví dụ về tài khoản ngân hàng, nó có thể chỉ có số tài khoản của tài khoản mới.

30
00:05:30,120 --> 00:05:45,180
Người tiêu dùng sẽ nhận được siêu dữ liệu này và một số người tiêu dùng có thể cần thông tin chi tiết về tài khoản có thể phải liên hệ với nhà sản xuất để lấy tất cả dữ liệu cần thiết cho quá trình xử lý của họ.

31
00:05:45,310 --> 00:05:54,060
Bạn sẽ sử dụng cả dữ liệu trạng thái và siêu dữ liệu trong mình, thậm chí cả tin nhắn.  Không có quy tắc cứng nhắc và nhanh chóng, nhưng có những cân nhắc nhất định.

32
00:05:54,060 --> 00:06:04,950
Nếu kích thước phương thức quá lớn thì có thể có những thách thức liên quan đến độ trễ.  Vì vậy, trong trường hợp đó, bạn có thể cân nhắc chỉ sử dụng siêu dữ liệu trong tin nhắn của mình.

33
00:06:05,100 --> 00:06:19,840
Nếu người tiêu dùng đang dẫn đến nhiều cuộc trò chuyện trong ứng dụng của bạn vì họ đang liên hệ với nhà sản xuất để lấy dữ liệu trạng thái, thì có lẽ bạn nên xem qua dữ liệu trạng thái trong thông báo sự kiện.

34
00:06:20,700 --> 00:06:30,930
Tiếp theo, tôi sẽ thảo luận về API so với kiến ​​trúc được điều khiển đồng đều.  API là các lệnh được định hướng, trong khi các sự kiện là có thể quan sát được.

35
00:06:31,260 --> 00:06:44,970
Chủ đề trung tâm trong kiến ​​trúc phụ thuộc vào EPA là bộ điều phối và bộ điều phối có thể được coi là một thành phần tập trung chứa logic nghiệp vụ và các quyết định sàn.

36
00:06:45,510 --> 00:06:57,240
Khi người điều phối cần thực hiện điều gì đó, nó sẽ gọi một API, đối với phản hồi yêu cầu người khác, dường như sẽ thực hiện quá trình xử lý nghiệp vụ cần thiết.

37
00:06:57,540 --> 00:07:12,920
Trong trường hợp của Edir, người điều phối được thay thế bằng nhà sản xuất chẵn và thậm chí cả người tiêu dùng.  Những người này, thậm chí cả người tiêu dùng, là những người quan sát các sự kiện do nhà sản xuất sự kiện tạo ra.

38
00:07:13,500 --> 00:07:26,970
Một điểm khác biệt lớn giữa hai kiến ​​trúc này là các nhà sản xuất và thậm chí cả người tiêu dùng đều có logic kinh doanh và chịu trách nhiệm đạt được kết quả mong muốn từ quy trình kinh doanh.

39
00:07:27,510 --> 00:07:40,740
Nhà sản xuất chẵn không thực hiện lệnh gọi trực tiếp trên bất kỳ thành phần nào.  Đúng hơn, nó chỉ đơn giản kích hoạt một sự kiện, một thông điệp được chuyển đến tất cả người tiêu dùng.

40
00:07:41,280 --> 00:07:49,110
Hãy nhớ rằng ngay cả nhà sản xuất cũng có thể là người tiêu dùng và thậm chí người tiêu dùng cũng có thể là nhà sản xuất.

41
00:07:49,960 --> 00:08:12,120
Chúng ta hãy nói về sự khác biệt giữa APA và kiến ​​​​trúc được điều khiển, trong trường hợp vượn, người gọi có kiến ​​thức về điểm cuối API, trong khi trong trường hợp nhà sản xuất thậm chí không biết bất kỳ API tiêu dùng nào là đồng bộ, nghĩa là người gọi có  để chờ phản hồi trở lại.

42
00:08:12,160 --> 00:08:20,350
Người gọi bị chặn, trong khi trong trường hợp có sự kiện, nhà sản xuất chỉ là sự kiện của Emmet và tiếp tục.

43
00:08:21,040 --> 00:08:31,110
Bây giờ, nó thậm chí không phụ thuộc vào sự sẵn có của người tiêu dùng.  Vì vậy, điều đó có nghĩa là nó có thể dẫn đến tính sẵn sàng cao hơn trong trường hợp người tiêu dùng không có mặt.

44
00:08:31,810 --> 00:08:41,770
Nhà sản xuất tiếp tục và khi người tiêu dùng đến, họ sẽ nhận được, dữ liệu xuất hiện dựa trên mô hình phản hồi yêu cầu.

45
00:08:42,010 --> 00:08:53,750
Trong khi đó, trong trường hợp sự kiện, thông báo bao gồm dữ liệu sự kiện, có thể là dữ liệu trạng thái hoặc siêu dữ liệu trong trường hợp API, ngay cả với kiến ​​trúc phân tán.

46
00:08:53,770 --> 00:09:09,870
Có mức độ kết nối tương đối cao giữa trình gọi API và điểm cuối API, trong khi đó trong trường hợp xảy ra sự kiện, các nhà sản xuất chẵn và người tiêu dùng chẵn có khả năng tách rời cao và bản thân kiến ​​trúc có thể mở rộng.

47
00:09:09,880 --> 00:09:27,430
Và lý do là bạn có thể thêm hoặc bớt người tiêu dùng mà không ảnh hưởng đến nhà sản xuất dưới bất kỳ hình thức nào.  Thông thường với API, logic nghiệp vụ được tập trung hóa, trong khi đó trong trường hợp có sự kiện, logic nghiệp vụ có thể được trải rộng trên nhiều thành phần.

48
00:09:27,430 --> 00:09:35,650
Và mỗi thành phần này, nhà sản xuất và người tiêu dùng, đều có quyền tự chủ đưa ra quyết định kinh doanh với các thành phần tương tự của họ.

49
00:09:35,680 --> 00:09:46,640
Có thể dễ dàng hiểu được lỗ hổng vì logic nghiệp vụ được tập trung hóa, nhưng ngay cả kiến ​​trúc được điều khiển, việc tuân theo logic nghiệp vụ cũng tương đối khó.

50
00:09:47,170 --> 00:10:08,920
Đã đến lúc làm một bài kiểm tra nhanh.  Bạn sẽ sử dụng kiến ​​trúc nào cho các dịch vụ vi mô của mình?  Câu trả lời là EDI được ưu tiên cho các dịch vụ vi mô, nhưng bạn có thể sử dụng cả ứng dụng và sự kiện trong các dịch vụ vi mô của mình và quyết định sẽ tùy thuộc vào trường hợp sử dụng cũng như các yêu cầu cụ thể của bạn.

51
00:10:08,920 --> 00:10:21,610
Những điểm chính trong bài học này cho thấy một điều gì đó quan trọng đã xảy ra.  Kiến trúc điều khiển chẵn là một mô hình kiến ​​trúc phần mềm dựa trên bản chất của kiến ​​trúc chẵn.

52
00:10:22,030 --> 00:10:37,360
Edir sử dụng giao tiếp không đồng bộ giữa nhà sản xuất và người tiêu dùng.  EDI có khả năng tách rời và mở rộng cao, logic kinh doanh và quy trình kinh doanh trong trường hợp của Edir được phân cấp.

53
00:10:37,520 --> 00:10:47,550
Điều đó có nghĩa là tất cả các thành phần trong hệ thống đều có logic nghiệp vụ nhất định có thể được quản lý độc lập với các thành phần khác trong hệ thống.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000005.srt -->

1
00:00:00,270 --> 00:00:11,630
Trong giờ giảng này, hãy trình diễn mô hình đăng ký công khai bằng cách sử dụng thỏ MQ.  Tôi sẽ bắt đầu bài giảng này bằng cách thảo luận về khái niệm AQAP cơ bản.

2
00:00:11,640 --> 00:00:25,410
Sau đó, chúng tôi sẽ tạo một phiên bản thỏ và tiêu diệt Broecker miễn phí trên AQAP dot com.  Sau đó, chúng ta sẽ sử dụng rabbit mq UI để thiết lập các thành phần trên Rabbit MQ để thực hiện đăng ký công khai.

3
00:00:25,410 --> 00:00:33,960
Xin lưu ý rằng bài giảng này sẽ không dạy cho bạn con thỏ MQ.  Mục đích của tôi là cung cấp cho bạn cái nhìn tổng quan ở mức độ cao về các khái niệm thiết yếu.

4
00:00:34,560 --> 00:00:50,030
Các khái niệm mà tôi đang trình bày trong bài giảng này được trình bày chi tiết tại liên kết này.  Nếu bạn muốn tìm hiểu thêm về nó, MQ hoặc M Cupie, tôi thực sự khuyên bạn nên xem qua nội dung có sẵn tại liên kết này.

5
00:00:50,310 --> 00:00:57,630
Sau khi xem bài giảng này, tôi sẽ bắt đầu bài giảng này với một số thuật ngữ cơ bản mà tôi đã trình bày trước đó.

6
00:00:58,110 --> 00:01:06,480
Và nhà môi giới tin nhắn AM Cupie nhận được tin nhắn từ nhà xuất bản và họ đã viết những tin nhắn này cho người tiêu dùng.

7
00:01:06,570 --> 00:01:20,070
Rabbitt Amcu là một triển khai của Giao thức Amcu, là giao thức mạng.  Nói cách khác, nó cho phép nhà xuất bản và người tiêu dùng kết nối với nhà môi giới tin nhắn qua mạng.

8
00:01:20,430 --> 00:01:30,120
Amcu có thể lập trình được.  Điều đó có nghĩa là các nhà phát triển đưa ra quyết định định tuyến trong phần mềm trung gian nhắn tin trước đó như IBM.

9
00:01:30,120 --> 00:01:39,590
Quản trị viên Amcu kiểm soát thiết lập định tuyến và các nhà phát triển có rất ít hoặc không kiểm soát được các quyết định định tuyến đó.

10
00:01:39,810 --> 00:01:48,170
Tính linh hoạt trong việc đưa ra quyết định định tuyến này giúp các nhà phát triển có nhiều tự do hơn nhưng cũng làm tăng nguy cơ xung đột.

11
00:01:48,720 --> 00:01:58,110
Tính linh hoạt trong việc kiểm soát định tuyến này đạt được nhờ một thành phần được gọi là trao đổi.  Exchange có logic định tuyến.

12
00:01:58,410 --> 00:02:15,120
Hãy tìm hiểu sâu hơn về cách Exchange Work Exchange hiển thị API cho người tiêu dùng và người tiêu dùng nhà xuất bản tạo hàng đợi tạm thời hoặc hàng đợi vĩnh viễn thông qua API của nhà môi giới hoặc bằng cách sử dụng giao diện người dùng của nhà môi giới.

13
00:02:15,600 --> 00:02:28,290
Tên được đặt cho hàng đợi cố định, trong khi hàng đợi tạm thời được tạo bởi nhà môi giới.  Sau đó, người tiêu dùng liên kết hàng đợi với các quy tắc ràng buộc với sàn giao dịch.

14
00:02:28,530 --> 00:02:39,210
Khóa ràng buộc được cung cấp như một phần của quá trình ràng buộc này.  Nhà xuất bản có thể xuất bản thông báo bằng cách sử dụng API do sàn giao dịch cung cấp.

15
00:02:39,630 --> 00:02:45,900
Là một phần của API đã xuất bản, nhà xuất bản phải cung cấp dữ liệu thông báo chính định tuyến và siêu dữ liệu.

16
00:02:45,990 --> 00:02:53,490
Sàn giao dịch sử dụng khóa liên kết, khóa định tuyến và siêu dữ liệu để đưa ra quyết định định tuyến.

17
00:02:53,640 --> 00:03:03,660
Tin nhắn được xuất bản sẽ nằm trong hàng đợi của người tiêu dùng.  Tùy thuộc vào logic định tuyến, nhiều người tiêu dùng có thể liên kết với một trao đổi duy nhất.

18
00:03:03,720 --> 00:03:11,580
Tương tự, nhiều nhà xuất bản có thể xuất bản thông qua một cuộc trao đổi duy nhất.  Có bốn loại trao đổi.

19
00:03:11,580 --> 00:03:21,180
Mỗi loại trao đổi này cung cấp một logic định tuyến khác nhau.  Loại đầu tiên là trao đổi trực tiếp và logic trong phương pháp này khá đơn giản.

20
00:03:21,180 --> 00:03:30,470
Các tin nhắn nhận được từ nhà xuất bản đến hàng đợi có cùng khóa liên kết với khóa định tuyến do nhà xuất bản cung cấp.

21
00:03:30,600 --> 00:03:50,310
Việc trao đổi trực tiếp chỉ tốt cho một lần xử lý.  Nói cách khác, bạn có thể có nhiều hàng đợi được liên kết với cùng một khóa liên kết nhưng thông báo sẽ chỉ được thay đổi thành một trong các Q để bạn có thể phân phối khối lượng công việc cho nhiều nhân viên trên các hàng đợi khác nhau.

22
00:03:50,310 --> 00:03:58,470
Và loại trao đổi trực tiếp sẽ sử dụng Round-Robin để phân phối tải trên nhiều hàng đợi với cùng một khóa liên kết.

23
00:03:58,830 --> 00:04:18,960
Lần sau là lần trao đổi cuối cùng.  Việc trao đổi fadeout bỏ qua định tuyến và khóa liên kết.  Điều đó có nghĩa là khi nhà xuất bản xuất bản một tin nhắn đến sàn giao dịch cuối cùng, việc định tuyến sẽ bị bỏ qua và tin nhắn sẽ được phát đến tất cả các hàng đợi được liên kết với sàn giao dịch đó.

24
00:04:19,080 --> 00:04:33,120
Loại tiếp theo là trao đổi sử dụng dữ liệu tiêu đề thư để định tuyến.  Người tiêu dùng có thể liên kết hàng đợi với loại trao đổi này bằng cách chỉ định lộ trình phù hợp cho dữ liệu trong tiêu đề.

25
00:04:33,420 --> 00:04:49,500
Tiếp theo là phần trao đổi chủ đề.  Trao đổi chủ đề sử dụng khớp mẫu cho khóa định tuyến.  Ý tưởng là người tiêu dùng phải chỉ định mẫu định tuyến trong khóa liên kết cho bị cáo.

26
00:04:49,890 --> 00:04:59,520
Khi nhà xuất bản xuất bản một tin nhắn có khóa định tuyến.  Khóa định tuyến được so sánh với khóa liên kết, đó là khóa.

27
00:04:59,760 --> 00:05:13,380
Giữ mẫu cho tất cả các hàng đợi được liên kết với trao đổi, tin nhắn sẽ được gửi đến tất cả các hàng đợi mà mẫu định tuyến khớp với khóa định tuyến được chỉ định trong tin nhắn đã xuất bản.

28
00:05:13,410 --> 00:05:23,190
Ví dụ về mẫu định tuyến là nơi khóa liên kết được đặt thành khóa định tuyến.  Vì vậy, người tiêu dùng trong trường hợp này đang tìm kiếm sự kết hợp trực tiếp.

29
00:05:24,100 --> 00:05:36,390
Bước đầu tiên, chúng ta cần tạo một phiên bản của Broca, vì vậy hãy truy cập cloud MQ dot com, nhấp vào đăng ký, làm theo hướng dẫn để tạo tài khoản trên cloud và cupie dot com.

30
00:05:36,400 --> 00:05:44,910
Khi bạn đã tạo xong tài khoản, hãy nhấp vào đăng nhập.  Và như bạn có thể thấy ở đây, tôi đã tạo một phiên bản của nhà môi giới để tạo tức thì mới.

31
00:05:44,920 --> 00:05:51,310
Bạn có thể nhấp vào tạo phiên bản mới.  Ở đây bạn cần phải cung cấp một tên.  Hãy gọi cho nhà môi giới Acme Travel.

32
00:05:51,310 --> 00:05:57,500
Đảm bảo rằng bạn đã chọn gói miễn phí.  Như bạn có thể thấy, có những kế hoạch khác sẽ khiến bạn tốn rất nhiều tiền.

33
00:05:57,500 --> 00:06:09,820
Vì vậy chỉ cần chọn Ba tầng rồi chọn khu vực.  Tôi sẽ đi cùng chúng tôi bằng một cú nhấp chuột vào đánh giá.  Và tại thời điểm này, bạn đã sẵn sàng tạo ngay lập tức việc tạo phiên bản có thể mất vài phút.

34
00:06:11,550 --> 00:06:31,690
Để biết thông tin chi tiết về phiên bản này, hãy nhấp vào tên tức thì và nghe điều quan trọng tôi muốn cho bạn xem là MQ Eurail mà chúng tôi sẽ sử dụng trong bài giảng sau để tương tác với nhà môi giới từ mã Java của chúng tôi để thực hiện  quản lý của nhà môi giới.

35
00:06:31,980 --> 00:06:45,480
Bấm vào người quản lý Robert MQ.  Và đây là năm mà chúng ta có thể sử dụng để thử nghiệm các sàn giao dịch.  Nhấp vào các sàn giao dịch và đây là các sàn giao dịch khác nhau có sẵn cho bạn.

36
00:06:45,510 --> 00:06:59,270
Chúng tôi sẽ không sử dụng các sàn giao dịch mặc định này.  Chúng tôi sẽ tạo ra một sàn giao dịch mới.  Vì vậy, hãy nhấp vào THÊM trao đổi mới, cung cấp tên. Tôi sẽ gọi nó là Akhmad hoặc kiểm tra chủ đề, chọn loại làm chủ đề và nhấp vào THÊM Exchange.

37
00:06:59,280 --> 00:07:06,330
Tại thời điểm này, trao đổi chủ đề thử nghiệm của chúng tôi đã được tạo và như bạn có thể thấy ở đây, không có hàng đợi nào bị ràng buộc với nó.

38
00:07:06,360 --> 00:07:12,870
Tiếp theo, chúng ta sẽ tạo một hàng đợi và liên kết với sàn giao dịch này.  Vì vậy hãy nhấp vào Kyuss, nhấp vào thêm hàng đợi mới, đặt tên cho nó.

39
00:07:12,870 --> 00:07:20,610
Hãy gọi nó là Q1 và Q2.  Hãy thêm một hàng đợi khác sẽ gọi nó là Q2 tại hàng đợi.  Và bây giờ chúng ta có hai hàng đợi này là bước tiếp theo.

40
00:07:20,610 --> 00:07:34,140
Chúng ta phải quay lại trao đổi, mở achmad hoặc kiểm tra trao đổi chủ đề của mình.  Và bây giờ chúng ta sẽ thêm các liên kết để thêm liên kết cho Q1 và chúng ta sẽ cung cấp khóa liên kết được chỉ định ở đây.

41
00:07:34,170 --> 00:07:43,350
Tôi sẽ gọi nó là phím chấm kiểm tra và liên kết.  Tại thời điểm này, chúng tôi có Q1 được liên kết với khóa ngày kiểm tra làm khóa liên kết.

42
00:07:43,350 --> 00:07:51,690
Hãy làm tương tự cho Q2 đó là key là test phi tiêu và liên kết.  Bây giờ cả hai hàng đợi của chúng tôi đều liên quan đến chủ đề kiểm tra Akhmadov.

43
00:07:51,690 --> 00:08:01,920
Bây giờ, để kiểm tra hoạt động của trao đổi này, chúng tôi sẽ xuất bản một tin nhắn, nhấp vào xuất bản tin nhắn, cung cấp khóa định tuyến mà anh ấy đã dạy và sau đó cung cấp tải trọng.

44
00:08:01,920 --> 00:08:12,210
Tôi sẽ gọi nó là Tin nhắn xuất bản thử nghiệm Haloed.  Tin nhắn được xuất bản.  Hãy quay lại tố cáo.  Và như bạn có thể thấy ở đây, chúng tôi có một thông điệp trong mỗi câu hỏi này.

45
00:08:12,540 --> 00:08:20,940
Vì vậy nếu muốn đọc tin nhắn chỉ cần vào CU, nhấn vào Get Message.  Và đây là tải trọng thử nghiệm của chúng tôi.

46
00:08:21,720 --> 00:08:32,820
Bây giờ, một thử nghiệm khác sẽ được thực hiện là chúng tôi sẽ thay đổi ràng buộc cho Q2.  Vì vậy, hãy quay lại trao đổi, nhấp vào Achmad hoặc kiểm tra chủ đề của chúng tôi.

47
00:08:33,360 --> 00:08:44,410
Q2 sẽ không bị ràng buộc.  Hãy liên kết lại Q2 bằng một khóa liên kết khác.  Vì vậy, hãy gọi bài kiểm tra quan trọng này ra.

48
00:08:44,460 --> 00:08:57,570
Chìa khoá mới.  Bây giờ chúng ta phải có Qs, Bonwit, các phím định tuyến khác nhau.  Vì vậy, tại thời điểm này, nếu nhà xuất bản xuất bản một thông báo, bài kiểm tra không phải là chìa khóa, nó sẽ kết thúc ở Q1 chứ không phải ở Q2.

49
00:08:57,900 --> 00:09:05,400
Và nếu nhà xuất bản xuất bản thông báo bằng Test Dot Newquay thì thông báo đó sẽ kết thúc ở Quý 2 chứ không phải ở Quý 1.

50
00:09:05,460 --> 00:09:16,260
Hãy tiếp tục và thử kiểm tra khóa mới giống như khóa định tuyến.  Tôi sẽ chỉ đưa vào một tải trọng cho biết rằng đây là khóa mới và xuất bản thông báo đã xuất bản.

51
00:09:16,320 --> 00:09:30,210
Hãy quay lại tố cáo và kiểm tra xem chúng ta có bao nhiêu tin nhắn.  Vì vậy, trong Q1, chúng tôi chỉ có một tin nhắn và trong Q2, chúng tôi có hai tin nhắn vì chúng tôi mong đợi một cú nhấp chuột vào hàng đợi và sau đó bạn sẽ nhận được tin nhắn trong tin nhắn đầu tiên.

52
00:09:30,210 --> 00:09:37,500
Hãy đọc tin nhắn số hai, và đây là tin nhắn số hai, kiểm tra Dort Newquay.  Và tin nhắn này là gửi tới Newquay.

53
00:09:37,500 --> 00:09:45,840
Tôi khuyên bạn nên tự mình thử trao đổi và liên kết hàng đợi để hiểu rõ hơn về cách hoạt động của Rabbit Amcu.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000006.srt -->

1
00:00:00,210 --> 00:00:10,300
Trong bài giảng này, bạn tìm hiểu về các loại sự kiện khác nhau trong thiết kế miền.  Sau đó, chúng ta sẽ tìm hiểu sâu hơn về các sự kiện và miền miền, thậm chí cả các trình xử lý.

2
00:00:10,350 --> 00:00:21,860
Sau đó, tôi sẽ nói về bản chất giao dịch của các sự kiện trong miền.  Sự kiện là một phần không thể thiếu của mô hình được xác định cho bối cảnh ranh giới.

3
00:00:22,260 --> 00:00:40,920
Trong ví dụ này ở đây, mỗi người trong số 100 người liên hệ sẽ có các sự kiện được xác định rõ ràng và vì các sự kiện là một phần của mô hình có thể áp dụng trong ngữ cảnh bị giới hạn nên định nghĩa chẵn luôn được quản lý bằng ngôn ngữ phổ biến cho ngữ cảnh ranh giới đó.

4
00:00:41,040 --> 00:00:53,440
Với tư cách là một chuyên gia, bạn có trách nhiệm đảm bảo rằng bạn đang nắm bắt tất cả các sự kiện có liên quan trong bối cảnh bị giới hạn như một phần của mô hình và ngôn ngữ phổ biến.

5
00:00:53,940 --> 00:01:02,190
Những sự kiện này được các thành phần mô hình đưa ra khi có một số loại thay đổi trạng thái.  Hãy xem một ví dụ.

6
00:01:02,400 --> 00:01:17,500
Các khoản vay cá nhân được triển khai dưới dạng dịch vụ vi mô sẽ có các dịch vụ ứng dụng, dịch vụ miền và tổng hợp, đồng thời mỗi thành phần này có thể đưa ra các sự kiện để chỉ ra một số loại thay đổi trạng thái.

7
00:01:17,940 --> 00:01:30,800
Hãy nhớ rằng có thể có các nguồn khác ngay cả trong một dịch vụ vi mô, chẳng hạn như có thể có giám sát ứng dụng, nhưng giám sát ứng dụng không phát hiện các sự kiện liên quan đến bối cảnh bị giới hạn.

8
00:01:31,110 --> 00:01:41,580
Đây là những sự kiện kỹ thuật và không phải là một phần của thiết kế hướng miền.  Cuộc thảo luận của tôi trong khóa học này là về các sự kiện bị các thành phần bỏ qua trong ngữ cảnh bị chặn.

9
00:01:42,330 --> 00:01:52,830
Các thành phần đang bỏ qua các sự kiện được gọi là nguồn sự kiện và thậm chí người tiêu dùng cũng là người tiêu dùng của các sự kiện đó.

10
00:01:53,340 --> 00:02:04,020
Những người tiêu dùng này thậm chí có thể là một phần của cùng một vi mạch.  Vì vậy, trong trường hợp đó, các sự kiện bị nguồn sự kiện bỏ qua được gọi là các sự kiện miền.

11
00:02:04,290 --> 00:02:18,300
Các sự kiện bị nguồn sự kiện bỏ qua có thể được sử dụng bởi các dịch vụ MICROS khác.  Vì vậy, điều đó có nghĩa là một sự kiện được xác định trong một ngữ cảnh bị chặn sẽ được sử dụng trong một ngữ cảnh bị chặn khác.

12
00:02:18,610 --> 00:02:27,960
Trong những trường hợp như vậy, sự kiện này được gọi là sự kiện tích hợp.  Ngay cả người tiêu dùng cũng có thể là một phần của dịch vụ bên ngoài.

13
00:02:28,320 --> 00:02:38,580
Tôi sẽ coi dịch vụ bên ngoài là API dịch vụ cũ hoặc bất kỳ dịch vụ nào khác không được triển khai dưới dạng dịch vụ vi mô trong những trường hợp như vậy.

14
00:02:38,580 --> 00:02:50,940
Ngoài ra, sự kiện này được gọi là sự tích hợp.  Thậm chí hãy nhớ rằng về mặt ngữ nghĩa không có sự khác biệt giữa các sự kiện miền và sự kiện tích hợp.

15
00:02:51,100 --> 00:02:58,620
Người tiêu dùng chỉ là người quyết định liệu sự kiện sẽ được coi là miền hay thậm chí là tích hợp.

16
00:02:59,250 --> 00:03:05,940
Hãy cùng tìm hiểu sâu hơn về miền và các sự kiện tích hợp.  Tôi sẽ bắt đầu với định nghĩa chính thức về miền.

17
00:03:05,940 --> 00:03:15,310
Ngay cả một sự kiện miền cũng là một thông báo thông báo cho các bộ phận khác trong cùng bối cảnh giới hạn rằng điều gì đó quan trọng đã xảy ra.

18
00:03:15,540 --> 00:03:36,630
Đây là phần quan trọng trong cùng một bối cảnh giới hạn.  Bây giờ, khi một sự kiện miền được kích hoạt, nó sẽ biểu thị sự thay đổi trạng thái trong ngữ cảnh bị giới hạn và người tiêu dùng của sự kiện sẽ nhận được thông báo sự kiện và thực thi một số logic nghiệp vụ trong cùng một ngữ cảnh bị giới hạn.

19
00:03:36,660 --> 00:03:46,190
Vì vậy, điều quan trọng ở đây là hãy nhớ rằng sự kiện miền được kích hoạt trong bối cảnh bị giới hạn và nó được sử dụng trong cùng bối cảnh bị giới hạn đó.

20
00:03:46,890 --> 00:03:55,800
Lý do tại sao các sự kiện đã trở thành một phần không thể thiếu trong thiết kế hướng miền là vì các sự kiện diễn ra một cách tự nhiên.

21
00:03:56,130 --> 00:04:08,920
Đó là những người thợ làm thịt có khái niệm về sự kiện.  Hãy nghĩ đến trường hợp khách hàng của cửa hàng mua sắm trực tuyến thêm hàng hóa vào quầy và sau đó thanh toán khi khách hàng thanh toán.

22
00:04:09,180 --> 00:04:23,670
Đó là dấu hiệu của sự thay đổi trạng thái, tức là một sự kiện mà khách hàng đã kiểm tra.  Điều này thậm chí sẽ dẫn đến quá trình xử lý khác và là một phần của quá trình xử lý đơn hàng, đơn hàng sẽ được chuyển đi, đây một lần nữa là dấu hiệu cho thấy sự thay đổi trạng thái.

23
00:04:24,090 --> 00:04:35,550
Và kết quả là, nó là một quyền tác giả sự kiện.  Các thành phần khác có thể phản ứng với sự kiện mới này.  Ví dụ: một email có thể được gửi đến khách hàng để thông báo cho khách hàng rằng đơn hàng đang được chuyển đi.

24
00:04:35,700 --> 00:04:48,840
Vì vậy các sự kiện xảy ra một cách tự nhiên ở mọi lĩnh vực.  Một cách nhanh chóng để xác định các sự kiện trong một miền là tìm kiếm các tuyên bố như thời điểm điều này xảy ra, sau đó thực hiện.

25
00:04:48,840 --> 00:04:56,550
Phần này thể hiện sự kiện và phần này thể hiện phản ứng đối với sự kiện đó.  Đó là logic kinh doanh.

26
00:04:56,550 --> 00:05:12,010
Xin lưu ý rằng phản ứng này còn được gọi là.  Tác dụng phụ là bây giờ, tôi chắc chắn rằng bạn hiểu rằng ngôn ngữ đóng một vai trò rất quan trọng trong thiết kế Theo nhu cầu, vì vậy bạn phải hết sức cẩn thận khi đặt tên cho các sự kiện của mình.

27
00:05:12,470 --> 00:05:19,480
Luôn sử dụng thì quá khứ, vì sự kiện thậm chí đã xảy ra.  Dưới đây là một số phương pháp hay nhất để đặt tên cho sự kiện.

28
00:05:19,490 --> 00:05:28,930
Bạn phải sử dụng ngôn ngữ phổ biến để không cần phải dịch giữa doanh nghiệp và ví dụ của nhóm CNTT.

29
00:05:29,240 --> 00:05:40,370
Những sự kiện này có phải là một phần của miền bán lẻ không, thậm chí không được thêm dưới dạng hậu tố cho tên chẵn.  Đây là một thực tế phổ biến mà tất cả chúng ta đều đã sử dụng với tư cách là nhà phát triển.

30
00:05:40,370 --> 00:05:49,520
Tương tự, không thêm thao tác làm hậu tố.  Vì vậy, tạo ra ở đây là hoạt động và gợi ý là sử dụng ngôn ngữ kinh doanh.

31
00:05:49,790 --> 00:05:59,600
Vì vậy, người dùng đã đăng ký được ưu tiên hơn tên miền do người dùng tạo.  Even Handler đề cập đến việc triển khai logic của người tiêu dùng chẵn.

32
00:06:00,110 --> 00:06:08,650
Trong trường hợp miền, ngay cả trình xử lý cũng là một phần của cơ sở mã dịch vụ vi mô giống như nhà sản xuất chẵn.

33
00:06:08,840 --> 00:06:15,980
Những trình xử lý này đăng ký các sự kiện quan tâm và có thể không có hoặc nhiều trình xử lý cho mỗi sự kiện.

34
00:06:16,490 --> 00:06:25,280
Giống như các sự kiện, trình xử lý sự kiện phải được đặt tên phù hợp bằng cách sử dụng ngôn ngữ phổ biến như được đề xuất như một phương pháp hay nhất.

35
00:06:25,640 --> 00:06:38,630
Bạn có thể đặt tên cho trình xử lý giống với sự kiện mà trình xử lý đó đang xử lý.  Ví dụ: Order Shib sẽ là tên của đối tượng sẽ xử lý thứ tự các sự kiện.

36
00:06:38,630 --> 00:06:46,640
Không thêm trình xử lý hoặc trình nhận làm hậu tố.  Vì vậy, đây là một cái tên xấu.  Thay vì tên này, bạn nên đi theo thứ tự.

37
00:06:47,660 --> 00:06:56,800
Hãy xem ví dụ về khoản vay cá nhân, dịch vụ vi mô, tên miền, thậm chí nguồn và trình xử lý sự kiện tên miền đều trong cùng một quy trình.

38
00:06:57,230 --> 00:07:11,660
Giả sử có một đơn xin vay tổng hợp.  Tổng hợp đơn đăng ký khoản vay này được gọi khi khách hàng tạo đơn đăng ký vay trực tuyến khi gửi đơn đăng ký trực tuyến.

39
00:07:11,990 --> 00:07:20,540
Việc tổng hợp đơn xin vay sẽ tạo ra đơn xin vay và kho lưu trữ liên tục.  Đó là dấu hiệu của một sự kiện.

40
00:07:20,580 --> 00:07:31,750
Hãy gọi đây là ứng dụng chẵn đã nhận được.  Bây giờ, có thể có một trình xử lý trong cùng một dịch vụ vi mô này quan tâm đến việc phản hồi các sự kiện nhận được của ứng dụng.

41
00:07:31,850 --> 00:07:40,670
Khi sự kiện này bị bỏ qua, trình xử lý sẽ nhận nó và gọi một thao tác để xem xét khoản vay.  Tổng hợp việc xem xét khoản vay này.

42
00:07:40,670 --> 00:07:54,170
Aggregate quản lý quá trình xem xét đơn xin vay.  Là một phần của quá trình xử lý này, người xử lý cũng có thể bắt đầu quá trình xem xét đơn đăng ký bằng cách thông báo cho nhân viên cho vay.

43
00:07:54,350 --> 00:08:03,230
Nhân viên cho vay có thể từ chối hoặc phê duyệt đơn xin vay, điều này có thể dẫn đến các sự kiện mới như đơn được phê duyệt.

44
00:08:03,230 --> 00:08:15,050
Sau đó, người xử lý ứng dụng được phê duyệt sẽ gọi một thao tác trên tổng hợp tài khoản, thao tác này sẽ chịu trách nhiệm thiết lập tài khoản cho vay mới và bộ lưu trữ liên tục.

45
00:08:15,830 --> 00:08:24,530
Một quan niệm sai lầm phổ biến về việc hiện thực hóa sự kiện là các sự kiện phải được quản lý bằng thông báo, nhưng điều đó không đúng với các sự kiện miền.

46
00:08:24,530 --> 00:08:31,490
Các sự kiện miền có thể được thừa nhận và sử dụng một cách đồng bộ, chẳng hạn như bằng cách gọi hàm trực tiếp.

47
00:08:31,490 --> 00:08:43,100
Hãy nhớ rằng nhà sản xuất sự kiện miền và trình xử lý đều ở trong cùng một quy trình.  Nhưng bạn cũng có thể sử dụng cơ chế không đồng bộ như gửi tin nhắn bộ nhớ hoặc thậm chí là tin nhắn bên ngoài.

48
00:08:43,100 --> 00:08:59,330
Broca.  Các thay đổi trạng thái và sự chạy đua của các sự kiện cần phải xảy ra, về mặt nguyên tử trong trường hợp các cuộc gọi Đồng bộ hóa, việc triển khai các cơ chế như vậy sẽ dễ dàng hơn, trong khi với không đồng bộ, bạn sẽ cần sử dụng các mẫu thích hợp.

49
00:08:59,440 --> 00:09:10,770
Hãy để tôi giải thích điều này bằng một ví dụ.  Trong dịch vụ vi mô cho vay cá nhân, tổng hợp đơn xin vay có trách nhiệm quản lý trạng thái của đơn xin vay.

50
00:09:11,050 --> 00:09:20,860
Vì vậy khi khách hàng đăng ký vay, tổng hợp hồ sơ vay sẽ lưu trạng thái hồ sơ vay mới vào cơ sở dữ liệu.

51
00:09:20,920 --> 00:09:28,860
Bây giờ, giả sử tổng hợp không thể đưa ra ứng dụng sự kiện nhận được trong kịch bản thì các bước tiếp theo sẽ không thực thi.

52
00:09:28,870 --> 00:09:40,630
Tại sao?  Bởi vì người xử lý sẽ không bao giờ nhận được thông báo để bắt đầu quá trình xem xét khoản vay.  Một tình huống thất bại khác là khi khách hàng đăng ký khoản vay và đơn xin vay.

53
00:09:40,630 --> 00:09:55,840
Tổng hợp không thể lưu ứng dụng vào cơ sở dữ liệu, nhưng nó đã nâng cấp ứng dụng nhận được.  Ngay cả trong trường hợp này, người xử lý sẽ nhận được thông báo nhưng sẽ không tìm thấy đơn xin vay trong cơ sở dữ liệu.

54
00:09:56,050 --> 00:10:09,340
Kịch bản thứ hai này có thể được giải quyết bằng cách kiểm tra xem tất cả các hoạt động trước khi phát sinh sự kiện có thành công hay không, sau đó chỉ phát sinh sự kiện nếu các hoạt động trước đó thành công.

55
00:10:09,520 --> 00:10:21,790
Hãy để tôi giải thích cách bạn có thể giải quyết tình huống số một.  Xin lưu ý rằng tôi sẽ giải thích một trong nhiều mẫu có sẵn để xây dựng hành vi giao dịch cho các sự kiện miền.

56
00:10:22,180 --> 00:10:30,340
Vì vậy, trong ví dụ này, tổng hợp đơn xin vay sẽ không xảy ra ngay khi nhận được đơn.

57
00:10:30,340 --> 00:10:41,140
Nó sẽ lưu ngay cả vào bộ lưu trữ, bộ lưu trữ, có thể chỉ trong bộ nhớ lưu trữ.  Sau đó, tổng hợp đơn xin vay có thể cố gắng lưu ứng dụng vào cơ sở dữ liệu.

58
00:10:41,470 --> 00:10:52,820
Nếu có lỗi thì sự kiện sẽ không bị xóa.  Nếu việc bán cơ sở dữ liệu thành công thì sự kiện sẽ bị xóa và người xử lý sẽ được thông báo.

59
00:10:53,230 --> 00:11:02,250
Vì vậy, theo cách này, sự thay đổi trạng thái và việc khơi dậy sự kiện sẽ diễn ra một cách nguyên tử.  Chúng ta hãy điểm qua những điểm chính từ bài giảng này.

60
00:11:02,260 --> 00:11:16,810
Có hai loại sự kiện miền và sự kiện tích hợp.  Các sự kiện miền được bỏ qua và xử lý trong cùng bối cảnh giới hạn, trong khi các sự kiện tích hợp được xử lý bên ngoài bối cảnh giới hạn.

61
00:11:16,810 --> 00:11:27,550
Các sự kiện miền có thể được xử lý đồng bộ cũng như không đồng bộ.  Nên sử dụng các quy ước đặt tên phù hợp để đặt tên cho các sự kiện và trình xử lý sự kiện.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000007.srt -->

1
00:00:00,120 --> 00:00:10,180
Trong bài giảng này, chúng ta sẽ đi sâu hơn vào lớp tĩnh, Broecker, mẫu chẵn.  Đầu tiên, tôi sẽ hướng dẫn bạn qua các lớp trong khung mẫu gãy mà tôi đã tập hợp lại.

2
00:00:10,230 --> 00:00:16,330
Sau đó, tôi sẽ chỉ cho bạn sơ đồ trình tự để đăng ký và tăng số chẵn như một phần của bài giảng này.

3
00:00:16,350 --> 00:00:27,240
Tôi cũng sẽ hướng dẫn bạn mã và bạn sẽ thấy mẫu này hoạt động trong lớp tĩnh thậm chí đã phá vỡ một mẫu, một lớp X duy nhất khi sự kiện bị phá vỡ.

4
00:00:27,630 --> 00:00:34,320
Lớp này hiển thị các hàm tĩnh để quản lý sự kiện.  Có một chức năng để nâng cao các sự kiện.

5
00:00:34,620 --> 00:00:41,220
Có chức năng xử lý đăng ký và hủy đăng ký.  Tất cả các cuộc gọi đều là cuộc gọi chức năng trực tiếp.

6
00:00:41,220 --> 00:00:50,790
Do đó tất cả chúng đều đồng bộ.  Và vì tất cả các lệnh gọi đều đang được xử lý, các lệnh gọi hàm trực tiếp nên mẫu này chỉ có thể được áp dụng cho các sự kiện miền.

7
00:00:50,790 --> 00:00:58,800
Nó không thể được sử dụng để tích hợp ngay cả trước khi tiếp tục bài giảng này.  Hãy chắc chắn rằng bạn đã kiểm tra chi nhánh sự kiện.

8
00:00:59,400 --> 00:01:16,560
Tất cả các mô hình đều có sẵn dưới dạng UML utils.  Ngay cả các lớp triển khai cũng không có trong mô hình, không được sử dụng hoặc thậm chí không được đóng gói và các lớp nhiệm vụ đang được thử nghiệm, thậm chí không tĩnh.

9
00:01:16,560 --> 00:01:28,800
Gói Broca.  Khung thống nhất mà tôi đã tập hợp lại sẽ có bốn lớp.  Lớp đầu tiên là lớp tĩnh hiển thị ba chức năng cần thiết để quản lý đồng đều.

10
00:01:29,160 --> 00:01:35,880
Đối với mỗi sự kiện, sẽ có một tập hợp các trình xử lý sẽ được quản lý trong lớp trình điều phối chẵn.

11
00:01:36,070 --> 00:01:45,030
Lớp người gửi hàng thậm chí này sẽ chịu trách nhiệm gửi sự kiện đến những người xử lý đã đăng ký cho sự kiện đó.

12
00:01:45,240 --> 00:01:56,010
Tất cả các trình xử lý sự kiện phải triển khai trình xử lý sự kiện giao diện.  Giao diện này có một hàm xử lý lấy sự kiện làm đối số.

13
00:01:56,010 --> 00:02:04,250
Tất cả các sự kiện phải mở rộng lớp trừu tượng sự kiện và bạn sẽ thấy rằng có một thuộc tính cho tên tên.

14
00:02:04,560 --> 00:02:16,760
Đây là những gì xác định cụ thể loại sự kiện cụ thể.  Thậm chí các lớp có thể giới thiệu các thuộc tính bổ sung để đáp ứng nhu cầu của các sự kiện cụ thể.

15
00:02:16,950 --> 00:02:27,660
Vui lòng xem sơ đồ lớp đầy đủ có sẵn trong dự án trong thư mục này.  Tiếp theo, tôi sẽ hướng dẫn bạn sơ đồ trình tự để đăng ký trình xử lý sự kiện.

16
00:02:27,660 --> 00:02:37,290
Thành phần đầu tiên trong chuỗi sẽ là thành phần lãi suất, là thành phần kiểm soát.  Sau đó, chúng ta có bus sự kiện xử lý sự kiện và một tập hợp các hoạt động gửi đi đều.

17
00:02:37,350 --> 00:02:45,240
Đây là những thành phần chính trong trình tự đăng ký.  Thành phần công nghiệp sẽ tạo một phiên bản của trình xử lý sự kiện.

18
00:02:45,240 --> 00:02:52,920
Sau đó, nó sẽ gọi hàm đăng ký trên bus sự kiện với nhóm sự kiện và trình xử lý chẳng hạn.

19
00:02:52,920 --> 00:03:01,500
Ngay cả xe buýt cũng sẽ tìm người điều phối tên sự kiện nhận được trong chức năng đăng ký.  Hai điều có thể xảy ra.

20
00:03:01,620 --> 00:03:10,530
Xe buýt sự kiện cuối cùng thậm chí sẽ gửi một bộ sưu tập cho sự kiện hoặc nó sẽ không tìm thấy.  Hãy xem kịch bản đầu tiên và tìm thấy bộ điều phối sự kiện.

21
00:03:10,560 --> 00:03:25,950
Nếu người điều phối sự kiện là điện thoại thì ngay cả xe buýt cũng sẽ gọi chức năng đăng ký trên sự kiện.  Bộ điều phối thậm chí cả bộ điều phối sẽ trả về một boolean true cho bus sự kiện và bus sự kiện sẽ trả về true cho lãi suất tại thành phần.

22
00:03:25,950 --> 00:03:48,000
Và tại thời điểm này, trình xử lý đã được đăng ký với sự kiện.  Nhưng nếu bộ điều phối không được tuân theo thì điều đầu tiên mà xe buýt thực hiện là tạo một bộ điều phối cho tên sự kiện đó, sau đó đăng ký bộ điều phối cho tên sự kiện, dẫn đến lệnh gọi đến bộ điều phối sự kiện để đăng ký bộ xử lý.

23
00:03:48,030 --> 00:03:56,610
Bộ điều phối trả về Boolean True, sau đó bus sự kiện sẽ quay trở lại thành phần được ủy thác.  Vì vậy, tại thời điểm này, trình xử lý đã được đăng ký.

24
00:03:57,010 --> 00:04:08,160
Chúng ta hãy xem nhanh hàm đăng ký lớp bus chẵn trong hàm register.  Điều đầu tiên là kiểm tra bộ sưu tập bộ điều phối sự kiện để xem liệu có bộ điều phối cho tên chẵn đã cho hay không.

25
00:04:08,190 --> 00:04:18,180
Nếu bộ điều phối không tồn tại trong bộ sưu tập tạo một bộ điều phối rồi gọi bộ điều phối sự kiện, hãy đăng ký một hàm trong bộ điều phối sự kiện, hãy đăng ký một hàm.

26
00:04:18,180 --> 00:04:27,570
Chúng tôi chỉ đơn giản là kiểm tra xem trình xử lý đã tồn tại chưa.  Nếu nó tồn tại, chỉ cần trả về false vì bạn không muốn cùng một trình xử lý được đăng ký hai lần.

27
00:04:27,570 --> 00:04:36,320
Nếu không, nó có thể dẫn đến trùng lặp và sau đó thêm trình xử lý vào bộ sưu tập.  Như bạn có thể thấy, việc triển khai này khá đơn giản.

28
00:04:36,480 --> 00:04:44,700
Tiếp theo, tôi sẽ hướng dẫn bạn qua trình tự nhận trong đó tuyến tổng hợp sẽ đóng vai trò là nguồn của sự kiện.

29
00:04:44,940 --> 00:04:56,460
Lộ trình tổng hợp sẽ tương tác với cả ông chủ để nâng cao sự kiện.  Sau đó, ông chủ sự kiện sẽ tương tác với người điều phối chẵn, sau đó người điều phối này sẽ tương tác với người xử lý sự kiện.

30
00:04:56,610 --> 00:05:09,170
Vì vậy, điều đầu tiên xảy ra là tuyến đường tổng hợp đó sẽ.  Tất cả chức năng đua xe trên xe buýt, thậm chí cả xe buýt, đều sẽ tìm người điều phối tên buổi tối, không thể xảy ra hai chuyện.

31
00:05:09,170 --> 00:05:22,060
Người điều phối sẽ được theo dõi hoặc nó sẽ không được tìm thấy.  Nếu không tìm thấy bộ điều phối cho sự kiện thì xe buýt chỉ trả về sai, điều này cho biết không có hành động nào được thực hiện vì không có trình xử lý.

32
00:05:22,190 --> 00:05:34,040
Ngược lại, bus sự kiện sẽ gọi hàm điều phối trên phiên bản bộ điều phối chẵn.  Sau đó, bộ điều phối chẵn sẽ gọi hàm xử lý trên tất cả các trình xử lý.

33
00:05:34,040 --> 00:05:44,140
Sau đó, nó trả về true cho cả ông chủ cho biết rằng sự kiện đã được xử lý.  Việc trả lại xe buýt đồng đều đúng với tuyến đường tổng hợp.

34
00:05:44,150 --> 00:05:56,120
Xin lưu ý rằng tất cả các lệnh gọi hàm này đều đồng bộ.  Trong lớp xe buýt chẵn.  Bạn sẽ tìm thấy hàm đua và bạn sẽ tìm thấy ba bước mà tôi đã thảo luận trong sơ đồ trình tự.

35
00:05:56,240 --> 00:06:03,260
Trước tiên, chúng tôi cố gắng tìm người điều phối cho sự kiện đang diễn ra.  Nếu không tìm thấy người điều phối thì không có hành động nào được thực hiện.

36
00:06:03,260 --> 00:06:10,700
Ngược lại, hàm điều phối sẽ được gọi trên phiên bản bộ điều phối chẵn và lớp bộ điều phối chẵn.

37
00:06:10,730 --> 00:06:19,700
Chức năng điều phối kiểm tra.  Nếu kích thước của bộ sưu tập trình xử lý bằng 0, trả về sai vì không có trình xử lý nào xử lý sự kiện.

38
00:06:20,030 --> 00:06:31,910
Nếu không, hãy lặp đến các phiên bản trình xử lý và gọi trình xử lý ngay cả trên mỗi trình xử lý.  Tôi đã đưa ra một trường hợp thử nghiệm để xem ông chủ và hành động đồng đều.

39
00:06:32,300 --> 00:06:41,540
Tất cả các lớp kiểm tra đều có sẵn trong bài kiểm tra.  Ngay cả gói tĩnh đã bị hỏng.  Lớp kiểm thử chính có mã trường hợp kiểm thử.

40
00:06:41,780 --> 00:06:57,720
Một số hành động là lớp xấu và một số hành động xảy ra là lớp xử lý.  Hãy để tôi hướng dẫn nhanh mã cho bạn và cho bạn thấy rằng ngay cả ông chủ cũng đang hành động, vì mục đích thử nghiệm này, hãy giả sử rằng gốc tổng hợp là nguồn gốc của sự kiện.

41
00:06:57,740 --> 00:07:14,360
Và đây là tên của sự kiện sẽ được lớp này đưa ra khi một số hành động được thực hiện ở đây, bạn sẽ thấy rằng chúng ta chỉ đơn giản in ra thông báo và sau đó đưa ra sự kiện chứ không phải để nêu lên sự kiện.

42
00:07:14,360 --> 00:07:23,510
Chúng ta đang chuyển một thể hiện của hành động some.  Hành động some thực sự là một lớp sự kiện mở rộng phần tóm tắt.

43
00:07:23,510 --> 00:07:40,210
Như bạn có thể thấy, không có gì đặc biệt trong lớp học này.  Trong lớp kiểm tra chính.  Những gì chúng ta đang làm trong hàm main là tạo một trình xử lý và sau đó đăng ký trình xử lý đó với ông chủ chẵn và với tên chẵn từ tuyến tổng hợp.

44
00:07:40,220 --> 00:07:49,910
Chúng ta hãy xem nhanh trình xử lý sự kiện.  Vì vậy, một số hành động đã xảy ra.  Đó có phải là một trình xử lý không và nó chỉ đơn giản là đưa ra một thông báo cho biết trình xử lý đã được thực thi.

45
00:07:50,240 --> 00:08:04,280
Vì vậy, hãy quay lại bài kiểm tra chính ở đây.  Và do đó, để thực hiện thử nghiệm, chúng tôi sẽ tạo một lộ trình tổng hợp mới và sau đó thực hiện một số hành động trên đó, điều này sẽ dẫn đến việc nâng cao sự kiện.

46
00:08:04,430 --> 00:08:11,630
Vì vậy, hãy tiếp tục và kiểm tra điều này.  Phải.  Nhấp vào Bài đăng chính và chạy thử nghiệm chính.  Và đây là kết quả của chúng tôi.

47
00:08:11,630 --> 00:08:18,650
Tuyến tổng hợp đã thực hiện hành động thành công và sau đó trình xử lý được thực thi do sự kiện.

48
00:08:18,650 --> 00:08:27,050
Con gái ông chủ đang ở trong lộ trình tổng hợp. Đề nghị bạn đi bộ đến tòa án và tự mình thử.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000008.srt -->

1
00:00:00,150 --> 00:00:18,410
Giống như bao miền khác, Acme sales cũng có các sự kiện trong bài giảng này.  Tôi sẽ xem xét một số sự kiện nhất định trong mô hình miền bán hàng và chúng tôi cũng sẽ nghiên cứu lập mô hình các sự kiện này cũng như trình xử lý các sự kiện này như một phần của quá trình khám phá.

2
00:00:18,420 --> 00:00:30,800
Chúng tôi đã phỏng vấn John.  Và điều John nói là tôi biết có nhiều yêu cầu về quy định và tuân thủ, nhưng vì tôi không phải là chuyên gia nên hãy tham gia cùng hoặc và từ nhóm pháp lý.

3
00:00:31,380 --> 00:00:58,100
Vì vậy chúng tôi đã mời hoặc tham gia cuộc họp và đây là những gì oint đã nói với chúng tôi.  Chúng tôi đang ở trong một ngành công nghiệp được quản lý.  Chúng tôi cần đảm bảo rằng chúng tôi tuân thủ tất cả các quy định, mặc dù có nhiều quy định, nhưng liên quan cụ thể đến việc thanh toán, điều bắt buộc là khi nhận được khoản thanh toán của khách hàng, khoản thanh toán đó phải được duy trì và yêu cầu thanh toán tối thiểu là  bảy năm.

4
00:00:58,590 --> 00:01:08,580
Vậy là có một thuật ngữ mới xuất hiện ở đây, lệnh thanh toán.  Vì vậy, với tư cách là một chuyên gia CNTT, hãy đảm bảo bạn thêm thuật ngữ này vào ngôn ngữ phổ biến.

5
00:01:09,000 --> 00:01:17,040
Tại thời điểm này.  John đã đề cập rằng sau khi chúng tôi nhận được tin nhắn đã nhận thanh toán, việc đặt chỗ sẽ bắt đầu.

6
00:01:17,070 --> 00:01:29,700
Cuối cùng, việc đặt chỗ đã được thực hiện thành công.  Chúng tôi đánh dấu việc đặt phòng là đã được xác nhận.  Đã đến lúc làm một bài kiểm tra, xem qua bản ghi và xác định một sự kiện cũng như tác dụng phụ.

7
00:01:31,210 --> 00:01:40,830
Nếu bạn cần thêm thời gian, vui lòng chuyển video.  Trong bài giảng trước, tôi đã đề cập rằng bạn cần tìm kiếm những câu phát biểu giống như khi một điều gì đó đã xảy ra.

8
00:01:40,840 --> 00:01:48,340
Vì vậy, nếu bạn nhìn vào bản ghi này, bạn có thể dễ dàng thấy rằng khi nhận được khoản thanh toán của khách hàng thì việc đặt chỗ sẽ diễn ra.

9
00:01:49,090 --> 00:01:59,290
Vì vậy, đây là sự kiện và đây là hành động hoặc tác dụng phụ tiếp theo.  Hãy suy nghĩ về cách chúng ta sẽ mô hình hóa những yêu cầu mới này.

10
00:01:59,860 --> 00:02:16,530
Tất cả thông tin thanh toán phải được lưu giữ trong bảy năm khi đề cập đến việc kiểm tra thanh toán.  Không có lệnh thanh toán nào là bản ghi tất cả các khoản thanh toán do khách hàng thực hiện, vì đó là một thực thể cũng sẽ cần một kho lưu trữ.

11
00:02:16,660 --> 00:02:24,880
Thực thể lệnh thanh toán này có thể hiển thị khoản thanh toán trong quy trình hoạt động và thực hiện việc xử lý khoản thanh toán.

12
00:02:25,060 --> 00:02:37,210
Chúng tôi sẽ gọi chức năng này.  Bất cứ khi nào chức năng này được gọi và thanh toán thành công, một thực thể mới sẽ được tạo và thêm vào bộ sưu tập thanh toán bằng kho lưu trữ thanh toán.

13
00:02:37,360 --> 00:02:50,470
Và các khoản thanh toán thành công cũng sẽ dẫn đến việc tăng số tiền nhận được.  Ngay cả khi sự kiện này được nêu ra, nó sẽ được xử lý bằng cách xử lý khoản thanh toán đã nhận để bắt đầu quá trình đặt trước.

14
00:02:50,470 --> 00:03:06,910
Và sau khi tất cả các lượt đặt trước thành công, nó sẽ thay đổi trạng thái xác nhận đặt chỗ để xác nhận rằng đó là sơ đồ lớp mô tả tất cả các lớp mới được giới thiệu trong mô hình nhằm đáp ứng các yêu cầu mới mà chúng tôi đã khám phá.

15
00:03:07,270 --> 00:03:22,980
Mô hình này có sẵn trong tệp mô hình này.  Như bạn có thể thấy ở đây, tôi đã giới thiệu khoản thanh toán nhận được ngay cả trong gói thanh toán và khoản thanh toán nhận được này thậm chí còn bị bỏ qua trong quá trình kiểm tra thanh toán lớp này.

16
00:03:23,230 --> 00:03:32,980
Trình xử lý nằm trong gói đặt chỗ và nó mở rộng lớp xử lý sự kiện.  Tất cả mã Java cho các lớp này đều có sẵn trong dự án.

17
00:03:33,400 --> 00:03:41,020
Nếu bạn quan tâm, bạn có thể truy cập mã vào lúc này.  Tiếp theo, tôi sẽ hướng dẫn bạn về miền thanh toán nhận được, theo trình tự chẵn.

18
00:03:41,200 --> 00:03:48,400
Mô hình này có sẵn trong tập tin này.  Đại lý bán hàng tiếp nhận thông tin thẻ tín dụng từ khách hàng.

19
00:03:48,700 --> 00:03:55,690
Họ nhập thông tin thẻ tín dụng này vào một loại ứng dụng nào đó mà tôi gọi là giao diện bán hàng.

20
00:03:55,720 --> 00:04:09,970
Sau đó, giao diện hoặc ứng dụng bán hàng sẽ thực hiện quá trình thanh toán trên lệnh thanh toán.  Lệnh thanh toán sử dụng Dịch vụ cơ sở hạ tầng cổng thanh toán để thực hiện xử lý thanh toán thực tế.

21
00:04:09,970 --> 00:04:18,700
Dịch vụ Cổng thanh toán này đã được thảo luận trong một trong những bài giảng trước đó.  Dịch vụ Cổng thanh toán tương tác với dịch vụ thanh toán bên ngoài.

22
00:04:18,700 --> 00:04:33,190
Xác nhận thanh toán được Cổng thanh toán nhận, sau đó được chuyển sang kiểm tra thanh toán, kiểm tra thanh toán khi nhận thanh toán, xác nhận quyền truy cập vào bộ lưu trữ liên tục và sau đó đưa ra sự kiện nhận thanh toán.

23
00:04:33,700 --> 00:04:41,860
Tiếp theo, hãy xem sơ đồ hoạt động của trình xử lý thanh toán đã nhận.  Mô hình được mô tả ở đây có sẵn trong tập tin này.

24
00:04:42,370 --> 00:04:57,730
Người xử lý thanh toán nhận được sự kiện đã nhận thanh toán và bắt đầu các đặt phòng khác nhau, chẳng hạn như Đặt phòng khách sạn, Đặt vé máy bay và đặt thuê xe, là một phần của gói kỳ nghỉ.

25
00:04:57,860 --> 00:05:10,600
Điều này sẽ dẫn đến việc thực hiện các dịch vụ cơ sở hạ tầng cho các đặt phòng này.  Ý tưởng là các dịch vụ bên ngoài sẽ được gọi và sẽ nhận được xác nhận.

26
00:05:10,600 --> 00:05:16,600
Đối với mỗi lần đặt trước này, người xử lý sẽ đảm bảo rằng tất cả các lần đặt trước đều thành công.

27
00:05:16,930 --> 00:05:30,340
Nếu bất kỳ lượt đặt chỗ nào không thành công thì lượt đặt chỗ đó sẽ được đánh dấu là không thành công.  Nếu tất cả các đặt phòng thành công thì trạng thái xác nhận đặt phòng sẽ được chuyển thành xác nhận đặt phòng.

28
00:05:31,300 --> 00:05:39,700
Trong bài học này, tôi đã chỉ cho bạn cách sử dụng chiến thuật này.  Mẫu lớp Braco để xây dựng trình xử lý cho sự kiện miền.

29
00:05:39,820 --> 00:05:51,700
Hãy nhớ rằng đây là một mẫu rất đơn giản.  Trên thực tế, bạn có thể sử dụng các thư viện và khung của bên thứ ba và thực hiện xử lý đồng đều theo cách không đồng bộ.

30
00:05:52,300 --> 00:06:01,750
Hãy thực hiện nghiên cứu của riêng bạn và chia sẻ những phát hiện của bạn.  Trong bài giảng tiếp theo, bạn sẽ thấy việc triển khai thử nghiệm các yêu cầu mới này.

31
00:06:02,290 --> 00:06:08,290
Nếu bạn không quan tâm đến việc xem qua mã và xem nó hoạt động như thế nào, bạn có thể bỏ qua bài giảng tiếp theo.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000009.srt -->

1
00:00:00,300 --> 00:00:09,160
Mục đích đằng sau bài học này là trình bày cách thức thanh toán nhận được, thậm chí là xử lý trong bài giảng này.

2
00:00:09,510 --> 00:00:22,110
Tôi sẽ hướng dẫn bạn mã kiểm tra và sau đó chúng ta sẽ xem quá trình thực thi của trình xử lý khoản thanh toán nhận được đang hoạt động như thế nào để chứng minh việc gửi và xử lý khoản thanh toán nhận được.

3
00:00:22,110 --> 00:00:34,130
Thậm chí tôi còn tập hợp bài kiểm tra thứ tự thanh toán lớp này làm bước tiếp theo.  Tôi sẽ hướng dẫn bạn mã trong lớp học này và chúng ta cũng sẽ thấy khoản thanh toán đã nhận được, thậm chí cả quá trình xử lý đang diễn ra.

4
00:00:34,470 --> 00:00:52,060
Xin lưu ý rằng để triển khai quá trình xử lý khoản thanh toán nhận được, tôi đang sử dụng mẫu Class Brocco chiến thuật này đã được thảo luận trong bài giảng trước đó trong chức năng chính như bước đầu tiên trong việc tạo đối tượng repo xác nhận đặt phòng.

5
00:00:52,110 --> 00:01:11,430
Đây là đối tượng repo giả mà chúng tôi sử dụng trong các thử nghiệm trước đó và bước thứ hai trong việc tạo một phiên bản của trình xử lý nhận được khoản thanh toán chuyển vào kho lưu trữ xác nhận đặt chỗ và sau đó đăng ký trình xử lý cho khoản thanh toán đã nhận.

6
00:01:11,430 --> 00:01:19,500
Ngay cả ở bước số ba, tôi vẫn nhận được xác nhận đặt chỗ hiện có với số tham chiếu từ chín đến tám.

7
00:01:19,620 --> 00:01:38,690
Hãy nhớ lại rằng dữ liệu xác nhận đặt phòng này là một phần của kho lưu trữ xác nhận đặt phòng giả mạo.  Nếu bạn muốn xem chi tiết về nó, chỉ cần xem đối tượng repo xác nhận đặt phòng trong gói repo ghi chú giả là bước tiếp theo, tạo quy trình cổng thanh toán.

8
00:01:38,970 --> 00:01:44,990
Đây là quá trình triển khai thử nghiệm cổng thanh toán.  Tiếp theo, chúng tôi đang tạo ba lệnh thanh toán giả.

9
00:01:45,000 --> 00:01:53,940
Điều này một lần nữa có sẵn trong các gói repo giả mạo.  Và như bạn sẽ thấy, cách triển khai này rất giống với các kho lưu trữ giả mạo khác.

10
00:01:53,970 --> 00:02:04,140
Khi bạn đã tạo repo yêu cầu thanh toán, chúng tôi sẽ tạo thực thể kiểm tra thanh toán.  Thực thể kiểm toán thanh toán này có sẵn trong gói thanh toán.

11
00:02:04,140 --> 00:02:13,260
Nó cho thấy một chức năng thanh toán quá trình.  Chúng tôi đang chuyển một số dữ liệu giả mạo và sau đó chúng tôi chỉ in xác nhận đặt phòng.

12
00:02:13,260 --> 00:02:24,540
Ý tưởng là chúng ta sẽ so sánh trạng thái xác nhận đặt phòng trước và sau khi xử lý để xem trạng thái đã thay đổi hay chưa.

13
00:02:24,840 --> 00:02:34,830
Vì vậy, hãy tiếp tục và thực hiện lớp này.  Phải, bấm, chạy.  Và đây là kết quả.  Như bạn có thể thấy ở đây, số tham chiếu đặt chỗ là chín hai mươi tám.

14
00:02:35,070 --> 00:02:49,200
Và những người mới bắt đầu lúc đầu đang chờ thanh toán.  Việc xử lý thanh toán được thực hiện trong quá trình kiểm tra thanh toán và sau đó người xử lý đã bị sa thải do bỏ sót khoản thanh toán đã nhận.

15
00:02:49,200 --> 00:02:57,120
Ngay cả người xử lý sau đó cũng cập nhật tham chiếu đặt chỗ từ chín đến tám và trạng thái đã được thay đổi để phù hợp.

16
00:02:57,390 --> 00:03:05,640
Đề xuất của tôi dành cho bạn là bạn nên tự mình xem mã này, kiểm tra mã và các lớp liên quan và cho tôi biết nếu bạn có bất kỳ câu hỏi nào.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000010.srt -->

1
00:00:00,180 --> 00:00:13,860
Trong bài giảng về tích hợp, thậm chí, sự nghiệp của Alpha, so sánh các sự kiện tích hợp và miền, sau đó chúng ta sẽ thảo luận về tích hợp, thậm chí xử lý từ góc độ dịch vụ vi mô của người tiêu dùng.

2
00:00:13,870 --> 00:00:23,070
Vào cuối bài học này, chúng tôi sẽ nâng cao mô hình cho bối cảnh giới hạn quản lý khoản vay đã được thảo luận trong bài giảng trước đó.

3
00:00:23,080 --> 00:00:30,900
Bây giờ, bạn đã biết rằng các sự kiện miền được nêu ra và sử dụng trong cùng một bối cảnh giới hạn của dịch vụ vi mô.

4
00:00:31,410 --> 00:00:40,110
Mặt khác, các sự kiện tích hợp được sử dụng bởi các dịch vụ vi mô khác bên ngoài bối cảnh bom con nguồn.

5
00:00:40,530 --> 00:01:05,850
Và những sự kiện tích hợp này cũng có thể được sử dụng bởi các dịch vụ bên ngoài.  Một định nghĩa chính thức hơn về sự tích hợp thậm chí là nó là một thông báo thông báo cho các thành phần bên ngoài bối cảnh giới hạn nguồn rằng điều gì đó quan trọng đã xảy ra và sự tích hợp thậm chí không dẫn đến bất kỳ loại thay đổi nào trong bối cảnh giới hạn nguồn.

6
00:01:06,160 --> 00:01:12,720
Hãy cùng điểm qua những khác biệt giữa miền và các sự kiện tích hợp.  Cái đầu tiên là một cái hiển nhiên, tên miền.

7
00:01:12,720 --> 00:01:41,400
Bạn được nêu lên và sử dụng trong cùng một bối cảnh bị giới hạn hoặc một dịch vụ vi mô, trong khi các sự kiện tích hợp được nêu ra trong một bối cảnh bị giới hạn nhưng có thể được sử dụng trong một bối cảnh bị giới hạn khác hoặc bởi một sự kiện miền dịch vụ bên ngoài dẫn đến những thay đổi trạng thái trong bối cảnh bị giới hạn nguồn,  trong khi không có thay đổi trạng thái nào xảy ra trong bối cảnh giới hạn nguồn.

8
00:01:41,550 --> 00:01:55,020
Do phản ứng với các sự kiện tích hợp, các sự kiện miền được triển khai bằng cách gọi hàm trực tiếp và các sự kiện tích hợp phải được sử dụng qua giao thức mạng.

9
00:01:55,200 --> 00:02:03,210
Nói cách khác, trong trường hợp các sự kiện tích hợp, nếu bạn sử dụng lệnh gọi hàm trực tiếp thì hãy đoán xem điều gì sẽ xảy ra?

10
00:02:03,210 --> 00:02:13,140
Bạn đang tạo một ứng dụng nguyên khối.  Trong trường hợp các sự kiện miền, việc tiêu thụ sự kiện có thể đồng bộ, như với các lệnh gọi hàm trực tiếp.

11
00:02:13,290 --> 00:02:25,580
Nhưng trong trường hợp các sự kiện tích hợp, các cơ chế không đồng bộ được ưu tiên hơn.  Cả sự kiện miền và sự kiện tích hợp đều là một phần của mô hình bối cảnh được mã hóa nguồn.

12
00:02:25,590 --> 00:02:36,330
Trong trường hợp có sự kiện tích hợp, người liên hệ bị giới hạn của người tiêu dùng phải quyết định về mẫu tích hợp mà nó sẽ sử dụng để tiêu thụ các sự kiện.

13
00:02:36,660 --> 00:02:51,960
Thêm về điều này trong một vài phút.  Mặc dù về mặt kỹ thuật có thể sử dụng cơ chế Đồng bộ hóa cho các sự kiện tích hợp, giao tiếp nhưng các giao thức mạng không đồng bộ được ưu tiên vì những lý do rõ ràng.

14
00:02:51,960 --> 00:03:00,300
Điều đầu tiên là bạn có thể đạt được mức độ tách rời cao bằng các cơ chế không đồng bộ.  Khả năng mở rộng trong tương lai dễ dàng hơn.

15
00:03:00,330 --> 00:03:10,740
Ví dụ: bạn có thể thêm người tiêu dùng mới mà không ảnh hưởng đến nguồn sự kiện hoặc dịch vụ vi mô đang thực hiện các sự kiện tích hợp.

16
00:03:10,920 --> 00:03:17,940
Nó giúp việc thiết lập mối quan hệ một-nhiều giữa các liên hệ bị chặn hoặc các dịch vụ vi mô trở nên dễ dàng hơn.

17
00:03:17,970 --> 00:03:26,430
Công nghệ nhắn tin được sử dụng phổ biến.  Đây là một số công cụ nhắn tin rất phổ biến để xây dựng các dịch vụ vi mô.

18
00:03:26,760 --> 00:03:38,820
Sự kiện tên miền cũng có thể được xuất bản dưới dạng sự kiện tích hợp.  Nói cách khác, đối với cùng một sự kiện, có thể có người tiêu dùng trong bối cảnh bị ràng buộc cũng như bên ngoài bối cảnh bị ràng buộc.

19
00:03:39,180 --> 00:03:46,910
Cả hai sự kiện đều là một phần của mô hình cho bối cảnh dài hơn.  Về mặt ngữ nghĩa, hai sự kiện đều giống nhau.

20
00:03:47,190 --> 00:04:06,900
Sự khác biệt nằm ở cách những sự kiện này được xuất bản và tiêu thụ.  Nhưng nếu người thiết kế dịch vụ vi mô đã quyết định sử dụng cùng một cơ chế không đồng bộ cho cả hai loại sự kiện thì cơ chế xuất bản và kích hoạt sẽ giống nhau đối với các sự kiện miền và tích hợp.

21
00:04:07,350 --> 00:04:15,750
Bây giờ chúng ta hãy xem xét các sự kiện tích hợp từ góc độ của người tiêu dùng, người tiêu dùng hoặc sự tích hợp, thậm chí có thể là một người theo chủ nghĩa tuân thủ.

22
00:04:15,900 --> 00:04:33,660
Vì vậy, trong trường hợp này, trong đó A là loại sự kiện và B là người tiêu dùng đồng đều là những người tuân thủ, điều đó có nghĩa là nhóm chịu trách nhiệm về B của Microsoft sẽ cần phải có kiến ​​thức về các mô hình được sử dụng trong bối cảnh liên kết.

23
00:04:34,050 --> 00:04:46,860
Nói cách khác, Microsoft chính là nó.  Và bất cứ khi nào có sự thay đổi về cấu trúc đồng đều hoặc cấu trúc mô hình, nhóm Microsoft B sẽ phải điều chỉnh để giảm thiểu tác động của những thay đổi đó.

24
00:04:47,190 --> 00:04:59,730
Nhóm của Microsoft là V có thể sử dụng lớp chống tham nhũng.  Trong trường hợp này, tất cả những thay đổi trong sự kiện bắt nguồn từ Microsoft, nó sẽ bị cô lập với.

25
00:04:59,840 --> 00:05:08,520
Chống tham nhũng, do đó giữ cho nền tảng đạo đức và quy tắc của Microsoft độc lập với mô hình của Microsoft là a.

26
00:05:09,400 --> 00:05:16,780
Hãy xem lại ví dụ về khoản vay cá nhân, quản lý tài khoản, dịch vụ vi mô của chúng tôi.  Giả sử có hai yêu cầu mới.

27
00:05:16,960 --> 00:05:33,700
Yêu cầu đầu tiên không phải là bối cảnh giới hạn tuân thủ được triển khai vì một dịch vụ vi mô cần được thông báo khi nhận được đơn đăng ký mới và khách hàng cần được thông báo qua email khi tài khoản vay được thiết lập.

28
00:05:33,850 --> 00:05:42,730
Bây giờ, để đáp ứng hai yêu cầu này, chúng tôi sẽ cần triển khai tích hợp ngay cả đối với yêu cầu đầu tiên trong đó chúng tôi cần thông báo việc tuân thủ.

29
00:05:43,060 --> 00:05:58,660
Chúng tôi có thể xuất bản miền ngay cả khi ứng dụng được nhận dưới dạng tích hợp.  Ngay cả dịch vụ vi mô để tuân thủ cũng sẽ có thể nhận được sự đồng đều và thực hiện quá trình xử lý phù hợp trong bối cảnh giới hạn của nó.

30
00:05:58,660 --> 00:06:08,620
Đối với thông báo của khách hàng, chúng tôi có thể thiết lập tổng hợp tài khoản để xuất bản một sự kiện mới và sự kiện mới này thậm chí có thể là một tài khoản được thiết lập.

31
00:06:08,620 --> 00:06:18,270
Một dịch vụ thông báo có thể đăng ký sự kiện mới này và khi nhận được tài khoản cho vay được thiết lập, nó thậm chí có thể gửi email cho khách hàng.

32
00:06:18,550 --> 00:06:32,710
Vì vậy, trong miền hiện có, thậm chí được xuất bản dưới dạng sự kiện tích hợp và với sự kiện tích hợp mới, sẽ có thể nâng cao mô hình dịch vụ quản lý tài khoản cho vay của chúng tôi để đáp ứng hai yêu cầu mới.

33
00:06:32,990 --> 00:06:39,370
Chúng ta hãy điểm qua những điểm chính từ bài học này.  Các sự kiện trên miền có thể được xuất bản dưới dạng sự kiện tích hợp.

34
00:06:39,790 --> 00:06:52,300
Ưu tiên các sự kiện tích hợp được xuất bản không đồng bộ.  Công nghệ nhắn tin thường được sử dụng để xuất bản và đăng ký các sự kiện hội nhập.

35
00:06:52,510 --> 00:07:05,620
Các dịch vụ vi mô tiêu dùng dành cho các sự kiện tích hợp có thể sử dụng Atheel hoặc lớp chống tham nhũng để tách biệt kiến ​​thức về bối cảnh giới hạn nguồn trước đó.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000011.srt -->

1
00:00:00,180 --> 00:00:11,250
Trong bài học này, chúng tôi sẽ mở rộng mô hình bán hàng Acme bằng cách giới thiệu một sự kiện tích hợp mới và thêm dịch vụ cơ sở hạ tầng tin nhắn.

2
00:00:12,430 --> 00:00:27,150
Trong lần tương tác gần đây nhất với John và Ian từ bộ phận pháp lý, chúng tôi được biết rằng sau khi khách hàng thanh toán thành công, trạng thái đặt chỗ sẽ thay đổi thành tuân thủ.

3
00:00:27,370 --> 00:00:38,170
Vậy câu hỏi đặt ra là điều gì sẽ xảy ra tiếp theo?  Mục tiêu của chúng ta trong bài học này là hiểu các hành động được thực hiện sau khi việc đặt chỗ được xác nhận.

4
00:00:38,410 --> 00:00:45,310
Vì vậy, chúng tôi đã hỏi John câu hỏi này và đây là những gì John nói với chúng tôi.  Khi đặt phòng được xác nhận, chúng tôi làm hai việc.

5
00:00:45,370 --> 00:00:56,470
Đầu tiên là chúng tôi gửi email cho khách hàng kèm theo thông tin xác nhận đặt phòng, đồng thời chúng tôi cũng cập nhật báo cáo hàng ngày và hàng tuần cho các bộ phận khác nhau của achmad.

6
00:00:56,920 --> 00:01:11,410
Bạn có thấy điều gì thú vị ở đây không?  Có một sự kiện khi việc đặt chỗ được xác nhận, vì vậy có vẻ như chúng tôi vừa phát hiện ra một sự kiện đặt chỗ mới được xác nhận yêu cầu không có ai có vẻ khá đơn giản.

7
00:01:11,460 --> 00:01:23,250
Hãy hỏi John về yêu cầu số hai.  Vì vậy, John đang nói với chúng tôi rằng việc tạo báo cáo là một công việc mệt mỏi vì mọi bộ phận đều muốn những báo cáo này phải có một định dạng nhất định.

8
00:01:23,400 --> 00:01:40,170
Nhưng một số dữ liệu nhất định, chúng tôi luôn cố gắng bắt kịp.  Đôi khi chúng tôi bị các bộ phận khác đổ lỗi cho những sai sót trong các bộ phận đó, chủ yếu là do không gửi báo cáo đúng hạn hoặc thiếu hoặc dữ liệu sai trong báo cáo.

9
00:01:40,800 --> 00:01:50,580
Dưới đây là một số báo cáo ví dụ.  Chúng tôi cần cung cấp báo cáo đặt phòng hàng ngày.  Sau đó, có một báo cáo doanh thu cần thiết hàng ngày.

10
00:01:50,940 --> 00:01:59,550
Báo cáo dự báo được thực hiện hàng tuần.  Tất cả điều này yêu cầu chúng tôi phải xem xét dữ liệu chúng tôi đã thu thập cho tất cả các lượt đặt chỗ.

11
00:01:59,550 --> 00:02:09,770
Và đôi khi các bộ phận này yêu cầu dữ liệu đặc biệt yêu cầu chúng tôi phải tìm hiểu kỹ tất cả dữ liệu mà chúng tôi đang thu thập từ các đề xuất và lượt đặt chỗ này.

12
00:02:09,990 --> 00:02:21,960
Đó là một công việc mệt mỏi.  Hy vọng có cách tốt hơn để giải quyết tất cả những điều này.  Với tư cách là chuyên gia CNTT, trách nhiệm của chúng tôi là đơn giản hóa quy trình này và giúp cuộc sống của John dễ dàng hơn.

13
00:02:22,110 --> 00:02:28,680
Hãy bắt tay vào làm việc ngay bây giờ.  Bạn sẽ đáp ứng những yêu cầu này như thế nào khi sử dụng mô hình này làm điểm khởi đầu?

14
00:02:28,950 --> 00:02:42,570
Hãy nhớ lại rằng chúng tôi đã nghĩ ra mô hình này trong cuộc trò chuyện gần đây nhất với John và vui lòng chuyển video, viết suy nghĩ của bạn ra một tờ giấy và tiếp theo tôi sẽ chia sẻ suy nghĩ của mình về giải pháp.

15
00:02:43,050 --> 00:02:52,020
Chúng tôi có thể giải quyết những yêu cầu này bằng cách giới thiệu một tiện ích tích hợp mới, thậm chí cả việc đặt chỗ đã được xác nhận trong kho lưu trữ xác nhận đặt chỗ.

16
00:02:52,320 --> 00:03:08,370
Mỗi khi một lượt đặt chỗ được xác nhận, một lượt đặt chỗ đã được xác nhận thậm chí sẽ được hủy bỏ.  Và tối nay sẽ được nhận bởi nhiều người đăng ký khác nhau, chẳng hạn như các dịch vụ Metro khác và dịch vụ thông báo về việc nhận sự kiện dưới dạng tin nhắn.

17
00:03:08,520 --> 00:03:20,220
Dịch vụ thông báo sẽ gửi email và các dịch vụ khác có thể thực hiện quá trình xử lý cần thiết để tạo báo cáo và sử dụng dữ liệu cho bất kỳ mục đích nào họ cần.

18
00:03:20,220 --> 00:03:27,050
Dữ liệu mang lại lợi ích cho phương pháp này là tất cả các sự kiện này sẽ được kích hoạt trong thời gian thực.

19
00:03:27,450 --> 00:03:45,830
Vì vậy, các dịch vụ khác này sẽ có tất cả dữ liệu hiện tại mà họ cần để xử lý.  Tiếp theo, tôi sẽ hướng dẫn bạn đến sơ đồ thành phần này từ góc độ sự kiện, ghi chú này và lớp lưu giữ được mô tả ở đây là dành cho dịch vụ vi mô bán hàng.

20
00:03:45,860 --> 00:03:56,780
Giả sử rằng đường trục nhắn tin được xây dựng trên Rabbit MQ và người đăng ký là các dịch vụ bên ngoài và các dịch vụ vi mô khác.

21
00:03:57,050 --> 00:04:16,490
Như bạn có thể thấy ở đây, chúng tôi có dịch vụ thông báo ở đây cũng như đã thảo luận trong bài giảng trước đó mà phụ huynh đã yêu cầu sau khi nhận được bản cập nhật xác nhận thanh toán thành công, thực thể yêu cầu thanh toán sẽ được lưu trữ liên tục và sau đó tăng miền nhận được khoản thanh toán.

22
00:04:16,490 --> 00:04:31,060
Ngay cả khoản thanh toán này đã nhận được.  Sự kiện chính được sử dụng bởi khoản thanh toán Hannelore nhận được và trạng thái xác nhận đặt phòng sau khi đặt chỗ được cập nhật để phù hợp nhằm đáp ứng yêu cầu mới.

23
00:04:31,580 --> 00:04:39,530
Bây giờ, sau khi trạng thái xác nhận đặt phòng được cập nhật, tổng hợp xác nhận đặt phòng sẽ đưa ra xác nhận đặt phòng.

24
00:04:39,530 --> 00:04:56,620
Thậm chí điều này sẽ dẫn đến việc xuất bản một thông báo tới một chủ đề được hiển thị ở đây.  Vì các thành phần này đã đăng ký chủ đề nên tất cả chúng sẽ nhận được sự kiện dưới dạng tin nhắn và sau đó mỗi thành phần này có thể xử lý tin nhắn theo nhu cầu của chúng.

25
00:04:57,670 --> 00:05:12,410
Cách tốt nhất là chúng tôi cần đảm bảo rằng mô hình của chúng tôi không bị ràng buộc với bất kỳ công nghệ cụ thể nào.  Do đó, chúng tôi sẽ xác định một dịch vụ cơ sở hạ tầng sẽ cách ly mô hình khỏi công nghệ nhắn tin cơ bản.

26
00:05:12,730 --> 00:05:27,990
Dịch vụ cơ sở hạ tầng này sẽ được triển khai như một dịch vụ nhắn tin giao diện.  Giao diện dịch vụ nhắn tin này sẽ hiển thị các chức năng cho các thành phần đạo đức khác nhau tương tác với công nghệ nhắn tin cơ bản.

27
00:05:28,150 --> 00:05:39,910
Chức năng đăng ký sẽ yêu cầu một phiên bản của trình xử lý tin nhắn.  Trình xử lý tin nhắn sẽ có một hàm xử lý duy nhất sẽ được thực thi khi người đăng ký nhận được tin nhắn.

28
00:05:40,060 --> 00:05:53,470
Tất cả các chức năng trong dịch vụ nhắn tin sẽ đưa ra một ngoại lệ với ngoại lệ thông báo tên.  Giao diện dịch vụ nhắn tin này sẽ được triển khai bởi các lớp cụ thể cho các công nghệ nhắn tin cụ thể.

29
00:05:53,620 --> 00:06:09,780
Ví dụ: tôi đã tạo một bản triển khai dịch vụ nhắn tin cho Robert MQ.  Mục đích của dịch vụ ở đây là triển khai dịch vụ nhắn tin và mã trong dịch vụ sử dụng ứng dụng Rabbit NQ.

30
00:06:10,150 --> 00:06:18,490
Tôi cũng đã tổng hợp mục đích của lớp kiểm tra dịch vụ mà chúng ta sẽ sử dụng sau này để kiểm tra dịch vụ FOB này.

31
00:06:19,500 --> 00:06:30,480
Bây giờ bạn đã hiểu giải pháp tổng thể và dịch vụ cơ sở hạ tầng nhắn tin, hãy tổng hợp mọi thứ lại với nhau để hiểu sự kiện xác nhận đặt chỗ sẽ diễn ra như thế nào.

32
00:06:30,510 --> 00:06:43,590
Sơ đồ tuần tự mà tôi sắp thảo luận có sẵn trong tệp này.  Vì đối tượng repo xác nhận đặt phòng sẽ tương tác với dịch vụ nhắn tin nên chúng ta sẽ thiết lập dịch vụ nhắn tin trên đối tượng báo cáo xác nhận đặt phòng.

33
00:06:43,590 --> 00:06:52,880
Tổng hợp xác nhận đặt phòng sẽ thực hiện cập nhật trạng thái trên repo xác nhận đặt phòng để cập nhật trạng thái xác nhận đặt phòng.

34
00:06:52,890 --> 00:07:07,260
Tại thời điểm này, báo cáo xác nhận đặt chỗ sẽ cập nhật trạng thái xác nhận đặt chỗ trong bộ lưu trữ liên tục và nếu điều đó thành công, nó sẽ công bố việc đặt chỗ đã được xác nhận ngay cả thông qua Dịch vụ cơ sở hạ tầng nhắn tin.

35
00:07:07,710 --> 00:07:15,510
Dịch vụ cơ sở hạ tầng nhắn tin sau đó sẽ xuất bản việc đặt chỗ đã được xác nhận ngay cả đối với cơ sở hạ tầng cơ bản.

36
00:07:15,720 --> 00:07:30,690
Trong trường hợp của chúng tôi, nó có MQ thỏ, sau đó nhà môi giới Rabbit và Q sẽ phân phối sự kiện dưới dạng tin nhắn cho tất cả những người đăng ký chẵn và thậm chí cả những người đăng ký sau đó sẽ thực hiện quá trình xử lý mong muốn của họ bằng cách sử dụng dữ liệu trong sự kiện.

37
00:07:31,200 --> 00:07:46,580
Đã đến lúc xem lại những điểm chính trong bài giảng này.  Điều đầu tiên là kho lưu trữ là một nơi tốt để nêu ra các sự kiện và lý do cho điều đó là do việc cập nhật tổng hợp và việc nâng cao sự kiện cần phải được thực hiện theo kiểu nguyên tử.

38
00:07:46,590 --> 00:07:55,050
Vì vậy, thậm chí sẽ chỉ được nâng lên nếu đối tượng lưu trữ thành công trong quá trình triển khai repro.  Bạn sẽ tìm hiểu thêm về nó trong một bài giảng sau.

39
00:07:55,260 --> 00:08:04,770
Điểm mấu chốt thứ hai là mô hình không được có bất kỳ chi tiết nào về công nghệ nhắn tin cơ bản hoặc bất kỳ công nghệ nào.

40
00:08:05,010 --> 00:08:12,890
Vì vậy, để bảo vệ mô hình khỏi bị hiểu biết về các công nghệ cơ sở hạ tầng cơ bản này, bạn phải sử dụng các dịch vụ cơ sở hạ tầng.

41
00:08:13,290 --> 00:08:21,330
Vì vậy chúng tôi đã tạo ra dịch vụ cơ sở hạ tầng tin nhắn.  Trong bài giảng tiếp theo, bạn sẽ thấy hoạt động của sự kiện xác nhận đặt chỗ đang diễn ra.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000012.srt -->

1
00:00:00,270 --> 00:00:12,340
Trong bài học này, bạn sẽ tìm hiểu về cách triển khai các sự kiện tích hợp, cụ thể là việc đặt chỗ đã được xác nhận ngay cả bằng cách hướng dẫn mã và hai bài giảng trong bài giảng này.

2
00:00:12,570 --> 00:00:28,970
Tôi sẽ đề cập đến việc thiết lập sàn giao dịch và Q trên Rabbitt MQ, sau đó tôi sẽ cung cấp cho bạn hướng dẫn chi tiết về dịch vụ cơ sở hạ tầng nhắn tin và sẽ kiểm tra dịch vụ cơ sở hạ tầng so với sàn giao dịch và Q được thiết lập trên MQ.

3
00:00:29,250 --> 00:00:42,300
Cách chia đoạn mã đi qua hoạt động thành ba phần.  Trong phần một, chúng ta sẽ thiết lập trao đổi và chủ đề trên Rabbitt MQ Broca, sau đó chúng ta sẽ thử nghiệm một phần để thử nghiệm dịch vụ nhắn tin cơ sở hạ tầng.

4
00:00:42,300 --> 00:00:49,890
Sau đó, trong phần ba, tôi sẽ hướng dẫn bạn mã để triển khai sự kiện xác nhận đặt chỗ và cũng sẽ kiểm tra mã đó.

5
00:00:50,040 --> 00:00:56,160
Trong bài giảng này tôi sẽ chỉ trình bày phần một và phần hai và trong bài giảng tiếp theo tôi sẽ trình bày phần ba.

6
00:00:56,460 --> 00:01:05,070
Trong Phần một sẽ thực hiện bốn bước.  Và bước số một, chúng ta sẽ thiết lập một cuộc trao đổi với tên Achmad hoặc chủ đề nhân viên bán hàng.

7
00:01:05,370 --> 00:01:20,130
Và cuộc trao đổi này sẽ theo chủ đề ở bước hai sẽ thiết lập một Q với tên email hoặc thông báo ở bước ba, Q mới của Bindi với khóa định tuyến achmad hoặc doanh số bán hàng hoặc đặt chỗ đã được xác nhận.

8
00:01:21,000 --> 00:01:31,500
Và trong bước bốn sẽ kiểm tra thiết lập này bằng cách xuất bản thông báo lên sàn giao dịch.  Thông báo này sẽ kết thúc trong hàng thông báo e-mail.

9
00:01:32,400 --> 00:01:47,210
Bước đầu tiên, đăng nhập vào cổng MQ trên đám mây, tôi đã có Acme travel ngay lập tức, nhấp vào trình quản lý Rabbit Amcu, đi tới các sàn giao dịch và điều đầu tiên bạn cần làm là tạo một sàn giao dịch.

10
00:01:47,420 --> 00:01:56,230
Chúng tôi sẽ đặt tên cho chủ đề trao đổi Acme Auto Sales.  Hãy chắc chắn rằng bạn thay đổi tiêu đề thành Papic và thêm trao đổi hoặc trao đổi được tạo.

11
00:01:56,250 --> 00:02:05,370
Bây giờ đây là phần lọc tiếp theo của Exchange mà bạn nhấn vào Qs cho biết tên của hàng đợi như email thông báo và chỉ cần nhấn vào lúc gợi ý.

12
00:02:05,520 --> 00:02:14,790
Nhấp vào Quay lại trao đổi và tất cả những gì chúng tôi cần để liên kết là xếp hàng đến Akhmad hoặc bán hàng hoặc trao đổi chủ đề hoặc nhấp vào trao đổi.

13
00:02:14,800 --> 00:02:23,640
Vì vậy chúng ta cần cung cấp tên của email thông báo hàng đợi.  Hàng đợi định tuyến sẽ là Achmad hoặc xác nhận đặt chỗ bắt đầu bán hàng và chỉ cần nhấn liên kết.

14
00:02:24,000 --> 00:02:32,330
Tại thời điểm này, sàn giao dịch của chúng tôi có một hàng đợi bị ràng buộc bởi qinawi định tuyến này sẵn sàng kiểm tra.

15
00:02:32,340 --> 00:02:41,780
Chỉ cần cuộn xuống, cung cấp khóa định tuyến achmad tất cả các đơn đặt hàng bắt đầu bán hàng đã xác nhận đây là bản thử nghiệm và xuất bản một tin nhắn được xuất bản.

16
00:02:42,120 --> 00:02:51,930
Hãy quay lại email hoặc thông báo của Cuno.  Và như bạn có thể thấy ở đây, có một tin nhắn.  Hãy cuộn xuống và chúng ta sẽ nhận được một tin nhắn trên đó.

17
00:02:51,930 --> 00:03:00,450
Và đây là thông điệp của chúng tôi.  Vì vậy, Sarah đã làm việc ổn vào thời điểm này.  Hãy đến Pakta trước khi tiếp tục.

18
00:03:00,450 --> 00:03:10,200
Vui lòng đảm bảo rằng bạn đã thiết lập đúng MQ Purell trong thử nghiệm dịch vụ phụ của quán rượu.  Nếu không làm như vậy sẽ dẫn đến Conexion thất bại.

19
00:03:10,680 --> 00:03:36,300
Vì vậy, hãy sao chép MQ Purell từ trang chi tiết và dán nó vào phần kiểm tra dịch vụ bật lên.  MQ b gạch dưới bạn là một biến trong phần hai sẽ kiểm tra dịch vụ cơ sở hạ tầng nhắn tin ở bước một sẽ đẩy thông báo email Q và bước hai sẽ thiết lập lớp kiểm tra bật lên để xuất bản một tin nhắn và sau đó sẽ chạy lớp.

20
00:03:36,300 --> 00:03:45,660
Sau đó chúng ta sẽ chạy lớp này.  Nó sẽ xuất bản một thông báo tới sàn giao dịch và thông báo đó sẽ xuất hiện trong thông báo qua email.

21
00:03:45,660 --> 00:03:53,460
Giữ nguyên bước ba sẽ phục vụ mục đích của lớp kiểm tra là đăng ký nhận tin nhắn và sau đó lớp sẽ chạy.

22
00:03:53,610 --> 00:04:06,870
Điều này sẽ tạo ra một đăng ký cho chủ đề và chúng tôi sẽ sử dụng giao diện người dùng để xuất bản một thông báo tới sàn giao dịch achmad hoặc bán chủ đề bằng khóa định tuyến achmad hoặc doanh số bán hàng không xác nhận đặt chỗ.

23
00:04:07,080 --> 00:04:21,220
Và điều này sẽ dẫn đến việc người đăng ký của chúng tôi nhận được một tin nhắn và người đăng ký của chúng tôi sẽ chỉ in tin nhắn đó ra bảng điều khiển vì bước đầu tiên sẽ chuyển các tin nhắn từ email Q hoặc thông báo.

24
00:04:21,220 --> 00:04:45,210
Vì vậy, hãy nhấp vào tín hiệu, nhấp vào email hoặc thông báo, cuộn xuống và nhấp vào nút để thanh lọc.  Và như bạn có thể thấy bây giờ, không có tin nhắn nào trong hàng đợi. Bước tiếp theo là tôi sẽ hướng dẫn bạn qua lớp cơ sở hạ tầng dịch vụ nhắn tin và cách triển khai cụ thể, chọn hành vi gói, không phải bán hàng, không phải tiện ích đạo đức hay thậm chí là nhắn tin.

25
00:04:45,890 --> 00:04:59,510
Đây là giao diện dịch vụ nhắn tin của chúng tôi.  Bạn sẽ tìm thấy các hàm đơn giản ở đây và bạn sẽ quan sát thấy rằng tất cả các hàm này đang đưa ra ngoại lệ nhắn tin được xác định ở đây.

26
00:04:59,660 --> 00:05:08,560
Hàm đăng ký ở đây yêu cầu một phiên bản của trình xử lý tin nhắn và đây là trình xử lý tin nhắn, chỉ có một hàm trong đó.

27
00:05:08,570 --> 00:05:28,760
Vì vậy, các giao diện và lớp này là định nghĩa dịch vụ cơ sở hạ tầng của chúng tôi.  Việc triển khai thực tế cho Rabbit MQ có sẵn trong gói Kondor Acme Dot Dot, Rabbit MQ và dịch vụ nhắn tin được triển khai bởi các lớp dịch vụ.

28
00:05:28,760 --> 00:05:37,160
Như bạn có thể thấy ở đây, việc triển khai lớp này đang sử dụng ứng dụng Rabbit MQ.  Không, tôi sẽ không hướng dẫn bạn.

29
00:05:37,190 --> 00:05:45,950
Tất cả API đều được sử dụng trong quá trình triển khai này, nhưng bạn sẽ thấy rằng tôi đã đưa liên kết đến các ứng dụng mà tôi đã sử dụng.

30
00:05:45,950 --> 00:06:02,660
Nếu bạn muốn tìm hiểu sâu hơn về Rabbit MPU, tôi khuyên bạn nên xem hướng dẫn API này và sau đó khi bạn xem mã trong lớp này, hãy tìm các liên kết mà tôi đã đưa vào nhận xét để kiểm tra việc triển khai của  dịch vụ nhắn tin của chúng tôi.

31
00:06:02,960 --> 00:06:19,100
Chúng tôi sẽ sử dụng lớp thử nghiệm dịch vụ phụ trong lớp này.  Bạn sẽ thấy rằng tất cả đã được thiết lập để thực thi để kiểm tra chức năng công cộng, chỉ phát hiện ra các phần nổi bật của dịch vụ chứ không xuất bản và nhận xét bài kiểm tra người đăng ký.

32
00:06:19,100 --> 00:06:28,460
Và bây giờ chúng tôi có thể thử nghiệm dịch vụ để kiểm tra một cách đơn giản.  Bấm và chạy.  Vì vậy, điều này sẽ xuất bản một thông điệp cho chủ đề này, Achmad.

33
00:06:28,470 --> 00:06:37,460
Không bán hàng, không xác nhận đặt phòng.  Chúng ta hãy tiếp tục kiểm tra Q Và đúng như dự đoán, chúng ta sẽ thấy một thông báo ở đây để kiểm tra nội dung của tin nhắn.

34
00:06:37,700 --> 00:06:43,850
Chỉ cần cuộn xuống, nhận được tin nhắn.  Và đây là nội dung tin nhắn chạy thử nghiệm đăng ký.

35
00:06:43,970 --> 00:06:56,480
Quay trở lại chức năng chính, chỉ huy mục đích dịch vụ, không xuất bản và Unkovic dòng này tại thời điểm này chúng tôi đã sẵn sàng kiểm tra ngay trước đó, chỉ cần dừng kiểm tra trước đó một lần nữa.

36
00:06:56,480 --> 00:07:03,770
Chạy cho bài kiểm tra này.  Bạn sẽ thấy rằng trong thử nghiệm này, chúng tôi đã đăng ký chủ đề xác nhận đặt phòng Achmad hoặc bắt đầu bán hàng.

37
00:07:03,780 --> 00:07:12,890
Vì vậy, điều đó có nghĩa là nếu tôi xuất bản một thông báo tới sàn giao dịch Achmad bán chủ đề đó, thì người đăng ký của chúng tôi sẽ có thể nhận được nó.

38
00:07:12,890 --> 00:07:22,940
Và như bạn có thể thấy ở đây, hiện tại có hai người đăng ký.  Một là thuê bao tĩnh mà chúng tôi đã tạo và thuê bao này là thuê bao dành cho mã đang chạy trong bảng điều khiển.

39
00:07:22,940 --> 00:07:28,430
Hãy tiếp tục và xuất bản một tin nhắn.  Chúng tôi cần cung cấp khóa định tuyến bán hàng achmad, hãy bắt đầu đặt chỗ.

40
00:07:28,460 --> 00:07:35,750
Và tôi sẽ chỉ nói từ tin nhắn đã xuất bản của bạn, tin nhắn đã xuất bản, hãy quay lại bảng điều khiển và đây là tin nhắn của chúng tôi.

41
00:07:35,750 --> 00:07:46,760
Hãy thử một lần nữa.  Tôi sẽ chỉ đặt tin nhắn được xuất bản thử nghiệm thứ hai và đây là thử nghiệm thứ hai của chúng tôi.  Và lúc này, chúng ta cũng sẽ thấy tin nhắn trong thông báo qua email.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\08EventsDrivenArchitectureDomainEvents_VVN\000000013.srt -->

1
00:00:00,150 --> 00:00:11,340
Đây là phần hai của hướng dẫn mã về các sự kiện tích hợp trong bài học này.  Tôi sẽ hướng dẫn bạn cách triển khai kho lưu trữ để xác nhận đăng ký.

2
00:00:11,370 --> 00:00:21,970
Sau đó, tôi sẽ hướng dẫn bạn mã mà chúng tôi sẽ sử dụng để kiểm tra sự kiện tích hợp.  Và cuối cùng, chúng ta sẽ thấy sự kiện xác nhận đặt chỗ đang diễn ra.

3
00:00:22,380 --> 00:00:28,500
Xin nhắc nhanh, mã mà tôi đang hướng dẫn bạn trong bài giảng này có sẵn ở nhánh cổng.

4
00:00:29,040 --> 00:00:36,240
Nhớ lại bài giảng trước rằng repo xác nhận đặt phòng là cái làm tăng việc xác nhận đặt phòng.

5
00:00:36,420 --> 00:00:46,700
Mặc dù vậy, để nâng cao sự kiện, tôi đã điều chỉnh lại repo xác nhận đặt phòng giả mạo bằng cách thêm hai chức năng mới vào chức năng đầu tiên là thiết lập dịch vụ nhắn tin.

6
00:00:47,220 --> 00:00:56,250
Đây là chức năng sẽ được sử dụng để thiết lập phiên bản của dịch vụ nhắn tin trên đối tượng giả mạo người xác nhận đặt phòng.

7
00:00:56,640 --> 00:01:25,110
Và chức năng thứ hai là chức năng trạng thái cập nhật, sẽ được gọi từ tổng hợp xác nhận đặt chỗ để cập nhật trạng thái của xác nhận đặt chỗ theo đức tin kho xác nhận đặt chỗ lớp và bạn sẽ tìm thấy chức năng dịch vụ nhắn tin lên có một phiên bản của tin nhắn  service làm đối số và nó trên dịch vụ nhắn tin biến thể hiện trong hàm bước cập nhật.

8
00:01:25,110 --> 00:01:39,670
Nếu trạng thái đang được cập nhật để phù hợp thì siêu dữ liệu sự kiện sẽ được tạo.  Siêu dữ liệu này chỉ có tham chiếu khách hàng và tham chiếu đặt chỗ, sau đó dịch vụ nhắn tin sẽ xuất bản dữ liệu dưới dạng sự kiện.

9
00:01:39,840 --> 00:01:48,660
Vì vậy, trong thiết lập này, chúng tôi không gửi tất cả dữ liệu trong tải trọng nhưng chúng tôi có thể làm điều đó rất tốt bằng cách thay thế mã này tại đây.

10
00:01:48,780 --> 00:01:56,190
Khi người đàn áp, sự kiện xảy ra, nó sẽ in ra thông báo này trên bảng điều khiển.  Hãy để tôi giải thích cách chúng tôi sẽ thực hiện bài kiểm tra.

11
00:01:56,370 --> 00:02:04,900
Chúng tôi sẽ sử dụng bài kiểm tra thứ tự thanh toán lớp mà chúng tôi đã sử dụng cho bài kiểm tra trước đó.  Trước đó, chúng tôi đã chạy thử nghiệm với tính năng nhắn tin bị tắt.

12
00:02:05,070 --> 00:02:13,230
Bây giờ chúng ta sẽ kích hoạt dịch vụ nhắn tin theo thứ tự thanh toán.  Lớp kiểm tra sẽ tạo một phiên bản của dịch vụ bật lên.

13
00:02:13,440 --> 00:02:29,750
Sau đó, chúng tôi sẽ bắt đầu phiên bản dịch vụ bật lên trên kho lưu trữ xác nhận đặt phòng giả.  Sau đó, chúng ta sẽ chạy lớp kiểm tra lệnh thanh toán và sau đó chúng ta sẽ thấy việc đặt chỗ đã được xác nhận, thậm chí được xuất bản để lấy nó trong email hoặc thông báo.

14
00:02:29,760 --> 00:02:37,050
Q Bước đầu tiên, chúng tôi cần đảm bảo rằng chúng tôi có thiết lập kết hợp phù hợp và lớp thanh toán hoặc thử nghiệm.

15
00:02:37,380 --> 00:02:57,960
Vì vậy, vui lòng tiếp tục, sao chép M Kupwara từ trang chi tiết và dán nó vào hàng kiểm tra đơn đặt hàng thanh toán trong biến Amcu gạch dưới Eurail mở lớp tài sản kiểm tra thanh toán đang được thử nghiệm mô hình bán hàng Kamelot Ackmann.

16
00:02:57,990 --> 00:03:09,420
Ngay cả trong quá trình kiểm tra và đây là lớp kiểm tra lệnh thanh toán của chúng tôi được gọi đến chức năng chính và bạn sẽ thấy lệnh gọi tới thông báo thiết lập trên dòng này.

17
00:03:09,720 --> 00:03:25,410
Đây là một chức năng địa phương.  Chúng ta hãy xem nhanh chức năng này và chức năng này.  Bạn sẽ thấy rằng tôi đang tạo phiên bản lớp dịch vụ bật lên, gửi các thuộc tính cho Amcu P, sau đó khởi động dịch vụ nhắn tin.

18
00:03:25,770 --> 00:03:34,050
Nếu bạn chưa nói Eurail hoặc nếu có bất kỳ vấn đề kết nối nào thì lúc này sẽ có ngoại lệ và quá trình kiểm tra sẽ dừng lại.

19
00:03:34,050 --> 00:03:47,520
Nếu không, dịch vụ nhắn tin sẽ được đặt trên đối tượng repo xác nhận đặt phòng.  Bây giờ chúng ta đã sẵn sàng chạy thử nghiệm, nhưng trước đó, hãy đẩy hàng đợi, đi tới Qs được gửi qua email hoặc thông báo, cuộn xuống và lọc thư.

20
00:03:47,640 --> 00:03:53,970
Không, chúng tôi không có tin nhắn nào trong hàng đợi.  Hãy tiếp tục và chạy thử nghiệm.  Chạy thử nghiệm đúng.  Bấm và chạy.

21
00:03:54,180 --> 00:04:00,140
Sau đó, bạn sẽ chạy thử nghiệm này.  Nó sẽ thực hiện nhiều hoạt động thông qua các kho lưu trữ giả mạo.

22
00:04:00,180 --> 00:04:07,000
Thử nghiệm này tương tự như thử nghiệm trước đó, ngoại trừ việc lần này kho lưu trữ giả mạo đang phát sinh một sự kiện.

23
00:04:07,000 --> 00:04:12,900
Đây là thông báo đến từ việc triển khai kho lưu trữ giả mạo để xác nhận đặt chỗ.

24
00:04:13,290 --> 00:04:25,830
Như bạn có thể thấy ở đây, một sự kiện đã được nêu ra.  Hãy kiểm tra Q và trong Q, như mong đợi, chúng ta thấy một thông báo và nếu nhận được thông báo, chúng ta sẽ thấy nội dung thông báo cho sự kiện.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\001 Learning Objectives _ Discovering the Events in a Domain.en.srt -->

1

00:00:00,150 --> 00:00:04,740

In the last section, you learn that events occur naturally in domains.



2

00:00:04,950 --> 00:00:11,910

So what that means is that to understand the domain, you must understand the events produced and consumed



3

00:00:12,150 --> 00:00:12,960

in the domain.



4

00:00:13,320 --> 00:00:20,940

Even Stahlman is a collaborative exercise that is carried out by the stakeholders to identify the even's



5

00:00:20,940 --> 00:00:24,040

producers and consumers in a given scope.



6

00:00:24,450 --> 00:00:29,520

The objective is to create a shared understanding of the domain.



7

00:00:29,760 --> 00:00:34,530

The outcome of the exercise is a knowledge model for the domain.



8

00:00:35,070 --> 00:00:38,950

Even storming is carried out in the workshop format.



9

00:00:39,180 --> 00:00:46,440

There is a facilitator who works with the stakeholders from different parts of the organization or different



10

00:00:46,710 --> 00:00:47,910

parts of the domain.



11

00:00:48,270 --> 00:00:53,550

This workshop may be carried out in person or online using collaboration tools.



12

00:00:53,850 --> 00:01:01,260

In one of the lectures in the section, you will learn how to use a collaboration tools for conducting



13

00:01:01,260 --> 00:01:03,080

the event storming workshop.



14

00:01:03,360 --> 00:01:06,170

Let's go over the learning objectives for this section.



15

00:01:06,300 --> 00:01:12,240

By the end of this section, you will have a good understanding of what even storming is, one of the



16

00:01:12,240 --> 00:01:16,710

objectives and the outcomes of an event storming workshop.



17

00:01:17,160 --> 00:01:22,440

You should be able to describe the process used for the creation of the knowledge models.



18

00:01:22,770 --> 00:01:29,460

You will learn how to prepare and conduct the event storming workshop and in the last lecture you will



19

00:01:29,460 --> 00:01:35,580

see how to use collaboration tools for conducting and online, even storming workshop.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\002 Introduction to Event Storming.en.srt -->

1

00:00:00,180 --> 00:00:07,290

Introduction to events storming, I'll start this lecture by revisiting knowledge crunching, and then



2

00:00:07,290 --> 00:00:14,970

I will discuss what is even storming workshop and what do you need for conducting the event storming



3

00:00:14,970 --> 00:00:15,630

workshop.



4

00:00:16,110 --> 00:00:21,150

In one of the earlier lectures, I introduce you to the common knowledge crunching.



5

00:00:21,270 --> 00:00:28,920

Knowledge crunching is a way by which teams process the knowledge received from the domain experts into



6

00:00:28,920 --> 00:00:29,760

domain model.



7

00:00:30,240 --> 00:00:37,080

As part of the course, I have shown you multiple examples in which we interview the domain experts



8

00:00:37,380 --> 00:00:45,750

and created the domain models which were predominantly in the form of UML and ubiquitous language at



9

00:00:45,750 --> 00:00:46,320

this point.



10

00:00:46,440 --> 00:00:51,120

The question is how do you receive the knowledge from the domain experts now?



11

00:00:51,120 --> 00:00:57,930

Interviews is one, which is what we have used, but there are multiple other techniques which are much



12

00:00:57,930 --> 00:01:01,790

more structured than informal interviews.



13

00:01:02,010 --> 00:01:08,230

For example, if you are carrying out ideation for developing a new product, you may use a technique



14

00:01:08,230 --> 00:01:10,930

called design thinking for domain driven design.



15

00:01:10,980 --> 00:01:15,180

There is a common technique that is used and that technique is known as even storming.



16

00:01:15,210 --> 00:01:19,170

Please note that these are just some examples of the techniques.



17

00:01:19,180 --> 00:01:25,290

There are various other ways in which you can receive knowledge from the domain experts in a structured



18

00:01:25,290 --> 00:01:25,680

manner.



19

00:01:25,800 --> 00:01:28,350

My focus is on even storming.



20

00:01:29,280 --> 00:01:36,960

It is a formal definition of even storming a collaborative workshop based technique for creating a shared



21

00:01:36,960 --> 00:01:40,660

understanding of complex business domains and processes.



22

00:01:40,950 --> 00:01:44,850

The key part here is creating a shared understanding.



23

00:01:45,300 --> 00:01:51,960

So the intent is not to design or model the system, but just create that shared understanding among



24

00:01:52,230 --> 00:02:00,240

the stakeholders within the domain and the stakeholders are the business experts as well as the technology



25

00:02:00,240 --> 00:02:00,810

experts.



26

00:02:01,800 --> 00:02:10,170

Even storming may be used for creating this shared understanding from the overall domain perspective



27

00:02:10,350 --> 00:02:16,920

or the big picture perspective, as well as it can be used for creating the shared knowledge from a



28

00:02:16,920 --> 00:02:18,510

business process perspective.



29

00:02:18,900 --> 00:02:24,450

So the technique is quite flexible in terms of what you can use it for.



30

00:02:24,630 --> 00:02:27,340

The central theme of the business events.



31

00:02:27,540 --> 00:02:35,490

The participants in the workshop identify and understand the business even as they look for the cause



32

00:02:35,490 --> 00:02:40,150

of the business, even as well as the effect of those business events.



33

00:02:40,830 --> 00:02:48,690

This technique was created by Alberto Brandolini in 2012, and since then it has gained a lot of popularity



34

00:02:48,960 --> 00:02:51,110

among the digital practitioners.



35

00:02:51,330 --> 00:02:58,440

The biggest benefit of this technique is that it accelerates the development process for complex applications.



36

00:02:58,590 --> 00:03:05,820

One important thing to keep in mind is that the knowledge created by way of events timing is used as



37

00:03:05,820 --> 00:03:08,470

an input for creating the models.



38

00:03:08,490 --> 00:03:15,030

So in other words, you will not be replacing human modelling with even Stormi, but you will be using



39

00:03:15,030 --> 00:03:22,860

the knowledge gained from the even Stormi as an input for creating your UML diagrams if you're interested



40

00:03:22,860 --> 00:03:24,750

in learning more about even storming.



41

00:03:25,140 --> 00:03:31,310

My suggestion is that you look at this book by Alberto introducing, even storming.



42

00:03:31,680 --> 00:03:33,250

Now let's talk about the workshop.



43

00:03:33,390 --> 00:03:39,750

The most important thing about the even storming workshop is that you must invite the right set of domain



44

00:03:39,990 --> 00:03:47,700

and IT experts, for example, if you are carrying out the even solving workshop for, let's say, some



45

00:03:47,700 --> 00:03:54,800

banking product, then you must have the right domain experts in the room who should be able to answer



46

00:03:55,110 --> 00:03:59,080

questions in their respective domains or areas of expertise.



47

00:03:59,130 --> 00:04:02,670

There is a dedicated facilitator who works with the participants.



48

00:04:02,700 --> 00:04:08,250

This dedicated facilitator should have some prior experience with even storming.



49

00:04:08,400 --> 00:04:13,340

The number of participants in the workshop is decided by the scope.



50

00:04:13,350 --> 00:04:20,850

If you're carrying out the even storming workshop for understanding the business process, then you



51

00:04:20,850 --> 00:04:25,770

should expect to have between four and eight participants in the workshop.



52

00:04:26,160 --> 00:04:33,170

The duration of the workshop depends on the scope of the domain and the experience of the participants.



53

00:04:33,180 --> 00:04:37,800

It may vary anywhere from a couple of hours to a couple of days in person.



54

00:04:37,810 --> 00:04:45,180

Workshop is preferred over online workshops and the reason is that even storming involves a lot of interactions



55

00:04:45,180 --> 00:04:51,090

and it is easier to carry out these interactions when the participants are in the same room with the.



56

00:04:51,230 --> 00:04:58,470

But recently online workshops have also become a commonplace and are becoming more and more acceptable.



57

00:04:58,500 --> 00:04:59,850

The good news is that there are.



58

00:04:59,880 --> 00:05:04,130

Very good tools available to carry out these workshops online.



59

00:05:04,160 --> 00:05:10,160

Next, I'll go look what you need for the in-person workshop as well as for the online workshop.



60

00:05:10,520 --> 00:05:16,110

An in-person workshop is conducted in a spacious room with a lot of walking area.



61

00:05:16,280 --> 00:05:23,360

This room must offer enough free space on walls to hang the plot of paper so that the participants have



62

00:05:23,390 --> 00:05:30,620

unlimited modeling space that they will not have to stop throwing their ideas on the plot of paper due



63

00:05:30,620 --> 00:05:32,060

to the running out of the space.



64

00:05:32,060 --> 00:05:38,030

For it, participants will be using a lot of different colored stickies at the end of the workshop.



65

00:05:38,360 --> 00:05:40,520

The walls will look something like this.



66

00:05:40,760 --> 00:05:45,830

You will have a lot of paper hanging off the walls and there will be a lot of stickies on it.



67

00:05:45,950 --> 00:05:49,460

The stickies placed on the part of paper, a color coded.



68

00:05:49,460 --> 00:05:51,890

You learn about the significance of these colors.



69

00:05:51,890 --> 00:05:58,760

In the next lecture for the online workshop, participants joined over a video call, and they use a



70

00:05:58,760 --> 00:06:03,490

collaboration platform for carrying out the even storming activities.



71

00:06:03,500 --> 00:06:10,240

All of the participants can make changes to a common virtual board, and these changes are visible to



72

00:06:10,280 --> 00:06:12,540

other participants in real time.



73

00:06:12,590 --> 00:06:18,200

There are many collaboration platforms that allow the participants to do exactly that.



74

00:06:18,230 --> 00:06:20,270

Here are two of those platforms.



75

00:06:20,300 --> 00:06:25,400

I suggest that you carry out your own research on these collaboration platforms.



76

00:06:25,400 --> 00:06:32,690

In one of the later lectures, I will be using Mirro for carrying out the workshop for Achmad Travels.



77

00:06:32,960 --> 00:06:40,190

The expected output from the workshop is the creation of a shared understanding of the business process



78

00:06:40,520 --> 00:06:41,050

this year.



79

00:06:41,060 --> 00:06:45,300

Understanding is then used for the modeling of the domain.



80

00:06:45,620 --> 00:06:48,550

The objective is not to design the system.



81

00:06:48,560 --> 00:06:51,800

The objective is not to be able to answer all questions.



82

00:06:51,980 --> 00:06:56,320

And it is not to produce the domain driven design models.



83

00:06:57,080 --> 00:06:58,430

Time to wrap up this lesson.



84

00:06:58,640 --> 00:07:05,300

Even storming is a collaborative process for creating shared understanding of the domain or the business



85

00:07:05,300 --> 00:07:05,870

process.



86

00:07:06,140 --> 00:07:14,330

Even storming is carried out in a facilitated workshop format, and it may be conducted in person or



87

00:07:14,420 --> 00:07:15,020

online.



88

00:07:15,200 --> 00:07:20,030

In the next lecture, you will learn how to even storming workshop is conducted.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\003 Elements of Event Storming.en.srt -->

1

00:00:00,180 --> 00:00:07,110

Fundamentals of even storming in this lecture, I'll discuss the various elements that I use for depicting



2

00:00:07,110 --> 00:00:10,030

knowledge in the event storming workshop.



3

00:00:10,050 --> 00:00:12,810

I'll start this lesson by discussing the cause and effect.



4

00:00:13,350 --> 00:00:19,710

Then I'll discuss the various elements of even storming, and then I'll end this lecture with the discussion



5

00:00:19,710 --> 00:00:21,900

on relationship between the elements.



6

00:00:22,800 --> 00:00:28,320

Quick note, this lesson will provide a high level introduction to even storming, if you would like



7

00:00:28,320 --> 00:00:31,890

to become a facilitator or an expert in even storming.



8

00:00:31,920 --> 00:00:38,100

My suggestion is that you do your own research, consider training and consider reading the book by



9

00:00:38,100 --> 00:00:38,670

Alberto.



10

00:00:39,210 --> 00:00:42,360

Business events are natural in all domains.



11

00:00:42,660 --> 00:00:48,230

They are the starting point of the conversation in an even storming workshop.



12

00:00:48,250 --> 00:00:55,500

Important point to note is that all business events are referred to as the domain events in the context



13

00:00:55,500 --> 00:00:56,460

of events.



14

00:00:56,460 --> 00:01:03,450

Storming the objective of the event storming workshop is to understand the causation.



15

00:01:03,810 --> 00:01:10,470

What that means is that the participants discuss the domain events to understand the cause of those



16

00:01:10,470 --> 00:01:15,240

events, and then they also discuss the effect of those events.



17

00:01:15,420 --> 00:01:23,000

This cause and effect is depicted as the knowledge of the domain by using the six basic elements.



18

00:01:23,730 --> 00:01:31,230

There are six building blocks or elements which are used for depicting the knowledge or flow in an even



19

00:01:31,230 --> 00:01:32,400

storming workshop.



20

00:01:32,400 --> 00:01:37,300

Color coded stickies are used to represent each of these six elements.



21

00:01:37,620 --> 00:01:45,270

Now there is a suggested standard for the colors of these stickies or the elements, but you don't have



22

00:01:45,270 --> 00:01:49,320

to follow it as long as you are consistent throughout your workshop.



23

00:01:49,350 --> 00:01:54,780

In other words, if you don't have these specific colors available for your workshop, it does not really



24

00:01:54,780 --> 00:01:55,180

matter.



25

00:01:55,380 --> 00:01:59,190

You can decide on a standard and just follow it through the workshop.



26

00:02:00,120 --> 00:02:09,000

A domain actor causes a stage change in the domain, and the stage change is initiated by way of a command



27

00:02:09,000 --> 00:02:10,690

and walk by the actor.



28

00:02:10,830 --> 00:02:15,150

This command is represented by a blue sticky on the workspace.



29

00:02:15,630 --> 00:02:20,670

This command leads to the raising of domain events.



30

00:02:20,670 --> 00:02:29,850

A domain even is a representation of some fact that has already happened, or domain even is represented



31

00:02:29,850 --> 00:02:32,520

in the workspace with the orange sticky.



32

00:02:32,760 --> 00:02:36,570

When the domain event is raised, it may lead to a reaction.



33

00:02:36,570 --> 00:02:42,420

And this reaction is carried out by way of a component that is referred to as the policy.



34

00:02:42,450 --> 00:02:46,620

And this policy is represented by way of a purple ticket.



35

00:02:46,980 --> 00:02:52,860

Since domain events represent something that has happened in the past, they should always be named



36

00:02:53,010 --> 00:02:54,270

in past tense.



37

00:02:54,570 --> 00:02:59,430

Here are examples of some events that have been named in the past tense.



38

00:02:59,730 --> 00:03:02,830

Loan approved, account canceled, funds withdrawn.



39

00:03:02,970 --> 00:03:03,910

These are good names.



40

00:03:04,380 --> 00:03:08,760

Here are some examples of bad names used for the events.



41

00:03:09,150 --> 00:03:12,470

Loan approval, cancel account, withdraw funds.



42

00:03:12,870 --> 00:03:14,310

These are not in past tense.



43

00:03:14,310 --> 00:03:17,280

As a result, they are not good names for Even's.



44

00:03:17,880 --> 00:03:20,910

Let's go with an example of online shopping.



45

00:03:21,210 --> 00:03:24,090

The cause is an action that produces an event.



46

00:03:24,450 --> 00:03:30,240

And in the case of online shopping, the domain actor is the customer.



47

00:03:30,600 --> 00:03:37,120

And the action that the domain actor takes is to pay for the items in the cart.



48

00:03:37,290 --> 00:03:44,430

When the payment is successful, it leads to the creation of an event and the event may be payment received.



49

00:03:44,640 --> 00:03:48,900

And then there is an effect, which is the reaction to the event.



50

00:03:49,350 --> 00:03:57,750

There may be a policy such as shipping, which one receives the payment received, even leads to the



51

00:03:57,990 --> 00:03:59,880

shipping of the goods.



52

00:04:00,120 --> 00:04:08,010

And this action is carried out again by way of a command, this action before the lead to raising additional



53

00:04:08,040 --> 00:04:08,580

events.



54

00:04:09,650 --> 00:04:17,120

It is important to understand that a command is abstract, that is, it does not represent an active



55

00:04:17,120 --> 00:04:24,980

component within the domain, it simply represents the intent of an act that must be carried out by



56

00:04:24,980 --> 00:04:25,490

the domain.



57

00:04:26,150 --> 00:04:34,340

For example, a banking customer may express the intent to deposit funds into account, or they may



58

00:04:34,340 --> 00:04:36,900

ask the bank to close the account.



59

00:04:36,980 --> 00:04:39,900

So these are simply intent of the bank customer.



60

00:04:39,920 --> 00:04:44,210

They are not the actual processing of any business logic.



61

00:04:44,210 --> 00:04:51,350

The business logic execution is carried out in the command processes in the context of even storming.



62

00:04:51,500 --> 00:04:57,000

The element that carries out the processing of the command is referred to as the aggregate.



63

00:04:57,020 --> 00:05:02,960

So if you look back at the illustration that I shared with you earlier, the command is not directly



64

00:05:02,960 --> 00:05:08,270

raising the domain, even it is the aggregate which is processing the command.



65

00:05:08,270 --> 00:05:14,140

And that processing is leading to the raising of the events in aggregate is represented by way of a



66

00:05:14,180 --> 00:05:15,020

yellow sticky.



67

00:05:15,930 --> 00:05:23,790

Apart from the command and external system or service can also be a source of even think of the external



68

00:05:23,790 --> 00:05:31,170

service as something outside the domain under consideration, such external services are represented



69

00:05:31,170 --> 00:05:32,380

by a pink sticky.



70

00:05:32,910 --> 00:05:36,990

Let me go over an example to explain external services.



71

00:05:37,630 --> 00:05:43,410

Think of a banking customer who's paying by our debit card to a merchant on successful processing of



72

00:05:43,410 --> 00:05:44,190

the payment.



73

00:05:44,310 --> 00:05:51,210

This external merchant payment system will raise an event within the bank and this raising of the event



74

00:05:51,330 --> 00:05:55,600

will then trigger the policy to reduce the account balance.



75

00:05:55,620 --> 00:06:02,940

So as you can see here, the merchant payment system or service is outside the bank's control or the



76

00:06:02,940 --> 00:06:11,040

bank's domain and event is directly or indirectly associated with the state change within a domain.



77

00:06:11,430 --> 00:06:17,050

A state change represents some kind of change in data within that domain.



78

00:06:17,220 --> 00:06:20,060

This data may be of interest to the stakeholder.



79

00:06:20,460 --> 00:06:28,000

So the way it works within even storming is that even has some data which is represented by a red model.



80

00:06:28,140 --> 00:06:32,640

This model is the response to queries for the domain data.



81

00:06:32,790 --> 00:06:38,240

This model is used by the user interface that the stakeholders can use.



82

00:06:38,280 --> 00:06:40,590

Now, this user interface can be an email.



83

00:06:40,590 --> 00:06:44,000

It doesn't have to be a pane of glass showing the data.



84

00:06:44,040 --> 00:06:50,660

It can be a dashboard for the executer or it can definitely be a rather obvious application.



85

00:06:50,670 --> 00:06:52,370

During the even storming workshop.



86

00:06:52,620 --> 00:06:56,150

This read model is represented by way of a green sticky.



87

00:06:56,190 --> 00:07:00,090

It is also referred to as the event data model or query model.



88

00:07:00,480 --> 00:07:08,090

The key point to keep in mind is that even has some data which is of value to the stakeholders and this



89

00:07:08,100 --> 00:07:10,750

Reed model represents that data.



90

00:07:10,980 --> 00:07:14,640

Let's revisit our example of the paper debit card.



91

00:07:14,820 --> 00:07:20,790

In this scenario, when the pierde from account eventers raised, the user may need to be notified.



92

00:07:21,030 --> 00:07:28,440

The Reed model will contain the transaction information which will be sent to the user or customer by



93

00:07:28,440 --> 00:07:30,480

way of by way of notification.



94

00:07:30,540 --> 00:07:37,050

This transaction information may have details about the merchant, the amount of the payment and even



95

00:07:37,050 --> 00:07:38,250

the account balance.



96

00:07:38,580 --> 00:07:46,050

Let's call the relationship between the various elements of even storming central to the idea is the



97

00:07:46,050 --> 00:07:46,620

domain.



98

00:07:46,620 --> 00:07:54,090

Even this domain even is caused by a command which is processed by the aggregate domain.



99

00:07:54,090 --> 00:07:58,960

Even may also be caused by a command being processed by an external service.



100

00:07:59,220 --> 00:08:05,900

The effect of the domain event is realized by way of policy that is triggered by the domain.



101

00:08:05,910 --> 00:08:13,260

Even this policy may further invoke commands that may lead to other domain events.



102

00:08:13,500 --> 00:08:17,160

Domain even has some data of value to the stakeholder.



103

00:08:17,340 --> 00:08:20,960

This data of value is represented by way of reboard.



104

00:08:21,270 --> 00:08:24,300

This Reid model may drive a user interface.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\004 Preparing for the ES Workshop.en.srt -->

1

00:00:00,180 --> 00:00:07,320

Preparing for the workshop in this lesson, I talk about who facilitates the workshop and discuss the



2

00:00:07,320 --> 00:00:11,850

tasks that need to be carried out prior to the knowledge gathering activities.



3

00:00:12,480 --> 00:00:13,830

Let's start with a question.



4

00:00:14,220 --> 00:00:17,140

Who facilitates the even storming workshop?



5

00:00:17,340 --> 00:00:24,480

It is common for large organizations to hire outside consultants to carry out the facilitation.



6

00:00:24,720 --> 00:00:30,180

In my opinion and in my experience, you really don't need outside consultants.



7

00:00:30,330 --> 00:00:37,500

Existing team members, such as project managers and scrum masters can easily be trained to become even



8

00:00:37,500 --> 00:00:39,700

storming workshop facilitators.



9

00:00:39,750 --> 00:00:44,710

I have seen many experts taking up this role in their organizations.



10

00:00:44,760 --> 00:00:52,560

Bottom line is, anyone can learn to become a facilitator by observing experienced facilitators and



11

00:00:52,560 --> 00:00:53,580

by practicing.



12

00:00:54,150 --> 00:01:00,610

Let's make an assumption here that the facilitator is identified and the participants have been invited.



13

00:01:00,750 --> 00:01:03,610

So what does the facilitator have to do next?



14

00:01:04,050 --> 00:01:09,900

They have to prepare the room for the in-person workshop, or if it is a remote workshop, then they



15

00:01:09,900 --> 00:01:13,470

need to ensure that all of the tools are ready to go.



16

00:01:13,650 --> 00:01:20,490

Second thing they need to do is on the day of the workshop, educate the participants on what is even



17

00:01:20,490 --> 00:01:26,220

storming workshop, define the scope of the workshop, make sure all the participants are on the same



18

00:01:26,220 --> 00:01:33,210

page in terms of which business process or processes are in the scope of the workshop and then level



19

00:01:33,210 --> 00:01:37,240

set the expectation by discussing the expected outcome.



20

00:01:37,260 --> 00:01:42,720

Once these tasks have been completed by the facilitator, it's time for the facilitator to dive in.



21

00:01:42,970 --> 00:01:45,660

Let's go through the details of each of these tasks.



22

00:01:46,410 --> 00:01:52,680

To set the stage for an in-person workshop, you need to make sure that the room that you're using is



23

00:01:52,680 --> 00:01:53,430

spacious.



24

00:01:53,730 --> 00:01:57,270

If there are tables and chairs in the room, move them to the side.



25

00:01:57,540 --> 00:02:04,320

And the reason for this is to provide space for participants to move around, hang the plot of paper



26

00:02:04,350 --> 00:02:09,260

on the walls with masking tape, and then draw a time line from left to right.



27

00:02:09,870 --> 00:02:15,760

The number of plot of papers that you will hang on the wall will depend on the scope of the exercise.



28

00:02:15,840 --> 00:02:21,540

Now, you don't have to hang the plot of paper all around the room as you can do it as you go.



29

00:02:21,960 --> 00:02:28,890

The idea is to be prepared to set up the stage for a remote workshop, ensure that all the tools are



30

00:02:28,890 --> 00:02:32,190

ready to go at least two days prior to the workshop.



31

00:02:32,220 --> 00:02:35,580

In other words, you must have the video conferencing set up.



32

00:02:35,580 --> 00:02:38,820

You must have the tool for the collaboration setup.



33

00:02:39,000 --> 00:02:46,080

Create a board and make sure that all participants are able to connect to the video conference and they



34

00:02:46,080 --> 00:02:50,360

are able to connect to the collaboration tool as well.



35

00:02:50,610 --> 00:02:56,670

And the reason for this is that in many workshops I have seen the first hour, hour and a half being



36

00:02:56,670 --> 00:03:02,630

spent on addressing technical challenges faced by the participants, and it can be a big damper.



37

00:03:02,730 --> 00:03:04,290

You don't want that to happen.



38

00:03:04,300 --> 00:03:11,460

So please make sure that if you are conducting the workshop remotely, you must have everything working



39

00:03:11,460 --> 00:03:13,830

on day one before the workshop starts.



40

00:03:15,010 --> 00:03:22,870

At the beginning of the even storming workshop, it is suggested that you provide a quick overview of



41

00:03:22,870 --> 00:03:25,380

what even storming is all about.



42

00:03:25,720 --> 00:03:32,140

Now, you may have a group of participants who are already experienced with the even storming, but



43

00:03:32,140 --> 00:03:38,430

there is no harm in spending a few minutes reminding everyone as to what is involved in the workshop.



44

00:03:38,440 --> 00:03:43,180

And as part of this education, please do not use any technical terms.



45

00:03:43,330 --> 00:03:49,330

Specifically, don't talk about domain driven design and all those good things that we technologists



46

00:03:49,450 --> 00:03:50,560

like to talk about.



47

00:03:50,560 --> 00:03:52,240

Keep it business focused.



48

00:03:52,250 --> 00:03:57,010

Remember, your participants are not necessarily technologists.



49

00:03:57,310 --> 00:04:04,210

Discuss the purpose of colored stickies and the workspace, but you don't have to spend too much time



50

00:04:04,390 --> 00:04:10,040

on these aspects as participants will learn, as you will proceed to the workshop.



51

00:04:10,180 --> 00:04:15,430

One thing that really helps is to put all the colored stickies and what they represent somewhere in



52

00:04:15,430 --> 00:04:22,630

the workspace so that it is visible to anyone who has a question about what color to use, which is



53

00:04:22,630 --> 00:04:24,310

an extremely common question.



54

00:04:24,310 --> 00:04:29,710

In the beginning of the workshop, after the general overview of even storming, it is time for the



55

00:04:29,710 --> 00:04:36,130

facilitator to define the scope of the workshop, the scope of the workshop, maybe a big picture from



56

00:04:36,130 --> 00:04:42,010

the domain perspective, or it may be a single business process, irrespective of what the scope is.



57

00:04:42,140 --> 00:04:48,940

It is important for all the participants in the room to be on the same page and to ensure that everyone



58

00:04:48,940 --> 00:04:49,960

stays on track.



59

00:04:50,260 --> 00:04:56,620

The high level objective for the workshop in the workspace so that it is visible at all times.



60

00:04:56,840 --> 00:05:03,250

For example, here I am suggesting the objective to be understand the loan approval process.



61

00:05:03,280 --> 00:05:09,010

Another thing that is important is that as you will start going to the workshop, it is very much possible



62

00:05:09,340 --> 00:05:15,340

that there may be discussions around aspects which are out of school from the workshop perspective,



63

00:05:15,550 --> 00:05:19,010

but they may be valuable from the domain perspective.



64

00:05:19,210 --> 00:05:26,530

As a result, you don't want to lose out on those aspects, so create a dedicated space to list out



65

00:05:26,560 --> 00:05:28,840

all of these otoscope elements.



66

00:05:29,200 --> 00:05:32,260

You can follow up on these items after the workshop.



67

00:05:33,150 --> 00:05:39,480

One last thing that the facilitator should do before starting the workshop is set, the expectations



68

00:05:40,000 --> 00:05:46,890

and this is best done in my experience, by way of sharing real experiences from the past workshops



69

00:05:47,100 --> 00:05:54,210

and if possible, sharing pictures from those workshops, these expectations should be realistic and



70

00:05:54,210 --> 00:06:01,020

gives the participants and ask them what their thoughts are on the even storming workshop, as well



71

00:06:01,020 --> 00:06:08,700

as on what they expect ideas to get everyone excited so that they become active participants in the



72

00:06:08,700 --> 00:06:14,250

workshop and they should all be looking forward to learning and teaching.



73

00:06:14,250 --> 00:06:18,120

Used this part of the workshop for some icebreaking activities.



74

00:06:18,780 --> 00:06:22,380

At this time, the facilitator is ready to dive in.



75

00:06:22,500 --> 00:06:28,290

One of the important role for the facilitator is to make sure that everyone is having fun and everyone



76

00:06:28,290 --> 00:06:35,430

is energized because low energy will lead to an outcome which is going to be of bad quality.



77

00:06:35,670 --> 00:06:38,550

Participants must feel engaged.



78

00:06:38,560 --> 00:06:42,300

Participants must be active throughout the workshop.



79

00:06:42,450 --> 00:06:45,930

So a facilitator must keep those aspects in mind.



80

00:06:46,080 --> 00:06:50,730

I'll see in the next lecture where I'm going to discuss how the knowledge model gets created.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\005 Conducting the ES Workshop.en.srt -->

1

00:00:00,120 --> 00:00:06,990

Conducting the even storming workshop in this lesson, I will cover the general steps carried out in



2

00:00:06,990 --> 00:00:10,170

the even storming workshop for creating the knowledge model.



3

00:00:10,380 --> 00:00:17,160

As part of this lesson, I'll also share some helpful tips for the facilitators to discuss the even



4

00:00:17,160 --> 00:00:18,730

storming process.



5

00:00:18,750 --> 00:00:21,150

I have picked up an example use case.



6

00:00:21,480 --> 00:00:24,240

This will be the bank's loan approval process.



7

00:00:24,390 --> 00:00:32,670

Let's assume that Facilitator's has invited the IT team as well as the business experts who can answer



8

00:00:32,940 --> 00:00:37,500

the questions related to the loan products offered by the bank.



9

00:00:37,860 --> 00:00:45,330

Facilitators must keep in mind that even storming does not require the participants to use all of the



10

00:00:45,360 --> 00:00:46,050

elements.



11

00:00:46,050 --> 00:00:51,780

Participants may pick only the relevant elements to create the knowledge model.



12

00:00:51,790 --> 00:00:59,880

It is the facilitators job to help the participants pick up the relevant elements to design the knowledge



13

00:00:59,880 --> 00:01:00,270

model.



14

00:01:00,660 --> 00:01:05,700

Before I discuss the general steps involved in the workshop, I would like to point out that there is



15

00:01:05,700 --> 00:01:10,060

a lot of flexibility in how they even storming workshop is conducted.



16

00:01:10,060 --> 00:01:14,810

A facilitator may adjust the steps, the floor, the pace as needed.



17

00:01:14,970 --> 00:01:21,960

These adjustments depend on multiple factors, such as the facilitators and participants, past experiences,



18

00:01:21,960 --> 00:01:27,330

complexity of the domain, granularity of the knowledge model, whether it's going to be high level



19

00:01:27,480 --> 00:01:29,280

or whether it's going to be detailed.



20

00:01:29,280 --> 00:01:31,740

And there may be other factors as well.



21

00:01:32,280 --> 00:01:34,080

Let's go to the general steps.



22

00:01:34,380 --> 00:01:41,540

The first step involved in the workshop requires the participants to identify the two main events.



23

00:01:41,580 --> 00:01:47,490

Once the domain events have been identified as a next step, participants discuss the ordering of the



24

00:01:47,490 --> 00:01:49,440

events across the timeline.



25

00:01:49,440 --> 00:01:53,790

In the step, duplicate events are also revealed and removed.



26

00:01:53,970 --> 00:01:59,760

In the third step, the participants are asked to identify the cause and effects of events.



27

00:01:59,850 --> 00:02:05,790

So here, commands, policies and external services get added to the knowledge model.



28

00:02:05,940 --> 00:02:10,710

And in the fourth step, the commands are associated with the aggregates.



29

00:02:10,710 --> 00:02:16,920

So let's dive into the first step as a first step in the knowledge gathering exercise.



30

00:02:17,340 --> 00:02:26,310

The facilitator asked the participants to brainstorm and hang as many events as possible in the workspace.



31

00:02:26,460 --> 00:02:29,220

Initially, the participants may be hesitant.



32

00:02:29,370 --> 00:02:30,300

That is common.



33

00:02:30,750 --> 00:02:36,120

So it is suggested that facilitator be the first one to place an even.



34

00:02:36,660 --> 00:02:40,500

So, here is the first event loan application received.



35

00:02:40,740 --> 00:02:47,820

At this point, all participants should be encouraged to hang events once all of the participants have



36

00:02:47,820 --> 00:02:53,130

placed the events that they could come up with this exercise move to the next step.



37

00:02:53,280 --> 00:03:02,100

In this step, the participants discuss when each of the events occur and order the events across the



38

00:03:02,100 --> 00:03:03,960

timeline from left to right.



39

00:03:04,170 --> 00:03:11,130

One important step for the facilitator is that facilitators should always remember that their role is



40

00:03:11,130 --> 00:03:17,700

to facilitate and they need to let the participants do the modeling once the participants have ordered



41

00:03:17,700 --> 00:03:20,400

the events look for duplicate.



42

00:03:20,520 --> 00:03:29,400

For example, in this set of events, the deposit installment and the customer deposit installment look



43

00:03:29,400 --> 00:03:30,600

to be duplicates.



44

00:03:30,600 --> 00:03:35,280

So conform with the participants and remove the duplicate event.



45

00:03:35,940 --> 00:03:43,500

And step number three, the participants need to think about commands, policies and actors to identify



46

00:03:43,500 --> 00:03:45,600

the cause and the effect of events.



47

00:03:46,380 --> 00:03:50,880

These concepts are a little tricky compared to the domain events.



48

00:03:51,450 --> 00:03:58,950

So at this point the facilitator is encouraged to ask questions to help the participants make some progress.



49

00:03:59,190 --> 00:04:05,670

Since we do not have enough real estate on the screen, I'll just focus on these three events so the



50

00:04:05,670 --> 00:04:11,850

facilitator may ask a question Who is responsible for approving or rejecting the loan?



51

00:04:12,000 --> 00:04:12,840

At that point?



52

00:04:12,930 --> 00:04:13,980

He may get the answer.



53

00:04:13,980 --> 00:04:16,440

Oh yes, it is the loan officer.



54

00:04:16,470 --> 00:04:20,730

At that point, the facilitator may suggest thinking about the commands.



55

00:04:20,730 --> 00:04:26,640

So let's say the participants come up with the reject application command and the approved application



56

00:04:26,640 --> 00:04:27,030

command.



57

00:04:27,030 --> 00:04:32,330

The next question the facilitator may ask, so when does the loan account get established?



58

00:04:32,760 --> 00:04:37,170

Yes, that gets established after the loan has been approved.



59

00:04:37,350 --> 00:04:44,850

So that means that approval of loan triggers the setting up of an account which seem to be a policy.



60

00:04:44,970 --> 00:04:52,650

So in step three, the facilitator has held the participant, identified some commands and a policy



61

00:04:53,460 --> 00:04:59,650

in step number for the facilitator, asked the participants to think about the.



62

00:05:00,030 --> 00:05:08,010

This logic that is responsible for creating the two main events at the same time, it is important for



63

00:05:08,010 --> 00:05:10,350

the facilitator to keep track of the time.



64

00:05:10,710 --> 00:05:18,270

Every 30 minutes it is suggested that the facilitator review the progress and adjust the pace and the



65

00:05:18,270 --> 00:05:19,620

direction as needed.



66

00:05:19,800 --> 00:05:26,520

So going back to where we were in the last step, the facilitator may ask the participants to focus



67

00:05:26,520 --> 00:05:30,420

on loan application rejected and loan application approved.



68

00:05:30,840 --> 00:05:38,100

And he may find out that there are multiple business rules that are applied to make a decision on the



69

00:05:38,100 --> 00:05:40,920

approval or rejection of the loan application.



70

00:05:40,950 --> 00:05:48,510

So now in this floor, we know the commands and the business logic associated with two of the events.



71

00:05:48,690 --> 00:05:55,560

The focus may shift to the next event for which we don't have the domain logic information facilitator



72

00:05:55,560 --> 00:06:03,210

may ask the participants to focus on loan account established, and after some discussion, the participants



73

00:06:03,210 --> 00:06:10,170

may decide to place an aggregate loan account, which represents the business logic leading to the creation



74

00:06:10,170 --> 00:06:12,650

of the loan account established even.



75

00:06:13,230 --> 00:06:18,120

Let's discuss the post workshop activities carried out by the facilitator.



76

00:06:18,270 --> 00:06:26,070

Facilitator takes pictures of the workspace before taking down all of the part of paper from the walls.



77

00:06:26,490 --> 00:06:32,490

It'll be much more easier for the facilitator to go to the pictures rather than rolling out these long



78

00:06:32,490 --> 00:06:33,570

sheets of paper.



79

00:06:33,720 --> 00:06:38,250

At the end of the workshop, the facilitator asked the participants for their feedback.



80

00:06:38,400 --> 00:06:39,480

What worked out well?



81

00:06:39,810 --> 00:06:41,100

What needs to be changed?



82

00:06:41,430 --> 00:06:48,090

The expectation is that the facilitator will incorporate this feedback in their next workshop.



83

00:06:48,360 --> 00:06:49,530

Within two to three days.



84

00:06:49,530 --> 00:06:57,210

The facilitator consolidates the Knowledge and shares knowledge model with all of the participants facilitator



85

00:06:57,210 --> 00:07:04,140

requesting participants to go over the knowledge modeler to ensure its accuracy facilitator decides



86

00:07:04,140 --> 00:07:09,030

on the next steps and ensures that all of the parking lot items are addressed.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09 Event Storming for creating shared knowledge\006 Exercise _ ACME Sales ES Workshop.en.srt -->

1

00:00:00,150 --> 00:00:07,680

Acme sales, even storming workshop in this lesson, I will demonstrate to you how a remote, even storming



2

00:00:07,680 --> 00:00:09,390

workshop is facilitated.



3

00:00:09,750 --> 00:00:16,710

And by the end of this lecture, we will have a knowledge model for Acme customer sales process for



4

00:00:16,710 --> 00:00:17,770

this demo workshop.



5

00:00:17,790 --> 00:00:27,390

Let's assume that Acme has already identified the facilitator and this facilitator has invited the technology



6

00:00:27,390 --> 00:00:29,490

team and the business team.



7

00:00:29,490 --> 00:00:38,100

The business team consist of John, who is the travel advisor, and Brianna, who is the sales manager.



8

00:00:38,490 --> 00:00:45,240

The facilitator has already selected Zouma as the tool of choice for video conference and Mirro as a



9

00:00:45,240 --> 00:00:46,350

collaboration tool.



10

00:00:47,710 --> 00:00:55,120

To prepare for the workshop, the facilitator has created the shared board on the collaboration tool



11

00:00:55,390 --> 00:01:02,980

and placed all the helpful information on the board, and then the facilitator has sent an invite to



12

00:01:02,980 --> 00:01:06,370

all the participants to join the shared board.



13

00:01:06,670 --> 00:01:13,570

Participants will receive an invite from the collaboration tool that they can accept and then access



14

00:01:13,570 --> 00:01:14,290

the board.



15

00:01:14,320 --> 00:01:21,130

Please note that focus in this lesson is on demonstrating the tasks involved and even storming.



16

00:01:21,430 --> 00:01:24,010

I will not be going into the details of Mirro.



17

00:01:24,190 --> 00:01:29,730

So if you are interested in understanding how Mirro works, I suggest that you visit Mirador.



18

00:01:29,800 --> 00:01:35,710

Com and go to a tutorial or YouTube video as a first step will set up the board.



19

00:01:35,720 --> 00:01:42,250

We need to make sure that the modelling elements are clearly depicted somewhere so that participants



20

00:01:42,250 --> 00:01:44,050

can easily find them next.



21

00:01:44,320 --> 00:01:46,630

Let's place the timeline now.



22

00:01:46,630 --> 00:01:48,970

We are ready to invite our participants.



23

00:01:48,970 --> 00:01:53,230

Every tool has its own way of managing the participants on video.



24

00:01:53,260 --> 00:01:58,870

To invite the participants, click on Share and then set up your participants.



25

00:01:58,870 --> 00:02:02,290

I've already invited the participants for this workshop.



26

00:02:02,500 --> 00:02:09,490

The invited participants will receive an email to join Mirro and get access to the shared board.



27

00:02:09,910 --> 00:02:17,040

On the day of the event, all of the participants will join the video conference and the middle board.



28

00:02:17,050 --> 00:02:24,160

And as you can see here, all participants will be able to see the location of the cursor for all of



29

00:02:24,160 --> 00:02:27,550

the other participants to identify the events.



30

00:02:27,550 --> 00:02:30,630

The participants will start with the brainstorming.



31

00:02:30,640 --> 00:02:33,460

They'll have some discussions around the type of event.



32

00:02:33,910 --> 00:02:43,030

And then as a best practice, the facilitator may go ahead and post the first event booking confirmed.



33

00:02:43,240 --> 00:02:49,390

Other participants will then start to further brainstorm and post Even's on the board.



34

00:03:00,630 --> 00:03:06,950

So these are the events that our participants have identified since John is the expert in the room,



35

00:03:06,960 --> 00:03:10,840

the participants may decide to let John drive the discussion.



36

00:03:11,280 --> 00:03:15,540

So here is John driving this discussion around the ordering of the events.



37

00:03:15,690 --> 00:03:23,900

The first thing that happens is that the customer tells us their preferences and we create a proposal.



38

00:03:24,240 --> 00:03:32,640

In fact, we will create multiple proposals and at some point the customer may select one of the proposals.



39

00:03:32,660 --> 00:03:40,920

So this is, I would say, the order in which the events happen from the proposal of creation and selection



40

00:03:40,920 --> 00:03:46,300

perspective at some point, the customer base for the selected proposal.



41

00:03:46,320 --> 00:03:50,590

And so let's move the booking confirmed after this.



42

00:03:50,610 --> 00:03:55,860

So once the customer has heard, that's when the booking gets confirmed.



43

00:03:56,100 --> 00:03:59,010

And I see there are two booking confirmed events here.



44

00:03:59,010 --> 00:04:01,420

So let's delete one of these.



45

00:04:01,440 --> 00:04:06,600

So John has just deleted one of the booking confirmed after the booking is confirmed.



46

00:04:07,020 --> 00:04:09,380

The booking can also be canceled.



47

00:04:10,050 --> 00:04:13,620

So let's put it after the booking confirmed.



48

00:04:14,050 --> 00:04:17,000

Obviously, there is this proposal confirmed.



49

00:04:17,430 --> 00:04:22,860

The question is, is proposal confirmed the same as proposal selected?



50

00:04:23,340 --> 00:04:24,900

We call it proposal selected.



51

00:04:24,900 --> 00:04:28,020

So looks like this is also a duplicate event.



52

00:04:28,110 --> 00:04:29,370

Let's just delete this.



53

00:04:29,400 --> 00:04:34,170

So I would say this is how our ordered events look like.



54

00:04:34,440 --> 00:04:40,960

Facilitator may ask questions to the participant, decide on the commands leading to these events.



55

00:04:40,980 --> 00:04:42,900

So how is the proposal created?



56

00:04:42,900 --> 00:04:48,720

And the response may be that when the customer shows interest in a vacation package, a proposal is



57

00:04:48,720 --> 00:04:49,240

created.



58

00:04:49,290 --> 00:04:52,450

So we have just identified an actor.



59

00:04:52,590 --> 00:04:58,770

Let's place the actor in the mix, facilitate or make sure that there is enough space for the stickies



60

00:04:58,770 --> 00:04:59,550

to replace.



61

00:04:59,550 --> 00:05:01,810

Let's name this active customer.



62

00:05:01,950 --> 00:05:04,980

So the next question may be how is the proposal created?



63

00:05:04,980 --> 00:05:07,110

And here comes the first command.



64

00:05:07,200 --> 00:05:10,870

The proposal is created by way of a command do proposal.



65

00:05:11,040 --> 00:05:12,770

So that's our first command.



66

00:05:12,780 --> 00:05:15,330

And how is the proposal selected?



67

00:05:15,510 --> 00:05:17,940

That may be by way of a select proposal.



68

00:05:17,940 --> 00:05:19,710

And how about payment received?



69

00:05:19,890 --> 00:05:27,570

Well, the payment received event is created when the customer makes a payment.



70

00:05:27,580 --> 00:05:30,300

So we have the make payment.



71

00:05:30,780 --> 00:05:31,520

This looks good.



72

00:05:31,950 --> 00:05:33,750

And how about booking confirmed?



73

00:05:34,530 --> 00:05:38,550

The booking confirmed happens when the payment is successful.



74

00:05:38,590 --> 00:05:43,940

So it looks like there's no direct command here, but it's an effect.



75

00:05:43,950 --> 00:05:46,880

And so as a result, we need to use a policy.



76

00:05:46,920 --> 00:05:49,930

Let's make some space here and add a policy.



77

00:05:49,950 --> 00:05:53,640

Now, the question here is what happens in this policy?



78

00:05:53,970 --> 00:06:01,230

Well, when the payment is successful, reservations are made and when all the reservations are successful,



79

00:06:01,800 --> 00:06:05,620

that's when the booking confirmed happens.



80

00:06:05,760 --> 00:06:12,600

So, OK, so it looks like reservations policy leads to booking confirmation.



81

00:06:12,990 --> 00:06:19,830

And this last one, the booking canceled, happens when the customer issues the command to cancel the



82

00:06:19,830 --> 00:06:20,350

booking.



83

00:06:20,370 --> 00:06:26,550

So at this point, we have some comments and a policy for the events identified in the first step.



84

00:06:27,390 --> 00:06:33,300

So the question now is when the customer issues the do proposal, what happens?



85

00:06:33,420 --> 00:06:38,340

Well, we have some business logic that leads to the setting up of the proposal.



86

00:06:38,610 --> 00:06:46,590

OK, so that means between the proposal and proposal created, even there is business logic and what



87

00:06:46,590 --> 00:06:48,600

we call it, we'll call it proposal.



88

00:06:48,810 --> 00:06:50,750

So this is our first aggregate.



89

00:06:51,210 --> 00:06:53,100

And how about Selecter proposal?



90

00:06:53,430 --> 00:06:59,160

It's the same business logic used for the proposal created so we can move this somewhere between the



91

00:06:59,160 --> 00:06:59,840

two events.



92

00:07:00,060 --> 00:07:02,750

So let's move to the next event.



93

00:07:02,910 --> 00:07:04,740

How does that make payment process?



94

00:07:04,770 --> 00:07:07,920

And this is where we may hear from John and others in the team.



95

00:07:07,920 --> 00:07:14,370

The payment received is an event that comes from an external source, and this external source is a



96

00:07:14,370 --> 00:07:17,360

payment processor which is outside of Acme.



97

00:07:17,370 --> 00:07:20,820

So that means we need to introduce an external service here.



98

00:07:21,030 --> 00:07:23,030

This is called How about cancel booking?



99

00:07:23,250 --> 00:07:26,460

Well, there are lots of rules for cancel booking.



100

00:07:27,120 --> 00:07:33,690

All these rules are in some kind of a business logic that leads to booking canceled, let's call it



101

00:07:33,990 --> 00:07:38,400

booking, confirm logic, move the stickies to make some space.



102

00:07:38,580 --> 00:07:43,200

And now we have a couple of aggregates and an external service.



103

00:07:43,380 --> 00:07:44,990

Let's make some space here.



104

00:07:45,360 --> 00:07:49,260

OK, so things look a little bit cleaner in this next step.



105

00:07:49,440 --> 00:07:57,540

The participants will review the knowledge model and make it easy to follow so they will place arrows



106

00:07:57,540 --> 00:07:59,310

to show the flow of events.



107

00:07:59,760 --> 00:08:05,910

So here, for example, the customer will invoke the command do proposal, which will invoke the aggregate



108

00:08:05,910 --> 00:08:10,050

proposal, which will lead to the creation of the proposal created.



109

00:08:10,170 --> 00:08:16,830

Even similarly, the customer will invoke the select proposal, which will be processed by the proposal



110

00:08:16,830 --> 00:08:20,970

aggregate and the proposal selected even will be created.



111

00:08:20,970 --> 00:08:27,780

An invocation of the make payment and external service will process the payment and lead to the creation



112

00:08:27,780 --> 00:08:35,130

of the event payment received, which will trigger a policy for making all the vacation package reservations



113

00:08:35,520 --> 00:08:37,710

and on successful reservations.



114

00:08:38,280 --> 00:08:45,500

The booking will be confirmed by the policy by way of triggering the confirmed booking command that



115

00:08:45,510 --> 00:08:52,080

will lead to the processing of the command and the booking confirm aggregate and unsuccessful confirmation



116

00:08:52,500 --> 00:08:55,790

the booking confirmed even will be created.



117

00:08:55,810 --> 00:09:02,220

Customer can cancel the booking by invoking the cancel booking command, but there are certain rules



118

00:09:02,220 --> 00:09:05,070

and these rules are managed in the booking.



119

00:09:05,070 --> 00:09:06,560

Confirm aggregate.



120

00:09:06,570 --> 00:09:13,200

If the customer is allowed to cancel the booking, then the booking will be cancelled and the booking



121

00:09:13,200 --> 00:09:15,210

canceled event will be released.



122

00:09:15,240 --> 00:09:21,120

So this is the final state of our knowledge model for Acme sales process.



123

00:09:21,570 --> 00:09:23,250

By no means it is complete.



124

00:09:23,940 --> 00:09:29,670

My intent was just to give you an idea on how the even storming workshop works.



125

00:09:30,000 --> 00:09:36,780

At the end of the day, this knowledge model will be expanded to include the processing of many of the



126

00:09:36,780 --> 00:09:38,880

events here and further details.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000001.srt -->

1
00:00:00,150 --> 00:00:12,960
Trong phần cuối cùng, bạn biết rằng các sự kiện xảy ra một cách tự nhiên trong các miền.  Vì vậy, điều đó có nghĩa là để hiểu miền, bạn phải hiểu các sự kiện được tạo ra và tiêu thụ trong miền.

2
00:00:13,320 --> 00:00:24,040
Even Stahlman là một bài tập hợp tác được thực hiện bởi các bên liên quan để xác định các nhà sản xuất và người tiêu dùng chẵn trong một phạm vi nhất định.

3
00:00:24,450 --> 00:00:34,530
Mục tiêu là tạo ra sự hiểu biết chung về miền.  Kết quả của bài tập là một mô hình kiến ​​thức cho miền đó.

4
00:00:35,070 --> 00:00:47,910
Ngay cả việc gây bão cũng được thực hiện theo hình thức hội thảo.  Có một người hỗ trợ làm việc với các bên liên quan từ các bộ phận khác nhau của tổ chức hoặc các bộ phận khác nhau của miền.

5
00:00:48,270 --> 00:01:03,080
Hội thảo này có thể được thực hiện trực tiếp hoặc trực tuyến bằng các công cụ cộng tác.  Trong một trong những bài giảng trong phần này, bạn sẽ học cách sử dụng các công cụ cộng tác để tiến hành hội thảo về sự kiện.

6
00:01:03,360 --> 00:01:16,710
Chúng ta hãy đi qua các mục tiêu học tập cho phần này.  Đến cuối phần này, bạn sẽ hiểu rõ về thậm chí gây bão là gì, một trong những mục tiêu và kết quả của một hội thảo về sự kiện gây bão.

7
00:01:17,160 --> 00:01:35,580
Bạn có thể mô tả quá trình được sử dụng để tạo ra các mô hình kiến ​​thức.  Bạn sẽ học cách chuẩn bị và tiến hành hội thảo gây bão sự kiện và trong bài giảng cuối cùng, bạn sẽ thấy cách sử dụng các công cụ cộng tác để tiến hành và hội thảo trực tuyến, thậm chí là gây bão.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000002.srt -->

1
00:00:00,180 --> 00:00:15,630
Giới thiệu về sự kiện gây bão, tôi sẽ bắt đầu bài giảng này bằng cách xem lại phần tóm tắt kiến ​​thức, sau đó tôi sẽ thảo luận về hội thảo thậm chí gây bão là gì và bạn cần những gì để tiến hành hội thảo gây bão sự kiện.

2
00:00:16,110 --> 00:00:29,760
Ở một trong những bài giảng trước đó, tôi đã giới thiệu cho các bạn cách nghiền nát kiến ​​thức phổ thông.  Xử lý kiến ​​thức là một cách để các nhóm xử lý kiến ​​thức nhận được từ các chuyên gia trong lĩnh vực thành mô hình miền.

3
00:00:30,240 --> 00:00:46,320
Là một phần của khóa học, tôi đã cho bạn xem nhiều ví dụ trong đó chúng tôi phỏng vấn các chuyên gia miền và tạo ra các mô hình miền chủ yếu ở dạng UML và ngôn ngữ phổ biến tại thời điểm này.

4
00:00:46,440 --> 00:01:01,790
Câu hỏi đặt ra bây giờ là bạn tiếp nhận kiến ​​thức từ các chuyên gia miền như thế nào?  Phỏng vấn là một trong những kỹ thuật chúng tôi đã sử dụng nhưng có nhiều kỹ thuật khác có cấu trúc chặt chẽ hơn nhiều so với các cuộc phỏng vấn không chính thức.

5
00:01:02,010 --> 00:01:10,930
Ví dụ: nếu bạn đang thực hiện việc lên ý tưởng để phát triển một sản phẩm mới, bạn có thể sử dụng một kỹ thuật gọi là tư duy thiết kế cho thiết kế theo hướng miền.

6
00:01:10,980 --> 00:01:19,170
Có một kỹ thuật phổ biến được sử dụng và kỹ thuật đó được gọi là tấn công chớp nhoáng.  Xin lưu ý rằng đây chỉ là một số ví dụ về các kỹ thuật.

7
00:01:19,180 --> 00:01:25,680
Có nhiều cách khác để bạn có thể nhận kiến ​​thức từ các chuyên gia trong lĩnh vực một cách có cấu trúc.

8
00:01:25,800 --> 00:01:40,660
Trọng tâm của tôi là thậm chí còn gây bão.  Đó là một định nghĩa chính thức về việc thậm chí gây bão bằng kỹ thuật dựa trên hội thảo hợp tác để tạo ra sự hiểu biết chung về các lĩnh vực và quy trình kinh doanh phức tạp.

9
00:01:40,950 --> 00:02:00,810
Phần quan trọng ở đây là tạo ra sự hiểu biết chung.  Vì vậy, mục đích không phải là thiết kế hoặc mô hình hóa hệ thống mà chỉ tạo ra sự hiểu biết chung giữa các bên liên quan trong miền và các bên liên quan là các chuyên gia kinh doanh cũng như chuyên gia công nghệ.

10
00:02:01,800 --> 00:02:18,510
Ngay cả việc gây bão cũng có thể được sử dụng để tạo ra sự hiểu biết được chia sẻ này từ góc độ lĩnh vực tổng thể hoặc góc độ bức tranh tổng thể, cũng như nó có thể được sử dụng để tạo ra kiến ​​thức được chia sẻ từ góc độ quy trình kinh doanh.

11
00:02:18,900 --> 00:02:27,340
Vì vậy, kỹ thuật này khá linh hoạt về những gì bạn có thể sử dụng nó.  Chủ đề trung tâm của các sự kiện kinh doanh.

12
00:02:27,540 --> 00:02:40,150
Những người tham gia hội thảo xác định và hiểu rõ về hoạt động kinh doanh ngay cả khi họ tìm kiếm nguyên nhân của hoạt động kinh doanh, thậm chí cũng như ảnh hưởng của các sự kiện kinh doanh đó.

13
00:02:40,830 --> 00:02:51,110
Kỹ thuật này được tạo ra bởi Alberto Brandolini vào năm 2012 và kể từ đó nó đã trở nên rất phổ biến đối với những người thực hành kỹ thuật số.

14
00:02:51,330 --> 00:02:58,440
Lợi ích lớn nhất của kỹ thuật này là nó tăng tốc quá trình phát triển cho các ứng dụng phức tạp.

15
00:02:58,590 --> 00:03:08,470
Một điều quan trọng cần ghi nhớ là kiến ​​thức được tạo ra bằng cách tính thời gian của sự kiện sẽ được sử dụng làm đầu vào để tạo mô hình.

16
00:03:08,490 --> 00:03:24,750
Vì vậy, nói cách khác, bạn sẽ không thay thế mô hình hóa con người bằng thậm chí Stormi, nhưng bạn sẽ sử dụng kiến ​​thức thu được từ thậm chí Stormi làm đầu vào để tạo sơ đồ UML nếu bạn muốn tìm hiểu thêm về bão thậm chí.

17
00:03:25,140 --> 00:03:33,250
Gợi ý của tôi là các bạn hãy xem cuốn sách này do Alberto giới thiệu, thậm chí còn gây bão.  Bây giờ hãy nói về hội thảo.

18
00:03:33,390 --> 00:03:59,080
Điều quan trọng nhất của hội thảo thậm chí còn gây bão là bạn phải mời đúng nhóm chuyên gia CNTT và miền, ví dụ: nếu bạn đang thực hiện hội thảo giải quyết đồng đều cho một số sản phẩm ngân hàng, thì bạn phải có quyền  các chuyên gia về lĩnh vực trong phòng, những người có thể trả lời các câu hỏi trong lĩnh vực hoặc lĩnh vực chuyên môn tương ứng của họ.

19
00:03:59,130 --> 00:04:08,250
Có một người hướng dẫn tận tâm làm việc với những người tham gia.  Người hướng dẫn tận tâm này phải có một số kinh nghiệm trước đó về việc gây bão.

20
00:04:08,400 --> 00:04:25,770
Số lượng người tham gia hội thảo được quyết định bởi phạm vi.  Nếu bạn đang tổ chức một buổi hội thảo có tính chất sôi động để hiểu rõ quy trình kinh doanh thì bạn nên dự kiến ​​có từ bốn đến tám người tham gia hội thảo.

21
00:04:26,160 --> 00:04:33,170
Thời lượng của hội thảo phụ thuộc vào phạm vi lĩnh vực và kinh nghiệm của những người tham gia.

22
00:04:33,180 --> 00:04:51,090
Nó có thể thay đổi từ vài giờ đến vài ngày khi gặp trực tiếp.  Hội thảo được ưa chuộng hơn hội thảo trực tuyến và lý do là ngay cả việc gây bão cũng bao gồm rất nhiều tương tác và việc thực hiện những tương tác này sẽ dễ dàng hơn khi những người tham gia ở cùng phòng với.

23
00:04:51,230 --> 00:04:58,470
Nhưng gần đây các buổi hội thảo trực tuyến cũng đã trở nên phổ biến và ngày càng được chấp nhận.

24
00:04:58,500 --> 00:05:10,160
Tin tốt là có.  Các công cụ rất tốt hiện có để thực hiện các hội thảo trực tuyến này.  Tiếp theo, tôi sẽ xem bạn cần những gì cho hội thảo trực tiếp cũng như hội thảo trực tuyến.

25
00:05:10,520 --> 00:05:32,060
Hội thảo trực tiếp được tiến hành trong một căn phòng rộng rãi với nhiều khu vực đi bộ.  Căn phòng này phải có đủ không gian trống trên tường để treo lô giấy để người tham gia có không gian mô hình không giới hạn mà họ không phải ngừng ném ý tưởng của mình lên lô giấy do hết chỗ.

26
00:05:32,060 --> 00:05:40,520
Để làm được điều này, người tham gia sẽ sử dụng rất nhiều loại giấy dính có màu sắc khác nhau vào cuối buổi hội thảo.  Các bức tường sẽ trông giống như thế này.

27
00:05:40,760 --> 00:05:49,460
Bạn sẽ có rất nhiều giấy treo trên tường và sẽ có rất nhiều giấy dính trên đó.  Các miếng dán được đặt trên một phần giấy, có mã màu.

28
00:05:49,460 --> 00:06:03,490
Bạn tìm hiểu về ý nghĩa của những màu sắc này.  Trong bài giảng tiếp theo của hội thảo trực tuyến, những người tham gia đã tham gia qua cuộc gọi điện video và họ sử dụng nền tảng cộng tác để thực hiện các hoạt động thậm chí còn gây bão.

29
00:06:03,500 --> 00:06:12,540
Tất cả những người tham gia có thể thực hiện các thay đổi đối với một bảng ảo chung và những thay đổi này được hiển thị cho những người tham gia khác trong thời gian thực.

30
00:06:12,590 --> 00:06:20,270
Có nhiều nền tảng cộng tác cho phép người tham gia thực hiện chính xác điều đó.  Đây là hai trong số những nền tảng đó.

31
00:06:20,300 --> 00:06:32,690
Tôi khuyên bạn nên thực hiện nghiên cứu của riêng mình trên các nền tảng cộng tác này.  Trong một trong những bài giảng sau, tôi sẽ sử dụng Mirro để thực hiện hội thảo cho Achmad Travels.

32
00:06:32,960 --> 00:06:41,050
Kết quả mong đợi của hội thảo là tạo ra sự hiểu biết chung về quy trình kinh doanh năm nay.

33
00:06:41,060 --> 00:06:48,550
Sự hiểu biết sau đó được sử dụng để mô hình hóa miền.  Mục tiêu không phải là thiết kế hệ thống.

34
00:06:48,560 --> 00:06:56,320
Mục tiêu là không thể trả lời tất cả các câu hỏi.  Và nó không phải để tạo ra các mô hình thiết kế theo miền.

35
00:06:57,080 --> 00:07:05,870
Đã đến lúc kết thúc bài học này.  Ngay cả việc gây bão cũng là một quá trình hợp tác để tạo ra sự hiểu biết chung về miền hoặc quy trình kinh doanh.

36
00:07:06,140 --> 00:07:15,020
Ngay cả việc gây bão cũng được thực hiện dưới hình thức hội thảo được hỗ trợ và có thể được tiến hành trực tiếp hoặc trực tuyến.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000003.srt -->

1
00:00:00,180 --> 00:00:10,030
Các nguyên tắc cơ bản của thậm chí gây bão trong bài giảng này, tôi sẽ thảo luận về các yếu tố khác nhau mà tôi sử dụng để mô tả kiến ​​thức trong hội thảo về sự kiện gây bão.

2
00:00:10,050 --> 00:00:21,900
Tôi sẽ bắt đầu bài học này bằng cách thảo luận về nguyên nhân và kết quả.  Sau đó, tôi sẽ thảo luận về các yếu tố khác nhau của bão đồng đều, và tôi sẽ kết thúc bài giảng này bằng phần thảo luận về mối quan hệ giữa các yếu tố.

3
00:00:22,800 --> 00:00:31,890
Lưu ý nhanh, bài học này sẽ cung cấp phần giới thiệu ở cấp độ cao về bão thậm chí, nếu bạn muốn trở thành người điều phối hoặc chuyên gia về bão thậm chí.

4
00:00:31,920 --> 00:00:38,670
Đề nghị của tôi là bạn nên tự nghiên cứu, cân nhắc việc đào tạo và cân nhắc việc đọc cuốn sách của Alberto.

5
00:00:39,210 --> 00:00:48,230
Sự kiện kinh doanh là điều tự nhiên trong mọi lĩnh vực.  Họ là điểm khởi đầu của cuộc trò chuyện trong một hội thảo đang gây bão.

6
00:00:48,250 --> 00:00:56,460
Điểm quan trọng cần lưu ý là tất cả các sự kiện kinh doanh đều được gọi là sự kiện miền trong bối cảnh các sự kiện.

7
00:00:56,460 --> 00:01:15,240
Mục tiêu của hội thảo gây bão sự kiện là tìm hiểu nguyên nhân.  Điều đó có nghĩa là những người tham gia thảo luận về các sự kiện trong miền để hiểu nguyên nhân của những sự kiện đó và sau đó họ cũng thảo luận về tác động của những sự kiện đó.

8
00:01:15,420 --> 00:01:32,400
Nhân quả này được mô tả như là sự hiểu biết về lĩnh vực bằng cách sử dụng sáu yếu tố cơ bản.  Có sáu khối hoặc thành phần xây dựng được sử dụng để mô tả kiến ​​thức hoặc dòng chảy trong một hội thảo đang có sóng gió.

9
00:01:32,400 --> 00:01:49,320
Các miếng dính có mã màu được sử dụng để thể hiện từng yếu tố trong số sáu yếu tố này.  Hiện đã có tiêu chuẩn đề xuất cho màu sắc của các chất dính hoặc các thành phần này, nhưng bạn không cần phải tuân theo tiêu chuẩn đó miễn là bạn nhất quán trong suốt buổi hội thảo của mình.

10
00:01:49,350 --> 00:01:55,180
Nói cách khác, nếu bạn không có sẵn những màu cụ thể này cho xưởng của mình thì điều đó không thực sự quan trọng.

11
00:01:55,380 --> 00:02:10,690
Bạn có thể quyết định một tiêu chuẩn và chỉ cần làm theo nó trong suốt buổi hội thảo.  Tác nhân miền gây ra thay đổi giai đoạn trong miền và thay đổi giai đoạn được bắt đầu bằng lệnh và bước đi của tác nhân.

12
00:02:10,830 --> 00:02:20,670
Lệnh này được thể hiện bằng một miếng dán màu xanh trên vùng làm việc.  Lệnh này dẫn đến việc nâng cao các sự kiện miền.

13
00:02:20,670 --> 00:02:32,520
Miền thậm chí là sự thể hiện của một số thực tế đã xảy ra hoặc miền thậm chí được thể hiện trong không gian làm việc bằng miếng dán màu cam.

14
00:02:32,760 --> 00:02:42,420
Khi sự kiện miền được nêu lên, nó có thể dẫn đến phản ứng.  Và phản ứng này được thực hiện thông qua một thành phần được gọi là chính sách.

15
00:02:42,450 --> 00:02:54,270
Và chính sách này được thể hiện bằng một tấm vé màu tím.  Vì các sự kiện miền thể hiện điều gì đó đã xảy ra trong quá khứ nên chúng phải luôn được đặt tên ở thì quá khứ.

16
00:02:54,570 --> 00:03:02,830
Dưới đây là ví dụ về một số sự kiện đã được đặt tên ở thì quá khứ.  Khoản vay được phê duyệt, tài khoản bị hủy, tiền rút.

17
00:03:02,970 --> 00:03:12,470
Đây là những cái tên hay.  Dưới đây là một số ví dụ về tên xấu được sử dụng cho các sự kiện.  Phê duyệt khoản vay, hủy tài khoản, rút ​​tiền.

18
00:03:12,870 --> 00:03:20,910
Đây không phải là ở thì quá khứ.  Kết quả là, chúng không phải là những cái tên hay dành cho Even's.  Hãy lấy một ví dụ về mua sắm trực tuyến.

19
00:03:21,210 --> 00:03:30,240
Nguyên nhân là một hành động tạo ra một sự kiện.  Và trong trường hợp mua sắm trực tuyến, tác nhân tên miền là khách hàng.

20
00:03:30,600 --> 00:03:44,430
Và hành động mà tác nhân miền thực hiện là thanh toán cho các mặt hàng trong giỏ hàng.  Khi thanh toán thành công sẽ dẫn đến việc tạo ra một sự kiện và sự kiện đó có thể được nhận thanh toán.

21
00:03:44,640 --> 00:03:59,880
Và sau đó có một hiệu ứng, đó là phản ứng đối với sự kiện.  Có thể có một chính sách như vận chuyển, người nào nhận được khoản thanh toán đã nhận, thậm chí dẫn đến việc vận chuyển hàng hóa.

22
00:04:00,120 --> 00:04:08,580
Và hành động này được thực hiện lại bằng cách ra lệnh, hành động này trước khi dẫn đến các sự kiện bổ sung.

23
00:04:09,650 --> 00:04:25,490
Điều quan trọng là phải hiểu rằng một lệnh là trừu tượng, nghĩa là nó không đại diện cho một thành phần hoạt động trong miền, nó chỉ đơn giản thể hiện mục đích của một hành động phải được thực hiện bởi miền.

24
00:04:26,150 --> 00:04:36,900
Ví dụ: khách hàng của ngân hàng có thể bày tỏ ý định gửi tiền vào tài khoản hoặc họ có thể yêu cầu ngân hàng đóng tài khoản.

25
00:04:36,980 --> 00:04:44,210
Vì vậy, đây chỉ đơn giản là ý định của khách hàng ngân hàng.  Chúng không phải là quá trình xử lý thực sự của bất kỳ logic nghiệp vụ nào.

26
00:04:44,210 --> 00:04:51,350
Việc thực thi logic nghiệp vụ được thực hiện trong các quy trình lệnh trong bối cảnh có bão.

27
00:04:51,500 --> 00:05:08,270
Phần tử thực hiện việc xử lý lệnh được gọi là phần tử tổng hợp.  Vì vậy, nếu bạn nhìn lại hình minh họa mà tôi đã chia sẻ với bạn trước đó, lệnh này không trực tiếp nâng cao miền, thậm chí nó là tổng hợp đang xử lý lệnh.

28
00:05:08,270 --> 00:05:15,020
Và quá trình xử lý đó dẫn đến việc nâng cao các sự kiện tổng hợp được thể hiện bằng một miếng dính màu vàng.

29
00:05:15,930 --> 00:05:32,380
Ngoài lệnh và hệ thống hoặc dịch vụ bên ngoài cũng có thể là nguồn khiến người ta thậm chí coi dịch vụ bên ngoài như một thứ gì đó nằm ngoài miền đang được xem xét, các dịch vụ bên ngoài đó được thể hiện bằng một miếng dính màu hồng.

30
00:05:32,910 --> 00:05:44,190
Hãy để tôi xem qua một ví dụ để giải thích các dịch vụ bên ngoài.  Hãy nghĩ đến một khách hàng ngân hàng đang thanh toán bằng thẻ ghi nợ của chúng tôi cho người bán khi xử lý thanh toán thành công.

31
00:05:44,310 --> 00:05:55,600
Hệ thống thanh toán người bán bên ngoài này sẽ phát sinh một sự kiện trong ngân hàng và sự kiện này sau đó sẽ kích hoạt chính sách giảm số dư tài khoản.

32
00:05:55,620 --> 00:06:11,040
Vì vậy, như bạn có thể thấy ở đây, hệ thống hoặc dịch vụ thanh toán của người bán nằm ngoài tầm kiểm soát của ngân hàng hoặc miền và sự kiện của ngân hàng có liên quan trực tiếp hoặc gián tiếp đến sự thay đổi trạng thái trong một miền.

33
00:06:11,430 --> 00:06:20,060
Thay đổi trạng thái thể hiện một số loại thay đổi về dữ liệu trong miền đó.  Dữ liệu này có thể được các bên liên quan quan tâm.

34
00:06:20,460 --> 00:06:28,000
Vì vậy, cách nó hoạt động trong cơn bão thậm chí còn có một số dữ liệu được biểu thị bằng mô hình màu đỏ.

35
00:06:28,140 --> 00:06:38,240
Mô hình này là phản hồi cho các truy vấn về dữ liệu miền.  Mô hình này được sử dụng bởi giao diện người dùng mà các bên liên quan có thể sử dụng.

36
00:06:38,280 --> 00:06:50,660
Bây giờ, giao diện người dùng này có thể là một email.  Nó không nhất thiết phải là một tấm kính hiển thị dữ liệu.  Nó có thể là một bảng điều khiển dành cho người thực thi hoặc nó chắc chắn có thể là một ứng dụng khá rõ ràng.

37
00:06:50,670 --> 00:07:00,090
Trong buổi hội thảo thậm chí còn gây bão.  Mô hình đọc này được thể hiện bằng một miếng dính màu xanh lá cây.  Nó còn được gọi là mô hình dữ liệu sự kiện hoặc mô hình truy vấn.

38
00:07:00,480 --> 00:07:10,750
Điểm quan trọng cần ghi nhớ là thậm chí còn có một số dữ liệu có giá trị đối với các bên liên quan và mô hình Reed này đại diện cho dữ liệu đó.

39
00:07:10,980 --> 00:07:20,790
Hãy xem lại ví dụ của chúng tôi về thẻ ghi nợ giấy.  Trong trường hợp này, khi số tiền từ sự kiện tài khoản tăng lên, người dùng có thể cần được thông báo.

40
00:07:21,030 --> 00:07:30,480
Mô hình Reed sẽ chứa thông tin giao dịch sẽ được gửi đến người dùng hoặc khách hàng bằng cách thông báo.

41
00:07:30,540 --> 00:07:38,250
Thông tin giao dịch này có thể có thông tin chi tiết về người bán, số tiền thanh toán và thậm chí cả số dư tài khoản.

42
00:07:38,580 --> 00:07:46,620
Hãy gọi mối quan hệ giữa các yếu tố khác nhau thậm chí còn làm mưa làm gió trung tâm của ý tưởng là miền.

43
00:07:46,620 --> 00:07:58,960
Thậm chí miền này thậm chí còn được gây ra bởi một lệnh được xử lý bởi miền tổng hợp.  Thậm chí cũng có thể do một lệnh đang được xử lý bởi một dịch vụ bên ngoài.

44
00:07:59,220 --> 00:08:13,260
Tác động của sự kiện miền được hiện thực hóa bằng chính sách do miền kích hoạt.  Thậm chí, chính sách này còn có thể gọi thêm các lệnh có thể dẫn đến các sự kiện miền khác.

45
00:08:13,500 --> 00:08:20,960
Tên miền thậm chí còn có một số dữ liệu có giá trị đối với các bên liên quan.  Dữ liệu có giá trị này được thể hiện bằng cách reboard.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:11,850
Chuẩn bị cho hội thảo trong bài học này, tôi nói về người điều hành hội thảo và thảo luận về các nhiệm vụ cần thực hiện trước các hoạt động thu thập kiến ​​thức.

2
00:00:12,480 --> 00:00:24,480
Hãy bắt đầu bằng một câu hỏi.  Ai tạo điều kiện cho hội thảo thậm chí còn gây bão?  Thông thường các tổ chức lớn thuê các chuyên gia tư vấn bên ngoài để thực hiện việc hỗ trợ.

3
00:00:24,720 --> 00:00:39,700
Theo quan điểm và kinh nghiệm của tôi, bạn thực sự không cần đến chuyên gia tư vấn bên ngoài.  Các thành viên hiện tại của nhóm, chẳng hạn như người quản lý dự án và chuyên gia scrum có thể dễ dàng được đào tạo để trở thành những người điều phối hội thảo nổi bật.

4
00:00:39,750 --> 00:00:53,580
Tôi đã thấy nhiều chuyên gia đảm nhận vai trò này trong tổ chức của họ.  Điểm mấu chốt là, bất kỳ ai cũng có thể học cách trở thành người điều phối bằng cách quan sát những người điều phối có kinh nghiệm và thực hành.

5
00:00:54,150 --> 00:01:00,610
Ở đây chúng ta hãy giả định rằng người điều phối đã được xác định và những người tham gia đã được mời.

6
00:01:00,750 --> 00:01:13,470
Vậy điều phối viên phải làm gì tiếp theo?  Họ phải chuẩn bị phòng cho buổi hội thảo trực tiếp hoặc nếu đó là buổi hội thảo từ xa thì họ cần đảm bảo rằng tất cả các công cụ đã sẵn sàng hoạt động.

7
00:01:13,650 --> 00:01:37,240
Điều thứ hai họ cần làm là vào ngày diễn ra hội thảo, hướng dẫn những người tham gia về hội thảo thậm chí còn gây bão, xác định phạm vi của hội thảo, đảm bảo tất cả những người tham gia đều có cùng quan điểm về quy trình kinh doanh hoặc các quy trình.  trong phạm vi hội thảo và sau đó cấp độ đặt ra kỳ vọng bằng cách thảo luận về kết quả mong đợi.

8
00:01:37,260 --> 00:01:45,660
Sau khi người điều phối đã hoàn thành những nhiệm vụ này, đã đến lúc người điều phối bắt tay vào thực hiện. Hãy cùng tìm hiểu chi tiết về từng nhiệm vụ này.

9
00:01:46,410 --> 00:01:53,430
Để chuẩn bị cho buổi hội thảo trực tiếp, bạn cần đảm bảo rằng căn phòng bạn đang sử dụng rộng rãi.

10
00:01:53,730 --> 00:02:09,260
Nếu có bàn ghế trong phòng, hãy di chuyển chúng sang một bên.  Và lý do của việc này là để tạo không gian cho người tham gia di chuyển xung quanh, treo ô giấy lên tường bằng băng dính, sau đó vẽ một đường thời gian từ trái sang phải.

11
00:02:09,870 --> 00:02:15,760
Số lượng tờ giấy bạn sẽ treo trên tường sẽ phụ thuộc vào phạm vi của bài tập.

12
00:02:15,840 --> 00:02:32,190
Giờ đây, bạn không cần phải treo lô giấy khắp phòng mà bạn có thể thực hiện tùy ý.  Ý tưởng là chuẩn bị sẵn sàng cho một hội thảo từ xa, đảm bảo rằng tất cả các công cụ đã sẵn sàng hoạt động ít nhất hai ngày trước hội thảo.

13
00:02:32,220 --> 00:02:38,820
Nói cách khác, bạn phải thiết lập hội nghị truyền hình.  Bạn phải có công cụ để thiết lập cộng tác.

14
00:02:39,000 --> 00:02:50,360
Tạo một bảng và đảm bảo rằng tất cả những người tham gia đều có thể kết nối với hội nghị video và họ cũng có thể kết nối với công cụ cộng tác.

15
00:02:50,610 --> 00:03:02,630
Và lý do cho điều này là trong nhiều hội thảo, tôi đã thấy một, một tiếng rưỡi đầu tiên được dành để giải quyết những thách thức kỹ thuật mà những người tham gia gặp phải, và nó có thể là một sự cản trở lớn.

16
00:03:02,730 --> 00:03:13,830
Bạn không muốn điều đó xảy ra.  Vì vậy, hãy đảm bảo rằng nếu bạn tiến hành hội thảo từ xa, bạn phải chuẩn bị sẵn sàng mọi thứ vào ngày đầu tiên trước khi hội thảo bắt đầu.

17
00:03:15,010 --> 00:03:25,380
Khi bắt đầu hội thảo về bão chẵn, bạn nên cung cấp một cái nhìn tổng quan nhanh về bão chẵn là gì.

18
00:03:25,720 --> 00:03:38,430
Bây giờ, bạn có thể có một nhóm người tham gia đã từng trải qua cơn bão, nhưng sẽ không có hại gì khi dành một vài phút để nhắc nhở mọi người về những gì liên quan đến hội thảo.

19
00:03:38,440 --> 00:03:50,560
Và như một phần của chương trình đào tạo này, vui lòng không sử dụng bất kỳ thuật ngữ kỹ thuật nào.  Cụ thể, đừng nói về thiết kế hướng miền và tất cả những điều tốt đẹp mà các nhà công nghệ chúng tôi muốn nói đến.

20
00:03:50,560 --> 00:04:10,040
Giữ nó tập trung vào kinh doanh.  Hãy nhớ rằng, những người tham gia của bạn không nhất thiết phải là nhà công nghệ.  Thảo luận về mục đích của giấy dán màu và không gian làm việc, nhưng bạn không cần phải dành quá nhiều thời gian cho những khía cạnh này vì người tham gia sẽ tìm hiểu vì bạn sẽ tiếp tục tham gia hội thảo.

21
00:04:10,180 --> 00:04:24,310
Một điều thực sự hữu ích là đặt tất cả các miếng dán màu và những gì chúng đại diện ở đâu đó trong không gian làm việc để bất kỳ ai có thắc mắc về việc sử dụng màu nào đều có thể nhìn thấy, đây là một câu hỏi cực kỳ phổ biến.

22
00:04:24,310 --> 00:04:42,010
Mở đầu hội thảo, sau khi khái quát chung về bão tố, đã đến lúc người điều hành xác định phạm vi của hội thảo, phạm vi của hội thảo, có thể là một bức tranh lớn từ góc độ miền, hoặc có thể là một bức tranh đơn lẻ.  quá trình kinh doanh, bất kể phạm vi là gì.

23
00:04:42,140 --> 00:04:49,960
Điều quan trọng là tất cả những người tham gia trong phòng phải có cùng quan điểm và đảm bảo rằng mọi người đều đi đúng hướng.

24
00:04:50,260 --> 00:05:03,250
Mục tiêu cấp cao của hội thảo là trong không gian làm việc để nó luôn được nhìn thấy.  Ví dụ, ở đây tôi đề xuất mục tiêu là hiểu rõ quy trình phê duyệt khoản vay.

25
00:05:03,280 --> 00:05:19,010
Một điều quan trọng khác là khi bạn bắt đầu tham gia hội thảo, rất có thể sẽ có các cuộc thảo luận xung quanh các khía cạnh ngoài trường học nhìn từ góc độ hội thảo, nhưng chúng có thể có giá trị từ góc độ lĩnh vực.

26
00:05:19,210 --> 00:05:28,840
Do đó, bạn không muốn bỏ lỡ những khía cạnh đó, vì vậy hãy tạo một không gian dành riêng để liệt kê tất cả các yếu tố của ống soi tai này.

27
00:05:29,200 --> 00:06:14,250
Bạn có thể theo dõi các mục này sau buổi hội thảo.  Một điều cuối cùng mà người hướng dẫn nên làm trước khi bắt đầu hội thảo là đặt ra những kỳ vọng và điều này được thực hiện tốt nhất theo kinh nghiệm của tôi, bằng cách chia sẻ kinh nghiệm thực tế từ các hội thảo trước đây và nếu có thể, chia sẻ hình ảnh từ những hội thảo đó, những kỳ vọng này nên được  thực tế và cung cấp cho những người tham gia và hỏi họ suy nghĩ của họ về hội thảo đang gây bão, cũng như những gì họ mong đợi các ý tưởng sẽ khiến mọi người hào hứng để họ trở thành những người tham gia tích cực trong hội thảo và tất cả họ đều mong muốn được học và giảng dạy  .

28
00:06:14,250 --> 00:06:22,380
Đã sử dụng phần này của hội thảo cho một số hoạt động phá băng.  Tại thời điểm này, người hướng dẫn đã sẵn sàng bắt tay vào thực hiện.

29
00:06:22,500 --> 00:06:35,430
Một trong những vai trò quan trọng của người điều phối là đảm bảo rằng mọi người đều vui vẻ và tràn đầy năng lượng vì năng lượng thấp sẽ dẫn đến kết quả có chất lượng kém.

30
00:06:35,670 --> 00:06:45,930
Người tham gia phải cảm thấy gắn bó.  Người tham gia phải tích cực trong suốt hội thảo.  Vì vậy, người điều phối phải ghi nhớ những khía cạnh đó.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000005.srt -->

1
00:00:00,120 --> 00:00:10,170
Tiến hành hội thảo về bão hòa trong bài học này, tôi sẽ trình bày các bước chung được thực hiện trong hội thảo về bão hòa để tạo ra mô hình kiến ​​thức.

2
00:00:10,380 --> 00:00:18,730
Là một phần của bài học này, tôi cũng sẽ chia sẻ một số lời khuyên hữu ích để người điều phối thảo luận về quy trình thậm chí có bão.

3
00:00:18,750 --> 00:00:37,500
Tôi đã chọn một trường hợp sử dụng ví dụ.  Đây sẽ là quy trình phê duyệt khoản vay của ngân hàng.  Giả sử Người hướng dẫn đã mời nhóm CNTT cũng như các chuyên gia kinh doanh có thể trả lời các câu hỏi liên quan đến các sản phẩm cho vay do ngân hàng cung cấp.

4
00:00:37,860 --> 00:00:46,050
Người hướng dẫn phải nhớ rằng ngay cả việc gây bão cũng không yêu cầu người tham gia sử dụng tất cả các yếu tố.

5
00:00:46,050 --> 00:01:00,270
Người tham gia chỉ có thể chọn các yếu tố có liên quan để tạo mô hình kiến ​​thức.  Công việc của người điều phối là giúp người tham gia thu thập các yếu tố liên quan để thiết kế mô hình kiến ​​thức.

6
00:01:00,660 --> 00:01:10,060
Trước khi thảo luận về các bước chung liên quan đến hội thảo, tôi muốn chỉ ra rằng có rất nhiều sự linh hoạt trong cách họ tiến hành hội thảo.

7
00:01:10,060 --> 00:01:29,280
Người điều phối có thể điều chỉnh các bước, sàn nhà, tốc độ nếu cần.  Những điều chỉnh này phụ thuộc vào nhiều yếu tố, chẳng hạn như người điều phối và người tham gia, kinh nghiệm trong quá khứ, độ phức tạp của lĩnh vực, mức độ chi tiết của mô hình kiến ​​thức, liệu nó sẽ ở cấp độ cao hay chi tiết.

8
00:01:29,280 --> 00:01:41,540
Và có thể có những yếu tố khác nữa.  Hãy đi đến các bước chung.  Bước đầu tiên khi tham gia hội thảo yêu cầu người tham gia xác định hai sự kiện chính.

9
00:01:41,580 --> 00:01:49,440
Khi các sự kiện trong miền đã được xác định là bước tiếp theo, những người tham gia sẽ thảo luận về thứ tự của các sự kiện theo dòng thời gian.

10
00:01:49,440 --> 00:01:59,760
Trong bước này, các sự kiện trùng lặp cũng được tiết lộ và loại bỏ.  Ở bước thứ ba, những người tham gia được yêu cầu xác định nguyên nhân và kết quả của các sự kiện.

11
00:01:59,850 --> 00:02:10,710
Vì vậy, ở đây, các lệnh, chính sách và dịch vụ bên ngoài sẽ được thêm vào mô hình tri thức.  Và ở bước thứ tư, các lệnh được liên kết với các tập hợp.

12
00:02:10,710 --> 00:02:26,310
Vì vậy, hãy đi sâu vào bước đầu tiên như bước đầu tiên trong bài tập thu thập kiến ​​thức.  Người điều phối yêu cầu những người tham gia động não và treo càng nhiều sự kiện càng tốt trong không gian làm việc.

13
00:02:26,460 --> 00:02:36,120
Ban đầu, những người tham gia có thể do dự.  Đó là điều phổ biến.  Vì vậy, người điều phối nên là người đầu tiên đưa ra mức chẵn.

14
00:02:36,660 --> 00:02:53,130
Vì vậy, đây là đơn xin vay sự kiện đầu tiên nhận được.  Tại thời điểm này, tất cả những người tham gia nên được khuyến khích treo các sự kiện sau khi tất cả những người tham gia đã đặt các sự kiện mà họ có thể nghĩ ra khi thực hiện bài tập này, hãy chuyển sang bước tiếp theo.

15
00:02:53,280 --> 00:03:03,960
Ở bước này, những người tham gia thảo luận về thời điểm mỗi sự kiện xảy ra và sắp xếp các sự kiện theo dòng thời gian từ trái sang phải.

16
00:03:04,170 --> 00:03:20,400
Một bước quan trọng đối với người điều phối là người điều phối phải luôn nhớ rằng vai trò của họ là điều phối và họ cần để người tham gia thực hiện mô hình hóa sau khi người tham gia đã yêu cầu các sự kiện tìm kiếm sự trùng lặp.

17
00:03:20,520 --> 00:03:30,600
Ví dụ: trong tập hợp sự kiện này, khoản tiền gửi và khoản tiền gửi của khách hàng có vẻ trùng lặp.

18
00:03:30,600 --> 00:03:45,600
Vì vậy, hãy tuân thủ những người tham gia và loại bỏ sự kiện trùng lặp.  Và bước thứ ba, những người tham gia cần suy nghĩ về mệnh lệnh, chính sách và các tác nhân để xác định nguyên nhân và kết quả của các sự kiện.

19
00:03:46,380 --> 00:03:58,950
Những khái niệm này hơi phức tạp so với các sự kiện trong miền.  Vì vậy, tại thời điểm này, người điều phối được khuyến khích đặt câu hỏi để giúp người tham gia đạt được tiến bộ nhất định.

20
00:03:59,190 --> 00:04:11,850
Vì chúng ta không có đủ bất động sản trên màn hình nên tôi sẽ chỉ tập trung vào ba sự kiện này để người điều phối có thể đặt câu hỏi Ai chịu trách nhiệm phê duyệt hoặc từ chối khoản vay?

21
00:04:12,000 --> 00:04:20,730
Tại thời điểm đó?  Anh ta có thể nhận được câu trả lời.  Ồ vâng, đó là nhân viên cho vay.  Khi đó, người hướng dẫn có thể đề nghị suy nghĩ về các mệnh lệnh.

22
00:04:20,730 --> 00:04:27,030
Vì vậy, giả sử những người tham gia đưa ra lệnh từ chối ứng dụng và lệnh ứng dụng đã được phê duyệt.

23
00:04:27,030 --> 00:04:37,170
Câu hỏi tiếp theo mà người hướng dẫn có thể hỏi là khi nào thì tài khoản cho vay được thiết lập?  Có, điều đó sẽ được thiết lập sau khi khoản vay được phê duyệt.

24
00:04:37,350 --> 00:04:44,850
Vì vậy, điều đó có nghĩa là việc phê duyệt khoản vay sẽ kích hoạt việc thiết lập một tài khoản dường như là một chính sách.

25
00:04:44,970 --> 00:04:59,650
Vì vậy, ở bước thứ ba, người hướng dẫn đã giữ người tham gia lại, xác định một số mệnh lệnh và chính sách ở bước đánh số cho người hướng dẫn, yêu cầu người tham gia suy nghĩ về điều đó.

26
00:05:00,030 --> 00:05:10,350
Logic này chịu trách nhiệm tạo ra hai sự kiện chính cùng một lúc, điều quan trọng là người điều phối phải theo dõi thời gian.

27
00:05:10,710 --> 00:05:19,620
Cứ sau 30 phút, người hướng dẫn nên xem lại tiến độ và điều chỉnh tốc độ cũng như hướng đi nếu cần.

28
00:05:19,800 --> 00:05:30,420
Vì vậy, quay trở lại bước trước, người hướng dẫn có thể yêu cầu người tham gia tập trung vào việc đơn xin vay bị từ chối và đơn xin vay được phê duyệt.

29
00:05:30,840 --> 00:05:40,920
Và anh ta có thể phát hiện ra rằng có nhiều quy tắc kinh doanh được áp dụng để đưa ra quyết định phê duyệt hay từ chối đơn xin vay tiền.

30
00:05:40,950 --> 00:05:48,510
Vì vậy, bây giờ ở tầng này, chúng ta biết các lệnh và logic nghiệp vụ liên quan đến hai sự kiện.

31
00:05:48,690 --> 00:06:12,650
Trọng tâm có thể chuyển sang sự kiện tiếp theo mà chúng tôi không có người hỗ trợ thông tin logic miền có thể yêu cầu người tham gia tập trung vào tài khoản cho vay được thiết lập và sau một số cuộc thảo luận, những người tham gia có thể quyết định đặt một tài khoản cho vay tổng hợp, đại diện cho doanh nghiệp  logic dẫn đến việc tạo lập các tài khoản vay vốn chẵn.

32
00:06:13,230 --> 00:06:26,070
Hãy cùng thảo luận về các hoạt động sau hội thảo do người hướng dẫn thực hiện.  Người hướng dẫn chụp ảnh không gian làm việc trước khi gỡ toàn bộ phần giấy ra khỏi tường.

33
00:06:26,490 --> 00:06:33,570
Người hướng dẫn sẽ dễ dàng xem các bức tranh hơn là trải ra những tờ giấy dài này.

34
00:06:33,720 --> 00:06:39,480
Vào cuối hội thảo, người hướng dẫn đã yêu cầu những người tham gia đưa ra phản hồi.  Điều gì đã diễn ra tốt đẹp?

35
00:06:39,810 --> 00:06:48,090
Những gì cần phải được thay đổi?  Kỳ vọng là người điều phối sẽ đưa phản hồi này vào hội thảo tiếp theo của họ.

36
00:06:48,360 --> 00:07:09,030
Trong vòng hai đến ba ngày.  Người điều phối củng cố Kiến thức và chia sẻ mô hình kiến ​​thức với tất cả những người tham gia Người điều phối yêu cầu người tham gia xem lại mô hình kiến ​​thức để đảm bảo tính chính xác của nó Người điều phối quyết định các bước tiếp theo và đảm bảo rằng tất cả các hạng mục trong bãi đậu xe đều được giải quyết.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\09EventStormingforcreatingsharedknowledge_VVN\000000006.srt -->

1
00:00:00,150 --> 00:00:09,390
Hội thảo bán hàng Acme, thậm chí gây bão trong bài học này, tôi sẽ chứng minh cho bạn cách tạo điều kiện thuận lợi cho một hội thảo từ xa, thậm chí gây bão.

2
00:00:09,750 --> 00:00:17,770
Và kết thúc bài giảng này chúng ta sẽ có mô hình kiến ​​thức về quy trình bán hàng cho khách hàng Acme cho buổi demo workshop này.

3
00:00:17,790 --> 00:00:29,490
Giả sử Acme đã xác định được người hỗ trợ và người hỗ trợ này đã mời nhóm công nghệ và nhóm kinh doanh.

4
00:00:29,490 --> 00:00:38,100
Nhóm kinh doanh bao gồm John, cố vấn du lịch và Brianna, giám đốc bán hàng.

5
00:00:38,490 --> 00:00:46,350
Người điều phối đã chọn Zouma làm công cụ được lựa chọn cho hội nghị truyền hình và Mirro làm công cụ cộng tác.

6
00:00:47,710 --> 00:01:06,370
Để chuẩn bị cho hội thảo, người điều phối đã tạo bảng chia sẻ trên công cụ cộng tác và đặt tất cả các thông tin hữu ích lên bảng, sau đó người điều phối đã gửi lời mời đến tất cả những người tham gia tham gia bảng chia sẻ.

7
00:01:06,670 --> 00:01:14,290
Những người tham gia sẽ nhận được lời mời từ công cụ cộng tác mà họ có thể chấp nhận và sau đó truy cập vào bảng.

8
00:01:14,320 --> 00:01:24,010
Xin lưu ý rằng trọng tâm của bài học này là thể hiện các nhiệm vụ liên quan và thậm chí cả việc gây bão.  Tôi sẽ không đi sâu vào chi tiết về Mirro.

9
00:01:24,190 --> 00:01:35,710
Vì vậy, nếu bạn muốn tìm hiểu cách Mirro hoạt động, tôi khuyên bạn nên ghé thăm Mirador.  Com và đi tới phần hướng dẫn hoặc video YouTube vì bước đầu tiên sẽ thiết lập bảng.

10
00:01:35,720 --> 00:01:44,050
Chúng ta cần đảm bảo rằng các yếu tố mô hình hóa được mô tả rõ ràng ở đâu đó để người tham gia có thể dễ dàng tìm thấy chúng ở lần tiếp theo.

11
00:01:44,320 --> 00:01:53,230
Hãy đặt dòng thời gian bây giờ.  Chúng tôi sẵn sàng mời những người tham gia.  Mỗi công cụ đều có cách quản lý người tham gia trên video riêng.

12
00:01:53,260 --> 00:02:02,290
Để mời những người tham gia, hãy nhấp vào Chia sẻ và sau đó thiết lập những người tham gia của bạn.  Tôi đã mời những người tham gia hội thảo này.

13
00:02:02,500 --> 00:02:17,040
Những người tham gia được mời sẽ nhận được email để tham gia Mirro và có quyền truy cập vào bảng chia sẻ.  Vào ngày diễn ra sự kiện, tất cả những người tham gia sẽ tham gia hội nghị video và bảng giữa.

14
00:02:17,050 --> 00:02:27,550
Và như bạn có thể thấy ở đây, tất cả những người tham gia sẽ có thể nhìn thấy vị trí của con trỏ để tất cả những người tham gia khác xác định các sự kiện.

15
00:02:27,550 --> 00:02:33,460
Những người tham gia sẽ bắt đầu bằng việc động não.  Họ sẽ có một số cuộc thảo luận xung quanh loại sự kiện.

16
00:02:33,910 --> 00:02:43,030
Và sau đó, cách tốt nhất là người điều phối có thể tiếp tục và đăng thông tin đặt chỗ sự kiện đầu tiên đã được xác nhận.

17
00:02:43,240 --> 00:03:10,840
Sau đó, những người tham gia khác sẽ bắt đầu suy nghĩ sâu hơn và đăng Even lên bảng.  Vì vậy, đây là những sự kiện mà những người tham gia của chúng tôi đã xác định được vì John là chuyên gia trong phòng nên những người tham gia có thể quyết định để John điều khiển cuộc thảo luận.

18
00:03:11,280 --> 00:03:23,900
Vì vậy, đây là John đang điều khiển cuộc thảo luận này xoay quanh thứ tự của các sự kiện.  Điều đầu tiên xảy ra là khách hàng cho chúng tôi biết sở thích của họ và chúng tôi đưa ra đề xuất.

19
00:03:24,240 --> 00:03:32,640
Trên thực tế, chúng tôi sẽ tạo nhiều đề xuất và đến một lúc nào đó khách hàng có thể chọn một trong các đề xuất.

20
00:03:32,660 --> 00:03:46,300
Vì vậy, tôi có thể nói, đây là thứ tự các sự kiện xảy ra từ quan điểm sáng tạo và lựa chọn đề xuất tại một thời điểm nào đó, cơ sở khách hàng cho đề xuất đã chọn.

21
00:03:46,320 --> 00:03:55,860
Và vì vậy hãy chuyển việc xác nhận đặt chỗ sau này.  Vì vậy, một khi khách hàng đã nghe, đó là lúc việc đặt phòng được xác nhận.

22
00:03:56,100 --> 00:04:06,600
Và tôi thấy có hai sự kiện đã được xác nhận đặt chỗ ở đây.  Vì vậy, hãy xóa một trong số này.  Vì vậy, John vừa xóa một trong các đặt phòng được xác nhận sau khi việc đặt phòng được xác nhận.

23
00:04:07,020 --> 00:04:17,000
Việc đặt phòng cũng có thể bị hủy bỏ.  Vì vậy, hãy đặt nó sau khi xác nhận đặt phòng.  Rõ ràng, đề xuất này đã được xác nhận.

24
00:04:17,430 --> 00:04:28,020
Câu hỏi đặt ra là đề xuất có được xác nhận giống như đề xuất được chọn không?  Chúng tôi gọi đó là đề xuất được chọn.  Vì vậy, có vẻ như đây cũng là một sự kiện trùng lặp.

25
00:04:28,110 --> 00:04:40,960
Hãy xóa cái này đi.  Vì vậy, tôi muốn nói đây là cách các sự kiện được sắp xếp của chúng tôi trông như thế nào.  Người hướng dẫn có thể đặt câu hỏi cho người tham gia, quyết định các mệnh lệnh dẫn đến các sự kiện này.

26
00:04:40,980 --> 00:04:49,240
Vậy đề xuất được tạo ra như thế nào?  Và phản hồi có thể là khi khách hàng tỏ ra quan tâm đến gói kỳ nghỉ thì một đề xuất sẽ được đưa ra.

27
00:04:49,290 --> 00:04:59,550
Vậy là chúng ta vừa xác định được một diễn viên.  Hãy đặt tác nhân vào hỗn hợp, tạo điều kiện thuận lợi hoặc đảm bảo rằng có đủ không gian cho các miếng dán thay thế.

28
00:04:59,550 --> 00:05:07,110
Hãy đặt tên cho khách hàng đang hoạt động này.  Vì vậy, câu hỏi tiếp theo có thể là đề xuất được tạo ra như thế nào?  Và đây là lệnh đầu tiên.

29
00:05:07,200 --> 00:05:15,330
Đề xuất được tạo bằng lệnh thực hiện đề xuất.  Vì vậy, đó là lệnh đầu tiên của chúng tôi.  Và đề xuất được lựa chọn như thế nào?

30
00:05:15,510 --> 00:05:27,570
Đó có thể là một đề xuất có chọn lọc.  Và thanh toán nhận được như thế nào?  Vâng, sự kiện nhận được thanh toán được tạo khi khách hàng thanh toán.

31
00:05:27,580 --> 00:05:38,550
Vì vậy, chúng tôi có thanh toán thực hiện.  Nhìn có vẻ tốt.  Và việc xác nhận đặt phòng như thế nào?  Việc đặt phòng được xác nhận xảy ra khi thanh toán thành công.

32
00:05:38,590 --> 00:05:46,880
Vì vậy, có vẻ như không có mệnh lệnh trực tiếp nào ở đây nhưng nó là một hiệu ứng.  Và do đó, chúng ta cần sử dụng một chính sách.

33
00:05:46,920 --> 00:06:05,620
Hãy tạo một số không gian ở đây và thêm một chính sách.  Bây giờ, câu hỏi ở đây là điều gì xảy ra trong chính sách này?  Chà, khi thanh toán thành công, việc đặt chỗ sẽ được thực hiện và khi tất cả các lượt đặt chỗ đều thành công, đó là lúc việc đặt phòng được xác nhận sẽ diễn ra.

34
00:06:05,760 --> 00:06:20,350
Được rồi, có vẻ như chính sách đặt phòng dẫn đến xác nhận đặt phòng.  Và điều cuối cùng, việc đặt chỗ bị hủy, xảy ra khi khách hàng đưa ra lệnh hủy đặt chỗ.

35
00:06:20,370 --> 00:06:33,300
Vì vậy, tại thời điểm này, chúng tôi có một số nhận xét và chính sách cho các sự kiện được xác định ở bước đầu tiên.  Vì vậy, câu hỏi bây giờ là khi khách hàng đưa ra đề xuất, điều gì sẽ xảy ra?

36
00:06:33,420 --> 00:06:48,600
Chà, chúng tôi có một số logic kinh doanh dẫn đến việc thiết lập đề xuất.  OK, điều đó có nghĩa là giữa đề xuất và đề xuất được tạo, thậm chí còn có logic nghiệp vụ và những gì chúng ta gọi, chúng ta sẽ gọi nó là đề xuất.

37
00:06:48,810 --> 00:06:59,840
Vì vậy, đây là tổng hợp đầu tiên của chúng tôi.  Và đề xuất của Selecter thì sao?  Đó là logic kinh doanh tương tự được sử dụng cho đề xuất được tạo để chúng tôi có thể di chuyển đề xuất này đến đâu đó giữa hai sự kiện.

38
00:07:00,060 --> 00:07:07,920
Vì vậy, hãy chuyển sang sự kiện tiếp theo.  Quá trình thanh toán được thực hiện như thế nào?  Và đây là nơi chúng ta có thể nghe được ý kiến ​​từ John và những người khác trong nhóm.

39
00:07:07,920 --> 00:07:17,360
Khoản thanh toán nhận được là một sự kiện đến từ nguồn bên ngoài và nguồn bên ngoài này là bộ xử lý thanh toán nằm ngoài Acme.

40
00:07:17,370 --> 00:07:23,030
Vì vậy, điều đó có nghĩa là chúng ta cần giới thiệu một dịch vụ bên ngoài ở đây.  Đây được gọi là Hủy đặt phòng thì sao?

41
00:07:23,250 --> 00:07:38,400
Vâng, có rất nhiều quy tắc để hủy đặt phòng.  Tất cả các quy tắc này đều nằm trong một loại logic kinh doanh nào đó dẫn đến việc đặt chỗ bị hủy, hãy gọi nó là đặt chỗ, logic xác nhận, di chuyển các miếng dán để tạo khoảng trống.

42
00:07:38,580 --> 00:07:49,260
Và bây giờ chúng tôi có một số tổng hợp và một dịch vụ bên ngoài.  Hãy tạo một chút không gian ở đây.  Được rồi, vậy là mọi thứ sẽ rõ ràng hơn một chút trong bước tiếp theo này.

43
00:07:49,440 --> 00:07:59,310
Những người tham gia sẽ xem lại mô hình kiến ​​thức và làm cho nó dễ theo dõi nên họ sẽ đặt các mũi tên để chỉ ra dòng sự kiện.

44
00:07:59,760 --> 00:08:10,050
Vì vậy, ví dụ ở đây, khách hàng sẽ gọi lệnh thực hiện đề xuất, lệnh này sẽ gọi đề xuất tổng hợp, điều này sẽ dẫn đến việc tạo đề xuất được tạo.

45
00:08:10,170 --> 00:08:20,970
Tương tự, khách hàng sẽ gọi đề xuất đã chọn, đề xuất này sẽ được tổng hợp đề xuất xử lý và thậm chí đề xuất đã chọn sẽ được tạo.

46
00:08:20,970 --> 00:08:37,710
Lệnh gọi thực hiện thanh toán và dịch vụ bên ngoài sẽ xử lý khoản thanh toán và dẫn đến việc tạo ra khoản thanh toán sự kiện nhận được, điều này sẽ kích hoạt chính sách thực hiện tất cả các đặt phòng trọn gói kỳ nghỉ và đặt chỗ thành công.

47
00:08:38,280 --> 00:08:55,790
Việc đặt chỗ sẽ được chính sách xác nhận bằng cách kích hoạt lệnh đặt chỗ đã được xác nhận, lệnh này sẽ dẫn đến việc xử lý lệnh và xác nhận đặt chỗ tổng hợp và xác nhận không thành công, thậm chí việc đặt chỗ đã được xác nhận sẽ được tạo.

48
00:08:55,810 --> 00:09:05,070
Khách hàng có thể hủy việc đặt chỗ bằng cách gọi lệnh hủy đặt chỗ, nhưng có một số quy tắc nhất định và các quy tắc này được quản lý trong việc đặt chỗ.

49
00:09:05,070 --> 00:09:15,210
Xác nhận tổng hợp.  Nếu khách hàng được phép hủy đặt chỗ thì việc đặt chỗ sẽ bị hủy và sự kiện hủy đặt chỗ sẽ được hủy bỏ.

50
00:09:15,240 --> 00:09:23,250
Vì vậy, đây là trạng thái cuối cùng của mô hình kiến ​​thức của chúng tôi dành cho quy trình bán hàng Acme.  Không có nghĩa là nó đã hoàn thành.

51
00:09:23,940 --> 00:09:38,880
Mục đích của tôi chỉ là cung cấp cho bạn ý tưởng về cách hoạt động của hội thảo thậm chí còn gây bão.  Cuối cùng, mô hình kiến ​​thức này sẽ được mở rộng để bao gồm việc xử lý nhiều sự kiện ở đây và các chi tiết khác.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\001 Introduction to Microservices Data Persistence.en.srt -->

1

00:00:00,190 --> 00:00:07,050

Databases are an essential part of all applications, micro services are developed independently by



2

00:00:07,050 --> 00:00:07,960

different teams.



3

00:00:07,980 --> 00:00:14,760

Each team can decide on the database technology as well as the structure of their database.



4

00:00:14,790 --> 00:00:21,870

Each team can independently make changes to their own database without impacting the other micro services.



5

00:00:22,260 --> 00:00:29,280

Conversion of a monolithic application to micro services requires the designer to not only think about



6

00:00:29,280 --> 00:00:37,260

the refactoring of the business logic and the components of the monolithic application, they also need



7

00:00:37,260 --> 00:00:40,650

to think about the refactoring of the database.



8

00:00:40,950 --> 00:00:49,050

And refactoring of the database would mean breaking the common database instance to multiple database



9

00:00:49,050 --> 00:00:49,980

instances.



10

00:00:50,460 --> 00:00:57,650

This breaking of common database instead into multiple database instances is not straightforward.



11

00:00:58,110 --> 00:00:59,910

There are multiple challenges.



12

00:01:00,240 --> 00:01:08,100

I will discuss some of these challenges in the section and I'll also discuss solutions in the form of



13

00:01:08,460 --> 00:01:16,110

technical options, as well as certain data patterns that may be used for designing the new micro services



14

00:01:16,110 --> 00:01:21,090

and for converting existing monolithic applications to micro services.



15

00:01:21,660 --> 00:01:28,050

Departments that I'm going to cover in this section are the shared database parathion, Sopra database



16

00:01:28,050 --> 00:01:30,300

parathion and this triangular pattern.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\002 Monolithic Apps - Shared Persistence Storage.en.srt -->

1

00:00:00,180 --> 00:00:06,570

Persistence and shared databases in this lecture, I'll first talk about the shared database pattern



2

00:00:06,570 --> 00:00:13,140

and then discuss the pros and cons of shared databases, applications need to persist.



3

00:00:13,320 --> 00:00:21,090

The data, this persistence of data is achieved by way of writing to the filesystems or more commonly,



4

00:00:21,090 --> 00:00:24,360

by writing the data to databases.



5

00:00:24,570 --> 00:00:31,290

There are multiple types of databases available today, but the most commonly used databases are the



6

00:00:31,290 --> 00:00:34,650

relational databases and no single databases.



7

00:00:34,920 --> 00:00:42,750

Legacy applications typically use RDBMS or relational databases for all types of data, and that is



8

00:00:42,750 --> 00:00:47,970

because no single databases were not available till early 2000s.



9

00:00:48,400 --> 00:00:56,040

A typical client server application development pattern used by these legacy applications involve multiple



10

00:00:56,040 --> 00:01:01,320

enterprise applications sharing a common instance of the database.



11

00:01:01,920 --> 00:01:09,810

All of the domain data was managed centrally in this shared database, and the enterprise application



12

00:01:10,080 --> 00:01:16,380

would manage the data by way of sequel's statements against this shared database.



13

00:01:16,560 --> 00:01:22,320

By today's standard, this architecture will not be acceptable, but there were certain good things



14

00:01:22,320 --> 00:01:22,920

about it.



15

00:01:23,460 --> 00:01:28,260

First thing is that it'll lead to a simplified data management process.



16

00:01:28,290 --> 00:01:36,660

Second is that since the database engine is shared by multiple application, the cost of the solution



17

00:01:36,660 --> 00:01:37,490

will go down.



18

00:01:37,500 --> 00:01:45,660

And the third is that a single team of database administrators can manage the database for all applications.



19

00:01:46,140 --> 00:01:50,260

Now let's go through the challenges with shared database pattern.



20

00:01:51,060 --> 00:01:56,670

The first challenge is that database changes need to be managed very carefully.



21

00:01:57,240 --> 00:02:03,580

Consider the scenario in which application it requires a change in the database schema.



22

00:02:03,720 --> 00:02:10,590

Now the owner of application, it cannot go ahead and make the change as it may have an impact on application



23

00:02:10,590 --> 00:02:12,210

B and application C.



24

00:02:12,240 --> 00:02:19,890

As a result, the owner of application, it will need to collaborate with application B and C to ensure



25

00:02:19,890 --> 00:02:24,270

that change in the schema will not impact application BNC.



26

00:02:24,300 --> 00:02:31,740

And if there is going to be an impact, then all of these applications will need to coordinate the rollout



27

00:02:31,740 --> 00:02:32,490

of the change.



28

00:02:32,700 --> 00:02:36,120

Or all this will lead to high cost of changes.



29

00:02:36,270 --> 00:02:42,780

It will lead to higher risk because making a change to the database may lead to breaking of other applications.



30

00:02:42,780 --> 00:02:47,070

And at the end of the day, this will lead to longer time to value.



31

00:02:48,030 --> 00:02:54,540

Second challenge is that one application may negatively impact all other applications, and this can



32

00:02:54,540 --> 00:03:02,550

happen if the application intentionally or unintentionally starts to use up a lot of resources on the



33

00:03:02,550 --> 00:03:03,180

database.



34

00:03:03,390 --> 00:03:05,550

Let me explain this with an example.



35

00:03:05,850 --> 00:03:14,280

Let's say we have a shared database and there is one reporting application that decided to execute a



36

00:03:14,280 --> 00:03:15,480

large, bad job.



37

00:03:15,750 --> 00:03:22,500

And this large bad job is holding up a lot of resources on shared database, for example, by way of



38

00:03:22,500 --> 00:03:27,740

long running queries or by way of queries that are returning large amounts of data.



39

00:03:28,050 --> 00:03:35,670

In this scenario, the resource usage on the shared database will go up and the sequel statements executed



40

00:03:35,670 --> 00:03:41,840

by the other applications that is application A, B and C will start to get impacted.



41

00:03:41,850 --> 00:03:48,750

And this kind of performance degradation is sometimes difficult to diagnose as each of the applications



42

00:03:48,930 --> 00:03:56,040

are looking just at their own application logs without the knowledge that some other application is



43

00:03:56,040 --> 00:03:58,970

actually causing the challenges on the database.



44

00:03:59,730 --> 00:04:04,790

The court challenges that the shared database acts as a single point of failure.



45

00:04:05,070 --> 00:04:10,120

Failure of the database will lead to the failure of all of the applications.



46

00:04:10,380 --> 00:04:16,200

So here in this scenario, if the share database goes down, all of the applications, that is A, B



47

00:04:16,200 --> 00:04:18,350

and C will be unavailable.



48

00:04:18,630 --> 00:04:26,280

Now, one may argue that this single point of failure may be removed by way of some kind of high availability



49

00:04:26,280 --> 00:04:33,510

technology, but those high availability solutions are quite complex to manage and they will lead to



50

00:04:33,540 --> 00:04:34,400

higher costs.



51

00:04:35,110 --> 00:04:41,310

Other challenges are that it is complex to carry out capacity planning for the shared database as the



52

00:04:41,310 --> 00:04:45,900

teams need to coordinate on forecasting the needs that they have.



53

00:04:45,900 --> 00:04:51,900

From the database perspective, application teams will need to be aware of the structure of the data.



54

00:04:51,900 --> 00:04:58,220

So onboarding new developers in the teams will be a challenge at this point.



55

00:04:58,320 --> 00:05:05,310

I'm sure you would agree with me that shared databases is an entry pattern, but there are many, many



56

00:05:05,310 --> 00:05:08,850

enterprises that are still dealing with such applications.



57

00:05:09,570 --> 00:05:17,130

In early 2000, service oriented architecture became a popular choice for addressing the challenges



58

00:05:17,130 --> 00:05:18,900

with shared databases.



59

00:05:18,900 --> 00:05:25,020

But it turned out that SOA was more of a Band-Aid to a bigger problem than a solution.



60

00:05:25,350 --> 00:05:29,130

In the next lecture, I talk about service oriented architecture.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\003 Service Oriented Architecture (SOA).en.srt -->

1

00:00:00,060 --> 00:00:06,900

Service oriented architecture became very popular in early 2000s, in this lesson, you learn about



2

00:00:06,900 --> 00:00:14,670

the service oriented architecture and how it is used in conjunction with shared database pattern in



3

00:00:14,670 --> 00:00:20,040

service oriented architecture, data is exposed by way of cloud services.



4

00:00:20,170 --> 00:00:28,290

Cloud stands for Create, Retrieve, Object and delete these cloud services, hide the details of the



5

00:00:28,290 --> 00:00:35,130

structure of the database from the applications apart from providing these low level data operations.



6

00:00:35,130 --> 00:00:42,750

So services may also be built by encapsulating the business logic to provide high level services.



7

00:00:43,350 --> 00:00:48,460

The social services layer is placed between the applications and the database.



8

00:00:49,140 --> 00:00:54,690

These services provide the card and high level business operations.



9

00:00:54,690 --> 00:00:59,940

Applications do not need to use sequel to carry out the data manipulation.



10

00:01:00,210 --> 00:01:07,160

They connect with these services or some kind of network protocol that is decided by the service provider.



11

00:01:07,770 --> 00:01:11,250

The social services layer provided multiple advantages.



12

00:01:11,430 --> 00:01:18,960

Since it had the structure of the database, the applications became much more simpler to code and manage.



13

00:01:19,260 --> 00:01:27,480

It led to the reuse of code by way of reusable services, and the changes to the database will become



14

00:01:27,480 --> 00:01:30,630

more manageable with the social services layer.



15

00:01:31,320 --> 00:01:39,120

But unfortunately, it does not address many of the other shared database challenges, such as single



16

00:01:39,120 --> 00:01:46,740

point of failure, uncontrolled use of resources and impact on other applications and capacity estimations.



17

00:01:47,740 --> 00:01:54,270

At this point, I would like to highlight a common misconception, many folks think that a small social



18

00:01:54,280 --> 00:01:58,240

service is a micro service, but that is not true.



19

00:01:58,720 --> 00:02:01,090

Azor Service is not a micro service.



20

00:02:01,300 --> 00:02:02,410

Think about it like this.



21

00:02:02,660 --> 00:02:10,200

A set of social services are part of the same bonded contacts, whereas a micro service represents a



22

00:02:10,220 --> 00:02:11,230

bonded context.



23

00:02:11,930 --> 00:02:14,170

Let's summarize what we have learned in this lesson.



24

00:02:14,320 --> 00:02:19,000

Social services insulating the applications from database changes.



25

00:02:19,000 --> 00:02:25,180

What social services did not address all of the challenges associated with shared databases?

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\004 Separate Database pattern.en.srt -->

1

00:00:00,150 --> 00:00:07,200

Separate database pattern in this lesson, I'll discuss Greenfield versus Greenfield Metro services



2

00:00:07,200 --> 00:00:12,480

initiatives, then I'll go with a separate database pattern and its advantages.



3

00:00:12,900 --> 00:00:20,430

Micro Services Project Coming to flavour's greenfield projects are the projects in which a new application



4

00:00:20,850 --> 00:00:23,880

with micro services architecture need to be created.



5

00:00:24,180 --> 00:00:31,830

And there are no constraints from the technical debt perspective, whereas the Brownfield Project is



6

00:00:31,830 --> 00:00:38,550

one in which an existing monolithic application need to be converted to micro services architecture.



7

00:00:39,600 --> 00:00:47,040

In the case of a greenfield application, teams will work on identifying the bonded contacts in the



8

00:00:47,040 --> 00:00:48,150

application domain.



9

00:00:48,300 --> 00:00:54,940

Once the bonded contacts have been identified, different teams will be formed to work on Microsoft



10

00:00:55,110 --> 00:00:57,350

and each of these bonded context.



11

00:00:57,480 --> 00:01:04,920

These micro services team will work independent of each other to make decisions around how these micro



12

00:01:04,920 --> 00:01:06,600

services will be implemented.



13

00:01:06,630 --> 00:01:13,380

Each team can independently decide on their own technical stack for the Microsoft as they are working



14

00:01:13,380 --> 00:01:13,620

on.



15

00:01:13,860 --> 00:01:20,000

They will decide on different interfaces that they will expose to other micro services.



16

00:01:20,010 --> 00:01:24,870

They'll decide on the event that they will publish for other micro services to consume.



17

00:01:25,170 --> 00:01:27,090

Now our focus here is data.



18

00:01:27,570 --> 00:01:34,830

Each Microsoft will own its own data, and it won't allow other micro services to directly access the



19

00:01:34,830 --> 00:01:35,280

data.



20

00:01:35,310 --> 00:01:40,390

All the data will be shared by way of well-defined interfaces.



21

00:01:40,530 --> 00:01:47,940

So in other words, each of the micro servers will have its own instance of the database and hence won't



22

00:01:47,940 --> 00:01:51,070

have the same challenges as the shared database.



23

00:01:51,960 --> 00:01:59,100

This pattern in which each of the micro services team owners and managers, their own database is referred



24

00:01:59,100 --> 00:02:01,610

to as the separate database pattern.



25

00:02:01,740 --> 00:02:07,020

Let's go over some of the advantages of this pattern with database pattern.



26

00:02:07,020 --> 00:02:09,340

The change management become simpler.



27

00:02:09,530 --> 00:02:15,320

Any changes to the database will be isolated to the MICROS service that owns the database.



28

00:02:15,330 --> 00:02:21,720

So in this scenario, if, let's say, Microsoft is undergoing some kind of a change in the database,



29

00:02:21,900 --> 00:02:25,140

there will be no direct impact on the micro service.



30

00:02:25,140 --> 00:02:34,670

A and B recall that in the case of a shared database, the database instance is a single point of failure



31

00:02:35,250 --> 00:02:37,790

in the case of a separate database pattern.



32

00:02:38,240 --> 00:02:42,330

The database is not a single point of failure here.



33

00:02:42,330 --> 00:02:49,240

In this example, if there is a problem in database for Microsoft, is it then only the Microsoft with



34

00:02:49,410 --> 00:02:52,920

a will become unavailable or will have challenges.



35

00:02:53,190 --> 00:03:01,230

Microsoft says B and C may not have any direct impact as a result of failure of database instance for



36

00:03:01,230 --> 00:03:08,730

Microsoft is a each team can independently carry out their own capacity planning for the database as



37

00:03:08,730 --> 00:03:10,440

there are no interdependencies.



38

00:03:10,710 --> 00:03:17,730

Also, scaling a database level becomes much more simpler compared to a shared database instance.



39

00:03:18,300 --> 00:03:24,370

Each team can independently decide on the database technology they would use.



40

00:03:24,960 --> 00:03:31,650

So here in this example, we see that each of the Microsoft research team has decided to go with a different



41

00:03:31,650 --> 00:03:32,310

database.



42

00:03:32,490 --> 00:03:40,140

This is referred to as the polyglot persistance, where teams within the same enterprise are using different



43

00:03:40,140 --> 00:03:41,550

database technologies.



44

00:03:42,270 --> 00:03:47,180

Let's go with a key point from this lecture for Greenfield, Microsoft's initiative.



45

00:03:47,310 --> 00:03:55,280

It is recommended that the Microsoft says designer use the separate database pattern in this pattern.



46

00:03:55,470 --> 00:03:59,380

Each of the Microsoft Office has its own instance of the database.



47

00:03:59,910 --> 00:04:05,490

Now, some time it may not be possible to apply the separate database pattern.



48

00:04:05,700 --> 00:04:09,120

And that is a topic I'll be covering in the next lecture.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\005 Brownfield Microservices _ Database patterns _ options.en.srt -->

1

00:00:00,210 --> 00:00:07,800

Wrongful initiatives and databases in this lecture, you learn about the options available for converting



2

00:00:07,950 --> 00:00:10,690

wrongful monoliths to micro services.



3

00:00:10,710 --> 00:00:17,970

You'll also learn why the shared database pattern is considered and antipodean in the context of micro



4

00:00:17,970 --> 00:00:18,540

services.



5

00:00:18,960 --> 00:00:25,740

And you will also learn a new pattern, this triangle pattern that may be used for converting wrongful



6

00:00:25,770 --> 00:00:30,270

applications to micro services in a brownfield project.



7

00:00:30,660 --> 00:00:37,320

A monolithic application is targeted to be refactored into multiple micro services.



8

00:00:38,280 --> 00:00:46,150

This monolithic application will more than likely have a database instance, the designer of the Microsoft



9

00:00:46,150 --> 00:00:52,170

Office will have three options from the database perspective that can go with the software database



10

00:00:52,170 --> 00:00:57,900

pattern within each Microsoft, which will have its own insurance, the database, or they can retain



11

00:00:58,230 --> 00:01:05,110

the common database and database refactoring or carry out logical separation of the database.



12

00:01:05,340 --> 00:01:09,100

So in the last two options, the shared database is retained.



13

00:01:09,600 --> 00:01:16,470

I will be covering only the first option in this lesson and I'll show you how strangler pattern may



14

00:01:16,470 --> 00:01:24,640

be used for transitioning from a common database to the separate database implementation of micro services.



15

00:01:25,710 --> 00:01:30,840

Think about a bank which has been in operation for multiple decades.



16

00:01:30,990 --> 00:01:37,360

This bank is more than likely to have an RDBMS for managing the system of records.



17

00:01:37,560 --> 00:01:45,270

This RDBMS over a period of time may have grown quite complex in terms of the number of tables, in



18

00:01:45,270 --> 00:01:50,070

terms of the relationship between various tables and columns.



19

00:01:50,070 --> 00:01:58,410

And on top of that, it is very commonly seen that legacy applications implement business logic and



20

00:01:58,410 --> 00:02:02,340

stored procedures and then there may be triggers to make things worse.



21

00:02:02,370 --> 00:02:09,330

So the idea here is that database has a lot of complexities and breaking the database into multiple



22

00:02:09,330 --> 00:02:12,660

databases may not be a straightforward task.



23

00:02:12,690 --> 00:02:18,900

So a common strategy that a lot of folks take for converting the brownfield application to micro services



24

00:02:19,350 --> 00:02:26,180

is to simply keep the database in place and convert the application to micro services.



25

00:02:26,190 --> 00:02:29,510

And this is how the application will look like.



26

00:02:29,970 --> 00:02:30,790

But guess what?



27

00:02:31,170 --> 00:02:38,370

Now we have a set of micro services that are sharing the database and hence they will suffer from the



28

00:02:38,370 --> 00:02:44,280

same challenges as the applications, sharing an instance of the database.



29

00:02:44,850 --> 00:02:51,540

The shared database pattern in the context of micro services is considered and antiproton.



30

00:02:51,690 --> 00:02:58,620

And the reason for it is that with the shared database, teams lose their independence, they are interdependent.



31

00:02:58,980 --> 00:03:02,220

Any change that they make will need to be coordinated.



32

00:03:02,340 --> 00:03:10,020

Changes would need increased testing effort and overall this will lead to the slow down of the delivery



33

00:03:10,020 --> 00:03:15,070

of value and no independent scaling will be possible at the end of the day.



34

00:03:15,390 --> 00:03:22,820

The instance of the database, maybe the choke point, although a shared database is an independent



35

00:03:22,860 --> 00:03:29,400

from the micro services perspective, it is still okay to use shared database parathion for transition



36

00:03:29,400 --> 00:03:30,640

state architecture.



37

00:03:30,660 --> 00:03:32,640

Let me explain what I mean by that.



38

00:03:33,120 --> 00:03:39,990

You start with a monolithic application, focus only on the application part of it and keep the database



39

00:03:40,020 --> 00:03:40,620

as is.



40

00:03:40,860 --> 00:03:48,780

And you arrive at this transition state architecture where all the micro services are using a shared



41

00:03:48,780 --> 00:03:49,500

database.



42

00:03:49,650 --> 00:03:57,090

Gradually, each of these micro services will be refactored to use their own database instance.



43

00:03:57,120 --> 00:04:05,490

So in this scheme of things, the shared database is used only as a transition state, not as a target



44

00:04:05,490 --> 00:04:05,940

state.



45

00:04:06,880 --> 00:04:13,330

Now, one important point to note about the shared database pattern for Microsoft research is that the



46

00:04:13,330 --> 00:04:18,280

Microsoft users should not have any sequel's statement in the code.



47

00:04:19,120 --> 00:04:26,140

And the reason is that having this equal statement in the code will require more effort for searching



48

00:04:26,140 --> 00:04:27,260

the database.



49

00:04:27,670 --> 00:04:35,200

Instead, the Microsoft says designer should consider using the strangler's strategy in the single strategy



50

00:04:35,500 --> 00:04:44,290

was trying to patent a collection of services is created for providing the database access to the Microsoft



51

00:04:44,290 --> 00:04:44,760

service.



52

00:04:44,950 --> 00:04:49,780

Each of these micro services depicted here will have their own set of services.



53

00:04:49,780 --> 00:04:54,860

Services are referred to as the strangler's services or just channelers.



54

00:04:55,090 --> 00:05:02,410

The idea behind the services is that switching off the database will have no impact on the micro services.



55

00:05:02,530 --> 00:05:06,930

As all of the changes will be confined to the strangler's services.



56

00:05:07,090 --> 00:05:15,360

The Microsoft business teams can decide on their priorities and search the databases at their own pace.



57

00:05:15,370 --> 00:05:22,060

And over a period of time, all of the micro services will have their own instance of the database.



58

00:05:22,090 --> 00:05:26,170

As a result, the target's architecture will be achieved.



59

00:05:26,290 --> 00:05:28,860

This triangular pattern is a generic pattern.



60

00:05:28,870 --> 00:05:33,250

It can be used for modernization of any legacy service.



61

00:05:33,580 --> 00:05:41,200

In this example here, the Microsoft Office is using a of strangler's services to connect with the mainframe



62

00:05:41,200 --> 00:05:43,090

and the team working on this.



63

00:05:43,090 --> 00:05:50,440

Micro servers may replace these mainframe legacy services with modernized version of the services during



64

00:05:50,440 --> 00:05:51,470

this transition.



65

00:05:51,640 --> 00:05:58,930

Some services may be pointing to the legacy services on the mainframe, while others may transition



66

00:05:58,930 --> 00:06:00,700

to the modernized version.



67

00:06:00,790 --> 00:06:06,940

At the end of the transition, all of the dependencies from the mainframe will be removed and all of



68

00:06:06,940 --> 00:06:10,840

the services will point to the modernized version of the services.



69

00:06:11,020 --> 00:06:17,920

The biggest benefit of this approach is that Microsoft escort will be insulated from all backend changes



70

00:06:18,130 --> 00:06:21,470

as these changes will be confined to the services layer.



71

00:06:22,120 --> 00:06:25,720

Let's go over the key points from this lecture, the shared database.



72

00:06:25,720 --> 00:06:30,670

Pachon is considered an antiproton from the Microsoft source perspective.



73

00:06:31,240 --> 00:06:38,350

Strangler pattern may be used for transitioning from the shared database implementation of micro services



74

00:06:38,620 --> 00:06:42,790

to separate database implementation of micro services.



75

00:06:43,750 --> 00:06:51,070

In the next lecture, you will learn about database refactoring and the logical separation of databases



76

00:06:51,100 --> 00:06:54,670

wherein the shared database is retained in the target state.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\006 Shared Database Pattern.en.srt -->

1

00:00:00,210 --> 00:00:06,720

Micro services shared database pattern in this lesson, I'll talk about the objective and challenges



2

00:00:06,870 --> 00:00:10,290

of preparing the database for micro services.



3

00:00:10,530 --> 00:00:17,310

Next, I'll discuss two options that you may consider for building micro services against shared databases.



4

00:00:17,880 --> 00:00:22,500

First one is the database refactoring and the logical database separation.



5

00:00:22,620 --> 00:00:28,800

Please note that the discussion in this lecture applies only to a relational database.



6

00:00:29,010 --> 00:00:36,050

Although the shared database pattern is considered as an Antipater in the context of micro services,



7

00:00:36,420 --> 00:00:43,650

there may be times when the micro services teams will not have the flexibility to use the separate database



8

00:00:43,650 --> 00:00:46,740

pattern, and there may be multiple reasons for it.



9

00:00:47,130 --> 00:00:54,060

Here are some of the common reasons that I have seen being quoted for not using separate databases.



10

00:00:54,090 --> 00:01:00,630

Time constraints, budget constraints, lack of scale resources and the complexity of the database are



11

00:01:00,630 --> 00:01:02,310

some of the most common reasons.



12

00:01:02,580 --> 00:01:07,950

And so in the scenario, teams have to consider the shared database pattern.



13

00:01:08,970 --> 00:01:16,560

When using the shared database, the objective of the Microsoft says designer is to achieve maximum



14

00:01:16,560 --> 00:01:24,270

isolation of data within the same database instance such that each Microsoft's own part of the data



15

00:01:24,420 --> 00:01:30,650

in the database and each Microsoft's service have direct access to only the data it owns.



16

00:01:30,780 --> 00:01:38,010

If possible, the Microsoft designer should use the database features to achieve the highest level of



17

00:01:38,010 --> 00:01:43,720

isolation between the Microsoft says, on data within the database instance.



18

00:01:44,310 --> 00:01:47,910

Let's talk about the challenges with breaking the databases.



19

00:01:48,300 --> 00:01:50,980

Large databases are not easy to separate.



20

00:01:51,090 --> 00:01:55,500

Consider this database structure that has roughly 60 tables.



21

00:01:55,510 --> 00:02:02,100

If you just look at this diagram, we may be able to demarcate the boundaries of the data within this



22

00:02:02,100 --> 00:02:07,250

database and assign the ownership of these tables to the micro services.



23

00:02:07,260 --> 00:02:10,610

But that's not where the exercise will end.



24

00:02:11,100 --> 00:02:18,300

We need to think about the shared data across the micro services, the relationships between the tables



25

00:02:18,300 --> 00:02:25,650

and the columns, the procedures that may have sequel's statements referenced multiple tables across



26

00:02:25,650 --> 00:02:26,370

the database.



27

00:02:26,730 --> 00:02:30,020

And then there are these triggers that need to be managed.



28

00:02:30,270 --> 00:02:33,480

All of these aspects need to be considered as well.



29

00:02:34,920 --> 00:02:38,470

So at this point, you may be thinking, what is the solution?



30

00:02:38,970 --> 00:02:41,360

Unfortunately, there is no silver bullet.



31

00:02:41,580 --> 00:02:47,580

I'm going to share some suggestions with you here, and you'll have to do your own research for your



32

00:02:47,580 --> 00:02:52,190

specific database to identify the best path forward.



33

00:02:52,620 --> 00:02:57,010

The first option is to use database refactoring in this approach.



34

00:02:57,330 --> 00:03:00,270

Changes are made to the underlying database.



35

00:03:00,600 --> 00:03:09,270

Or you can use logical separation or database in which the database is used, as is with logical boundaries



36

00:03:09,630 --> 00:03:13,770

to identify the data owned by different micro services.



37

00:03:14,400 --> 00:03:22,410

Determine database refactoring was introduced by Scott W. and promote as in their book Refactoring Databases.



38

00:03:22,410 --> 00:03:30,720

The database refactoring is defined as a small change to the database, which improves its design without



39

00:03:30,720 --> 00:03:32,750

changing its semantics.



40

00:03:33,030 --> 00:03:39,290

Now, the intent of database refactoring is quite different from what we are trying to achieve here.



41

00:03:39,450 --> 00:03:46,500

But the practice is discussed in this book are quite applicable in terms of optimizing the database



42

00:03:46,500 --> 00:03:50,190

design for use from multiple micro services.



43

00:03:51,000 --> 00:03:58,350

Changes made to the database as part of the DB refactoring exercise may be placed under one of the six



44

00:03:58,350 --> 00:03:59,130

categories.



45

00:04:00,150 --> 00:04:07,770

The first one is the structural change, the definition of the table views and columns are changed.



46

00:04:08,250 --> 00:04:14,790

Think about a table that has a large number of columns and this table gets broken into two different



47

00:04:14,790 --> 00:04:15,420

tables.



48

00:04:15,990 --> 00:04:20,490

And each of these tables is owned by a different micro service.



49

00:04:21,270 --> 00:04:28,440

The next change type is an architectural change, which is a change that applies to the methodology



50

00:04:28,440 --> 00:04:31,440

on how the application interacts with the database.



51

00:04:31,860 --> 00:04:35,850

Next one is the referential integrity changes here.



52

00:04:36,180 --> 00:04:40,740

The relationship between the database objects get changed.



53

00:04:40,960 --> 00:04:48,540

For example, you may remove the foreign key relationship between tables that belong to different micro



54

00:04:48,540 --> 00:04:49,230

services.



55

00:04:50,230 --> 00:04:57,280

The methods category refers to the changes applied to the stored procedure, for example, adding and



56

00:04:57,280 --> 00:05:00,490

removing parameters from the stored procedure.



57

00:05:01,210 --> 00:05:07,300

Next one is the transformation's, which are changes applied to the database schema.



58

00:05:07,720 --> 00:05:15,070

And the last one is the data quality wherein changes are applied for improvement of the data quality.



59

00:05:16,200 --> 00:05:23,640

Here is an example of structural refactoring in which the database is redesigned to have multiple schemas.



60

00:05:24,030 --> 00:05:31,540

Each of these schemas will be protected by way of access control mechanisms available in the database.



61

00:05:32,010 --> 00:05:38,190

Each of the Microsoft Office will own and manage the data in their respective schemas.



62

00:05:38,640 --> 00:05:42,090

Now, if you ask me a question, how would you implement it?



63

00:05:42,480 --> 00:05:47,400

The response will be that it depends on the specific RDBMS that you are using.



64

00:05:47,700 --> 00:05:54,000

Not all databases may provide you the schema mechanism with access control.



65

00:05:54,720 --> 00:06:02,160

PostgreSQL supports the schema McCarthyism that you can use for isolating the data, which schemas,



66

00:06:02,170 --> 00:06:04,370

as you can read in this link here.



67

00:06:04,730 --> 00:06:11,220

There are multiple reasons why you may want to use the schema mechanism available in PostgreSQL to allow



68

00:06:11,220 --> 00:06:17,940

many users to use one database without interfering with each other, to organize database objects into



69

00:06:18,180 --> 00:06:20,970

logical groups to make them more manageable.



70

00:06:21,330 --> 00:06:27,870

And third, party applications can be put in separate schemas so they cannot collide with the names



71

00:06:27,870 --> 00:06:29,570

of other objects.



72

00:06:29,580 --> 00:06:34,360

And this is exactly what we are looking for from the micro services perspective.



73

00:06:34,380 --> 00:06:41,310

I suggest that you carry out research on the availability of such mechanisms for the databases that



74

00:06:41,310 --> 00:06:42,240

you are using.



75

00:06:43,160 --> 00:06:50,390

Let's discuss option number two, logical separation of the database in this option, no design changes



76

00:06:50,390 --> 00:06:51,670

are made to the database.



77

00:06:51,950 --> 00:07:00,260

The database is logically separated into groups of tables, and each group of table is owned and managed



78

00:07:00,380 --> 00:07:03,410

by one micro service in this kind of a setup.



79

00:07:03,560 --> 00:07:06,230

Teams are expected to be highly disciplined.



80

00:07:06,710 --> 00:07:14,180

The idea is that each team will need to ensure that they are directly accessing only their own data



81

00:07:14,330 --> 00:07:19,040

and are not directly accessing the data for other metro services.



82

00:07:19,220 --> 00:07:22,520

And this obviously is easier said than done.



83

00:07:23,790 --> 00:07:31,620

To minimize the risk of micro services directly accessing each other's data, you may use services in



84

00:07:31,620 --> 00:07:34,020

front of the logically separated database.



85

00:07:34,500 --> 00:07:42,240

These services are government services and they provide control or only the assigned set of tables or



86

00:07:42,240 --> 00:07:42,690

data.



87

00:07:42,960 --> 00:07:50,160

So, for example, the services for Microsoft will see will have SQL statements only for the table X,



88

00:07:50,160 --> 00:07:50,850

Y and Z.



89

00:07:51,150 --> 00:07:57,750

This does not remove all of the challenges associated with the shared database, but it does provide



90

00:07:57,900 --> 00:08:02,640

a way to control ownership on data by each Microsoft's.



91

00:08:03,590 --> 00:08:07,680

Let's go over all the database related patterns that we have covered so far.



92

00:08:08,330 --> 00:08:14,570

The decision around how you would set up the database for your micro services will depend on your micro



93

00:08:14,570 --> 00:08:15,880

services initiative.



94

00:08:16,040 --> 00:08:22,310

If you're working on a greenfield initiative, that is, there is no technical debt and you have the



95

00:08:22,490 --> 00:08:27,920

flexibility to decide on the technology and the design and architecture of your micro services.



96

00:08:28,110 --> 00:08:34,460

It is recommended that you go with a separate database pattern that is each Microsoft's will have its



97

00:08:34,460 --> 00:08:36,520

own instance of the database.



98

00:08:36,680 --> 00:08:44,620

Otherwise you're dealing with a brownfield initiative wherein you have to evaluate your existing database,



99

00:08:44,930 --> 00:08:52,070

understand the time cost, resource constraints, risk and complexity, and based on the outcome of



100

00:08:52,070 --> 00:08:58,670

the evaluation, you may decide to go with the separate database pattern, which would require you to



101

00:08:58,670 --> 00:09:01,490

break the database into multiple databases.



102

00:09:01,640 --> 00:09:08,720

This may be possible for smaller databases, but there may be challenges with large and complex databases,



103

00:09:08,720 --> 00:09:12,880

in which case you need to carry out the analysis of your database.



104

00:09:12,980 --> 00:09:18,650

You would need to look at the technology, the complexity, the skills that you have in the micro services



105

00:09:18,650 --> 00:09:18,980

team.



106

00:09:19,340 --> 00:09:24,140

And then based on the outcome of this analysis, you will have two options.



107

00:09:24,470 --> 00:09:28,610

You can make design changes and carry out database refactoring.



108

00:09:28,910 --> 00:09:35,450

Or you may use logical separation, which would not require any database design changes.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10 Microservices Data Management Patterns\007 Shared Database _ Challenges & Solutions.en.srt -->

1

00:00:00,240 --> 00:00:09,300

Downside of separate databases in this lesson, I'll cover the challenges associated with multiple databases



2

00:00:09,510 --> 00:00:11,190

across the micro services.



3

00:00:11,430 --> 00:00:16,890

I'll also discuss the solutions that can be used for addressing these challenges.



4

00:00:17,340 --> 00:00:23,850

By the end of this lesson, you will have a basic understanding of securest pattern, even sourcing



5

00:00:24,060 --> 00:00:25,160

and Saagar pattern.



6

00:00:26,010 --> 00:00:32,580

The first downside of the separate database pattern is that the overall cost of the solution from the



7

00:00:32,580 --> 00:00:34,900

database perspective will go up.



8

00:00:35,310 --> 00:00:39,100

There are two factors that contribute to the cost from the database perspective.



9

00:00:39,120 --> 00:00:45,630

The first one is the increased need for the licensing and increased need for the hardware.



10

00:00:45,780 --> 00:00:51,400

You would need more servers, more storage, more networking for building multiple databases.



11

00:00:52,020 --> 00:00:57,690

The second factor is related to the operational and maintenance needs.



12

00:00:57,990 --> 00:01:04,530

For the additional databases, you may need additional team members to take care of the new database



13

00:01:04,530 --> 00:01:09,090

instances, and you would also have to invest in monitoring solutions.



14

00:01:09,420 --> 00:01:16,310

Just looking at this illustration, we may estimate the cost of database going up by up to three times.



15

00:01:17,070 --> 00:01:23,370

Let's discuss ways in which we can address some of these higher cost related challenges.



16

00:01:23,580 --> 00:01:30,240

You may use open source databases instead of the licensed software such as Oracle and Sequel's.



17

00:01:30,240 --> 00:01:34,170

So that would save you on the licensing cost.



18

00:01:34,500 --> 00:01:40,980

But keep in mind, you still need to pay for the infrastructure, the servers, the network, the storage



19

00:01:41,400 --> 00:01:43,620

to reduce the cost of the infrastructure.



20

00:01:43,950 --> 00:01:48,450

One may use a shared horse for multiple database instances.



21

00:01:48,760 --> 00:01:55,350

This way, the overall cost of the compute capacity for databases will go down.



22

00:01:55,620 --> 00:02:02,310

A very popular way of addressing the cost concern is by adopting the cloud native databases.



23

00:02:02,460 --> 00:02:08,610

The idea here is that multiple cloud vendors today are providing databases as services.



24

00:02:08,610 --> 00:02:14,940

For example, Amazon A.W. has offers 14 different types of PURPOSE-BUILT databases.



25

00:02:14,970 --> 00:02:22,320

Some of these databases, like Amazon, Dinamo DBI are serverless and they are order of magnitude cheaper



26

00:02:22,590 --> 00:02:26,370

than hosting a similar database in your own data center.



27

00:02:27,210 --> 00:02:34,290

The next downside of this database pattern is that the query performance may be degraded due to the



28

00:02:34,290 --> 00:02:35,700

distribution of data.



29

00:02:36,240 --> 00:02:43,270

Consider this example where Microsoft CE needs data from Microsoft and Microsoft is beat.



30

00:02:43,330 --> 00:02:50,310

In this scenario, the court that the Microsoft CE will need to put together is where it gets the data



31

00:02:50,310 --> 00:02:57,720

from it by invoking an API and the Microsoft is able then execute a sequel to get the data from the



32

00:02:57,720 --> 00:02:58,290

database.



33

00:02:58,440 --> 00:03:07,260

Then the court and Microsoft CE will get the data from B by invoking the API on Microsoft's P, which



34

00:03:07,260 --> 00:03:13,440

in turn will invoke a sequel statement against a database after getting the data from B, the Microsoft



35

00:03:13,440 --> 00:03:18,000

C code will need to then merge the data from A and B.



36

00:03:18,030 --> 00:03:24,170

As you can see here, there are multiple API calls and multiple sequel's statements at play.



37

00:03:24,210 --> 00:03:31,230

If we were using a shared database, this could have been easily done with a single sequel's statement



38

00:03:31,380 --> 00:03:32,710

using a joint.



39

00:03:33,870 --> 00:03:40,620

Now this may be managed by way of local copies of data through asynchronous replication.



40

00:03:40,920 --> 00:03:42,550

Let me explain how it works.



41

00:03:42,750 --> 00:03:45,770

Let's say there is a Microsoft Office and a Microsoft Office.



42

00:03:45,780 --> 00:03:49,720

B, each of these micro services have their own database.



43

00:03:50,100 --> 00:03:53,920

Let's say an action is taken on the Microsoft Office.



44

00:03:53,940 --> 00:03:57,990

B that leads to a change in data for Microsoft Office.



45

00:03:58,000 --> 00:04:05,010

B, think of it as the execution of sequel insert, update or delete on the B's database.



46

00:04:05,190 --> 00:04:10,220

B will act as an even source and it will act as a consumer.



47

00:04:10,350 --> 00:04:18,570

All of the information related to the change in BEAS data will be published as an event and the Microsoft



48

00:04:18,570 --> 00:04:22,560

Office will subscribe to these events on receiving the event.



49

00:04:22,620 --> 00:04:30,090

Microsoft has a right to data received from B in its own database as a read-only copy.



50

00:04:30,360 --> 00:04:39,000

No reliquaries executed against the Microsoft is if it is able to invoke this equal statement against



51

00:04:39,000 --> 00:04:43,080

the local database to create the response to these queries.



52

00:04:43,290 --> 00:04:50,760

This forms the basis for the Securus and even saucing patterns, which are leverage for building complex



53

00:04:50,760 --> 00:04:52,080

high throughput systems.



54

00:04:52,080 --> 00:04:55,510

You will be learning about these patents in later lectures.



55

00:04:56,160 --> 00:04:59,730

The next downside of such a database pattern is.



56

00:04:59,980 --> 00:05:04,370

Complexity in managing the transactional and data integrity.



57

00:05:04,510 --> 00:05:06,490

Let me explain this with an example.



58

00:05:06,790 --> 00:05:13,750

Let's say there is an online shopping store that is using micro services architecture and the order



59

00:05:13,750 --> 00:05:15,260

is placed by the customer.



60

00:05:15,730 --> 00:05:22,150

The orders, Miko's services, publishers and even and there are two micro services which are subscribing



61

00:05:22,300 --> 00:05:23,520

to these events.



62

00:05:23,530 --> 00:05:30,020

The Notifier Micro Service receives the event and notifies the customer by way of an email.



63

00:05:30,280 --> 00:05:32,680

Let's say this action was successful.



64

00:05:33,070 --> 00:05:40,090

The shipment service on receiving the evening update, the internal state of the order to indicate that



65

00:05:40,090 --> 00:05:41,770

the order may be shipped.



66

00:05:41,980 --> 00:05:48,860

But let's assume for the sake of this discussion that because of some issue on the database, the shipments



67

00:05:48,860 --> 00:05:49,930

service failed.



68

00:05:50,410 --> 00:05:58,810

In this scenario, the customer has paid for the order, has received an email indicating that the order



69

00:05:58,810 --> 00:05:59,710

was successful.



70

00:06:00,160 --> 00:06:03,430

But unfortunately, this customer will never receive the goods.



71

00:06:03,640 --> 00:06:11,200

If we were to build a system using a shared database, a local transaction could be used to avoid such



72

00:06:11,200 --> 00:06:11,800

a failure.



73

00:06:12,220 --> 00:06:19,630

This challenge may be addressed by using a sequence of local transactions with distributed rollbacks.



74

00:06:19,780 --> 00:06:20,920

This is how it'll work.



75

00:06:21,070 --> 00:06:27,790

Let's say a micro service received a transaction and it was successful in updating it stayed in the



76

00:06:27,790 --> 00:06:28,810

local database.



77

00:06:28,810 --> 00:06:35,690

It then publishes an event which is received by another micro service that carries out the state update



78

00:06:35,710 --> 00:06:36,310

locally.



79

00:06:36,460 --> 00:06:42,580

And the sequence will continue until all of the micro services involved in the transaction are successful.



80

00:06:42,610 --> 00:06:49,450

Now, this is a sunny day scenario where all of the micro services were successful in updating their



81

00:06:49,450 --> 00:06:51,190

internal state in the database.



82

00:06:51,580 --> 00:06:55,270

Let's go with a scenario in which one of the micro servers will fail.



83

00:06:55,600 --> 00:07:04,060

Let's say see on receiving the event tries to process it, but fails to update its internal state in



84

00:07:04,060 --> 00:07:04,780

the database.



85

00:07:04,960 --> 00:07:13,060

In this scenario, C will inform the other micro services by publishing an event and B on receiving



86

00:07:13,060 --> 00:07:20,320

the failure, even from C will update their internal state by rolling back the transaction.



87

00:07:20,470 --> 00:07:28,210

This mechanism involving the use of local transactions but distributed rollbacks form the basis for



88

00:07:28,210 --> 00:07:36,010

the saga pattern and the reliable messaging pattern, only covering these two patterns in details in



89

00:07:36,010 --> 00:07:36,880

later lectures.



90

00:07:37,180 --> 00:07:39,560

Time to go over the key points from this lecture.



91

00:07:39,700 --> 00:07:46,960

High cost of micro services with separate databases may be addressed by using open source and cloud



92

00:07:46,960 --> 00:07:48,280

native databases.



93

00:07:48,280 --> 00:07:55,300

Performance degradation, due to distribution of data may be addressed by way of securest pattern and



94

00:07:55,330 --> 00:08:02,810

even sourcing complexity in their integrity and transaction management may be addressed by way of Saagar



95

00:08:03,430 --> 00:08:04,780

and reliable messaging.



96

00:08:04,990 --> 00:08:11,710

In the next section, you learn about the Securus pattern, even sourcing Saagar pertinent and reliable



97

00:08:11,710 --> 00:08:12,220

messaging.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000001.srt -->

1
00:00:00,190 --> 00:00:07,960
Cơ sở dữ liệu là một phần thiết yếu của tất cả các ứng dụng, các dịch vụ vi mô được phát triển độc lập bởi các nhóm khác nhau.

2
00:00:07,980 --> 00:00:21,870
Mỗi đội có thể quyết định về công nghệ cơ sở dữ liệu cũng như cấu trúc cơ sở dữ liệu của mình.  Mỗi nhóm có thể độc lập thực hiện các thay đổi đối với cơ sở dữ liệu của riêng mình mà không ảnh hưởng đến các dịch vụ vi mô khác.

3
00:00:22,260 --> 00:00:40,650
Việc chuyển đổi một ứng dụng nguyên khối sang các dịch vụ vi mô đòi hỏi người thiết kế không chỉ nghĩ đến việc tái cấu trúc logic nghiệp vụ và các thành phần của ứng dụng nguyên khối mà còn cần phải suy nghĩ về việc tái cấu trúc cơ sở dữ liệu.

4
00:00:40,950 --> 00:00:49,980
Và việc tái cấu trúc cơ sở dữ liệu có nghĩa là chia phiên bản cơ sở dữ liệu chung thành nhiều phiên bản cơ sở dữ liệu.

5
00:00:50,460 --> 00:00:59,910
Việc chia cơ sở dữ liệu chung này thành nhiều phiên bản cơ sở dữ liệu không đơn giản.  Có nhiều thách thức.

6
00:01:00,240 --> 00:01:21,090
Tôi sẽ thảo luận về một số thách thức này trong phần này và tôi cũng sẽ thảo luận về các giải pháp dưới dạng tùy chọn kỹ thuật, cũng như các mẫu dữ liệu nhất định có thể được sử dụng để thiết kế các dịch vụ vi mô mới và để chuyển đổi các ứng dụng nguyên khối hiện có sang các dịch vụ vi mô.

7
00:01:21,660 --> 00:01:30,300
Các phần mà tôi sẽ đề cập trong phần này là parathion cơ sở dữ liệu dùng chung, parathion cơ sở dữ liệu Sopra và mẫu hình tam giác này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000002.srt -->

1
00:00:00,180 --> 00:00:13,140
Cơ sở dữ liệu bền vững và chia sẻ trong bài giảng này, trước tiên tôi sẽ nói về mẫu cơ sở dữ liệu dùng chung và sau đó thảo luận về ưu và nhược điểm của cơ sở dữ liệu dùng chung, các ứng dụng cần phải tồn tại.

2
00:00:13,320 --> 00:00:24,360
Dữ liệu, tính bền vững của dữ liệu này đạt được bằng cách ghi vào hệ thống tệp hoặc phổ biến hơn là bằng cách ghi dữ liệu vào cơ sở dữ liệu.

3
00:00:24,570 --> 00:00:34,650
Hiện nay có nhiều loại cơ sở dữ liệu, nhưng cơ sở dữ liệu được sử dụng phổ biến nhất là cơ sở dữ liệu quan hệ và không có cơ sở dữ liệu đơn lẻ.

4
00:00:34,920 --> 00:00:47,970
Các ứng dụng kế thừa thường sử dụng RDBMS hoặc cơ sở dữ liệu quan hệ cho tất cả các loại dữ liệu và đó là do không có cơ sở dữ liệu đơn lẻ nào không có sẵn cho đến đầu những năm 2000.

5
00:00:48,400 --> 00:01:01,320
Mẫu phát triển ứng dụng máy chủ khách điển hình được các ứng dụng cũ này sử dụng bao gồm nhiều ứng dụng doanh nghiệp chia sẻ một phiên bản chung của cơ sở dữ liệu.

6
00:01:01,920 --> 00:01:16,380
Tất cả dữ liệu miền được quản lý tập trung trong cơ sở dữ liệu dùng chung này và ứng dụng doanh nghiệp sẽ quản lý dữ liệu bằng các câu lệnh tiếp theo đối với cơ sở dữ liệu dùng chung này.

7
00:01:16,560 --> 00:01:22,920
Theo tiêu chuẩn ngày nay, kiến ​​trúc này sẽ không được chấp nhận, nhưng có một số điều tốt về nó.

8
00:01:23,460 --> 00:01:37,490
Điều đầu tiên là nó sẽ dẫn đến một quy trình quản lý dữ liệu được đơn giản hóa.  Thứ hai là do công cụ cơ sở dữ liệu được chia sẻ bởi nhiều ứng dụng nên chi phí của giải pháp sẽ giảm xuống.

9
00:01:37,500 --> 00:01:45,660
Và thứ ba là một nhóm quản trị viên cơ sở dữ liệu có thể quản lý cơ sở dữ liệu cho tất cả các ứng dụng.

10
00:01:46,140 --> 00:01:56,670
Bây giờ chúng ta hãy cùng vượt qua các thử thách với mẫu cơ sở dữ liệu dùng chung.  Thách thức đầu tiên là những thay đổi về cơ sở dữ liệu cần phải được quản lý rất cẩn thận.

11
00:01:57,240 --> 00:02:12,210
Hãy xem xét tình huống trong đó ứng dụng yêu cầu thay đổi lược đồ cơ sở dữ liệu.  Bây giờ chủ sở hữu ứng dụng không thể tiếp tục và thực hiện thay đổi vì nó có thể ảnh hưởng đến ứng dụng B và ứng dụng C.

12
00:02:12,240 --> 00:02:24,270
Do đó, chủ sở hữu ứng dụng sẽ cần cộng tác với ứng dụng B và C để đảm bảo rằng thay đổi trong lược đồ sẽ không ảnh hưởng đến BNC của ứng dụng.

13
00:02:24,300 --> 00:02:32,490
Và nếu có tác động thì tất cả các ứng dụng này sẽ cần phối hợp triển khai thay đổi.

14
00:02:32,700 --> 00:02:42,780
Hoặc tất cả điều này sẽ dẫn đến chi phí thay đổi cao.  Nó sẽ dẫn đến rủi ro cao hơn vì việc thay đổi cơ sở dữ liệu có thể dẫn đến việc phá vỡ các ứng dụng khác.

15
00:02:42,780 --> 00:03:03,180
Và vào cuối ngày, điều này sẽ dẫn đến thời gian định giá lâu hơn.  Thách thức thứ hai là một ứng dụng có thể tác động tiêu cực đến tất cả các ứng dụng khác và điều này có thể xảy ra nếu ứng dụng đó cố tình hoặc vô ý bắt đầu sử dụng nhiều tài nguyên trên cơ sở dữ liệu.

16
00:03:03,390 --> 00:03:15,480
Hãy để tôi giải thích điều này bằng một ví dụ.  Giả sử chúng ta có một cơ sở dữ liệu dùng chung và có một ứng dụng báo cáo đã quyết định thực hiện một công việc tồi tệ.

17
00:03:15,750 --> 00:03:27,740
Và công việc tồi tệ lớn này đang chiếm giữ rất nhiều tài nguyên trên cơ sở dữ liệu dùng chung, chẳng hạn như bằng các truy vấn chạy dài hoặc bằng các truy vấn trả về lượng lớn dữ liệu.

18
00:03:28,050 --> 00:03:41,840
Trong trường hợp này, mức sử dụng tài nguyên trên cơ sở dữ liệu dùng chung sẽ tăng lên và các câu lệnh tiếp theo được thực thi bởi các ứng dụng khác là ứng dụng A, B và C sẽ bắt đầu bị ảnh hưởng.

19
00:03:41,850 --> 00:03:58,970
Và loại suy giảm hiệu suất này đôi khi khó chẩn đoán vì mỗi ứng dụng chỉ xem nhật ký ứng dụng của chính chúng mà không biết rằng một số ứng dụng khác thực sự đang gây ra thách thức trên cơ sở dữ liệu.

20
00:03:59,730 --> 00:04:10,120
Tòa án thách thức rằng cơ sở dữ liệu dùng chung hoạt động như một điểm lỗi duy nhất.  Cơ sở dữ liệu bị lỗi sẽ dẫn đến lỗi của tất cả các ứng dụng.

21
00:04:10,380 --> 00:04:18,350
Vì vậy, trong trường hợp này, nếu cơ sở dữ liệu chia sẻ bị hỏng, tất cả các ứng dụng A, B và C sẽ không khả dụng.

22
00:04:18,630 --> 00:04:34,400
Bây giờ, người ta có thể lập luận rằng điểm lỗi duy nhất này có thể được loại bỏ bằng một số loại công nghệ có tính sẵn sàng cao, nhưng những giải pháp có tính sẵn sàng cao đó khá phức tạp để quản lý và chúng sẽ dẫn đến chi phí cao hơn.

23
00:04:35,110 --> 00:04:45,900
Những thách thức khác là việc thực hiện lập kế hoạch năng lực cho cơ sở dữ liệu dùng chung rất phức tạp vì các nhóm cần phối hợp để dự báo nhu cầu mà họ có.

24
00:04:45,900 --> 00:04:51,900
Từ góc độ cơ sở dữ liệu, các nhóm ứng dụng sẽ cần nhận thức được cấu trúc của dữ liệu.

25
00:04:51,900 --> 00:05:08,850
Vì vậy, việc đưa các nhà phát triển mới vào nhóm sẽ là một thách thức vào thời điểm này.  Tôi chắc chắn rằng bạn sẽ đồng ý với tôi rằng cơ sở dữ liệu dùng chung là một mô hình đầu vào, nhưng có rất nhiều doanh nghiệp vẫn đang xử lý các ứng dụng như vậy.

26
00:05:09,570 --> 00:05:18,900
Đầu năm 2000, kiến ​​trúc hướng dịch vụ đã trở thành một lựa chọn phổ biến để giải quyết các thách thức với cơ sở dữ liệu dùng chung.

27
00:05:18,900 --> 00:05:29,130
Nhưng hóa ra SOA giống như một phương tiện hỗ trợ cho một vấn đề lớn hơn là một giải pháp.  Trong bài giảng tiếp theo, tôi sẽ nói về kiến ​​trúc hướng dịch vụ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000003.srt -->

1
00:00:00,060 --> 00:00:20,040
Kiến trúc hướng dịch vụ trở nên rất phổ biến vào đầu những năm 2000, trong bài học này, bạn tìm hiểu về kiến ​​trúc hướng dịch vụ và cách nó được sử dụng kết hợp với mẫu cơ sở dữ liệu dùng chung trong kiến ​​trúc hướng dịch vụ, dữ liệu được hiển thị qua các dịch vụ đám mây.

2
00:00:20,170 --> 00:00:35,130
Đám mây là viết tắt của Tạo, Truy xuất, Đối tượng và xóa các dịch vụ đám mây này, ẩn các chi tiết về cấu trúc của cơ sở dữ liệu khỏi các ứng dụng ngoài việc cung cấp các hoạt động dữ liệu cấp thấp này.

3
00:00:35,130 --> 00:00:48,460
Vì vậy, các dịch vụ cũng có thể được xây dựng bằng cách đóng gói logic nghiệp vụ để cung cấp các dịch vụ cấp cao.  Lớp dịch vụ xã hội được đặt giữa các ứng dụng và cơ sở dữ liệu.

4
00:00:49,140 --> 00:00:59,940
Những dịch vụ này cung cấp thẻ và hoạt động kinh doanh cấp cao.  Các ứng dụng không cần sử dụng phần tiếp theo để thực hiện thao tác dữ liệu.

5
00:01:00,210 --> 00:01:07,160
Họ kết nối với các dịch vụ này hoặc một số loại giao thức mạng do nhà cung cấp dịch vụ quyết định.

6
00:01:07,770 --> 00:01:18,960
Lớp dịch vụ xã hội cung cấp nhiều lợi thế.  Vì nó có cấu trúc của cơ sở dữ liệu nên việc mã hóa và quản lý các ứng dụng trở nên đơn giản hơn nhiều.

7
00:01:19,260 --> 00:01:30,630
Nó dẫn đến việc sử dụng lại mã thông qua các dịch vụ có thể tái sử dụng và những thay đổi đối với cơ sở dữ liệu sẽ trở nên dễ quản lý hơn với lớp dịch vụ xã hội.

8
00:01:31,320 --> 00:01:46,740
Nhưng thật không may, nó không giải quyết được nhiều thách thức về cơ sở dữ liệu dùng chung khác, chẳng hạn như điểm lỗi duy nhất, việc sử dụng tài nguyên không được kiểm soát và tác động đến các ứng dụng khác cũng như ước tính dung lượng.

9
00:01:47,740 --> 00:01:58,240
Ở điểm này, tôi muốn nêu ra một quan niệm sai lầm phổ biến, nhiều người cho rằng dịch vụ xã hội nhỏ là dịch vụ vi mô, nhưng điều đó không đúng.

10
00:01:58,720 --> 00:02:11,230
Dịch vụ Azor không phải là một dịch vụ vi mô.  Hãy suy nghĩ về nó như thế này.  Một tập hợp các dịch vụ xã hội là một phần của các mối liên hệ gắn kết giống nhau, trong khi dịch vụ vi mô thể hiện một bối cảnh gắn kết.

11
00:02:11,930 --> 00:02:19,000
Hãy tóm tắt những gì chúng ta đã học được trong bài học này.  Các dịch vụ xã hội cách ly các ứng dụng khỏi những thay đổi cơ sở dữ liệu.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000004.srt -->

1
00:00:00,150 --> 00:00:12,480
Mẫu cơ sở dữ liệu riêng biệt trong bài học này, tôi sẽ thảo luận về các sáng kiến ​​dịch vụ của Greenfield so với Greenfield Metro, sau đó tôi sẽ đi với một mẫu cơ sở dữ liệu riêng biệt và những ưu điểm của nó.

2
00:00:12,900 --> 00:00:23,880
Dự án Dịch vụ Vi mô Các dự án lĩnh vực xanh của Flavor là những dự án cần tạo ra một ứng dụng mới với kiến ​​trúc dịch vụ vi mô.

3
00:00:24,180 --> 00:00:38,550
Và không có ràng buộc nào từ góc độ nợ kỹ thuật, trong khi Dự án Brownfield là một dự án trong đó ứng dụng nguyên khối hiện có cần được chuyển đổi sang kiến ​​trúc dịch vụ vi mô.

4
00:00:39,600 --> 00:00:48,150
Trong trường hợp ứng dụng greenfield, các nhóm sẽ làm việc để xác định các liên hệ được liên kết trong miền ứng dụng.

5
00:00:48,300 --> 00:00:57,350
Sau khi xác định được các liên hệ liên kết, các nhóm khác nhau sẽ được thành lập để làm việc trên Microsoft và từng bối cảnh liên kết này.

6
00:00:57,480 --> 00:01:06,600
Nhóm dịch vụ vi mô này sẽ làm việc độc lập với nhau để đưa ra quyết định về cách triển khai các dịch vụ vi mô này.

7
00:01:06,630 --> 00:01:13,620
Mỗi nhóm có thể độc lập quyết định về hệ thống kỹ thuật của riêng mình cho Microsoft khi họ đang làm việc.

8
00:01:13,860 --> 00:01:24,870
Họ sẽ quyết định các giao diện khác nhau mà họ sẽ hiển thị cho các dịch vụ vi mô khác.  Họ sẽ quyết định xem họ sẽ xuất bản để các dịch vụ vi mô khác sử dụng.

9
00:01:25,170 --> 00:01:35,280
Bây giờ trọng tâm của chúng tôi ở đây là dữ liệu.  Mỗi Microsoft sẽ sở hữu dữ liệu riêng của mình và sẽ không cho phép các dịch vụ vi mô khác truy cập trực tiếp vào dữ liệu.

10
00:01:35,310 --> 00:01:51,070
Tất cả dữ liệu sẽ được chia sẻ bằng các giao diện được xác định rõ ràng.  Vì vậy, nói cách khác, mỗi máy chủ vi mô sẽ có phiên bản cơ sở dữ liệu riêng và do đó sẽ không gặp những thách thức giống như cơ sở dữ liệu dùng chung.

11
00:01:51,960 --> 00:02:01,610
Mẫu này trong đó mỗi chủ sở hữu và người quản lý nhóm dịch vụ vi mô có cơ sở dữ liệu riêng của họ được gọi là mẫu cơ sở dữ liệu riêng biệt.

12
00:02:01,740 --> 00:02:09,340
Chúng ta hãy xem qua một số ưu điểm của mẫu này với mẫu cơ sở dữ liệu.  Việc quản lý thay đổi trở nên đơn giản hơn.

13
00:02:09,530 --> 00:02:25,140
Mọi thay đổi đối với cơ sở dữ liệu sẽ được cách ly với dịch vụ MICROS sở hữu cơ sở dữ liệu.  Vì vậy, trong trường hợp này, giả sử nếu Microsoft đang thực hiện một số thay đổi nào đó trong cơ sở dữ liệu thì sẽ không có tác động trực tiếp đến dịch vụ vi mô.

14
00:02:25,140 --> 00:02:37,790
A và B nhớ lại rằng trong trường hợp cơ sở dữ liệu dùng chung, phiên bản cơ sở dữ liệu là một điểm lỗi trong trường hợp mẫu cơ sở dữ liệu riêng biệt.

15
00:02:38,240 --> 00:02:52,920
Cơ sở dữ liệu không phải là một điểm lỗi duy nhất ở đây.  Trong ví dụ này, nếu có vấn đề trong cơ sở dữ liệu của Microsoft thì chỉ có Microsoft có a mới không khả dụng hoặc sẽ gặp thách thức.

16
00:02:53,190 --> 00:03:10,440
Microsoft cho biết B và C có thể không có bất kỳ tác động trực tiếp nào do phiên bản cơ sở dữ liệu của Microsoft bị lỗi nên mỗi nhóm có thể độc lập thực hiện việc lập kế hoạch năng lực của riêng mình cho cơ sở dữ liệu vì không có sự phụ thuộc lẫn nhau.

17
00:03:10,710 --> 00:03:24,370
Ngoài ra, việc mở rộng cấp độ cơ sở dữ liệu trở nên đơn giản hơn nhiều so với phiên bản cơ sở dữ liệu dùng chung.  Mỗi nhóm có thể quyết định độc lập về công nghệ cơ sở dữ liệu mà họ sẽ sử dụng.

18
00:03:24,960 --> 00:03:32,310
Vì vậy, trong ví dụ này, chúng ta thấy rằng mỗi nhóm nghiên cứu của Microsoft đã quyết định sử dụng một cơ sở dữ liệu khác nhau.

19
00:03:32,490 --> 00:03:41,550
Điều này được gọi là tính bền bỉ đa ngôn ngữ, trong đó các nhóm trong cùng một doanh nghiệp đang sử dụng các công nghệ cơ sở dữ liệu khác nhau.

20
00:03:42,270 --> 00:03:55,280
Hãy cùng chuyển sang điểm chính trong bài giảng này cho Greenfield, sáng kiến ​​của Microsoft.  Microsoft khuyến nghị nhà thiết kế nên sử dụng mẫu cơ sở dữ liệu riêng biệt trong mẫu này.

21
00:03:55,470 --> 00:04:05,490
Mỗi Microsoft Office đều có phiên bản cơ sở dữ liệu riêng.  Hiện tại, đôi khi có thể không áp dụng được mẫu cơ sở dữ liệu riêng biệt.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000005.srt -->

1
00:00:00,210 --> 00:00:10,690
Trong bài giảng này, các sáng kiến ​​và cơ sở dữ liệu sai trái sẽ tìm hiểu về các tùy chọn có sẵn để chuyển đổi các khối nguyên khối sai trái thành các dịch vụ vi mô.

2
00:00:10,710 --> 00:00:18,540
Bạn cũng sẽ tìm hiểu lý do tại sao mẫu cơ sở dữ liệu dùng chung được xem xét và phản đối trong bối cảnh các dịch vụ vi mô.

3
00:00:18,960 --> 00:00:30,270
Và bạn cũng sẽ tìm hiểu một mẫu mới, mẫu hình tam giác này có thể được sử dụng để chuyển đổi các ứng dụng sai thành các dịch vụ vi mô trong một dự án brownfield.

4
00:00:30,660 --> 00:01:05,110
Một ứng dụng nguyên khối được nhắm mục tiêu tái cấu trúc thành nhiều dịch vụ vi mô.  Ứng dụng nguyên khối này nhiều khả năng sẽ có một phiên bản cơ sở dữ liệu, người thiết kế Microsoft Office sẽ có ba tùy chọn từ góc độ cơ sở dữ liệu có thể đi với mẫu cơ sở dữ liệu phần mềm trong mỗi Microsoft, sẽ có bảo hiểm, cơ sở dữ liệu riêng hoặc chúng  có thể giữ lại cơ sở dữ liệu chung và tái cấu trúc cơ sở dữ liệu hoặc thực hiện phân tách logic cơ sở dữ liệu.

5
00:01:05,340 --> 00:01:24,640
Vì vậy, trong hai tùy chọn cuối cùng, cơ sở dữ liệu dùng chung sẽ được giữ lại.  Tôi sẽ chỉ đề cập đến tùy chọn đầu tiên trong bài học này và tôi sẽ chỉ cho bạn cách sử dụng mẫu strangler để chuyển từ cơ sở dữ liệu chung sang triển khai cơ sở dữ liệu riêng biệt của các dịch vụ vi mô.

6
00:01:25,710 --> 00:01:37,360
Hãy nghĩ về một ngân hàng đã hoạt động được nhiều thập kỷ.  Ngân hàng này có nhiều khả năng có RDBMS để quản lý hệ thống hồ sơ.

7
00:01:37,560 --> 00:01:50,070
RDBMS này trong một khoảng thời gian có thể đã phát triển khá phức tạp về số lượng bảng, về mối quan hệ giữa các bảng và cột khác nhau.

8
00:01:50,070 --> 00:02:02,340
Và trên hết, người ta thường thấy rằng các ứng dụng cũ triển khai logic nghiệp vụ và các thủ tục được lưu trữ và sau đó có thể có các yếu tố kích hoạt khiến mọi thứ trở nên tồi tệ hơn.

9
00:02:02,370 --> 00:02:12,660
Vì vậy, ý tưởng ở đây là cơ sở dữ liệu có rất nhiều sự phức tạp và việc chia cơ sở dữ liệu thành nhiều cơ sở dữ liệu có thể không phải là một nhiệm vụ đơn giản.

10
00:02:12,690 --> 00:02:26,180
Vì vậy, một chiến lược chung mà nhiều người thực hiện để chuyển đổi ứng dụng brownfield sang các dịch vụ vi mô là chỉ cần giữ nguyên cơ sở dữ liệu và chuyển đổi ứng dụng sang các dịch vụ vi mô.

11
00:02:26,190 --> 00:02:44,280
Và ứng dụng sẽ trông như thế này.  Nhưng đoán xem?  Bây giờ chúng ta có một tập hợp các dịch vụ vi mô đang chia sẻ cơ sở dữ liệu và do đó chúng sẽ gặp phải những thách thức tương tự như các ứng dụng chia sẻ phiên bản của cơ sở dữ liệu.

12
00:02:44,850 --> 00:02:58,620
Mẫu cơ sở dữ liệu dùng chung trong bối cảnh dịch vụ vi mô được xem xét và phản proton.  Và lý do là vì với cơ sở dữ liệu dùng chung, các nhóm mất đi tính độc lập, phụ thuộc lẫn nhau.

13
00:02:58,980 --> 00:03:15,070
Bất kỳ thay đổi nào họ thực hiện sẽ cần phải được phối hợp.  Những thay đổi sẽ cần nỗ lực thử nghiệm nhiều hơn và nhìn chung, điều này sẽ dẫn đến việc cung cấp giá trị bị chậm lại và không thể mở rộng quy mô độc lập vào cuối ngày.

14
00:03:15,390 --> 00:03:30,640
Phiên bản của cơ sở dữ liệu, có thể là điểm nghẽn, mặc dù cơ sở dữ liệu dùng chung độc lập với góc độ dịch vụ vi mô, nhưng bạn vẫn có thể sử dụng parathion cơ sở dữ liệu dùng chung cho kiến ​​trúc trạng thái chuyển tiếp.

15
00:03:30,660 --> 00:03:40,620
Hãy để tôi giải thích điều tôi muốn nói.  Bạn bắt đầu với một ứng dụng nguyên khối, chỉ tập trung vào phần ứng dụng của nó và giữ nguyên cơ sở dữ liệu.

16
00:03:40,860 --> 00:03:49,500
Và bạn đạt đến kiến ​​trúc trạng thái chuyển tiếp này, nơi tất cả các dịch vụ vi mô đang sử dụng cơ sở dữ liệu dùng chung.

17
00:03:49,650 --> 00:04:05,940
Dần dần, mỗi dịch vụ vi mô này sẽ được tái cấu trúc để sử dụng phiên bản cơ sở dữ liệu của riêng chúng.  Vì vậy, trong sơ đồ này, cơ sở dữ liệu dùng chung chỉ được sử dụng làm trạng thái chuyển tiếp chứ không phải là trạng thái đích.

18
00:04:06,880 --> 00:04:18,280
Bây giờ, một điểm quan trọng cần lưu ý về mẫu cơ sở dữ liệu dùng chung cho nghiên cứu của Microsoft là người dùng Microsoft không được có bất kỳ câu lệnh nào về phần tiếp theo trong mã.

19
00:04:19,120 --> 00:04:27,260
Và lý do là việc có câu lệnh bằng nhau này trong code sẽ đòi hỏi nhiều nỗ lực hơn cho việc tìm kiếm cơ sở dữ liệu.

20
00:04:27,670 --> 00:04:44,760
Thay vào đó, Microsoft cho biết nhà thiết kế nên cân nhắc việc sử dụng chiến lược của kẻ bóp nghẹt trong chiến lược duy nhất là cố gắng cấp bằng sáng chế cho một tập hợp các dịch vụ được tạo ra để cung cấp quyền truy cập cơ sở dữ liệu cho dịch vụ của Microsoft.

21
00:04:44,950 --> 00:04:54,860
Mỗi dịch vụ vi mô được mô tả ở đây sẽ có bộ dịch vụ riêng.  Các dịch vụ được gọi là dịch vụ của kẻ lạ mặt hoặc chỉ là người phân phối.

22
00:04:55,090 --> 00:05:02,410
Ý tưởng đằng sau các dịch vụ này là việc tắt cơ sở dữ liệu sẽ không ảnh hưởng đến các dịch vụ vi mô.

23
00:05:02,530 --> 00:05:15,360
Vì tất cả những thay đổi sẽ được giới hạn trong các dịch vụ của kẻ lạ mặt.  Các nhóm kinh doanh của Microsoft có thể quyết định các ưu tiên của mình và tìm kiếm cơ sở dữ liệu theo tốc độ riêng của họ.

24
00:05:15,370 --> 00:05:26,170
Và trong một khoảng thời gian, tất cả các dịch vụ vi mô sẽ có phiên bản cơ sở dữ liệu riêng.  Kết quả là kiến ​​trúc của mục tiêu sẽ đạt được.

25
00:05:26,290 --> 00:05:33,250
Mẫu hình tam giác này là một mẫu chung.  Nó có thể được sử dụng để hiện đại hóa bất kỳ dịch vụ cũ nào.

26
00:05:33,580 --> 00:05:43,090
Trong ví dụ này ở đây, Microsoft Office đang sử dụng một trong các dịch vụ của strangler để kết nối với máy tính lớn và nhóm làm việc về vấn đề này.

27
00:05:43,090 --> 00:05:51,470
Các máy chủ vi mô có thể thay thế các dịch vụ cũ của máy tính lớn này bằng phiên bản dịch vụ hiện đại hóa trong quá trình chuyển đổi này.

28
00:05:51,640 --> 00:06:00,700
Một số dịch vụ có thể trỏ đến các dịch vụ cũ trên máy tính lớn, trong khi những dịch vụ khác có thể chuyển sang phiên bản hiện đại hóa.

29
00:06:00,790 --> 00:06:10,840
Khi kết thúc quá trình chuyển đổi, tất cả các phần phụ thuộc từ máy tính lớn sẽ bị xóa và tất cả các dịch vụ sẽ trỏ đến phiên bản hiện đại hóa của dịch vụ.

30
00:06:11,020 --> 00:06:21,470
Lợi ích lớn nhất của phương pháp này là việc hộ tống của Microsoft sẽ được cách ly khỏi tất cả các thay đổi phụ trợ vì những thay đổi này sẽ được giới hạn trong lớp dịch vụ.

31
00:06:22,120 --> 00:06:30,670
Chúng ta hãy điểm qua những điểm chính trong bài giảng này, cơ sở dữ liệu dùng chung.  Pachon được coi là một phản proton từ góc độ nguồn của Microsoft.

32
00:06:31,240 --> 00:06:42,790
Mẫu Strangler có thể được sử dụng để chuyển từ việc triển khai cơ sở dữ liệu dùng chung của các dịch vụ vi mô sang triển khai cơ sở dữ liệu riêng biệt của các dịch vụ vi mô.

33
00:06:43,750 --> 00:06:54,670
Trong bài giảng tiếp theo, bạn sẽ tìm hiểu về cách tái cấu trúc cơ sở dữ liệu và phân tách logic các cơ sở dữ liệu trong đó cơ sở dữ liệu dùng chung được giữ lại ở trạng thái đích.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000006.srt -->

1
00:00:00,210 --> 00:00:10,290
Mẫu cơ sở dữ liệu chia sẻ của các dịch vụ vi mô trong bài học này, tôi sẽ nói về mục tiêu và thách thức của việc chuẩn bị cơ sở dữ liệu cho các dịch vụ vi mô.

2
00:00:10,530 --> 00:00:17,310
Tiếp theo, tôi sẽ thảo luận về hai tùy chọn mà bạn có thể cân nhắc để xây dựng các dịch vụ vi mô dựa trên cơ sở dữ liệu dùng chung.

3
00:00:17,880 --> 00:00:28,800
Đầu tiên là tái cấu trúc cơ sở dữ liệu và phân tách cơ sở dữ liệu logic.  Xin lưu ý rằng cuộc thảo luận trong bài giảng này chỉ áp dụng cho cơ sở dữ liệu quan hệ.

4
00:00:29,010 --> 00:00:46,740
Mặc dù mẫu cơ sở dữ liệu dùng chung được coi là Antipater trong bối cảnh các dịch vụ vi mô, nhưng có thể đôi khi các nhóm dịch vụ vi mô sẽ không linh hoạt sử dụng mẫu cơ sở dữ liệu riêng biệt và có thể có nhiều lý do dẫn đến việc đó.

5
00:00:47,130 --> 00:01:02,310
Dưới đây là một số lý do phổ biến mà tôi thấy được trích dẫn vì không sử dụng cơ sở dữ liệu riêng biệt.  Hạn chế về thời gian, hạn chế về ngân sách, thiếu nguồn lực quy mô và sự phức tạp của cơ sở dữ liệu là một số lý do phổ biến nhất.

6
00:01:02,580 --> 00:01:30,650
Và vì vậy trong kịch bản, các nhóm phải xem xét mẫu cơ sở dữ liệu dùng chung.  Khi sử dụng cơ sở dữ liệu dùng chung, mục tiêu của nhà thiết kế Microsoft là đạt được sự cách ly dữ liệu tối đa trong cùng một phiên bản cơ sở dữ liệu sao cho mỗi phần dữ liệu của Microsoft trong cơ sở dữ liệu và mỗi dịch vụ của Microsoft chỉ có quyền truy cập trực tiếp vào dữ liệu mà nó sở hữu.  .

7
00:01:30,780 --> 00:01:43,720
Nếu có thể, nhà thiết kế của Microsoft nên sử dụng các tính năng cơ sở dữ liệu để đạt được mức độ cách ly cao nhất giữa Microsoft cho biết, về dữ liệu trong phiên bản cơ sở dữ liệu.

8
00:01:44,310 --> 00:01:50,980
Hãy nói về những thách thức khi phá vỡ cơ sở dữ liệu.  Cơ sở dữ liệu lớn không dễ tách rời.

9
00:01:51,090 --> 00:02:07,250
Hãy xem xét cấu trúc cơ sở dữ liệu có khoảng 60 bảng này.  Nếu bạn chỉ nhìn vào sơ đồ này, chúng tôi có thể phân định ranh giới của dữ liệu trong cơ sở dữ liệu này và gán quyền sở hữu các bảng này cho các dịch vụ vi mô.

10
00:02:07,260 --> 00:02:26,370
Nhưng đó không phải là nơi bài tập sẽ kết thúc.  Chúng ta cần xem xét dữ liệu được chia sẻ trên các dịch vụ vi mô, mối quan hệ giữa các bảng và các cột, các quy trình có thể có các câu lệnh tiếp theo được tham chiếu đến nhiều bảng trên cơ sở dữ liệu.

11
00:02:26,730 --> 00:02:33,480
Và sau đó có những yếu tố kích hoạt này cần được quản lý.  Tất cả những khía cạnh này cũng cần được xem xét.

12
00:02:34,920 --> 00:02:41,360
Vì vậy, tại thời điểm này, bạn có thể nghĩ, giải pháp là gì?  Thật không may, không có viên đạn bạc.

13
00:02:41,580 --> 00:02:52,190
Tôi sẽ chia sẻ một số gợi ý với bạn tại đây và bạn sẽ phải tự nghiên cứu cơ sở dữ liệu cụ thể của mình để xác định con đường tốt nhất phía trước.

14
00:02:52,620 --> 00:03:00,270
Tùy chọn đầu tiên là sử dụng tái cấu trúc cơ sở dữ liệu theo phương pháp này.  Các thay đổi được thực hiện đối với cơ sở dữ liệu cơ bản.

15
00:03:00,600 --> 00:03:13,770
Hoặc bạn có thể sử dụng tính năng phân tách logic hoặc cơ sở dữ liệu trong đó cơ sở dữ liệu được sử dụng, cũng như với các ranh giới logic để xác định dữ liệu thuộc sở hữu của các dịch vụ vi mô khác nhau.

16
00:03:14,400 --> 00:03:22,410
Xác định tái cấu trúc cơ sở dữ liệu đã được Scott W. giới thiệu và quảng bá như trong cuốn sách Tái cấu trúc cơ sở dữ liệu của họ.

17
00:03:22,410 --> 00:03:32,750
Tái cấu trúc cơ sở dữ liệu được định nghĩa là một thay đổi nhỏ đối với cơ sở dữ liệu, giúp cải thiện thiết kế của nó mà không thay đổi ngữ nghĩa của nó.

18
00:03:33,030 --> 00:03:50,190
Bây giờ, mục đích của việc tái cấu trúc cơ sở dữ liệu khá khác so với những gì chúng tôi đang cố gắng đạt được ở đây.  Tuy nhiên, thực tiễn được thảo luận trong cuốn sách này hoàn toàn có thể áp dụng được về mặt tối ưu hóa thiết kế cơ sở dữ liệu để sử dụng từ nhiều dịch vụ vi mô.

19
00:03:51,000 --> 00:03:59,130
Những thay đổi được thực hiện đối với cơ sở dữ liệu như một phần của bài tập tái cấu trúc DB có thể được xếp vào một trong sáu danh mục.

20
00:04:00,150 --> 00:04:15,420
Đầu tiên là sự thay đổi về cấu trúc, định nghĩa về các khung nhìn bảng và các cột được thay đổi.  Hãy nghĩ về một bảng có số lượng cột lớn và bảng này được chia thành hai bảng khác nhau.

21
00:04:15,990 --> 00:04:31,440
Và mỗi bảng này thuộc sở hữu của một dịch vụ vi mô khác nhau.  Loại thay đổi tiếp theo là thay đổi về kiến ​​trúc, là thay đổi áp dụng cho phương pháp về cách ứng dụng tương tác với cơ sở dữ liệu.

22
00:04:31,860 --> 00:04:40,740
Tiếp theo là những thay đổi về tính toàn vẹn tham chiếu ở đây.  Mối quan hệ giữa các đối tượng cơ sở dữ liệu được thay đổi.

23
00:04:40,960 --> 00:04:49,230
Ví dụ: bạn có thể xóa mối quan hệ khóa ngoại giữa các bảng thuộc các dịch vụ vi mô khác nhau.

24
00:04:50,230 --> 00:05:00,490
Danh mục phương thức đề cập đến những thay đổi được áp dụng cho thủ tục được lưu trữ, ví dụ: thêm và xóa các tham số khỏi thủ tục được lưu trữ.

25
00:05:01,210 --> 00:05:15,070
Tiếp theo là phép biến đổi, là những thay đổi được áp dụng cho lược đồ cơ sở dữ liệu.  Và điều cuối cùng là chất lượng dữ liệu trong đó các thay đổi được áp dụng để cải thiện chất lượng dữ liệu.

26
00:05:16,200 --> 00:05:23,640
Dưới đây là một ví dụ về tái cấu trúc cấu trúc trong đó cơ sở dữ liệu được thiết kế lại để có nhiều lược đồ.

27
00:05:24,030 --> 00:05:31,540
Mỗi lược đồ này sẽ được bảo vệ bằng các cơ chế kiểm soát truy cập có sẵn trong cơ sở dữ liệu.

28
00:05:32,010 --> 00:05:42,090
Mỗi Microsoft Office sẽ sở hữu và quản lý dữ liệu trong các lược đồ tương ứng của họ.  Bây giờ, nếu bạn hỏi tôi một câu hỏi, bạn sẽ thực hiện nó như thế nào?

29
00:05:42,480 --> 00:05:54,000
Câu trả lời sẽ là nó phụ thuộc vào RDBMS cụ thể mà bạn đang sử dụng.  Không phải tất cả cơ sở dữ liệu đều có thể cung cấp cho bạn cơ chế lược đồ kiểm soát quyền truy cập.

30
00:05:54,720 --> 00:06:04,370
PostgreSQL hỗ trợ lược đồ McCarthyism mà bạn có thể sử dụng để tách dữ liệu, lược đồ nào, như bạn có thể đọc trong liên kết này tại đây.

31
00:06:04,730 --> 00:06:20,970
Có nhiều lý do khiến bạn muốn sử dụng cơ chế lược đồ có sẵn trong PostgreSQL để cho phép nhiều người dùng sử dụng một cơ sở dữ liệu mà không can thiệp lẫn nhau, để tổ chức các đối tượng cơ sở dữ liệu thành các nhóm logic giúp chúng dễ quản lý hơn.

32
00:06:21,330 --> 00:06:29,570
Và thứ ba, các ứng dụng của bên có thể được đặt trong các lược đồ riêng biệt để chúng không thể xung đột với tên của các đối tượng khác.

33
00:06:29,580 --> 00:06:42,240
Và đây chính xác là những gì chúng tôi đang tìm kiếm từ góc độ dịch vụ vi mô.  Tôi khuyên bạn nên thực hiện nghiên cứu về tính khả dụng của các cơ chế như vậy đối với cơ sở dữ liệu mà bạn đang sử dụng.

34
00:06:43,160 --> 00:06:51,670
Hãy thảo luận về tùy chọn số hai, phân tách hợp lý cơ sở dữ liệu trong tùy chọn này, không có thay đổi thiết kế nào được thực hiện đối với cơ sở dữ liệu.

35
00:06:51,950 --> 00:07:03,410
Cơ sở dữ liệu được phân tách một cách hợp lý thành các nhóm bảng và mỗi nhóm bảng được sở hữu và quản lý bởi một dịch vụ vi mô trong kiểu thiết lập này.

36
00:07:03,560 --> 00:07:19,040
Các đội được kỳ vọng sẽ có tính kỷ luật cao.  Ý tưởng là mỗi nhóm sẽ cần đảm bảo rằng họ chỉ truy cập trực tiếp vào dữ liệu của riêng mình và không truy cập trực tiếp vào dữ liệu của các dịch vụ metro khác.

37
00:07:19,220 --> 00:07:34,020
Và điều này rõ ràng là nói dễ hơn làm.  Để giảm thiểu rủi ro các dịch vụ vi mô truy cập trực tiếp vào dữ liệu của nhau, bạn có thể sử dụng các dịch vụ phía trước cơ sở dữ liệu được phân tách hợp lý.

38
00:07:34,500 --> 00:07:42,690
Các dịch vụ này là dịch vụ của chính phủ và chúng cung cấp quyền kiểm soát hoặc chỉ cung cấp bộ bảng hoặc dữ liệu được chỉ định.

39
00:07:42,960 --> 00:07:50,850
Vì vậy, ví dụ: các dịch vụ dành cho Microsoft sẽ thấy sẽ chỉ có các câu lệnh SQL cho bảng X, Y và Z.

40
00:07:51,150 --> 00:08:02,640
Điều này không loại bỏ tất cả các thách thức liên quan đến cơ sở dữ liệu dùng chung nhưng nó cung cấp một cách để kiểm soát quyền sở hữu dữ liệu của mỗi Microsoft.

41
00:08:03,590 --> 00:08:15,880
Chúng ta hãy xem qua tất cả các mẫu liên quan đến cơ sở dữ liệu mà chúng ta đã trình bày cho đến nay.  Quyết định về cách bạn thiết lập cơ sở dữ liệu cho các dịch vụ vi mô của mình sẽ phụ thuộc vào sáng kiến ​​về dịch vụ vi mô của bạn.

42
00:08:16,040 --> 00:08:27,920
Nếu bạn đang thực hiện một sáng kiến ​​mới, nghĩa là không có nợ kỹ thuật và bạn có thể linh hoạt quyết định về công nghệ cũng như thiết kế và kiến ​​trúc của các dịch vụ vi mô của mình.

43
00:08:28,110 --> 00:08:36,520
Bạn nên sử dụng một mẫu cơ sở dữ liệu riêng biệt mà mỗi mẫu của Microsoft sẽ có phiên bản cơ sở dữ liệu riêng.

44
00:08:36,680 --> 00:09:01,490
Mặt khác, bạn đang xử lý một sáng kiến ​​brownfield trong đó bạn phải đánh giá cơ sở dữ liệu hiện có của mình, hiểu chi phí thời gian, hạn chế về nguồn lực, rủi ro và độ phức tạp, đồng thời dựa trên kết quả đánh giá, bạn có thể quyết định sử dụng mẫu cơ sở dữ liệu riêng biệt, trong đó  sẽ yêu cầu bạn chia cơ sở dữ liệu thành nhiều cơ sở dữ liệu.

45
00:09:01,640 --> 00:09:12,880
Điều này có thể thực hiện được đối với cơ sở dữ liệu nhỏ hơn nhưng có thể có những thách thức với cơ sở dữ liệu lớn và phức tạp, trong trường hợp đó bạn cần tiến hành phân tích cơ sở dữ liệu của mình.

46
00:09:12,980 --> 00:09:18,980
Bạn sẽ cần xem xét công nghệ, độ phức tạp, kỹ năng mà bạn có trong nhóm dịch vụ vi mô.

47
00:09:19,340 --> 00:09:28,610
Và sau đó dựa trên kết quả phân tích này, bạn sẽ có hai lựa chọn.  Bạn có thể thực hiện thay đổi thiết kế và thực hiện tái cấu trúc cơ sở dữ liệu.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\10MicroservicesDataManagementPatterns_VVN\000000007.srt -->

1
00:00:00,240 --> 00:00:11,190
Nhược điểm của cơ sở dữ liệu riêng biệt trong bài học này, tôi sẽ đề cập đến những thách thức liên quan đến nhiều cơ sở dữ liệu trên các dịch vụ vi mô.

2
00:00:11,430 --> 00:00:25,160
Tôi cũng sẽ thảo luận về các giải pháp có thể được sử dụng để giải quyết những thách thức này.  Đến cuối bài học này, bạn sẽ có hiểu biết cơ bản về mẫu an toàn nhất, thậm chí tìm nguồn cung ứng và mẫu Saagar.

3
00:00:26,010 --> 00:00:34,900
Nhược điểm đầu tiên của mẫu cơ sở dữ liệu riêng biệt là chi phí tổng thể của giải pháp xét từ góc độ cơ sở dữ liệu sẽ tăng lên.

4
00:00:35,310 --> 00:00:45,630
Có hai yếu tố góp phần vào chi phí từ góc độ cơ sở dữ liệu.  Đầu tiên là nhu cầu cấp phép ngày càng tăng và nhu cầu về phần cứng ngày càng tăng.

5
00:00:45,780 --> 00:00:57,690
Bạn sẽ cần nhiều máy chủ hơn, nhiều bộ nhớ hơn, nhiều mạng hơn để xây dựng nhiều cơ sở dữ liệu.  Yếu tố thứ hai liên quan đến nhu cầu vận hành và bảo trì.

6
00:00:57,990 --> 00:01:09,090
Đối với các cơ sở dữ liệu bổ sung, bạn có thể cần thêm thành viên nhóm để chăm sóc các phiên bản cơ sở dữ liệu mới và bạn cũng sẽ phải đầu tư vào các giải pháp giám sát.

7
00:01:09,420 --> 00:01:16,310
Chỉ cần nhìn vào hình minh họa này, chúng ta có thể ước tính chi phí cơ sở dữ liệu sẽ tăng gấp ba lần.

8
00:01:17,070 --> 00:01:30,240
Hãy thảo luận về những cách mà chúng ta có thể giải quyết một số thách thức liên quan đến chi phí cao hơn này.  Bạn có thể sử dụng cơ sở dữ liệu nguồn mở thay vì phần mềm được cấp phép như của Oracle và Sequel.

9
00:01:30,240 --> 00:01:43,620
Vì vậy, điều đó sẽ giúp bạn tiết kiệm chi phí cấp phép.  Nhưng hãy nhớ, bạn vẫn cần trả tiền cho cơ sở hạ tầng, máy chủ, mạng, bộ lưu trữ để giảm chi phí cho cơ sở hạ tầng.

10
00:01:43,950 --> 00:01:55,350
Người ta có thể sử dụng một con ngựa dùng chung cho nhiều phiên bản cơ sở dữ liệu.  Bằng cách này, tổng chi phí về khả năng tính toán cho cơ sở dữ liệu sẽ giảm xuống.

11
00:01:55,620 --> 00:02:08,610
Một cách rất phổ biến để giải quyết mối lo ngại về chi phí là áp dụng cơ sở dữ liệu gốc trên đám mây.  Ý tưởng ở đây là nhiều nhà cung cấp đám mây ngày nay đang cung cấp cơ sở dữ liệu dưới dạng dịch vụ.

12
00:02:08,610 --> 00:02:26,370
Ví dụ: Amazon A.W.  đã cung cấp 14 loại cơ sở dữ liệu ĐƯỢC XÂY DỰNG MỤC ĐÍCH khác nhau.  Một số cơ sở dữ liệu này, như Amazon, Dinamo DBI là không có máy chủ và chúng rẻ hơn rất nhiều so với việc lưu trữ một cơ sở dữ liệu tương tự trong trung tâm dữ liệu của riêng bạn.

13
00:02:27,210 --> 00:02:35,700
Nhược điểm tiếp theo của mẫu cơ sở dữ liệu này là hiệu suất truy vấn có thể bị giảm do phân phối dữ liệu.

14
00:02:36,240 --> 00:02:58,290
Hãy xem xét ví dụ này khi Microsoft CE cần dữ liệu từ Microsoft và Microsoft đã bị đánh bại.  Trong trường hợp này, tòa án mà Microsoft CE sẽ cần tập hợp lại là nơi lấy dữ liệu từ nó bằng cách gọi một API và sau đó Microsoft có thể thực thi phần tiếp theo để lấy dữ liệu từ cơ sở dữ liệu.

15
00:02:58,440 --> 00:03:18,000
Sau đó, tòa án và Microsoft CE sẽ lấy dữ liệu từ B bằng cách gọi API trên P của Microsoft, từ đó sẽ gọi ra tuyên bố tiếp theo đối với cơ sở dữ liệu sau khi lấy dữ liệu từ B, mã Microsoft C sẽ cần hợp nhất dữ liệu từ đó.  A và B.

16
00:03:18,030 --> 00:03:32,710
Như bạn có thể thấy ở đây, có nhiều lệnh gọi API và nhiều câu lệnh của phần tiếp theo đang diễn ra.  Nếu chúng ta đang sử dụng cơ sở dữ liệu dùng chung, điều này có thể được thực hiện dễ dàng bằng câu lệnh của phần tiếp theo bằng cách sử dụng khớp.

17
00:03:33,870 --> 00:03:42,550
Bây giờ điều này có thể được quản lý bằng cách sao chép dữ liệu cục bộ thông qua sao chép không đồng bộ.  Hãy để tôi giải thích nó hoạt động như thế nào.

18
00:03:42,750 --> 00:03:49,720
Giả sử có Microsoft Office và Microsoft Office.  B, mỗi dịch vụ vi mô này đều có cơ sở dữ liệu riêng.

19
00:03:50,100 --> 00:03:57,990
Giả sử một hành động được thực hiện trên Microsoft Office.  B dẫn đến thay đổi dữ liệu của Microsoft Office.

20
00:03:58,000 --> 00:04:10,220
B, hãy coi nó như việc thực hiện thao tác chèn, cập nhật hoặc xóa phần tiếp theo trên cơ sở dữ liệu của B.  B sẽ hoạt động như một nguồn cân bằng và nó sẽ hoạt động như một người tiêu dùng.

21
00:04:10,350 --> 00:04:22,560
Tất cả thông tin liên quan đến thay đổi trong dữ liệu BEAS sẽ được xuất bản dưới dạng sự kiện và Microsoft Office sẽ đăng ký các sự kiện này khi nhận được sự kiện.

22
00:04:22,620 --> 00:04:43,080
Microsoft có quyền đối với dữ liệu nhận được từ B trong cơ sở dữ liệu của chính mình dưới dạng bản sao chỉ đọc.  Không có thư viện nào được thực thi đối với Microsoft nếu nó có thể gọi câu lệnh bằng nhau này đối với cơ sở dữ liệu cục bộ để tạo phản hồi cho các truy vấn này.

23
00:04:43,290 --> 00:04:52,080
Điều này tạo cơ sở cho các mô hình Securus và thậm chí cả saucing, vốn là đòn bẩy để xây dựng các hệ thống thông lượng cao phức tạp.

24
00:04:52,080 --> 00:04:59,730
Bạn sẽ được học về những bằng sáng chế này trong các bài giảng sau.  Nhược điểm tiếp theo của mẫu cơ sở dữ liệu như vậy là.

25
00:04:59,980 --> 00:05:15,260
Sự phức tạp trong việc quản lý tính toàn vẹn dữ liệu và giao dịch.  Hãy để tôi giải thích điều này bằng một ví dụ.  Giả sử có một cửa hàng mua sắm trực tuyến đang sử dụng kiến ​​trúc dịch vụ vi mô và khách hàng đặt hàng.

26
00:05:15,730 --> 00:05:23,520
Các đơn đặt hàng, dịch vụ của Miko, nhà xuất bản và thậm chí và có hai dịch vụ vi mô đang đăng ký các sự kiện này.

27
00:05:23,530 --> 00:05:32,680
Notifier Micro Service nhận được sự kiện và thông báo cho khách hàng bằng email.  Giả sử hành động này đã thành công.

28
00:05:33,070 --> 00:05:41,770
Dịch vụ vận chuyển khi nhận được bản cập nhật buổi tối, trạng thái bên trong của đơn hàng để cho biết đơn hàng có thể được chuyển đi.

29
00:05:41,980 --> 00:05:49,930
Nhưng trong cuộc thảo luận này, hãy giả sử rằng do một số vấn đề trên cơ sở dữ liệu nên dịch vụ vận chuyển không thành công.

30
00:05:50,410 --> 00:05:59,710
Trong trường hợp này, khách hàng đã thanh toán đơn hàng và nhận được email cho biết đơn hàng đã thành công.

31
00:06:00,160 --> 00:06:11,800
Nhưng thật không may, khách hàng này sẽ không bao giờ nhận được hàng.  Nếu chúng ta xây dựng một hệ thống sử dụng cơ sở dữ liệu dùng chung, giao dịch cục bộ có thể được sử dụng để tránh lỗi như vậy.

32
00:06:12,220 --> 00:06:19,630
Thách thức này có thể được giải quyết bằng cách sử dụng một chuỗi các giao dịch cục bộ với các lần khôi phục phân tán.

33
00:06:19,780 --> 00:06:28,810
Đây là cách nó sẽ hoạt động.  Giả sử một dịch vụ vi mô đã nhận được một giao dịch và nó đã cập nhật thành công giao dịch đó trong cơ sở dữ liệu cục bộ.

34
00:06:28,810 --> 00:06:36,310
Sau đó, nó xuất bản một sự kiện được nhận bởi một dịch vụ vi mô khác thực hiện cập nhật trạng thái cục bộ.

35
00:06:36,460 --> 00:06:42,580
Và trình tự sẽ tiếp tục cho đến khi tất cả các dịch vụ vi mô liên quan đến giao dịch đều thành công.

36
00:06:42,610 --> 00:06:51,190
Bây giờ, đây là một tình huống trong ngày nắng đẹp khi tất cả các dịch vụ vi mô đều cập nhật thành công trạng thái nội bộ của chúng trong cơ sở dữ liệu.

37
00:06:51,580 --> 00:07:04,780
Hãy xem xét một tình huống trong đó một trong các máy chủ vi mô sẽ bị lỗi.  Giả sử khi nhận được sự kiện, hãy cố gắng xử lý nó nhưng không cập nhật được trạng thái nội bộ của nó trong cơ sở dữ liệu.

38
00:07:04,960 --> 00:07:20,320
Trong trường hợp này, C sẽ thông báo cho các dịch vụ vi mô khác bằng cách xuất bản một sự kiện và B khi nhận được lỗi, thậm chí từ C sẽ cập nhật trạng thái nội bộ của chúng bằng cách khôi phục giao dịch.

39
00:07:20,470 --> 00:07:36,880
Cơ chế này liên quan đến việc sử dụng các giao dịch cục bộ nhưng khôi phục phân tán tạo thành cơ sở cho mẫu saga và mẫu tin nhắn đáng tin cậy, chỉ trình bày chi tiết về hai mẫu này trong các bài giảng sau.

40
00:07:37,180 --> 00:07:48,280
Đã đến lúc điểm lại những điểm chính của bài giảng này.  Chi phí cao của các dịch vụ vi mô với cơ sở dữ liệu riêng biệt có thể được giải quyết bằng cách sử dụng cơ sở dữ liệu gốc trên nền tảng đám mây và nguồn mở.

41
00:07:48,280 --> 00:08:04,780
Suy giảm hiệu suất do phân phối dữ liệu có thể được giải quyết bằng mô hình an toàn nhất và thậm chí sự phức tạp trong việc tìm nguồn cung ứng trong tính toàn vẹn và quản lý giao dịch của chúng có thể được giải quyết bằng Saagar và nhắn tin đáng tin cậy.

42
00:08:04,990 --> 00:08:12,220
Trong phần tiếp theo, bạn tìm hiểu về mẫu Securus, thậm chí tìm nguồn cung cấp thông điệp thích hợp và đáng tin cậy cho Saagar.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\001 Need for more Data Patterns.en.srt -->

1

00:00:00,120 --> 00:00:06,690

Consider the scenario in which a micro service is exposing an API, let's say there are multiple consumers



2

00:00:06,690 --> 00:00:10,470

of this API consumer, it is right.



3

00:00:10,740 --> 00:00:18,210

In other words, the API calls are leading to a lot of insert update and delete sequel.



4

00:00:18,210 --> 00:00:23,210

Execution's on the database, whereas consumer B and C are heavy.



5

00:00:23,220 --> 00:00:31,440

In other words, a large portion of the API invocations are leading to the sequel select calls on the



6

00:00:31,440 --> 00:00:32,760

database instance.



7

00:00:32,950 --> 00:00:38,470

Now let's say over a period of time, the load from this consumer started to grow.



8

00:00:38,610 --> 00:00:44,340

So to address the additional load, the micro services team Macario instance scaling.



9

00:00:44,550 --> 00:00:51,870

Now, this would help to a point where the database is able to handle the query traffic from all of



10

00:00:51,870 --> 00:00:52,830

the instances.



11

00:00:53,010 --> 00:01:00,540

What if the query load from the instances exceed the maximum queries that the database can handle,



12

00:01:00,900 --> 00:01:03,780

then the database will become a bottleneck.



13

00:01:04,470 --> 00:01:12,690

One common technique used for addressing the database bottleneck is to separate the database instance



14

00:01:12,690 --> 00:01:17,850

into right optimized and read optimized database instances.



15

00:01:18,060 --> 00:01:25,030

In fact, it is very common to see multiple instances in large scale applications.



16

00:01:25,380 --> 00:01:31,980

Please note that this separation of the database is different from the Sopra database pattern for the



17

00:01:31,980 --> 00:01:33,030

micro services.



18

00:01:33,880 --> 00:01:41,830

Now, this mechanism of separating the databases into read and write optimized instances will work as



19

00:01:41,830 --> 00:01:48,880

long as the data integrity is maintained across the multiple instances of the database.



20

00:01:49,030 --> 00:01:56,560

In other words, when the data gets written to the right optimized database, that data is consistently



21

00:01:56,560 --> 00:02:01,710

reflected across all the copies of the read optimized database.



22

00:02:01,990 --> 00:02:07,100

And to achieve this, there is a need for additional patterns in this section.



23

00:02:07,240 --> 00:02:11,710

I'll be covering multiple data patterns to ensure their integrity.



24

00:02:11,740 --> 00:02:13,660

Across multiple databases.



25

00:02:13,670 --> 00:02:15,910

You will learn command, query separation.



26

00:02:15,920 --> 00:02:22,150

You will learn the command, query responsibility, segregation pattern, even sourcing patterns, and



27

00:02:22,150 --> 00:02:29,860

you will see these patterns in action as part of the implementation of the sales proposal capability.



28

00:02:30,040 --> 00:02:35,140

We will be using Rabbit MQ, both classical and Mongo DB.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\002 Commands Query Separation (CQS).en.srt -->

1

00:00:00,180 --> 00:00:06,060

Commands and queries in this lecture, you learn about commands and queries, you'll also learn about



2

00:00:06,060 --> 00:00:14,340

the command queries, separation principle and I'll discuss some of the realization aspects of the command



3

00:00:14,340 --> 00:00:16,140

query separation principle.



4

00:00:17,010 --> 00:00:19,220

Let's start with some basic terminology.



5

00:00:19,230 --> 00:00:22,320

An operation is either a command or a query.



6

00:00:22,680 --> 00:00:28,740

An operation refers to a message that tells the application of system to do something.



7

00:00:29,130 --> 00:00:37,770

And if this message leads to the change instead of a domain object, then this message is referred to



8

00:00:37,770 --> 00:00:38,550

as a command.



9

00:00:38,880 --> 00:00:47,250

If the intent behind the message is to get the state of the domain object, then that message is referred



10

00:00:47,250 --> 00:00:48,300

to as a query.



11

00:00:48,780 --> 00:00:53,220

A query message does not change the state of a domain model.



12

00:00:53,940 --> 00:00:55,290

So here is an example.



13

00:00:55,290 --> 00:00:56,280

A checking account.



14

00:00:56,430 --> 00:00:58,740

Aggregate the operations.



15

00:00:58,950 --> 00:01:06,540

The deposit and transfer funds are examples of commands that changed the state of the checking account,



16

00:01:06,900 --> 00:01:14,850

whereas the operations, balance and transactions can be used for retrieval of information about the



17

00:01:14,940 --> 00:01:15,800

checking account.



18

00:01:16,080 --> 00:01:17,040

So they are query.



19

00:01:17,220 --> 00:01:21,240

These two operations do not lead to any change.



20

00:01:21,240 --> 00:01:28,440

Instead of the checking account, the command query separation principle, also known as the command



21

00:01:28,440 --> 00:01:37,140

query separation pattern, suggests that the designer of the domain object should demarcate the methods



22

00:01:37,320 --> 00:01:40,050

as either commands or as queries.



23

00:01:40,410 --> 00:01:46,050

In other words, same method cannot be used for both command and queries.



24

00:01:46,260 --> 00:01:54,000

This idea was suggested by Burton Myers in early 2000s, since this principle leads to the simplification



25

00:01:54,000 --> 00:01:55,330

of the domain model.



26

00:01:55,620 --> 00:01:59,760

It has been very well received by the digital practitioners.



27

00:02:00,570 --> 00:02:08,310

Recall that I discussed command as part of the lectures on even storming a command is an action initiated



28

00:02:08,310 --> 00:02:14,250

by user system service or is triggered by some accounts in time.



29

00:02:14,430 --> 00:02:21,300

A command is imperative, meaning that the action or the intent in the command must be carried out in



30

00:02:21,300 --> 00:02:21,840

the domain.



31

00:02:22,080 --> 00:02:25,050

Commands are always named as waps.



32

00:02:25,230 --> 00:02:31,200

I walked you through this example wherein we created commands such as make payment, conform booking



33

00:02:31,230 --> 00:02:32,300

or cancel booking.



34

00:02:32,340 --> 00:02:38,760

Similarly, Reed models, also referred to as the query models, are used for projecting domain data



35

00:02:38,910 --> 00:02:40,490

on the user interface.



36

00:02:41,250 --> 00:02:48,750

The reason behind the command query separation is the fact that there is a different set of concerns



37

00:02:49,110 --> 00:02:54,390

to be kept in mind when you are implementing the command and the query operations.



38

00:02:54,600 --> 00:02:57,120

Let's go back to an example of checking account.



39

00:02:57,810 --> 00:03:04,650

The query operations here need to be performing and they need to be flexible enough to fulfill all the



40

00:03:04,650 --> 00:03:06,390

needs of applications.



41

00:03:06,420 --> 00:03:13,110

At the same time, the command operations deal with complex business logic and they will also need to



42

00:03:13,110 --> 00:03:14,990

work under a unit of work.



43

00:03:15,000 --> 00:03:22,680

In other words, when executed, these command functions should not lead to any kind of data integrity



44

00:03:22,710 --> 00:03:23,310

issues.



45

00:03:23,670 --> 00:03:29,580

And last but not least, these functions also have to deal with the challenges of scalability.



46

00:03:30,270 --> 00:03:37,620

So at this point, you must be clear that commands are the ones that write to a database and the queries



47

00:03:37,620 --> 00:03:40,460

are the ones that read from the databases.



48

00:03:40,470 --> 00:03:47,400

So in this illustration, I'm showing a shared disaster, but it is very much possible to use or write



49

00:03:47,400 --> 00:03:54,150

optimized data stored for commands and read optimized data stored for queries.



50

00:03:54,720 --> 00:04:01,740

Typically, the commands and queries in the sequence pattern are part of the same component and they



51

00:04:01,740 --> 00:04:04,260

are built and managed by a common theme.



52

00:04:05,390 --> 00:04:07,890

Let's go with the key points from this lesson.



53

00:04:08,010 --> 00:04:17,400

Commands represent actions or intent queries, so the domain data and the command query separation patterns



54

00:04:17,400 --> 00:04:25,290

suggests that operation exposed by the domain object should either be a command or a query.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\003 Hands On _ PostgreSQL Database for backend.en.srt -->

1

00:00:00,360 --> 00:00:05,740

Repository for JDBC souls managing the data in PostgreSQL in this lecture.



2

00:00:05,760 --> 00:00:12,600

We're going to create an instance of PostgreSQL, then I'll walk you through the classes, JDBC based



3

00:00:12,600 --> 00:00:14,490

and GBC reports.



4

00:00:14,850 --> 00:00:22,650

And at the end, you will see the two classes in action where we will execute the Java code to write



5

00:00:22,650 --> 00:00:27,930

data into the table that we will create in the Posterous database instance.



6

00:00:28,290 --> 00:00:34,620

The code that I'll walk you through in this lecture is available under the branch data and the prerequisites



7

00:00:34,620 --> 00:00:39,420

for this lecture are you need to have a basic understanding of JDBC.



8

00:00:39,720 --> 00:00:45,360

And Jason, the instruction for testing is available in the not empty file.



9

00:00:45,510 --> 00:00:54,120

And the two classes that we are going to look at are the GBC based or Java and JDBC Report Test or Java.



10

00:00:54,510 --> 00:00:59,010

As a first step, we will be creating an instance of the PostgreSQL database.



11

00:00:59,010 --> 00:01:05,100

Not only are we going to use this instance of the database in this lecture, but also in future lectures,



12

00:01:05,310 --> 00:01:12,790

we will be using the database as a service called LFN sequel to create every instance of the database.



13

00:01:13,320 --> 00:01:20,580

Now you may create the Postgres equal instance locally on your machine or on the cloud, but if you



14

00:01:20,580 --> 00:01:25,110

decide to do that, please note that I won't be able to support you in this course.



15

00:01:25,110 --> 00:01:30,780

We will be using different instance of the database on elephant sequel dot com.



16

00:01:30,780 --> 00:01:33,630

So let's go ahead and create the database.



17

00:01:34,230 --> 00:01:41,760

Go to elephant sickle dot com, click on login, then click on Sign up here.



18

00:01:41,760 --> 00:01:48,810

You would provide your email address, you will receive an email from elephants equal dot com with a



19

00:01:48,810 --> 00:01:50,640

link to set up the account.



20

00:01:50,650 --> 00:01:52,980

Follow the instructions and you will have the account.



21

00:01:53,130 --> 00:01:55,190

I only have the account so I'm going to log in.



22

00:01:55,380 --> 00:01:57,450

You will see a different database.



23

00:01:57,450 --> 00:02:02,700

What we're going to do is we are going to delete that default database by clicking on edit.



24

00:02:02,700 --> 00:02:06,060

Scroll down and you will see that delete instance.



25

00:02:06,060 --> 00:02:13,350

Just copy and paste the name of the database instance in the box here and click on delete confirm the



26

00:02:13,350 --> 00:02:15,630

instance will be deleted as a next step.



27

00:02:15,630 --> 00:02:17,160

We will create an instance.



28

00:02:17,160 --> 00:02:21,000

So click on create new instance, provide the name of the database.



29

00:02:21,000 --> 00:02:22,860

I'm going to call it Achmat Trouble.



30

00:02:23,010 --> 00:02:25,800

Make sure the plan is Tiny Turtle, which is free.



31

00:02:26,010 --> 00:02:27,330

Click on Select Region.



32

00:02:28,080 --> 00:02:30,000

Click the region which is nearest to you.



33

00:02:30,000 --> 00:02:35,310

For me, it's Northern Virginia Review and then help create instance.



34

00:02:35,820 --> 00:02:38,100

And here is our instance now.



35

00:02:38,370 --> 00:02:45,150

So now we have an instance of the Postgres database which are going to use for our testing as a next



36

00:02:45,150 --> 00:02:45,510

step.



37

00:02:45,510 --> 00:02:49,050

I'll walk you to the interface for Elephant sequel.



38

00:02:49,440 --> 00:02:55,650

So click on the name of the database instance and it'll bring you to the detailed screen where you can



39

00:02:55,650 --> 00:02:59,550

see the information on the database instance.



40

00:02:59,550 --> 00:03:05,670

We will use this information to set up our Java class for testing at this time.



41

00:03:06,150 --> 00:03:11,790

Let's click on Groser and here you can interact with the database.



42

00:03:11,790 --> 00:03:14,190

So let's go ahead and create a table.



43

00:03:14,190 --> 00:03:15,690

Create a table.



44

00:03:15,930 --> 00:03:17,880

This is a test table, I'll just call it.



45

00:03:17,880 --> 00:03:26,610

Person will have the person ID, which is an integer generated by default as identity.



46

00:03:26,610 --> 00:03:32,910

So this is an auto generated number and every time we'll insert a new person, it'll increment we'll



47

00:03:32,910 --> 00:03:34,200

have the name of the person.



48

00:03:34,320 --> 00:03:38,400

Let's say it's H.R. 255, not null.



49

00:03:38,730 --> 00:03:45,210

Then we'll have the edge and not null and we will have the primary key person ID.



50

00:03:45,480 --> 00:03:49,770

So this will create the table that we are going to use for testing.



51

00:03:49,770 --> 00:03:57,430

So just execute this create table statement and you will see this box pop up that says Querrey completed.



52

00:03:57,450 --> 00:04:00,570

If it is green, that means the command was successful.



53

00:04:00,840 --> 00:04:03,310

At this time we are ready to insert some rows.



54

00:04:03,330 --> 00:04:09,330

So insert into person name age values.



55

00:04:09,480 --> 00:04:15,360

Let's Joe twenty five click on execute query completed.



56

00:04:15,870 --> 00:04:23,940

Let's select from the person table select start from person execute.



57

00:04:24,330 --> 00:04:26,970

And here is our person here.



58

00:04:27,330 --> 00:04:32,970

I suggest that you plan the browser on your own to get a feel of how PostgreSQL works.



59

00:04:32,970 --> 00:04:41,550

Next, I'll walk you to the Java classes that we will use for interacting with PostgreSQL, the first



60

00:04:41,550 --> 00:04:45,990

class that I'll walk you through is the Getback based class, which is abstract.



61

00:04:46,380 --> 00:04:51,360

This class provides the sequel execution functions.



62

00:04:52,050 --> 00:04:59,160

This equal execution functions return the result in the form of Jason's string instead of returning



63

00:04:59,160 --> 00:04:59,370

it.



64

00:04:59,560 --> 00:05:07,930

As JBC ResultSet Object, and this is to simplify things for folks who are not familiar with JDBC to



65

00:05:07,930 --> 00:05:14,830

test out the Geremek based class, we will use the GETBACK report test class that simply extends the



66

00:05:14,830 --> 00:05:22,390

JDBC based class and executes some sequel's statements against the table we created on our Postgres



67

00:05:22,630 --> 00:05:24,210

database instance.



68

00:05:24,220 --> 00:05:30,640

One important thing to note is that JDBC based class requires you to provide the connection parameters



69

00:05:30,640 --> 00:05:31,750

and the credentials.



70

00:05:31,780 --> 00:05:36,790

These parameters are available on the details page that I showed you earlier.



71

00:05:37,510 --> 00:05:46,630

The abstract JDBC based class is available under Kamden Acme Dot Info PostgreSQL click on the jury VXI



72

00:05:47,020 --> 00:05:47,520

here.



73

00:05:47,830 --> 00:05:54,790

The most important part is the set up of the database connection parameters for your postgrads equal



74

00:05:54,790 --> 00:05:55,320

instance.



75

00:05:55,690 --> 00:06:00,670

So here you need to provide the host both user information and the password.



76

00:06:00,700 --> 00:06:05,920

This information is available on the details page that I showed you earlier.



77

00:06:06,070 --> 00:06:12,520

In this class, you will find that the first thing we are doing is loading the JDBC driver class.



78

00:06:12,880 --> 00:06:20,830

In this class you will find multiple sequel functions and the basic idea behind these sexual functions



79

00:06:21,100 --> 00:06:28,750

is to execute the sexual statements against the database, execute sexual function text as equals statement



80

00:06:28,750 --> 00:06:31,120

and a boolean first element only.



81

00:06:31,120 --> 00:06:38,110

The idea behind this first element only is that if you would like to get only the first record from



82

00:06:38,110 --> 00:06:42,790

a collection of records received from the database, then set this to true.



83

00:06:42,910 --> 00:06:47,890

From the implementation perspective, the first thing we are doing is getting a connection, creating



84

00:06:47,890 --> 00:06:55,570

the school statement, then executing this equals statement, converting the results that received from



85

00:06:55,570 --> 00:07:01,330

the database to Jason by using this utility class JDBC ResultSet to Jason.



86

00:07:01,600 --> 00:07:07,420

If you're interested in knowing how this is implemented, it's available under Kamelot Akhmad utils



87

00:07:07,420 --> 00:07:08,050

package.



88

00:07:08,260 --> 00:07:11,080

Once the results are, let's convert it to Jason.



89

00:07:11,080 --> 00:07:17,920

We are closing the statement and if the first element is true, then we are extracting the first element



90

00:07:17,920 --> 00:07:20,490

and just returning that first element.



91

00:07:20,740 --> 00:07:22,960

Otherwise all of the Jason is returned.



92

00:07:23,230 --> 00:07:25,110

Finally, we are closing the connection.



93

00:07:25,330 --> 00:07:31,630

Now you can go to this class and check out the other execute functions, which are very similar to the



94

00:07:31,630 --> 00:07:33,710

function that I've just walked you through.



95

00:07:34,480 --> 00:07:37,810

Let's go ahead and copy our connection parameters.



96

00:07:37,810 --> 00:07:40,750

Go back to Elephant sequel, click on details.



97

00:07:40,750 --> 00:07:44,110

And from here you need to copy the hostname.



98

00:07:44,110 --> 00:07:48,280

You need to copy report number, which by default is five, four, three, two.



99

00:07:48,490 --> 00:07:50,020

So it shouldn't be changed.



100

00:07:50,020 --> 00:07:52,770

But just in case it changes, make sure you have the right port.



101

00:07:52,860 --> 00:07:58,990

No, pick up the username and then to get the password, just click on this icon here.



102

00:07:58,990 --> 00:08:02,530

It will copy it in the password and just has straight hair.



103

00:08:03,400 --> 00:08:10,740

And now we are ready to test the JDBC base and that we are going to do by using the class and the Condor



104

00:08:11,290 --> 00:08:19,080

Acme door sales model test under the repeal package, you will find JDBC report test.



105

00:08:19,240 --> 00:08:23,010

This class is extending the GBC based class.



106

00:08:23,170 --> 00:08:25,600

And here you will find that I have two functions.



107

00:08:25,750 --> 00:08:33,730

This function will insert a new record in the person table by executing the insert statement that we



108

00:08:33,730 --> 00:08:34,590

are defining here.



109

00:08:35,110 --> 00:08:44,050

It takes name and age as the parameters invokes the execute of the sequel, and that's how it is inserting



110

00:08:44,050 --> 00:08:46,180

in the database table.



111

00:08:46,540 --> 00:08:50,040

This function here selects the person based on the name.



112

00:08:50,260 --> 00:08:58,000

It uses the name in the vehicles and then in walks the Execute sequel function, which is available



113

00:08:58,000 --> 00:08:59,740

in the Getback based class.



114

00:08:59,920 --> 00:09:06,310

In the main function here we are invoking the insert person function with the name and the H, again



115

00:09:06,310 --> 00:09:12,930

calling the insert person function and then calling the select person function, printing out the results.



116

00:09:13,060 --> 00:09:16,300

So let's go ahead and execute it right.



117

00:09:16,300 --> 00:09:20,210

Click on JDBC Report Test and run.



118

00:09:20,350 --> 00:09:25,450

So here are our insert statements and the results from the insert statement.



119

00:09:25,720 --> 00:09:29,670

And then we have this equal statement and result from this equal statement.



120

00:09:29,730 --> 00:09:37,420

Let's go ahead and check out the table in the sequel, rather select star from person execute.



121

00:09:37,420 --> 00:09:45,280

And now we have three rules suggest that you try out making changes to the GBC report test class to



122

00:09:45,280 --> 00:09:52,960

see how the sequels can be executed by using the functions exposed in the Geremek based class.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\004 Realization of Commands & Queries.en.srt -->

1

00:00:00,180 --> 00:00:07,850

Realization of commands and queries in this lesson, I'll talk about how to command and query are implemented.



2

00:00:08,220 --> 00:00:12,390

None are discussed the right and read performance considerations.



3

00:00:12,510 --> 00:00:18,000

And I learned this lesson with the definition of a new term, collaborative domains.



4

00:00:18,570 --> 00:00:24,910

The commands and queries may be exposed by way of Synchronoss as well as asynchronous protocols.



5

00:00:24,930 --> 00:00:30,270

So in this Microsoft, there may be a domain aggregate that is exposing the commands and the queries



6

00:00:30,600 --> 00:00:35,700

which may be invoked by way of SCDP or GRB API.



7

00:00:35,910 --> 00:00:41,430

And some of these commands and queries may also be executed by way of a messaging protocol.



8

00:00:41,730 --> 00:00:47,400

The format of the request and responses for commands and queries is flexible.



9

00:00:47,400 --> 00:00:55,200

It may be Jason CSFI, XML Protocol, Buffa format or any other format that the designer of the microcircuits



10

00:00:55,230 --> 00:00:57,600

finds to be suitable for the requirement.



11

00:00:57,900 --> 00:01:03,120

Ackerman writes to the database and the query reads from the database.



12

00:01:03,360 --> 00:01:09,810

Before the command writes to the database, it needs to translate from the common domain model object



13

00:01:10,140 --> 00:01:13,560

to the language that database understands.



14

00:01:13,770 --> 00:01:19,800

In the context of the commands, the common model is referred to as the right model or sometimes just



15

00:01:19,800 --> 00:01:20,670

right site.



16

00:01:20,790 --> 00:01:27,030

Similarly, when the query is read, the data from the database, it converts from the database representation



17

00:01:27,360 --> 00:01:32,530

to the common domain model object representation in the context of queries.



18

00:01:32,850 --> 00:01:38,080

This common domain model is referred to as the read model or just the read site.



19

00:01:38,900 --> 00:01:41,730

Let's go over the pseudocode for the command and the query.



20

00:01:41,730 --> 00:01:47,450

Processa echo invokes the command which is received by the command processor.



21

00:01:47,450 --> 00:01:54,210

The first thing the command processor does is it converts the request data to domain model as a next



22

00:01:54,210 --> 00:01:54,530

step.



23

00:01:54,900 --> 00:02:02,640

It executes the business logic and then converts the model to the database representation and then writes



24

00:02:02,640 --> 00:02:04,170

the data database.



25

00:02:04,620 --> 00:02:12,210

On the query side, the query processor receives the request and converts the receive request data to



26

00:02:12,360 --> 00:02:13,290

domain model.



27

00:02:13,800 --> 00:02:20,460

Then it gets the data from the database, converts the response data to domain model, and then send



28

00:02:20,460 --> 00:02:22,170

it back to the caller of the query.



29

00:02:22,320 --> 00:02:29,640

One point to note is that in a typical system, a common LeDroit model and a common reader database



30

00:02:29,640 --> 00:02:32,490

is used for both commands and queries.



31

00:02:33,430 --> 00:02:38,500

It is commonly seen that there are more equity requirements than the right requirements.



32

00:02:38,530 --> 00:02:40,540

Let me explain this for an example.



33

00:02:41,170 --> 00:02:49,600

Recall the Microsoft Office for the loan application where we had multiple commands available for the



34

00:02:49,930 --> 00:02:58,390

customer and the loan officer there also had access to some queries to get information about the loan



35

00:02:58,390 --> 00:02:59,170

application.



36

00:02:59,440 --> 00:03:04,610

The data gathered in this Microsoft Office is of interest to multiple stakeholders.



37

00:03:04,630 --> 00:03:12,220

As a result, there may be a need to create additional queries to fulfill the needs of these other stakeholders,



38

00:03:12,430 --> 00:03:18,630

such as the reporting applications, analytics, compliance and many more.



39

00:03:18,850 --> 00:03:27,400

Typically, you would find that systems provide multiple queries that serves up the same data in multiple



40

00:03:27,400 --> 00:03:29,500

formats or multiple views.



41

00:03:29,710 --> 00:03:36,550

The challenge with this is that there is a need for the common model to be changed for meeting all of



42

00:03:36,550 --> 00:03:43,240

these requirements to achieve an optimal performance level for the various read requirements of the



43

00:03:43,240 --> 00:03:44,260

query requirements.



44

00:03:44,590 --> 00:03:51,510

The micro servicers designer needs to think about the index, the need to create in the database.



45

00:03:51,550 --> 00:03:59,230

The challenge with indexing is that it leads to negative impact on the performance of the right no formal



46

00:03:59,240 --> 00:03:59,920

system.



47

00:04:00,220 --> 00:04:07,150

The performance hit on the right may be acceptable, but for Internet scale systems or high volume systems,



48

00:04:07,570 --> 00:04:14,530

the performance may not be acceptable, in which case Ortner Designs may need to be considered.



49

00:04:14,950 --> 00:04:18,340

Next, I'll introduce you to the term collaborative domain.



50

00:04:18,490 --> 00:04:25,510

A collaborative domain is a domain in which multiple actors invoke commands and parallel on the same



51

00:04:25,510 --> 00:04:25,990

data.



52

00:04:26,140 --> 00:04:33,490

Examples of such domains are online bidding, concert ticket reservations and trading systems where



53

00:04:33,490 --> 00:04:40,530

multiple actors are looking at the same data and carrying out certain actions on that data.



54

00:04:40,660 --> 00:04:47,860

Parallel collaborative domains have low tolerance for performance degradation commands and such systems



55

00:04:48,100 --> 00:04:55,010

have complex business logic, and the commands are implemented with final level of granularity.



56

00:04:55,240 --> 00:05:02,530

Also, the business logic and the business rules change frequently in collaborative domains.



57

00:05:02,560 --> 00:05:09,660

The right and the right model need to be adjusted to meet the demands of the collaborative domains.



58

00:05:10,270 --> 00:05:11,830

Time to go over the key points.



59

00:05:12,160 --> 00:05:15,660

Common Model is used for comment and queries.



60

00:05:15,670 --> 00:05:22,000

It is common for most systems to have multiple query requirements, and these multiple query requirements



61

00:05:22,000 --> 00:05:24,850

may need a change in the common model.



62

00:05:25,120 --> 00:05:32,710

Indexes are commonly used for making the queries performant, but that impacts the performance of the



63

00:05:32,860 --> 00:05:33,400

right.



64

00:05:33,640 --> 00:05:41,110

Collaborative domains have little tolerance for performance regulation and so for collaborative domains.



65

00:05:41,350 --> 00:05:46,690

Alternate designs need to be considered for implementing commands in queries.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\005 Hands On _ Build the CQS Pattern.en.srt -->

1

00:00:00,150 --> 00:00:06,840

In this lesson on building and testing command and Querrey, Allfirst discussed the need for a posse



2

00:00:06,840 --> 00:00:07,950

at Acme Travel.



3

00:00:08,370 --> 00:00:15,420

Then I'll walk you through the code in the classes for implementing the command and query.



4

00:00:15,810 --> 00:00:22,580

And at the end of the lecture, you will see the command and query in action before proceeding.



5

00:00:22,590 --> 00:00:28,040

Please make sure that you have already set up an instance of the PostgreSQL database.



6

00:00:28,380 --> 00:00:35,000

It was described in one of the earlier lectures and you should have set up the JDBC based class.



7

00:00:35,190 --> 00:00:42,980

So if you have not done it, please revisit the lecture on setting up the Getback repositories.



8

00:00:43,350 --> 00:00:49,680

The code that I'm going to walk you through in this lecture is available in the get branch data, so



9

00:00:49,680 --> 00:00:57,330

please make sure to check out the branch data before moving forward to demonstrate the working of commands



10

00:00:57,330 --> 00:00:58,110

and queries.



11

00:00:58,440 --> 00:01:06,120

The EITE lead in the Acme sales team decided to build a posse in this posse.



12

00:01:06,330 --> 00:01:13,020

He wanted to create a command which will create a proposal for the customer in the database, and he



13

00:01:13,020 --> 00:01:21,990

wanted to put together some common queries against the proposals and he decided to keep it flexible



14

00:01:22,110 --> 00:01:23,400

for future queries.



15

00:01:23,670 --> 00:01:30,090

So at a high level, he needed to implement the repository for proposal and for customer.



16

00:01:30,330 --> 00:01:38,100

Both these repositories are using the most critical, the command and query, but also use the models



17

00:01:38,220 --> 00:01:40,110

for proposal and customer.



18

00:01:40,160 --> 00:01:44,800

But let's take a look at how Dikili implemented the command and the query.



19

00:01:45,090 --> 00:01:48,210

There are two tables of interest in this database.



20

00:01:48,220 --> 00:01:50,700

The first one is the customer's table.



21

00:01:51,360 --> 00:01:58,020

Customer's table has the customer underscore ID, which is a number that is generated automatically



22

00:01:58,020 --> 00:01:59,640

when the customer is inserted.



23

00:01:59,910 --> 00:02:06,780

Then there is basic information such as name, email, address and phone, and the primary key is customer



24

00:02:07,170 --> 00:02:07,590

ID.



25

00:02:07,800 --> 00:02:10,770

The second table is the proposals table.



26

00:02:10,770 --> 00:02:14,240

It has a primary care proposal on the school ID.



27

00:02:14,430 --> 00:02:16,530

Again, this is an auto generated number.



28

00:02:16,680 --> 00:02:22,830

So what that means is that when a proposal is inserted in the proposals table, a new idea is generated



29

00:02:23,190 --> 00:02:26,050

and assigned to the newly added role in the table.



30

00:02:26,130 --> 00:02:28,320

There is a reference to the customer ID.



31

00:02:28,890 --> 00:02:30,830

Then there is a vacation package idea.



32

00:02:30,900 --> 00:02:35,310

This is the package ID for the vacation for which the proposal is getting created.



33

00:02:35,730 --> 00:02:42,450

Now, instead of maintaining a separate table for passengers, I decided to keep things simple and have



34

00:02:42,450 --> 00:02:50,520

all of the passengers within the proposals table recall that the passenger information is captured in



35

00:02:50,520 --> 00:02:54,330

a very limited format for proposals for the booking confirmation.



36

00:02:54,360 --> 00:02:55,200

It's a different story.



37

00:02:55,200 --> 00:02:59,160

We'll need more information about the passengers, but not for the proposals.



38

00:02:59,280 --> 00:03:00,930

Then there is this foreign key constraint.



39

00:03:01,050 --> 00:03:08,520

That proposal can be created for a customer only if the customer exists in the customer's table.



40

00:03:09,000 --> 00:03:17,040

Next will go ahead and create the table in the database by using the script available under the sequel



41

00:03:17,040 --> 00:03:17,490

folder.



42

00:03:17,700 --> 00:03:20,550

Accommodation proposals detailed or sequel.



43

00:03:21,060 --> 00:03:22,030

It is the script.



44

00:03:22,230 --> 00:03:29,610

Copy the complete script, open up the browser, paste the script in the sequel browser and execute



45

00:03:30,060 --> 00:03:32,040

and our query has completed.



46

00:03:32,040 --> 00:03:35,610

That means our tables have been created as a next step.



47

00:03:36,000 --> 00:03:43,850

We are going to populate these tables with some data by using the script Achmat proposals Dumbledore's



48

00:03:43,850 --> 00:03:44,250

sequel.



49

00:03:44,850 --> 00:03:46,170

So let's go ahead and copy.



50

00:03:46,410 --> 00:03:49,920

Select all control or command.



51

00:03:49,920 --> 00:03:51,030

Save your own Mac.



52

00:03:51,270 --> 00:03:58,980

Go to sequel browser, select all of the earlier script and paste new script and the query completed



53

00:03:58,980 --> 00:03:59,690

successfully.



54

00:04:00,030 --> 00:04:05,910

Now, just to make sure that the tables have been created, just to refresh, click on the table queries.



55

00:04:05,910 --> 00:04:12,990

And as you can see now we have four tables and if I select customer, this generates the sequel that



56

00:04:12,990 --> 00:04:14,070

you can execute.



57

00:04:14,700 --> 00:04:21,570

And as you can see now, we have three customers created in the customer's table that we can use for



58

00:04:21,570 --> 00:04:22,260

our testing.



59

00:04:22,620 --> 00:04:29,190

Recall that the proposals can only be created for the customers that are in this table because of the



60

00:04:29,190 --> 00:04:30,240

foreign key constraint.



61

00:04:30,480 --> 00:04:34,680

So for our testing, we will use customer ID one.



62

00:04:36,040 --> 00:04:42,130

This is the class diagram depicting all of the classes that are part of the PEOC, we have the command



63

00:04:42,130 --> 00:04:45,410

interface, which is implemented by all commands.



64

00:04:45,820 --> 00:04:53,430

This interface exposes one function process, which throws an exception in case of errors.



65

00:04:53,650 --> 00:05:00,580

There is no interface for the queries as they can be many different types of queries needed in the model.



66

00:05:00,850 --> 00:05:07,050

But all query functions that will be implemented as part of the U.S. will through query exceptions.



67

00:05:07,090 --> 00:05:14,050

There are two repositories customer repo and proposal repo, which are extending the JDBC based class.



68

00:05:14,230 --> 00:05:21,280

These repositories are implementing the model interfaces that we define in the sales model.



69

00:05:21,340 --> 00:05:28,060

This is the create proposal command that implements the command interface and uses the repositories.



70

00:05:28,270 --> 00:05:35,470

Similarly, there is this proposal query class that implement multiple query functions and the proposal



71

00:05:35,470 --> 00:05:38,630

query class also uses the repositories for testing.



72

00:05:38,860 --> 00:05:41,890

There are two classes test command and test query.



73

00:05:42,100 --> 00:05:49,180

Once we have up to the court, we will execute the test command to see a proposal created in the database



74

00:05:49,480 --> 00:05:54,160

and when we will run test query, we will be able to query the proposals.



75

00:05:54,310 --> 00:05:57,650

So let's go ahead and take a look at the code in these classes.



76

00:05:57,670 --> 00:06:05,140

Now, here is the command interface and as you can see, it just has one function process and it throws



77

00:06:05,410 --> 00:06:06,430

an exception.



78

00:06:06,670 --> 00:06:10,600

The command exception is simply extending the exception class.



79

00:06:10,600 --> 00:06:16,420

And then we have the query exception that also extends the exception to the customer repository class



80

00:06:16,420 --> 00:06:23,230

is extending the JDBC base and is implementing the customer interface.



81

00:06:23,260 --> 00:06:28,900

I suggest that you go through the code in this class on your own and you will find that it is simply



82

00:06:28,900 --> 00:06:36,610

creating the sequel statements and then executing the sequel statements by using the execute cycle functions



83

00:06:36,610 --> 00:06:39,140

exposed by the base class.



84

00:06:39,250 --> 00:06:46,000

Similarly, there is a proposal repository class which extends the data base and implements the proposal



85

00:06:46,600 --> 00:06:48,150

interface in this class.



86

00:06:48,160 --> 00:06:55,420

Also, you will find that we have sequel's statements getting created and then getting executed by way



87

00:06:55,420 --> 00:06:58,510

of the functions exposed by the GBC based class.



88

00:06:59,140 --> 00:07:03,290

The CREATE proposal command implements the command interface.



89

00:07:03,370 --> 00:07:08,920

So if we look at the process function, you will find that we are not doing much on this in a real implementation.



90

00:07:09,160 --> 00:07:15,250

We would have transformed, transform the request to the model object if needed, will need to validate



91

00:07:15,250 --> 00:07:16,120

the request.



92

00:07:16,120 --> 00:07:21,910

Then we need to implement the business logic and then execute the instructions for the command in this



93

00:07:21,910 --> 00:07:23,090

PEOC implementation.



94

00:07:23,410 --> 00:07:29,920

We are simply creating an instance of the proposal repository and then adding the proposal to the database



95

00:07:30,100 --> 00:07:32,940

by calling on the proposal repository.



96

00:07:33,100 --> 00:07:37,410

And if this is successful, then we are executing the post-processing.



97

00:07:37,870 --> 00:07:44,590

Now, in this implementation, you will find that we are simply printing out a message in the post processing



98

00:07:44,590 --> 00:07:51,970

function and we will be using this function in a later implementation of the command in the proposal



99

00:07:51,970 --> 00:07:52,390

query.



100

00:07:52,390 --> 00:08:00,130

Plus, we have a couple of query functions like get proposal using the proposal ID and get Proposal



101

00:08:00,130 --> 00:08:06,240

for Customer, which returns a collection of proposals for a given customer in the GET proposal.



102

00:08:06,250 --> 00:08:14,860

We are creating an instance of the proposal repository, then getting the proposal with the proposal



103

00:08:14,860 --> 00:08:19,360

ID as the argument after that if the return proposal is null.



104

00:08:19,390 --> 00:08:21,610

That means the proposal will not Fonzo.



105

00:08:21,610 --> 00:08:24,670

We are simply sending back an empty JSON object string.



106

00:08:24,790 --> 00:08:32,530

Otherwise we get the customer reference from the proposal and then create an instance of the customer



107

00:08:32,860 --> 00:08:37,060

repository getting the customer based on the customer reference.



108

00:08:37,090 --> 00:08:42,810

After that, we are converting the proposal and the customer model objects to adjacent.



109

00:08:42,850 --> 00:08:49,690

A big part of the code in this file actually deals with the transformation of model objects to adjacent



110

00:08:49,690 --> 00:08:50,180

string.



111

00:08:50,710 --> 00:08:57,370

Now, I would suggest that you go through the second query function on your own, get proposal for customer



112

00:08:57,370 --> 00:09:02,660

and you will find it is implemented on the same lines as the get proposal function.



113

00:09:02,860 --> 00:09:05,740

Next, I'll walk you to the test command class.



114

00:09:06,010 --> 00:09:07,290

In the test command class.



115

00:09:07,660 --> 00:09:11,230

We are first creating a couple of dummy vacation packages.



116

00:09:11,680 --> 00:09:20,650

Then we are creating a proposal object, creating an instance of the create proposal command class and



117

00:09:20,650 --> 00:09:22,450

then simply calling process.



118

00:09:22,720 --> 00:09:27,640

If this is successful, then a rule will be created in the proposal table.



119

00:09:27,790 --> 00:09:34,780

In the Tuscany class, you will find that in the main function we are creating an instance of the proposal



120

00:09:34,780 --> 00:09:35,180

query.



121

00:09:35,800 --> 00:09:42,610

Then we have these two local variables, proposal ID and customer I.D., which are used to invoke the



122

00:09:42,610 --> 00:09:50,020

queries we can use to get proposal function, to get the data for the specified proposal ID or we can



123

00:09:50,020 --> 00:09:56,530

execute to get proposal for customer to get all the proposals for the customer, changes to local variables



124

00:09:56,620 --> 00:09:58,660

to change the customer and the proposal.



125

00:09:59,320 --> 00:10:04,900

If these queries are successful, then we are simply printing the result.



126

00:10:05,200 --> 00:10:08,290

Let's go ahead and try out the test command.



127

00:10:08,500 --> 00:10:08,830

Right.



128

00:10:08,830 --> 00:10:14,470

Click on the Test Command class and run test command.



129

00:10:14,710 --> 00:10:16,530

The test command was successful.



130

00:10:16,940 --> 00:10:19,810

Let's go ahead and query the data to query.



131

00:10:20,080 --> 00:10:23,400

I click on test query and run test query.



132

00:10:23,590 --> 00:10:31,240

We are getting all of the proposals for the customer and here are all the proposals for the customer.



133

00:10:31,360 --> 00:10:36,580

I suggest that you change the data, create new proposals and try it out on your own.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\006 Command Query Responsibility Segregation (CQRS).en.srt -->

1

00:00:00,210 --> 00:00:07,010

Command, responsibility, segregation, I'll start this lesson by defining security and then I'll go



2

00:00:07,010 --> 00:00:11,140

over the benefits and the realisation considerations for security.



3

00:00:11,800 --> 00:00:20,910

Security stands for command, responsibility, segregation, security applies the security idea to the



4

00:00:20,910 --> 00:00:23,460

main moral rather than operations.



5

00:00:23,910 --> 00:00:31,050

So here, instead of splitting the operations into command and query, the suggestion is to split the



6

00:00:31,050 --> 00:00:35,010

domain model into the command and query models.



7

00:00:35,340 --> 00:00:40,950

The command model is also referred to as the right model, and the query model is referred to as the



8

00:00:40,950 --> 00:00:41,700

Reed model.



9

00:00:42,180 --> 00:00:44,580

This idea was suggested by Greg Young.



10

00:00:44,590 --> 00:00:46,710

You can read more about it at this.



11

00:00:46,710 --> 00:00:53,580

You are a more formal definition of securities that command responsibility.



12

00:00:53,580 --> 00:01:01,020

Segregation suggest the use of separate, read and write models for the realization of collaborative



13

00:01:01,020 --> 00:01:01,550

domains.



14

00:01:01,800 --> 00:01:05,550

I talked about the collaborative domain in the earlier lecture.



15

00:01:05,880 --> 00:01:13,050

So in collaborative domain, the typical characteristics required from the command module are final



16

00:01:13,050 --> 00:01:17,790

granularity and support for ever changing business rules.



17

00:01:18,030 --> 00:01:24,540

Similarly, the desired characteristics for the Reed model are that it should be able to meet different



18

00:01:24,540 --> 00:01:28,710

requirements and provide very high levels of query performance.



19

00:01:29,400 --> 00:01:35,260

To read and write models may use the common instance of the datastore.



20

00:01:35,520 --> 00:01:41,850

This may lead to the loss of ability to optimize the database for reads and writes.



21

00:01:42,310 --> 00:01:44,900

Let me explain it with a common example.



22

00:01:45,360 --> 00:01:53,970

If you create too many indexes on the database, then the performance on the right will degrade and



23

00:01:53,970 --> 00:01:58,560

if you remove indexes from the database, it'll impact the query performance.



24

00:01:58,830 --> 00:02:00,740

So it's kind of a balancing act.



25

00:02:01,110 --> 00:02:07,080

What if there is a need for both the right and the read to be highly performant?



26

00:02:07,470 --> 00:02:14,660

One solution to this problem would be to use independent data stores for the right and the right side.



27

00:02:14,730 --> 00:02:21,600

Not only that, depending on the use cases for the read and the right side, different database technologies



28

00:02:21,600 --> 00:02:27,630

maybe use use of different database technologies within the same domain is sometimes referred to as



29

00:02:27,630 --> 00:02:29,580

the polyglot persistence.



30

00:02:30,030 --> 00:02:35,370

Here's an example of why it makes sense to go with a different database technologies.



31

00:02:35,490 --> 00:02:41,280

Let's say the requirements for the right site is to have asset properties for the transactions, and



32

00:02:41,520 --> 00:02:48,570

the desire is that no indexer should be created on the database tables to achieve high throughput for



33

00:02:48,570 --> 00:02:49,200

the right.



34

00:02:49,200 --> 00:02:55,350

And on the right side, let's say the requirement is to have highly performant relationship queries.



35

00:02:55,350 --> 00:03:05,250

In this scenario, the developers may decide to go with the RDBMS database on the right side and a graph



36

00:03:05,250 --> 00:03:07,380

database on the read site.



37

00:03:07,380 --> 00:03:14,190

So had this set up, the developers will be able to achieve the requirements for both the right and



38

00:03:14,190 --> 00:03:15,150

the right models.



39

00:03:15,330 --> 00:03:22,140

Another advantage of using independent data stores on the right and the right side is that each side



40

00:03:22,350 --> 00:03:24,220

may scale independently.



41

00:03:24,690 --> 00:03:29,580

For example, let's say the developers are dealing with a heavy application.



42

00:03:29,580 --> 00:03:35,370

In that scenario, they have the choice of horizontally scaling the right side.



43

00:03:35,700 --> 00:03:43,260

Or if that does not suffice, then they can consider creating the reader replicas for the reader database



44

00:03:43,290 --> 00:03:44,640

or use sharding.



45

00:03:44,850 --> 00:03:51,540

Since the two sides are independent, actions performed on one side would not impact the other side.



46

00:03:52,560 --> 00:03:59,370

Next, I'll talk about the performance considerations, typically there are more reads than write in



47

00:03:59,370 --> 00:04:00,320

applications.



48

00:04:00,330 --> 00:04:08,280

In my experience, the split between the reads and writes is roughly 85 percent leads to 15 percent



49

00:04:08,280 --> 00:04:08,820

writes.



50

00:04:08,970 --> 00:04:17,010

As a result, application developers are always looking for options to achieve highest rate performance.



51

00:04:17,130 --> 00:04:24,180

Common ways by which it is achieved is by way of caching or by way of materialized views that would



52

00:04:24,180 --> 00:04:32,280

not require model translation or use of complex joints, as the data is only persisted in the format



53

00:04:32,280 --> 00:04:34,590

in which it will be served to the requester.



54

00:04:34,770 --> 00:04:37,130

But sometime this may not suffice.



55

00:04:37,170 --> 00:04:43,560

For example, there may be multiple different types of queries that need to be fulfilled by the reader.



56

00:04:43,580 --> 00:04:50,010

Cite examples of such queries are free text queries and reports from multiple data sources.



57

00:04:50,010 --> 00:04:58,170

In this scenario, same type of database on the right side will not be able to efficiently handle all



58

00:04:58,170 --> 00:04:59,580

different types of queries.



59

00:04:59,820 --> 00:05:08,070

In such cases, we may need to further break the Reid model into independent models and use different



60

00:05:08,070 --> 00:05:08,850

data tools.



61

00:05:09,180 --> 00:05:17,700

So in this example, we may use the ElasticSearch for providing the free text query capabilities and



62

00:05:17,700 --> 00:05:25,890

use a combination of Hadoop and presto for providing a capability for querying data from multiple sources



63

00:05:26,640 --> 00:05:31,640

in certain scenarios involving collaborative and dynamic applications.



64

00:05:31,890 --> 00:05:39,030

There may be a need to frequently make changes to the read and write models for such applications.



65

00:05:39,480 --> 00:05:46,570

One may consider leveraging different teams for managing the read and write models independently.



66

00:05:46,620 --> 00:05:50,280

With this kind of a setup, the teams can manage their own code based.



67

00:05:50,280 --> 00:05:56,310

They do not need to collaborate with other teams to make changes to the code bases that they are managing,



68

00:05:56,730 --> 00:06:01,590

and all other deployments can be independently carried out by the owner team.



69

00:06:01,830 --> 00:06:08,010

Now, this is an extreme case of an application that may have some stringent requirements in terms of



70

00:06:08,010 --> 00:06:11,280

availability, speed to market and performance.



71

00:06:11,690 --> 00:06:16,320

The last thing that I would like to cover in this lecture is a common misconception.



72

00:06:16,950 --> 00:06:23,250

A common misconception is that in domain driven design, you must always use Securus.



73

00:06:23,400 --> 00:06:25,020

And that is not correct.



74

00:06:25,290 --> 00:06:31,020

It all depends on the requirements you have to use case you have and your objectives.



75

00:06:31,470 --> 00:06:37,950

There are certain considerations that you need to keep in mind when deciding between using or not using



76

00:06:37,950 --> 00:06:38,820

the Securus.



77

00:06:39,060 --> 00:06:45,680

The first one is that you must be able to clearly define the advantages of using Securus.



78

00:06:45,690 --> 00:06:52,980

Keep in mind that using the Securus would mean higher cost of the solution and more moving parts and



79

00:06:52,980 --> 00:06:57,470

components that will need to be managed over the lifetime of the application.



80

00:06:57,840 --> 00:07:00,300

Time to go over the key points from this lesson.



81

00:07:00,570 --> 00:07:08,130

You may consider using Securus for collaborative domains with Securus, with Securus, the right side



82

00:07:08,130 --> 00:07:16,280

and the right side may be independently managed from the performance, scalability and changes perspective.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\007 Data Replication between WRITE-READ sides.en.srt -->

1

00:00:00,330 --> 00:00:07,980

Securus, their application in this lesson, I'll talk about whatever application is needed for Securus,



2

00:00:08,370 --> 00:00:14,430

then I will go over the differences between the Synchronoss and asynchronous application and at the



3

00:00:14,430 --> 00:00:19,590

end, I'll discuss the various different application technology options.



4

00:00:19,980 --> 00:00:26,040

When there are two independent data stores for the read and the right side, you would need your application



5

00:00:26,580 --> 00:00:27,770

to state our application.



6

00:00:27,990 --> 00:00:33,940

Maybe Synchronoss or it may be asynchronous in the case of synchronous replication.



7

00:00:34,110 --> 00:00:40,530

There may be some technical challenges as synchronous replication may not be available natively for



8

00:00:40,530 --> 00:00:46,860

the database that you are using, or if you are using different database technologies, it may not even



9

00:00:46,860 --> 00:00:47,760

be possible.



10

00:00:47,760 --> 00:00:53,940

Even with natively available synchronous replication technology, there may be impact on right performance.



11

00:00:54,510 --> 00:00:59,880

Example of a technology that supports synchronous replication is the Amazon.



12

00:00:59,880 --> 00:01:08,100

A.W. has already has databases wherein you may create reader applications in the same region with synchronous



13

00:01:08,100 --> 00:01:08,940

replication.



14

00:01:09,150 --> 00:01:16,230

This kind of mechanism is supported for multiple areas databases such as Postgrads, Equal Mass, Equal



15

00:01:16,230 --> 00:01:17,950

SQL Server and Oracle.



16

00:01:18,300 --> 00:01:22,710

Now let's talk about asynchronous replication in asynchronous replication.



17

00:01:23,130 --> 00:01:30,780

The right side writes to its data store and then some kind of asynchronous replication mechanism kicks



18

00:01:30,780 --> 00:01:36,520

in and picks up the data from the right site and updated on the right side.



19

00:01:36,540 --> 00:01:41,480

As a result, there may be some lags and the data is eventually consistent.



20

00:01:41,640 --> 00:01:48,520

The implication of eventual consistency is that the redecide may not reflect the current state of data.



21

00:01:48,960 --> 00:01:55,560

There are multiple data replication options available, and the decision on which one to use will depend



22

00:01:55,590 --> 00:02:02,130

on the use case and the non-functional requirements, such as the consistency of the data.



23

00:02:02,160 --> 00:02:08,790

So, for example, some applications may not fulfill the requirement if they have eventual consistency



24

00:02:08,790 --> 00:02:09,960

from the read end.



25

00:02:09,960 --> 00:02:14,740

And in that case, you would have to go with some kind of synchronous replication technology.



26

00:02:14,760 --> 00:02:16,860

So let's go over some of the options.



27

00:02:16,860 --> 00:02:23,010

You may use chain data capture technologies that allow you to capture the changes in one data store



28

00:02:23,340 --> 00:02:25,910

and update the other data store.



29

00:02:25,980 --> 00:02:29,190

You may use native application such as Amazon.



30

00:02:29,340 --> 00:02:32,160

A.W. has Artigas MySQL replicas.



31

00:02:32,520 --> 00:02:38,550

You may use third party tools such as Click and A.W. is data migration services.



32

00:02:38,550 --> 00:02:46,200

And then there is the messaging streaming based replication in which the right side omits the data update



33

00:02:46,200 --> 00:02:54,540

as events and the read side receives these units to update its own data store later.



34

00:02:54,540 --> 00:02:59,040

Lecture's in this section will show you this mechanism in action.



35

00:02:59,790 --> 00:03:06,810

In this lesson, I talked about replication of data between the read and the right data stores, which



36

00:03:06,810 --> 00:03:13,200

is needed when you segregate the command and the query and use different data stores.



37

00:03:13,590 --> 00:03:17,340

This application may be synchronous or asynchronous.



38

00:03:17,460 --> 00:03:24,300

You would need to look at your specific requirements and supporting technologies to decide which replication



39

00:03:24,300 --> 00:03:28,320

technology would make more sense for your use case.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\008 Exercise _ ACME CQRS for Proposal.en.srt -->

1

00:00:00,510 --> 00:00:08,460

Implementing proposal management with Securus pattern in this lesson are discussed the various requirements



2

00:00:08,460 --> 00:00:13,170

for the proposal management that makes it a candidate for securities.



3

00:00:13,200 --> 00:00:20,010

I'll also walk you through a component diagram and a sequence diagram for the implementation of ACMS



4

00:00:20,100 --> 00:00:21,900

vacation proposal management.



5

00:00:22,760 --> 00:00:28,690

The decoder that I'm going to walk you through in this lecture is available in the get branch data,



6

00:00:29,150 --> 00:00:34,640

so please make sure to check out the branch data before moving forward.



7

00:00:35,480 --> 00:00:45,080

The idea that Acme is evaluating the applicability of Securus pattern for implementing the proposal



8

00:00:45,080 --> 00:00:51,800

management in order to understand the proposal management better, the ideally decided to interview



9

00:00:51,950 --> 00:00:54,470

various stakeholders at Acme.



10

00:00:55,070 --> 00:01:01,520

John, who is a travel advisor, talked about the fact that Acme is in a highly competitive industry



11

00:01:01,760 --> 00:01:07,370

and performance of its websites and applications matter a lot.



12

00:01:07,520 --> 00:01:13,110

He also informed the idea that business would change almost on a weekly basis.



13

00:01:13,130 --> 00:01:20,480

Chalmers, who is part of the business intelligence team, informed the white elite that Buhr team needs



14

00:01:20,480 --> 00:01:23,030

access to all kind of proposal data.



15

00:01:23,060 --> 00:01:25,190

The new as well as historical.



16

00:01:25,520 --> 00:01:32,030

And he also talked about the fact that management dashboards need to be Real-Time and highly performant



17

00:01:32,180 --> 00:01:39,470

as a lot of decisions made by the leadership at Acme are dependent on these management dashboards.



18

00:01:39,480 --> 00:01:46,040

Jack, from Marketing and Sales, talked about the use of current and historical data to understand



19

00:01:46,040 --> 00:01:47,350

the market trends.



20

00:01:47,870 --> 00:01:55,640

And he also talked about the fact that first access to the data is essential so that ACMC can send out



21

00:01:55,880 --> 00:02:03,710

offers to the customers the attitude, analyze all the information that he has received from these stakeholders



22

00:02:04,010 --> 00:02:10,210

and has decided to implement the proposal management using the Securus pattern.



23

00:02:10,850 --> 00:02:18,650

The reason he decided to go with the Securus pattern is because proposal management has a lot of changing



24

00:02:18,650 --> 00:02:19,910

business requirements.



25

00:02:20,300 --> 00:02:23,570

There are multiple types of read and query requirements.



26

00:02:23,750 --> 00:02:27,650

Very high levels of performance is expected from the region.



27

00:02:27,650 --> 00:02:28,160

Right.



28

00:02:28,240 --> 00:02:37,160

Also, there is an opportunity to achieve competitive advantage by way of managing the proposals using



29

00:02:37,160 --> 00:02:44,030

Securus pattern, because changes to the read and the right would be rolled out independent of each



30

00:02:44,030 --> 00:02:44,330

other.



31

00:02:44,660 --> 00:02:51,950

And that can reduce the time to market and as a result, give a competitive advantage to ACMC.



32

00:02:52,160 --> 00:03:00,140

Next, I'll discuss the proposal management Securus components that the ITV has decided to put together



33

00:03:00,320 --> 00:03:01,040

the proposal.



34

00:03:01,040 --> 00:03:08,630

Securus implementation will be carried out in three independent deployable units, the command, the



35

00:03:08,630 --> 00:03:11,690

even subscriber and the query in the command.



36

00:03:12,020 --> 00:03:17,000

There will be a command which will be used by the human to initiate the command.



37

00:03:17,300 --> 00:03:24,200

The command implementation or the command processor will carry out the execution of the business rules



38

00:03:24,200 --> 00:03:31,730

and the business logic and then write the proposal data to the right side, to the command module on



39

00:03:31,730 --> 00:03:34,490

the creation of the new proposal will also emit.



40

00:03:34,820 --> 00:03:41,480

And even this event will be put in a queue on Robert MQ The Achmea.



41

00:03:41,510 --> 00:03:46,400

It has decided to use Posterous equal for the right side.



42

00:03:46,400 --> 00:03:54,350

DataStore and even subscriber will be a standalone process which will subscribe to the proposal messages



43

00:03:54,500 --> 00:03:57,800

against Rabbitt MQ on receiving the proposal.



44

00:03:57,950 --> 00:04:06,020

Even the subscriber will carry out some processing on it and then add the proposal to the read site



45

00:04:06,110 --> 00:04:06,950

DataStore.



46

00:04:07,130 --> 00:04:11,570

This even subscriber component will act as an anti-corruption layer.



47

00:04:11,720 --> 00:04:20,450

It will convert the right side model to the right side model before adding it to the right side datastore.



48

00:04:20,570 --> 00:04:27,560

On the query side, there will be a query UID which will lead to the invocation of the query against



49

00:04:27,560 --> 00:04:28,070

the query.



50

00:04:28,070 --> 00:04:36,560

Process of this query process will carry out retrieval from the streetside data stored by way of a criteria



51

00:04:36,560 --> 00:04:38,420

based fetch or select.



52

00:04:38,570 --> 00:04:44,980

The ideal that Acme has decided to use Mongo DB for the redecide there.



53

00:04:44,990 --> 00:04:53,900

As to the sequence diagram depicts Enteron processing of a new proposal on the right side and the right



54

00:04:53,900 --> 00:04:54,260

side.



55

00:04:54,260 --> 00:05:01,040

Command is part of the right side and a command is invoked by a human against a user interface.



56

00:05:01,040 --> 00:05:07,340

The user interface creates the command object and then initiate the processing of the command.



57

00:05:07,460 --> 00:05:14,600

The command adds a new proposal to the right side data stored and then publishes a proposal.



58

00:05:14,750 --> 00:05:22,160

Even on the right side, we have two components subscriber and the query subscriber subscribes to.



59

00:05:22,500 --> 00:05:30,080

Proposal, even on receiving the proposal, even if it carries out the processing of the event's payload,



60

00:05:30,090 --> 00:05:38,700

for example, it may transform the event to the retired model and then insert the transformed proposal



61

00:05:38,970 --> 00:05:41,460

into the Redecide DataStore.



62

00:05:42,440 --> 00:05:50,310

A query is invoked by the humans against a user interface, do you execute the query, the query implementation,



63

00:05:50,460 --> 00:05:59,400

execute find or a sequel select against the reader as it receives the data from the data datastore packages



64

00:05:59,400 --> 00:06:03,150

into a response and send it back to the user interface.



65

00:06:04,160 --> 00:06:11,570

The key point from this lesson is that the decision to implement security depends on the use case as



66

00:06:11,570 --> 00:06:16,370

well as the desired LeDroit characteristics in the hands on lecture's.



67

00:06:16,520 --> 00:06:25,160

In this section, you will see the End-To-End implementation of security that I have discussed in this



68

00:06:25,160 --> 00:06:25,670

lesson.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\009 Hands On _ ACME CQRS command implementation.en.srt -->

1

00:00:00,120 --> 00:00:07,350

Securus million test command in this lecture, you will see the command implementation for security



2

00:00:07,350 --> 00:00:08,130

in action.



3

00:00:08,710 --> 00:00:14,300

There are three things that we are going to do was we will set up private MQ four, even messaging.



4

00:00:14,310 --> 00:00:20,880

Then I'll walk you through the code for version two of command implementation and then will test the



5

00:00:20,880 --> 00:00:22,880

version two of command implementation.



6

00:00:22,900 --> 00:00:28,770

Please note that the code that I'll walk you through in this lecture depends on postgrads sequence and



7

00:00:28,770 --> 00:00:29,880

Rabbitt MQ.



8

00:00:30,570 --> 00:00:35,550

In the earlier hands on lecture, I described the implementation within the proposal.



9

00:00:35,550 --> 00:00:41,400

Repo uncustomary, use the postgresql, the command and the query object.



10

00:00:41,550 --> 00:00:49,560

Use the domain model for proposal and customer and the repositories for providing the command and query



11

00:00:49,560 --> 00:00:50,340

functionality.



12

00:00:50,760 --> 00:00:56,670

In this lesson we will extend the implementation within the create proposal.



13

00:00:56,670 --> 00:01:04,620

Command will not only insert the proposal in the database, it will also publish and even to a topic



14

00:01:04,620 --> 00:01:12,270

on Rabbitt MQ since the read side will be different from the right side in this implementation going



15

00:01:12,270 --> 00:01:12,820

forward.



16

00:01:12,960 --> 00:01:16,610

The model depicted here will be referred to as the right model.



17

00:01:16,860 --> 00:01:22,680

Next, I'll walk you through the implementation of the messaging in the clear proposal command.



18

00:01:23,040 --> 00:01:27,030

And the first step we are going to set up are even bus on rabbit.



19

00:01:27,030 --> 00:01:36,000

MQ will set up a Q A topic exchange and a Q binding between the topic exchange and the Q Log into your



20

00:01:36,000 --> 00:01:40,200

rabbit Amcu account and click on Rabbit.



21

00:01:40,330 --> 00:01:50,130

Q Manager go to cuz we will create a new Q So provide a name proposal or reader dot Q and then click



22

00:01:50,130 --> 00:01:52,710

on add Q A Q is added.



23

00:01:52,710 --> 00:01:55,230

So let's go ahead and create a topic exchange.



24

00:01:55,230 --> 00:02:00,120

Click on exchanges, provide the name will call it Acme else topic.



25

00:02:00,120 --> 00:02:01,890

Change the type of topic.



26

00:02:01,890 --> 00:02:06,540

If you already have this exchange you can just delete it and create it again.



27

00:02:06,540 --> 00:02:08,040

Click on ADD Exchange.



28

00:02:08,040 --> 00:02:15,270

Now we need to add the bindings so click on the newly created exchange select to exchange and put the



29

00:02:15,270 --> 00:02:17,850

Q name which is proposal reader.



30

00:02:17,910 --> 00:02:22,110

Q And the routing key will be proposal dot update click on.



31

00:02:22,130 --> 00:02:27,270

Right now we have the rabbit Amcu set up and we are ready to move on to the next step.



32

00:02:28,080 --> 00:02:34,530

Diversion to of create proposal command extends the version one of create proposal command.



33

00:02:34,680 --> 00:02:41,640

The only difference between the two classes is that the words used to override the post-processing function



34

00:02:41,910 --> 00:02:45,870

that I showed you earlier in the post processing function.



35

00:02:46,380 --> 00:02:54,390

The words two of the create proposal command creates the even payload for the new proposal being created



36

00:02:54,660 --> 00:03:02,310

and then publishes the event to a topic on Rabbit Amcu using the of service to test out the version



37

00:03:02,310 --> 00:03:04,230

two of Create Proposal Command.



38

00:03:04,530 --> 00:03:11,880

There is a new class test command version two which executes the create proposal command and it should



39

00:03:11,880 --> 00:03:19,920

lead to the insertion of a arrow and the Postgres database and also in the publishing of the even message



40

00:03:19,920 --> 00:03:28,110

on the Q the version two of the Create Proposal Command extends version one of create proposal command.



41

00:03:28,650 --> 00:03:37,560

The only difference between version one and version two is in the implementation of the execute post-processing.



42

00:03:37,560 --> 00:03:39,530

In the execute post-processing.



43

00:03:39,630 --> 00:03:46,290

We are receiving the proposal, Jason, and then using this proposal, Jason, to create the payload



44

00:03:46,290 --> 00:03:47,310

for the event.



45

00:03:47,310 --> 00:03:54,180

So as you can see here, we are creating the adjacent object for the event by getting the proposal ID



46

00:03:54,390 --> 00:04:02,340

from the proposal idea, Jason, and then creating the repository to get the proposal, converting the



47

00:04:02,340 --> 00:04:09,360

proposal to Jason, getting the customer information from the customer repository, and then creating



48

00:04:09,540 --> 00:04:16,230

the payload for the event after that, simply creating an instance of the purpose of service, providing



49

00:04:16,230 --> 00:04:20,280

at the MQ B parameters and publishing the event.



50

00:04:20,880 --> 00:04:25,770

If everything goes fine, the event data ends up in the event.



51

00:04:25,770 --> 00:04:26,930

Q No.



52

00:04:26,940 --> 00:04:34,560

Before proceeding further, please make sure that you have set up the MQ funeral for Rabbit MPU correctly.



53

00:04:34,560 --> 00:04:41,610

If you don't have it set properly, then you will get an exception or the message may not end up in



54

00:04:41,610 --> 00:04:48,750

the Q Also, if you have any problem, double check the name of the exchange and the topic.



55

00:04:48,750 --> 00:04:54,690

Go to your Rabbit Amcu account and you will find the incorporeal on the details page.



56

00:04:55,050 --> 00:04:59,040

Just copy from here and pasted in this.



57

00:04:59,110 --> 00:05:06,430

Variable to test how the command we will use the test command under the V2 package.



58

00:05:06,610 --> 00:05:15,220

The only difference between the test command implementation under V1 and Rita is that in test command



59

00:05:15,220 --> 00:05:20,890

V two, we are using the version two of the CREATE proposal command.



60

00:05:21,130 --> 00:05:22,930

Rest of the code is the same.



61

00:05:23,170 --> 00:05:26,020

So let's go ahead and execute test command.



62

00:05:26,620 --> 00:05:26,950

Right.



63

00:05:26,950 --> 00:05:28,990

Click around Test Command.



64

00:05:29,270 --> 00:05:37,120

And as you can see here, this time on the execution of the test command, we received the message post-processing



65

00:05:37,120 --> 00:05:40,670

started to check out if the event was published or not.



66

00:05:40,900 --> 00:05:42,280

Let's go to Rabbitt MQ.



67

00:05:42,500 --> 00:05:49,420

Open up the rabbit Amcu manager in Rabbit Amcu manager click on Kyuss and as you can see here we have



68

00:05:49,420 --> 00:05:50,280

one message.



69

00:05:50,830 --> 00:05:52,830

Let's go ahead and read the message.



70

00:05:53,110 --> 00:06:02,050

Click on proposal, read a Q, scroll down and click on Get Message and here is our proposal message



71

00:06:02,200 --> 00:06:04,570

that was published by the command.



72

00:06:04,810 --> 00:06:07,930

I suggest that you try out the command on your own.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\010 Event Sourcing and Event Store considerations.en.srt -->

1

00:00:00,210 --> 00:00:06,990

Even sourcing partner in this lesson, you learn about even sourcing and even stores, and you will



2

00:00:06,990 --> 00:00:11,930

also learn about the benefits of using even sourcing pattern.



3

00:00:12,150 --> 00:00:20,220

Traditional applications use state oriented persistance systems and these state oriented, persistance



4

00:00:20,220 --> 00:00:21,120

based systems.



5

00:00:21,480 --> 00:00:24,820

Only the current state of the object is maintained.



6

00:00:24,990 --> 00:00:30,500

What leads to the current state is the historical information which is not maintained.



7

00:00:30,510 --> 00:00:37,500

For example, in the case of an inventory system, you can always find a number of specific items in



8

00:00:37,500 --> 00:00:38,240

the inventory.



9

00:00:38,370 --> 00:00:46,050

Any time a new item is added to the inventory, the count of the item increases and any time an item



10

00:00:46,050 --> 00:00:49,400

is sold, the count of the items is decreased.



11

00:00:49,800 --> 00:00:54,540

So we are not maintaining how we arrived at the current state.



12

00:00:54,550 --> 00:00:59,060

We are just maintaining the current state of the item in the inventory.



13

00:00:59,190 --> 00:01:06,300

On the other hand, there are even sourced persistance systems which persist all of the state changes.



14

00:01:06,510 --> 00:01:14,150

So as the domain events are received on the Reid side, they get added to the persistent storage.



15

00:01:14,160 --> 00:01:17,820

Let's go over the formal definition of even sourcing.



16

00:01:18,330 --> 00:01:26,730

Even sourcing suggests persisting the domain, even in an even store and using these events for recreating



17

00:01:26,730 --> 00:01:30,420

the state of the domain object at any point in time.



18

00:01:30,930 --> 00:01:38,650

Even store is an apparent only event log use for persisting the received events.



19

00:01:38,790 --> 00:01:44,220

Let me explain even sourcing and even store with an example.



20

00:01:44,910 --> 00:01:52,260

Let's take a look at bank transactions where the roadside purchased the events omitted by the right



21

00:01:52,260 --> 00:02:01,020

site in an event store when the customer carries out a transaction against the bank account and even



22

00:02:01,130 --> 00:02:04,680

is admitted by way of a messaging infrastructure.



23

00:02:05,010 --> 00:02:07,380

So let's look at a couple of transactions.



24

00:02:07,380 --> 00:02:14,550

Let's say the customer deposited hundred dollars and even was omitted and that he went on the right



25

00:02:14,590 --> 00:02:22,650

side, got added to the store further as the transaction started to come in, the even's admitted by



26

00:02:22,650 --> 00:02:26,820

the right side, started to get added to the event store.



27

00:02:27,060 --> 00:02:34,910

The right side can use these events to create the state of the bank account for any date.



28

00:02:35,130 --> 00:02:42,780

For example, if the question is what was the balance of the bank account on the end of the day on May



29

00:02:42,780 --> 00:02:50,100

3rd, these transactions can easily be aggregated to get the balance for the account.



30

00:02:50,460 --> 00:02:56,240

We have hundred dollars plus one hundred dollars, subtract fifty and that is the balance on that account.



31

00:02:56,820 --> 00:02:58,650

Let's take a look at another query.



32

00:02:59,190 --> 00:03:03,390

What was the balance on the end of the day on May 5th?



33

00:03:03,780 --> 00:03:09,960

In this case, we have to consider all of these transactions, carry out the simple mathematics and



34

00:03:09,960 --> 00:03:17,040

we have the balance as two hundred and fifty dollars up with this example, you got an idea as to how



35

00:03:17,040 --> 00:03:25,500

the events are stored and how they can be used for creating the current state or the state of the domain



36

00:03:25,500 --> 00:03:26,160

object.



37

00:03:26,790 --> 00:03:34,410

What obvious concern you may have at this point is that the current state requires aggregation of the



38

00:03:34,440 --> 00:03:38,430

event data and that concern is valid.



39

00:03:38,790 --> 00:03:45,750

Recreating the state from events will lead to bad performance, especially if you have to aggregate



40

00:03:45,990 --> 00:03:50,760

a large number of events to address this concern regarding the performance.



41

00:03:51,000 --> 00:03:57,120

Even saucing implementations manage the current state in a separate data store.



42

00:03:57,210 --> 00:04:03,930

So in the case of the banking example, as events will be received by the redecide, the balance will



43

00:04:03,930 --> 00:04:07,500

be calculated and placed in a separate data store.



44

00:04:07,510 --> 00:04:12,240

So here, for example, on May 1st, the balance in the account was hundred dollars.



45

00:04:12,480 --> 00:04:16,410

And that's reflected in the current state data store.



46

00:04:16,710 --> 00:04:22,560

On May 2nd, another hundred dollars was received, so the balance became two hundred on May 3rd.



47

00:04:22,560 --> 00:04:29,490

Fifty dollars were withdrawn, so the balance became one hundred and fifty and so on and so forth.



48

00:04:29,640 --> 00:04:35,820

The idea is that to query the balance, the event store will not be queried.



49

00:04:36,090 --> 00:04:41,100

Rather, the current state data store will be queried for the balance.



50

00:04:41,250 --> 00:04:47,130

As a result, the performance of the query will be much better compared to the performance of the query



51

00:04:47,280 --> 00:04:50,310

if it was to be done against the event store.



52

00:04:50,550 --> 00:04:58,830

In fact, the right side may create multiple data views for optimizing the query performance.



53

00:04:58,980 --> 00:04:59,580

Please note.



54

00:04:59,850 --> 00:05:07,380

Are the views here are not relational database views, these are data views needed by the consumers



55

00:05:07,380 --> 00:05:08,680

of the site.



56

00:05:09,240 --> 00:05:12,630

Let's go over the benefits of the even sourcing.



57

00:05:13,080 --> 00:05:21,270

The first one is that events may be replayed to create the point in time state multiple Reid models



58

00:05:21,270 --> 00:05:26,210

and views may be derived from the events in the events store.



59

00:05:26,880 --> 00:05:33,650

Even saucing provides an accurate out of the box order thing which is available in the event store.



60

00:05:33,900 --> 00:05:37,140

It also leads to a simplified reconciliation.



61

00:05:37,440 --> 00:05:44,100

The right side and the right side can compare the events to ensure that each side is dealing with the



62

00:05:44,100 --> 00:05:45,660

same set of events.



63

00:05:45,990 --> 00:05:54,360

Even sourcing allows execution of temporal and complex historical queries against the event.



64

00:05:54,370 --> 00:05:59,370

Store security and even sourcing are commonly used together.



65

00:05:59,730 --> 00:06:05,570

The right side publishers' the events that are received by the redecide side added to the event store.



66

00:06:06,060 --> 00:06:12,720

And as these events are flowing, Purpose-built data stores get created and updated.



67

00:06:12,840 --> 00:06:20,340

Since all of the event data is available in the event store, new purpose-built data stores may be added



68

00:06:20,340 --> 00:06:25,950

at any time to meet the specific business requirement for the site.



69

00:06:26,730 --> 00:06:28,290

Not the question then.



70

00:06:28,290 --> 00:06:30,330

Should one use even saucing?



71

00:06:30,510 --> 00:06:33,270

And the answer is it depends on the use case.



72

00:06:33,690 --> 00:06:39,590

You need to evaluate your use case from the even sourcing benefits perspective.



73

00:06:39,870 --> 00:06:46,160

For example, do you have a need for simplification of reconciliation then?



74

00:06:46,170 --> 00:06:48,570

Yes, even saucing may be a good idea.



75

00:06:49,020 --> 00:06:56,600

Or are you looking to create a data store that would support temporal or complex historical queries



76

00:06:56,610 --> 00:06:56,970

then?



77

00:06:56,970 --> 00:07:00,240

Yes, it may be a good idea to go with even sourcing.



78

00:07:00,660 --> 00:07:07,440

On the other hand, if you do not have a need to manage the state changes and you are just interested



79

00:07:07,440 --> 00:07:14,720

in current state of the asset or data, then even sourcing may not give you any benefit.



80

00:07:14,760 --> 00:07:21,840

So long story short, take a look at these benefits and then check out your users to understand if even



81

00:07:21,840 --> 00:07:24,240

sourcing is going to help or not.



82

00:07:24,840 --> 00:07:27,060

Now let's talk about even stoats.



83

00:07:27,060 --> 00:07:34,530

Even stores may be buried on top of any traditional RDBMS or the quality of technology.



84

00:07:34,890 --> 00:07:40,530

And there are also some specialized databases built for even sourcing.



85

00:07:40,740 --> 00:07:49,200

One such database is even stored and you can read more about it at W w w dot, even store dot com.



86

00:07:50,200 --> 00:07:57,510

Time for a quick review of the key points from this lesson, even sword's persistence systems persist.



87

00:07:57,520 --> 00:08:06,130

All state changes to manage the current state of the domain object in a separate data store for performance



88

00:08:06,130 --> 00:08:06,660

reasons.



89

00:08:06,880 --> 00:08:14,290

The benefits of even such persistence is that you would get out of the box audit mechanism, reconciliation



90

00:08:14,290 --> 00:08:17,530

mechanism and support for temporal queries.



91

00:08:18,040 --> 00:08:20,770

Events are stored and even stored.



92

00:08:20,920 --> 00:08:27,100

That may be traditional databases such as RDBMS or an easy call database.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\011 Hands On _ MongoDB for ACME Sales READ side.en.srt -->

1

00:00:00,180 --> 00:00:08,040

Set up Mongo DB for the right side in this lesson, we will create an instance of Modiba database on



2

00:00:08,040 --> 00:00:10,080

cloud dot, mongo DB dot com.



3

00:00:10,530 --> 00:00:13,560

Then I'll walk you through the Mongo DBAs class.



4

00:00:13,650 --> 00:00:17,280

And at the end, we're going to test our Mongo DB setup.



5

00:00:17,520 --> 00:00:22,980

Please note that my intent in this lesson is not to teach Mongo DB for this code.



6

00:00:23,100 --> 00:00:25,200

You're not expected to know Mongo DB.



7

00:00:25,380 --> 00:00:30,570

I'll walk you to the basic operations that we will use in this course.



8

00:00:31,110 --> 00:00:35,780

The Cordarrelle Vorkuta in this lecture is available in the get branch data.



9

00:00:35,790 --> 00:00:39,370

Please make sure to check out the get branch data.



10

00:00:39,690 --> 00:00:45,330

So far we have worked on the right side of our Securus implementation.



11

00:00:45,810 --> 00:00:53,670

In the last Hands-On lecture, the Clear Proposal Command was updated to publish a message to the Rabbit



12

00:00:53,670 --> 00:00:54,240

MQ.



13

00:00:54,240 --> 00:01:00,870

Whenever a new proposal is created, starting from this lecture will focus on the right side that each



14

00:01:00,870 --> 00:01:04,650

side will use Mongo DB for managing the data.



15

00:01:04,650 --> 00:01:12,030

By the end of this lecture, we will have among OTV instance and will have the best class for interacting



16

00:01:12,030 --> 00:01:13,190

with Mongo DB.



17

00:01:14,010 --> 00:01:18,510

We will create a free instance of Mongo DB on cloud dot vongole.



18

00:01:18,510 --> 00:01:22,480

We dot com like elephants, equal cloud dot mongo.



19

00:01:22,560 --> 00:01:27,840

Dot com is a provider of database as a service for Mongo DB.



20

00:01:28,470 --> 00:01:32,820

To create an instance, just go to cloud dot mongo db dot com.



21

00:01:33,670 --> 00:01:40,200

Click on sign up, provide the information, follow the instructions, and you will have an account,



22

00:01:40,900 --> 00:01:43,900

I already have an account, so I'm going to just log in.



23

00:01:44,950 --> 00:01:51,140

Once you have successfully logged in, you may see that there is already a cluster available for use.



24

00:01:51,160 --> 00:01:59,380

If not, then you can click on clusters and then click on build a cluster, pick up the shared cluster,



25

00:01:59,380 --> 00:02:04,330

which is free click on W.S. It will automatically pick up the nearest region to you.



26

00:02:04,430 --> 00:02:07,680

Call all and provide a cluster name.



27

00:02:07,690 --> 00:02:10,550

I'll call this cluster ackmann trouble.



28

00:02:10,630 --> 00:02:17,020

You don't have to create a cluster if you already have one click on Create Cluster and it'll take a



29

00:02:17,020 --> 00:02:18,810

few minutes to create the cluster.



30

00:02:19,160 --> 00:02:21,080

This time the cluster is created.



31

00:02:21,550 --> 00:02:28,060

Now one important thing that I like to show you is the network axis here, cloud, dot, dot com is



32

00:02:28,060 --> 00:02:33,590

automatically detecting your IP address and adding that IP address in the white list.



33

00:02:33,640 --> 00:02:40,420

What that means is that if you try to use the cluster from some of the machine via some other network,



34

00:02:40,450 --> 00:02:42,430

you will get exceptions.



35

00:02:42,580 --> 00:02:44,710

Your application will fail to connect.



36

00:02:44,710 --> 00:02:49,060

And if you would like to make any changes to this IP address, just click on ADD.



37

00:02:49,360 --> 00:02:52,630

Provide the new IP address and that should do the trick.



38

00:02:52,690 --> 00:02:56,830

Now let's go back to the cluster and create some collections.



39

00:02:56,830 --> 00:02:59,950

So come to the cluster click on collections.



40

00:02:59,960 --> 00:03:03,490

Now here in the cluster we will add our own database.



41

00:03:04,000 --> 00:03:07,300

And to do that, just click on Add my own data.



42

00:03:07,480 --> 00:03:12,030

Let's name the database as Achmad Travel and let's create a test collection.



43

00:03:12,040 --> 00:03:16,960

I'll just call it test and we have a collection with the name test as a next step.



44

00:03:16,990 --> 00:03:18,980

We're going to add some documents to it.



45

00:03:19,120 --> 00:03:23,920

Click on insert document and here you can add some data.



46

00:03:23,980 --> 00:03:29,060

I have the name and age and click on Insert and here is our first record.



47

00:03:29,080 --> 00:03:31,930

I suggest that you play with this on your own.



48

00:03:31,940 --> 00:03:40,420

Now we will be using the cluster information for connecting to the database from the Java test classes.



49

00:03:40,660 --> 00:03:45,310

At this point, I suggest that you play a little bit with your database instance.



50

00:03:45,700 --> 00:03:52,680

The abstract McGreavy based class provides the basic operations that can be executed against the McGarvie



51

00:03:52,840 --> 00:03:53,590

instance.



52

00:03:53,740 --> 00:04:01,390

The idea is that repositories that will use Mongo DB will extend the McGreavy based class for testing.



53

00:04:01,570 --> 00:04:09,430

We will use Mongul every protest, which extends the Mongar DV based class and then executes the insert



54

00:04:09,430 --> 00:04:17,530

and find operation against the test collection in the Akhmatova database, the Mongolia based class



55

00:04:17,530 --> 00:04:21,880

is available and AKAM DOT or Info Dot Mongo DB.



56

00:04:22,180 --> 00:04:25,840

You will see that it uses the Mongo DB client.



57

00:04:25,840 --> 00:04:33,070

There is a set of variables that hold the connection parameters for Mongo DB the execute insert function,



58

00:04:33,220 --> 00:04:43,390

insert the adjacent document and Mongo DB collection and the find function finds the collection of documents



59

00:04:43,390 --> 00:04:46,030

that match the specified criteria.



60

00:04:46,030 --> 00:04:49,750

So let's go ahead and make sure that our parameters are good.



61

00:04:49,900 --> 00:04:54,850

Open up the McGreavy console, go to Cluster's and then click on Connect.



62

00:04:55,060 --> 00:04:57,610

Click on the connect to your application.



63

00:04:57,790 --> 00:05:01,690

Then you will see that there is a variable defined in this example.



64

00:05:01,690 --> 00:05:07,060

Copy this and paste it under the variable Mongar TV host.



65

00:05:07,060 --> 00:05:14,980

Copy only the host part and then replace Mongul TV host with your own Mongo DB host and then just remove



66

00:05:14,980 --> 00:05:15,450

this.



67

00:05:15,460 --> 00:05:17,920

So now our host is good at this time.



68

00:05:17,920 --> 00:05:21,340

We need to create a new user in our database to do that.



69

00:05:21,340 --> 00:05:28,780

In the left navigation panel, click on database access and then click on ADD New Database user provide



70

00:05:28,780 --> 00:05:34,060

the name here will call the user repro user said the password for keeping things easy.



71

00:05:34,090 --> 00:05:35,310

I have kept the password.



72

00:05:35,320 --> 00:05:40,270

Same as the user name that is Lepo user scroll down and user.



73

00:05:40,360 --> 00:05:48,250

Now we have the user added to the database and as you will see I already have the repo user as the McGreavy



74

00:05:48,250 --> 00:05:50,890

user and the password as repo user.



75

00:05:51,010 --> 00:05:51,790

One last thing.



76

00:05:51,790 --> 00:05:57,400

Make sure that the database name is Achmea Travel, so click on Kluster.



77

00:05:57,760 --> 00:06:04,990

And as you can see, the name is Acme Travel and now are McGreavy based class is set with the required



78

00:06:04,990 --> 00:06:09,080

parameters for connecting to Mongo DB Democratie.



79

00:06:09,080 --> 00:06:15,070

We report test class extends the Mongo DB base in the main function.



80

00:06:15,070 --> 00:06:23,200

Here we are first creating an instance of the Maghrib test class, then creating a document that we



81

00:06:23,200 --> 00:06:30,520

will be inserting in the test collection and then simply executing the execute insert to insert the



82

00:06:30,520 --> 00:06:32,110

document in the test collection.



83

00:06:32,350 --> 00:06:38,500

If this is successful, we should see a message indicating that the document was inserted in the collection.



84

00:06:38,770 --> 00:06:44,020

In the second step, we are executing the get by name function.



85

00:06:45,010 --> 00:06:53,110

To get the newly inserted document by way of a filter name equal to John now, dysfunction gap by name



86

00:06:53,260 --> 00:06:57,130

is a local function and you may go to this code on your own.



87

00:06:57,160 --> 00:07:02,860

It is simply creating a filter and then finding the document collection, converting it into Jason's



88

00:07:02,860 --> 00:07:06,540

string and turning it back if the retrieval is successful.



89

00:07:06,910 --> 00:07:13,180

And then we are simply printing out the gist and string received from Mongo DB before running this class.



90

00:07:13,210 --> 00:07:16,440

Let's go ahead and clean up our test collection.



91

00:07:16,450 --> 00:07:18,250

So head on collections.



92

00:07:18,250 --> 00:07:22,000

When you will money the collection, then you will see this delete icon.



93

00:07:22,240 --> 00:07:28,210

Just click on it to delete this collection test and now our collection is deleted.



94

00:07:28,390 --> 00:07:36,370

Will go ahead and run our Mongar TV report test by right clicking run Mongo DB Report test.



95

00:07:36,520 --> 00:07:40,630

And as you can see, the first step was successful in the second step.



96

00:07:40,630 --> 00:07:45,760

We have the Jason document with the data from Mongo DB go back to collections.



97

00:07:45,760 --> 00:07:51,880

Here is the data that we just inserted suggest that you try out the Mongo TV based class on your own.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\012 Hands On _ CQRS-v1 Proposal Subscriber.en.srt -->

1

00:00:00,390 --> 00:00:04,440

Iran is building the ACL subscriber by the end of this lesson.



2

00:00:04,740 --> 00:00:11,700

We will have a working subscriber that will act as the anti-corruption law for the Redecide.



3

00:00:11,820 --> 00:00:17,280

I'll walk you through the code and the proposal, read a report, then I'll walk you to the code and



4

00:00:17,280 --> 00:00:24,120

the proposal subscriber and at the end of the lecture will see the proposal subscriber in action.



5

00:00:24,510 --> 00:00:27,750

In this lesson, we will further develop the Reid model.



6

00:00:28,140 --> 00:00:35,340

In the Reid model, there will be a repository implementation that will connect to the Mongo DB A subscriber



7

00:00:35,340 --> 00:00:42,660

will be created for receiving the even messages from Rabbitt Amcu and then the subscriber will use the



8

00:00:42,810 --> 00:00:47,400

repositories to write the events to the Mongo DB.



9

00:00:47,820 --> 00:00:53,880

The proposal reader repo class extends the best class proposal.



10

00:00:53,880 --> 00:01:03,030

Subscriber uses the Pops star service class to receive even messages on receiving the event proposal.



11

00:01:03,030 --> 00:01:11,100

Subscriber uses the proposal reader Rupo to add proposal data to the database collections.



12

00:01:11,220 --> 00:01:17,520

In order to test the setup, we will use the test subscriber, which will launch an instance of the



13

00:01:17,520 --> 00:01:22,380

proposal subscriber to receive messages from Rabbitt MQ.



14

00:01:23,290 --> 00:01:30,910

The proposal to repeal class extends the Mongo DB base, one important point to note here is that this



15

00:01:30,910 --> 00:01:39,130

class is not implementing the proposal interface, and that is because the Redecide is independent of



16

00:01:39,130 --> 00:01:41,410

the model on the right side.



17

00:01:41,500 --> 00:01:47,800

This class deals with two collections, the collection for the proposal events and the collection for



18

00:01:47,800 --> 00:01:50,860

the proposals, the art proposal even function.



19

00:01:51,160 --> 00:01:56,530

And they provided even Gissen in the proposal even's collection.



20

00:01:56,530 --> 00:02:00,430

And the ad proposal adds the provided proposal.



21

00:02:00,440 --> 00:02:03,160

Jason, in the proposals collection.



22

00:02:03,280 --> 00:02:10,060

Then there are some query functions that proposal function finds the proposal in the proposal collection



23

00:02:10,060 --> 00:02:12,310

and returns it as adjacent string.



24

00:02:12,370 --> 00:02:19,240

The GET proposal for customer function finds the collection of proposals for the specified customer



25

00:02:19,240 --> 00:02:22,360

loyalty and returns it as adjacent object.



26

00:02:22,370 --> 00:02:24,690

You may go through this code on your own.



27

00:02:24,700 --> 00:02:31,930

It is simply retrieving the documents from Mongo DB and then converting these documents to adjacent



28

00:02:31,930 --> 00:02:35,450

string before I walk you to the code in the subscriber.



29

00:02:35,740 --> 00:02:39,310

Let's take a look at the structure of the proposal.



30

00:02:39,460 --> 00:02:46,660

Even though there are multiple attribute to the action attribute indicates the action that led to the



31

00:02:46,660 --> 00:02:47,880

omitting of the event.



32

00:02:48,430 --> 00:02:55,390

We have only only created even, but they can be updated as well as removed action and there is timestamp



33

00:02:55,390 --> 00:02:56,090

and good.



34

00:02:56,110 --> 00:03:01,340

The source is the source of the event, which in our case is the clear proposal CAMAC.



35

00:03:01,690 --> 00:03:04,930

And then there is the actual payload of the event.



36

00:03:05,380 --> 00:03:13,020

The proposal subscriber class is the anti-corruption layer that prevents the corruption of the read



37

00:03:13,060 --> 00:03:16,210

site by the models in the right side.



38

00:03:16,420 --> 00:03:23,620

This class takes an instance of the pops up service to subscribe to the events from the proposal related



39

00:03:23,620 --> 00:03:24,190

commands.



40

00:03:24,460 --> 00:03:27,820

The subscription process is defined in the START function.



41

00:03:27,970 --> 00:03:31,570

The first thing that is happening here is a message handler is getting created.



42

00:03:31,600 --> 00:03:36,700

This message handler has passed to the purpose of service for subscription to the messages.



43

00:03:36,700 --> 00:03:42,010

When a message arrives, the first thing that happens is that proposal reader repository is created



44

00:03:42,010 --> 00:03:45,310

and the ad proposal event is invoked on it.



45

00:03:45,460 --> 00:03:50,720

And that leads to the adding of the event to the proposal events collection.



46

00:03:50,740 --> 00:03:57,820

After that, the event is processed by invoking the process proposal event, which is a local function



47

00:03:57,820 --> 00:04:02,320

in this local function to receive Jason's string is converted to adjacent document.



48

00:04:02,330 --> 00:04:08,410

A message is printed on the console and then processing is carried out based on the action.



49

00:04:08,470 --> 00:04:13,810

Now the action that can be taken on the proposal is created, updated and removed.



50

00:04:14,110 --> 00:04:18,280

And this implementation we are just focusing on creating the proposal.



51

00:04:18,280 --> 00:04:25,990

Data is extracted from the urine payload and then added to the proposal collection using the proposal



52

00:04:25,990 --> 00:04:26,770

reader REPL.



53

00:04:27,740 --> 00:04:34,340

Its subscriber is available under the tax Securus V2 package in the test subscriber.



54

00:04:34,370 --> 00:04:41,390

We need to provide the MQ connection parameters and in the main function, we are creating an instance



55

00:04:41,390 --> 00:04:47,570

of the purpose of service, creating an instance of this subscriber and calling stock on it.



56

00:04:47,660 --> 00:04:51,440

Now, let's go ahead and set up our AQAP parameters.



57

00:04:51,620 --> 00:04:59,490

Open up your rabbit Amcu details and on the details page you will see the MQ bureau just copy the Occupy



58

00:04:59,510 --> 00:05:04,610

Wall and replace the Eurail that we already have in the code.



59

00:05:04,760 --> 00:05:07,010

And that is what you need to do.



60

00:05:07,010 --> 00:05:15,410

And now I'm assuming that you have already created the Acme Sales Coppock exchange and the binding between



61

00:05:15,410 --> 00:05:16,580

the proposal.



62

00:05:16,580 --> 00:05:18,400

Q and the exchange.



63

00:05:18,650 --> 00:05:21,470

This was discussed in one of the earlier lectures.



64

00:05:21,620 --> 00:05:24,050

At this time we are ready to test.



65

00:05:24,900 --> 00:05:28,270

To test, the subscriber will first launched the test subscriber.



66

00:05:28,590 --> 00:05:30,780

Then we will execute the test command.



67

00:05:30,960 --> 00:05:36,690

This will lead to the end of the evening, which will be received by the test subscriber, and then



68

00:05:36,870 --> 00:05:41,550

we will check if the subscriber added the data to the collections or not.



69

00:05:41,790 --> 00:05:46,430

So let's go ahead and launch the test subscriber launched a test subscriber.



70

00:05:46,500 --> 00:05:46,920

Right.



71

00:05:46,920 --> 00:05:54,030

Click on the Test subscriber and run test subscriber once the subscriber has launched Execute the test



72

00:05:54,030 --> 00:05:56,000

command run test command.



73

00:05:56,280 --> 00:06:04,170

And once the command has executed, we will see a message in the console on the subscriber end.



74

00:06:04,170 --> 00:06:07,370

And here is the message received proposal.



75

00:06:07,380 --> 00:06:14,310

Even so, in our third step, we need to check if the data was added to the Mongar DB or not.



76

00:06:14,340 --> 00:06:16,230

So open up your collections.



77

00:06:16,260 --> 00:06:17,110

Refresh.



78

00:06:17,130 --> 00:06:22,290

And here are two new collections proposal, even store and proposals.



79

00:06:22,470 --> 00:06:27,650

This is the data that the subscriber has added to the proposal, even store.



80

00:06:28,020 --> 00:06:34,470

And if we look at the proposals collection, we will see the data just for the proposal.



81

00:06:34,500 --> 00:06:38,580

So at this point, are subscribers working as expected?

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11 Microservices DB Performance Management\013 Hands On _ CQRS-v2 Read side Query.en.srt -->

1

00:00:00,250 --> 00:00:03,480

Securus redecide query in this lecture.



2

00:00:03,510 --> 00:00:10,710

I'll walk you through the implementation of the version two of proposal query and then we will test



3

00:00:10,710 --> 00:00:13,010

out the version two of proposal query.



4

00:00:13,560 --> 00:00:20,610

So far, our Securus implementation is in the state where we have a subscriber receiving the events



5

00:00:20,610 --> 00:00:23,060

and populating the McGreavy collections.



6

00:00:23,610 --> 00:00:31,410

Now we are going to introduce the query component, which will provide the functionality to query the



7

00:00:31,410 --> 00:00:34,350

proposals from the McGreavy collections.



8

00:00:34,830 --> 00:00:42,300

Devotion to a proposal query exposes the same query functions as wasn't one of proposal query proposal



9

00:00:42,300 --> 00:00:43,560

query class users.



10

00:00:43,560 --> 00:00:49,950

The proposal reader repo to execute queries against the Mongo DB collections for testing out the proposal



11

00:00:49,950 --> 00:00:50,310

query.



12

00:00:50,550 --> 00:00:53,790

We will use the version two of the test query.



13

00:00:53,790 --> 00:00:57,900

Plus, here is the implementation of the proposal query class.



14

00:00:58,020 --> 00:01:05,550

The Gap proposal function takes the proposal idy as an argument and returns the Jasons chain for the



15

00:01:05,550 --> 00:01:06,120

proposal.



16

00:01:06,210 --> 00:01:13,410

First thing it is doing is creating the instance of proposal repo and then invoking the get proposal



17

00:01:13,650 --> 00:01:18,680

on the repo object returning the Jason received from the repo object.



18

00:01:18,690 --> 00:01:26,490

Similarly, in the GET proposal for customer the customer, it is received as the argument an instance



19

00:01:26,490 --> 00:01:34,040

of the proposal reader repo is created to get proposals for customer is invoked on the repo object and



20

00:01:34,060 --> 00:01:41,580

the adjacent is returned to the main function in the test query class first creates the proposal query



21

00:01:41,580 --> 00:01:47,570

class object and then calls the query functions on the query object.



22

00:01:47,580 --> 00:01:55,110

Here we are getting all of the proposals for the customer is equal to one and then printing out the



23

00:01:55,260 --> 00:01:55,910

received.



24

00:01:55,920 --> 00:01:59,130

Jason, let's go ahead and run test query.



25

00:01:59,130 --> 00:02:01,580

Right, click on test query and run.



26

00:02:01,590 --> 00:02:03,990

And here is the result from the query.



27

00:02:04,230 --> 00:02:09,900

One thing that you would note here is that the adjacent structure for version two of the query is different



28

00:02:09,900 --> 00:02:15,120

from the adjacent structure of the version, one of query implementation.



29

00:02:15,390 --> 00:02:19,620

And so the idea is that read model may be different from the right model.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000001.srt -->

1
00:00:00,120 --> 00:00:10,470
Hãy xem xét tình huống trong đó một dịch vụ vi mô hiển thị một API, giả sử có nhiều người tiêu dùng API này, điều đó đúng.

2
00:00:10,740 --> 00:00:23,210
Nói cách khác, các lệnh gọi API đang dẫn đến rất nhiều phần tiếp theo được chèn và xóa.  Việc thực thi trên cơ sở dữ liệu, trong khi người tiêu dùng B và C rất nặng.

3
00:00:23,220 --> 00:00:32,760
Nói cách khác, phần lớn các lệnh gọi API đang dẫn đến các lệnh gọi chọn tiếp theo trên phiên bản cơ sở dữ liệu.

4
00:00:32,950 --> 00:00:44,340
Bây giờ, giả sử trong một khoảng thời gian, tải từ người tiêu dùng này bắt đầu tăng lên.  Vì vậy, để giải quyết tải bổ sung, nhóm dịch vụ vi mô Macario sẽ mở rộng quy mô phiên bản.

5
00:00:44,550 --> 00:00:52,830
Bây giờ, điều này sẽ giúp cơ sở dữ liệu có thể xử lý lưu lượng truy vấn từ tất cả các phiên bản.

6
00:00:53,010 --> 00:01:03,780
Điều gì sẽ xảy ra nếu tải truy vấn từ các phiên bản vượt quá truy vấn tối đa mà cơ sở dữ liệu có thể xử lý thì cơ sở dữ liệu sẽ trở thành nút cổ chai.

7
00:01:04,470 --> 00:01:17,850
Một kỹ thuật phổ biến được sử dụng để giải quyết tắc nghẽn cơ sở dữ liệu là tách phiên bản cơ sở dữ liệu thành các phiên bản cơ sở dữ liệu được tối ưu hóa và đọc được tối ưu hóa phù hợp.

8
00:01:18,060 --> 00:01:33,030
Trên thực tế, việc thấy nhiều trường hợp trong các ứng dụng quy mô lớn là điều rất bình thường.  Xin lưu ý rằng việc tách cơ sở dữ liệu này khác với mẫu cơ sở dữ liệu Sopra dành cho các dịch vụ vi mô.

9
00:01:33,880 --> 00:01:48,880
Giờ đây, cơ chế tách cơ sở dữ liệu thành các phiên bản được tối ưu hóa đọc và ghi này sẽ hoạt động miễn là tính toàn vẹn của dữ liệu được duy trì trên nhiều phiên bản của cơ sở dữ liệu.

10
00:01:49,030 --> 00:02:01,710
Nói cách khác, khi dữ liệu được ghi vào cơ sở dữ liệu được tối ưu hóa phù hợp, dữ liệu đó sẽ được phản ánh nhất quán trên tất cả các bản sao của cơ sở dữ liệu được tối ưu hóa việc đọc.

11
00:02:01,990 --> 00:02:11,710
Và để đạt được điều này, cần có thêm các mẫu trong phần này.  Tôi sẽ đề cập đến nhiều mẫu dữ liệu để đảm bảo tính toàn vẹn của chúng.

12
00:02:11,740 --> 00:02:29,860
Trên nhiều cơ sở dữ liệu.  Bạn sẽ học lệnh, phân tách truy vấn.  Bạn sẽ tìm hiểu lệnh, trách nhiệm truy vấn, mẫu phân tách, thậm chí cả mẫu tìm nguồn cung ứng và bạn sẽ thấy các mẫu này hoạt động như một phần của quá trình triển khai khả năng đề xuất bán hàng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000002.srt -->

1
00:00:00,180 --> 00:00:16,140
Các lệnh và truy vấn trong bài giảng này, bạn tìm hiểu về các lệnh và truy vấn, bạn cũng sẽ tìm hiểu về các truy vấn lệnh, nguyên tắc phân tách và tôi sẽ thảo luận về một số khía cạnh hiện thực hóa của nguyên tắc phân tách truy vấn lệnh.

2
00:00:17,010 --> 00:00:28,740
Hãy bắt đầu với một số thuật ngữ cơ bản.  Một thao tác là một lệnh hoặc một truy vấn.  Một thao tác đề cập đến một thông báo yêu cầu ứng dụng của hệ thống thực hiện một điều gì đó.

3
00:00:29,130 --> 00:00:38,550
Và nếu thông báo này dẫn đến sự thay đổi thay vì một đối tượng miền thì thông báo này được gọi là lệnh.

4
00:00:38,880 --> 00:00:48,300
Nếu mục đích đằng sau thông báo là lấy trạng thái của đối tượng miền thì thông báo đó được gọi là truy vấn.

5
00:00:48,780 --> 00:00:56,280
Thông báo truy vấn không thay đổi trạng thái của mô hình miền.  Vì vậy, đây là một ví dụ.  Một tài khoản kiểm tra.

6
00:00:56,430 --> 00:01:15,800
Tổng hợp các thao tác.  Tiền gửi và chuyển tiền là ví dụ về các lệnh thay đổi trạng thái của tài khoản séc, trong khi các hoạt động, số dư và giao dịch có thể được sử dụng để truy xuất thông tin về tài khoản séc.

7
00:01:16,080 --> 00:01:40,050
Vì vậy, họ là truy vấn.  Hai hoạt động này không dẫn đến bất kỳ thay đổi nào.  Thay vì tài khoản kiểm tra, nguyên tắc phân tách truy vấn lệnh, còn được gọi là mẫu phân tách truy vấn lệnh, gợi ý rằng người thiết kế đối tượng miền nên phân định các phương thức dưới dạng lệnh hoặc dưới dạng truy vấn.

8
00:01:40,410 --> 00:01:55,330
Nói cách khác, không thể sử dụng cùng một phương pháp cho cả lệnh và truy vấn.  Ý tưởng này được Burton Myers đề xuất vào đầu những năm 2000, vì nguyên tắc này dẫn đến việc đơn giản hóa mô hình miền.

9
00:01:55,620 --> 00:02:14,250
Nó đã được các nhà thực hành kỹ thuật số đón nhận rất nồng nhiệt.  Hãy nhớ lại rằng tôi đã thảo luận về lệnh như một phần của bài giảng về việc gửi lệnh thậm chí là một hành động được khởi tạo bởi dịch vụ hệ thống của người dùng hoặc được một số tài khoản kích hoạt kịp thời.

10
00:02:14,430 --> 00:02:21,840
Lệnh mang tính bắt buộc, nghĩa là hành động hoặc ý định trong lệnh phải được thực hiện trong miền.

11
00:02:22,080 --> 00:02:32,300
Các lệnh luôn được đặt tên là waps.  Tôi đã hướng dẫn bạn qua ví dụ này, trong đó chúng tôi đã tạo các lệnh như thanh toán, tuân thủ đặt chỗ hoặc hủy đặt chỗ.

12
00:02:32,340 --> 00:02:40,490
Tương tự, các mô hình Reed, còn được gọi là mô hình truy vấn, được sử dụng để chiếu dữ liệu miền lên giao diện người dùng.

13
00:02:41,250 --> 00:02:54,390
Lý do đằng sau việc tách biệt truy vấn lệnh là thực tế có một loạt mối quan tâm khác cần lưu ý khi bạn triển khai lệnh và các hoạt động truy vấn.

14
00:02:54,600 --> 00:03:06,390
Hãy quay lại ví dụ về tài khoản séc.  Các hoạt động truy vấn ở đây cần phải được thực hiện và chúng cần đủ linh hoạt để đáp ứng mọi nhu cầu của ứng dụng.

15
00:03:06,420 --> 00:03:14,990
Đồng thời, các hoạt động lệnh xử lý logic kinh doanh phức tạp và chúng cũng sẽ cần phải hoạt động theo một đơn vị công việc.

16
00:03:15,000 --> 00:03:23,310
Nói cách khác, khi được thực thi, các hàm lệnh này sẽ không dẫn đến bất kỳ loại vấn đề nào về tính toàn vẹn dữ liệu.

17
00:03:23,670 --> 00:03:40,460
Và cuối cùng nhưng không kém phần quan trọng, các chức năng này cũng phải đối mặt với những thách thức về khả năng mở rộng.  Vì vậy, tại thời điểm này, bạn phải hiểu rõ rằng các lệnh là những lệnh ghi vào cơ sở dữ liệu và các truy vấn là những lệnh đọc từ cơ sở dữ liệu.

18
00:03:40,470 --> 00:03:54,150
Vì vậy, trong hình minh họa này, tôi đang trình bày một thảm họa chung, nhưng rất có thể sử dụng hoặc ghi dữ liệu được tối ưu hóa được lưu trữ cho các lệnh và đọc dữ liệu được tối ưu hóa được lưu trữ cho các truy vấn.

19
00:03:54,720 --> 00:04:04,260
Thông thường, các lệnh và truy vấn trong mẫu trình tự là một phần của cùng một thành phần và chúng được xây dựng và quản lý theo một chủ đề chung.

20
00:04:05,390 --> 00:04:25,290
Chúng ta hãy đi với những điểm chính từ bài học này.  Các lệnh thể hiện các hành động hoặc truy vấn ý định, do đó, dữ liệu miền và các mẫu phân tách truy vấn lệnh gợi ý rằng hoạt động được đối tượng miền hiển thị phải là một lệnh hoặc một truy vấn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000003.srt -->

1
00:00:00,360 --> 00:00:14,490
Kho lưu trữ dành cho những người JDBC quản lý dữ liệu trong PostgreSQL trong bài giảng này.  Chúng ta sẽ tạo một phiên bản PostgreSQL, sau đó tôi sẽ hướng dẫn bạn qua các lớp, báo cáo dựa trên JDBC và GBC.

2
00:00:14,850 --> 00:00:27,930
Và ở phần cuối, bạn sẽ thấy hai lớp hoạt động trong đó chúng ta sẽ thực thi mã Java để ghi dữ liệu vào bảng mà chúng ta sẽ tạo trong phiên bản cơ sở dữ liệu Posterous.

3
00:00:28,290 --> 00:00:39,420
Mã mà tôi sẽ hướng dẫn bạn trong bài giảng này có sẵn theo dữ liệu nhánh và điều kiện tiên quyết cho bài giảng này là bạn cần có hiểu biết cơ bản về JDBC.

4
00:00:39,720 --> 00:00:54,120
Và Jason, hướng dẫn kiểm tra có sẵn trong tệp không trống.  Và hai lớp mà chúng ta sẽ xem xét là GBC dựa trên Java và Kiểm tra báo cáo JDBC hoặc Java.

5
00:00:54,510 --> 00:01:12,790
Bước đầu tiên, chúng ta sẽ tạo một phiên bản của cơ sở dữ liệu PostgreSQL.  Chúng ta không chỉ sử dụng phiên bản cơ sở dữ liệu này trong bài giảng này mà còn trong các bài giảng sau này, chúng ta sẽ sử dụng cơ sở dữ liệu như một dịch vụ có tên là phần tiếp theo của LFN để tạo mọi phiên bản của cơ sở dữ liệu.

6
00:01:13,320 --> 00:01:25,110
Bây giờ bạn có thể tạo phiên bản tương đương Postgres cục bộ trên máy của mình hoặc trên đám mây, nhưng nếu bạn quyết định làm điều đó, xin lưu ý rằng tôi sẽ không thể hỗ trợ bạn trong khóa học này.

7
00:01:25,110 --> 00:01:33,630
Chúng tôi sẽ sử dụng phiên bản khác của cơ sở dữ liệu trên phần tiếp theo của voi dot com.  Vì vậy, hãy tiếp tục và tạo cơ sở dữ liệu.

8
00:01:34,230 --> 00:01:50,640
Vào trang con voi liềm dot com, nhấp vào đăng nhập, sau đó nhấp vào Đăng ký tại đây.  Bạn sẽ cung cấp địa chỉ email của mình, bạn sẽ nhận được email từ voi bằng dot com kèm theo liên kết để thiết lập tài khoản.

9
00:01:50,650 --> 00:01:55,190
Làm theo hướng dẫn là bạn sẽ có tài khoản.  Tôi chỉ có tài khoản nên tôi sẽ đăng nhập.

10
00:01:55,380 --> 00:02:02,700
Bạn sẽ thấy một cơ sở dữ liệu khác.  Những gì chúng ta sẽ làm là xóa cơ sở dữ liệu mặc định đó bằng cách nhấp vào chỉnh sửa.

11
00:02:02,700 --> 00:02:15,630
Cuộn xuống và bạn sẽ thấy trường hợp xóa đó.  Chỉ cần sao chép và dán tên của phiên bản cơ sở dữ liệu vào hộp ở đây và nhấp vào xóa để xác nhận phiên bản sẽ bị xóa trong bước tiếp theo.

12
00:02:15,630 --> 00:02:22,860
Chúng tôi sẽ tạo một ví dụ.  Vì vậy hãy nhấp vào tạo phiên bản mới, cung cấp tên của cơ sở dữ liệu.  Tôi sẽ gọi nó là Rắc rối Achmat.

13
00:02:23,010 --> 00:02:30,000
Đảm bảo gói là Tiny Turtle, miễn phí.  Bấm vào Chọn khu vực.  Nhấp vào khu vực gần bạn nhất.

14
00:02:30,000 --> 00:02:45,510
Đối với tôi, đó là Northern Virginia Review và sau đó giúp tạo instance.  Và đây là ví dụ của chúng tôi bây giờ.  Vì vậy, bây giờ chúng ta có một phiên bản của cơ sở dữ liệu Postgres sẽ được sử dụng cho bước thử nghiệm tiếp theo của chúng ta.

15
00:02:45,510 --> 00:02:59,550
Tôi sẽ hướng dẫn bạn đến giao diện của phần tiếp theo của Elephant.  Vì vậy, hãy nhấp vào tên của phiên bản cơ sở dữ liệu và nó sẽ đưa bạn đến màn hình chi tiết nơi bạn có thể xem thông tin về phiên bản cơ sở dữ liệu.

16
00:02:59,550 --> 00:03:11,790
Chúng tôi sẽ sử dụng thông tin này để thiết lập lớp Java để thử nghiệm tại thời điểm này.  Hãy nhấp vào Groser và tại đây bạn có thể tương tác với cơ sở dữ liệu.

17
00:03:11,790 --> 00:03:26,610
Vì vậy, hãy tiếp tục và tạo một bảng.  Tạo một bảng.  Đây là một bảng thử nghiệm, tôi sẽ chỉ gọi nó.  Người đó sẽ có ID người đó, là số nguyên được tạo theo mặc định làm danh tính.

18
00:03:26,610 --> 00:03:34,200
Vì vậy, đây là số được tạo tự động và mỗi khi chúng tôi chèn một người mới, số đó sẽ tăng lên, chúng tôi sẽ có tên của người đó.

19
00:03:34,320 --> 00:03:45,210
Giả sử đó là H.R. 255, không phải null.  Sau đó, chúng ta sẽ có lợi thế chứ không phải rỗng và chúng ta sẽ có ID người khóa chính.

20
00:03:45,480 --> 00:03:57,430
Vì vậy, điều này sẽ tạo ra bảng mà chúng tôi sẽ sử dụng để thử nghiệm.  Vì vậy, chỉ cần thực hiện câu lệnh tạo bảng này và bạn sẽ thấy hộp này bật lên thông báo Querrey đã hoàn thành.

21
00:03:57,450 --> 00:04:03,310
Nếu nó có màu xanh nghĩa là lệnh đã thành công.  Tại thời điểm này chúng tôi đã sẵn sàng để chèn một số hàng.

22
00:04:03,330 --> 00:04:23,940
Vì vậy hãy chèn vào giá trị tuổi của tên người.  Hãy cùng Joe 25 nhấp vào thực hiện truy vấn đã hoàn tất.  Hãy chọn từ bảng người chọn bắt đầu từ người thực thi.

23
00:04:24,330 --> 00:04:32,970
Và đây là người của chúng tôi ở đây.  Tôi khuyên bạn nên tự mình lập kế hoạch cho trình duyệt để hiểu cách PostgreSQL hoạt động.

24
00:04:32,970 --> 00:04:45,990
Tiếp theo, tôi sẽ hướng dẫn bạn đến các lớp Java mà chúng ta sẽ sử dụng để tương tác với PostgreSQL, lớp đầu tiên mà tôi sẽ hướng dẫn bạn là lớp dựa trên Getback, lớp này là lớp trừu tượng.

25
00:04:46,380 --> 00:04:59,370
Lớp này cung cấp các chức năng thực hiện phần tiếp theo.  Các hàm thực thi bằng nhau này trả về kết quả ở dạng chuỗi của Jason thay vì trả về kết quả đó.

26
00:04:59,560 --> 00:05:24,210
Là Đối tượng Bộ kết quả JBC và điều này nhằm đơn giản hóa mọi thứ cho những người không quen thuộc với JDBC để kiểm tra lớp dựa trên Geremek, chúng tôi sẽ sử dụng lớp kiểm tra báo cáo GETBACK chỉ đơn giản là mở rộng lớp dựa trên JDBC và thực thi một số câu lệnh của phần tiếp theo đối với bảng  chúng tôi đã tạo trên phiên bản cơ sở dữ liệu Postgres của mình.

27
00:05:24,220 --> 00:05:31,750
Một điều quan trọng cần lưu ý là lớp dựa trên JDBC yêu cầu bạn cung cấp các tham số kết nối và thông tin xác thực.

28
00:05:31,780 --> 00:05:47,520
Các thông số này có sẵn trên trang chi tiết mà tôi đã chỉ cho bạn trước đó.  Lớp dựa trên JDBC trừu tượng có sẵn trong Kamden Acme Dot Info PostgreSQL, nhấp vào VXI của ban giám khảo tại đây.

29
00:05:47,830 --> 00:05:55,320
Phần quan trọng nhất là thiết lập các tham số kết nối cơ sở dữ liệu cho phiên bản tương đương sau đại học của bạn.

30
00:05:55,690 --> 00:06:05,920
Vì vậy ở đây bạn cần cung cấp cho Host cả thông tin người dùng và mật khẩu.  Thông tin này có sẵn trên trang chi tiết mà tôi đã cho bạn xem trước đó.

31
00:06:06,070 --> 00:06:31,120
Trong lớp này, bạn sẽ thấy rằng điều đầu tiên chúng ta làm là tải lớp trình điều khiển JDBC.  Trong lớp này, bạn sẽ tìm thấy nhiều hàm tiếp theo và ý tưởng cơ bản đằng sau các hàm tình dục này là thực thi các câu lệnh tình dục dựa trên cơ sở dữ liệu, thực thi văn bản hàm tình dục dưới dạng câu lệnh bằng và chỉ phần tử đầu tiên boolean.

32
00:06:31,120 --> 00:06:42,790
Ý tưởng đằng sau phần tử đầu tiên này chỉ là nếu bạn chỉ muốn lấy bản ghi đầu tiên từ tập hợp các bản ghi nhận được từ cơ sở dữ liệu thì hãy đặt giá trị này thành true.

33
00:06:42,910 --> 00:07:01,330
Từ góc độ triển khai, điều đầu tiên chúng ta làm là tạo kết nối, tạo câu lệnh school, sau đó thực thi câu lệnh bằng này, chuyển đổi các kết quả nhận được từ cơ sở dữ liệu sang Jason bằng cách sử dụng lớp tiện ích JDBC ResultSet sang Jason.

34
00:07:01,600 --> 00:07:08,050
Nếu bạn muốn biết cách thực hiện điều này, nó có sẵn trong gói Kamelot Akhmad utils.

35
00:07:08,260 --> 00:07:20,490
Khi có kết quả, hãy chuyển đổi nó thành Jason.  Chúng ta đang đóng câu lệnh và nếu phần tử đầu tiên đúng thì chúng ta sẽ trích xuất phần tử đầu tiên và chỉ trả về phần tử đầu tiên đó.

36
00:07:20,740 --> 00:07:33,710
Nếu không thì tất cả Jason sẽ được trả lại.  Cuối cùng, chúng tôi sẽ đóng kết nối.  Bây giờ bạn có thể vào lớp này và kiểm tra các hàm thực thi khác, rất giống với hàm mà tôi vừa hướng dẫn bạn.

37
00:07:34,480 --> 00:07:44,110
Hãy tiếp tục và sao chép các tham số kết nối của chúng tôi.  Quay lại phần tiếp theo của Elephant, nhấp vào chi tiết.  Và từ đây bạn cần sao chép tên máy chủ.

38
00:07:44,110 --> 00:07:50,020
Bạn cần sao chép số báo cáo, theo mặc định là năm, bốn, ba, hai.  Vì vậy không nên thay đổi.

39
00:07:50,020 --> 00:07:58,990
Nhưng chỉ trong trường hợp nó thay đổi, hãy đảm bảo bạn có đúng cổng.  Không, chọn tên người dùng và sau đó để lấy mật khẩu, chỉ cần nhấp vào biểu tượng này ở đây.

40
00:07:58,990 --> 00:08:19,080
Nó sẽ sao chép nó vào mật khẩu và chỉ có tóc thẳng.  Và bây giờ chúng tôi đã sẵn sàng kiểm tra cơ sở JDBC và điều mà chúng tôi sẽ thực hiện bằng cách sử dụng lớp và kiểm tra mô hình bán cửa Condor Acme trong gói bãi bỏ, bạn sẽ tìm thấy kiểm tra báo cáo JDBC.

41
00:08:19,240 --> 00:08:34,590
Lớp này đang mở rộng lớp dựa trên GBC.  Và ở đây bạn sẽ thấy rằng tôi có hai chức năng.  Hàm này sẽ chèn một bản ghi mới vào bảng người bằng cách thực thi câu lệnh chèn mà chúng ta đang xác định ở đây.

42
00:08:35,110 --> 00:08:46,180
Nó lấy tên và tuổi làm tham số gọi việc thực thi phần tiếp theo và đó là cách nó được chèn vào bảng cơ sở dữ liệu.

43
00:08:46,540 --> 00:08:59,740
Hàm này ở đây chọn người dựa trên tên.  Nó sử dụng tên trong các phương tiện và sau đó thực hiện chức năng Thực thi phần tiếp theo, có sẵn trong lớp dựa trên Getback.

44
00:08:59,920 --> 00:09:12,930
Trong hàm main ở đây, chúng ta đang gọi hàm chèn người với tên và chữ H, một lần nữa gọi hàm chèn người rồi gọi hàm chọn người, in ra kết quả.

45
00:09:13,060 --> 00:09:25,450
Vì vậy, hãy tiếp tục và thực hiện nó đúng.  Nhấp vào Kiểm tra báo cáo JDBC và chạy.  Vì vậy, đây là câu lệnh chèn của chúng tôi và kết quả từ câu lệnh chèn.

46
00:09:25,720 --> 00:09:37,420
Và sau đó chúng ta có mệnh đề đẳng thức này và là kết quả của mệnh đề đẳng thức này.  Hãy tiếp tục và xem bảng trong phần tiếp theo, thay vì chọn ngôi sao từ người thực thi.

47
00:09:37,420 --> 00:09:52,960
Và bây giờ chúng tôi có ba quy tắc khuyên bạn nên thử thực hiện các thay đổi đối với lớp kiểm tra báo cáo GBC để xem cách thực thi các phần tiếp theo bằng cách sử dụng các hàm được hiển thị trong lớp dựa trên Geremek.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:07,850
Thực hiện các lệnh và truy vấn trong bài học này tôi sẽ nói về cách thực hiện lệnh và truy vấn.

2
00:00:08,220 --> 00:00:18,000
Không ai được thảo luận về quyền và đọc các cân nhắc về hiệu suất.  Và tôi đã học được bài học này với định nghĩa về một thuật ngữ mới, các lĩnh vực cộng tác.

3
00:00:18,570 --> 00:00:35,700
Các lệnh và truy vấn có thể được hiển thị thông qua Synchronoss cũng như các giao thức không đồng bộ.  Vì vậy, trong Microsoft này, có thể có một tập hợp miền hiển thị các lệnh và truy vấn có thể được gọi thông qua API SCDP hoặc GRA.

4
00:00:35,910 --> 00:00:47,400
Và một số lệnh và truy vấn này cũng có thể được thực thi bằng giao thức nhắn tin.  Định dạng của yêu cầu và phản hồi cho các lệnh và truy vấn rất linh hoạt.

5
00:00:47,400 --> 00:00:57,600
Nó có thể là Jason CSFI, Giao thức XML, định dạng Buffa hoặc bất kỳ định dạng nào khác mà người thiết kế vi mạch thấy phù hợp với yêu cầu.

6
00:00:57,900 --> 00:01:13,560
Ackerman ghi vào cơ sở dữ liệu và truy vấn sẽ đọc từ cơ sở dữ liệu.  Trước khi lệnh ghi vào cơ sở dữ liệu, nó cần dịch từ đối tượng mô hình miền chung sang ngôn ngữ mà cơ sở dữ liệu hiểu được.

7
00:01:13,770 --> 00:01:20,670
Trong ngữ cảnh của các lệnh, mô hình chung được gọi là mô hình phù hợp hoặc đôi khi chỉ là trang web phù hợp.

8
00:01:20,790 --> 00:01:32,530
Tương tự, khi truy vấn được đọc, dữ liệu từ cơ sở dữ liệu sẽ chuyển đổi từ biểu diễn cơ sở dữ liệu sang biểu diễn đối tượng mô hình miền chung trong ngữ cảnh truy vấn.

9
00:01:32,850 --> 00:01:41,730
Mô hình miền chung này được gọi là mô hình đọc hoặc chỉ trang đọc.  Chúng ta hãy xem qua mã giả cho lệnh và truy vấn.

10
00:01:41,730 --> 00:01:54,530
Processa echo gọi lệnh được bộ xử lý lệnh nhận được.  Điều đầu tiên bộ xử lý lệnh thực hiện là chuyển đổi dữ liệu yêu cầu sang mô hình miền trong bước tiếp theo.

11
00:01:54,900 --> 00:02:04,170
Nó thực thi logic nghiệp vụ và sau đó chuyển đổi mô hình thành biểu diễn cơ sở dữ liệu và sau đó ghi cơ sở dữ liệu.

12
00:02:04,620 --> 00:02:13,290
Về phía truy vấn, bộ xử lý truy vấn nhận được yêu cầu và chuyển đổi dữ liệu yêu cầu nhận sang mô hình miền.

13
00:02:13,800 --> 00:02:22,170
Sau đó, nó lấy dữ liệu từ cơ sở dữ liệu, chuyển đổi dữ liệu phản hồi thành mô hình miền rồi gửi lại cho người gọi truy vấn.

14
00:02:22,320 --> 00:02:32,490
Một điểm cần lưu ý là trong một hệ thống điển hình, mô hình LeDroit chung và cơ sở dữ liệu trình đọc chung được sử dụng cho cả lệnh và truy vấn.

15
00:02:33,430 --> 00:02:40,540
Người ta thường thấy rằng có nhiều yêu cầu về tính công bằng hơn là yêu cầu phù hợp.  Hãy để tôi giải thích điều này cho một ví dụ.

16
00:02:41,170 --> 00:02:59,170
Hãy nhớ lại Microsoft Office dành cho ứng dụng khoản vay, nơi chúng tôi có sẵn nhiều lệnh cho khách hàng và nhân viên cho vay ở đó cũng có quyền truy cập vào một số truy vấn để lấy thông tin về đơn xin vay.

17
00:02:59,440 --> 00:03:18,630
Dữ liệu được thu thập trong Microsoft Office này được nhiều bên liên quan quan tâm.  Do đó, có thể cần phải tạo các truy vấn bổ sung để đáp ứng nhu cầu của các bên liên quan khác này, chẳng hạn như ứng dụng báo cáo, phân tích, tuân thủ, v.v.

18
00:03:18,850 --> 00:03:29,500
Thông thường, bạn sẽ thấy rằng hệ thống cung cấp nhiều truy vấn cung cấp cùng một dữ liệu ở nhiều định dạng hoặc nhiều chế độ xem.

19
00:03:29,710 --> 00:03:44,260
Thách thức với điều này là cần phải thay đổi mô hình chung để đáp ứng tất cả các yêu cầu này nhằm đạt được mức hiệu suất tối ưu cho các yêu cầu đọc khác nhau của các yêu cầu truy vấn.

20
00:03:44,590 --> 00:03:59,920
Người thiết kế dịch vụ vi mô cần suy nghĩ về chỉ mục, nhu cầu tạo trong cơ sở dữ liệu.  Thách thức của việc lập chỉ mục là nó dẫn đến tác động tiêu cực đến việc thực hiện quyền không có hệ thống chính thức.

21
00:04:00,220 --> 00:04:14,530
Hiệu suất đạt được ở bên phải có thể chấp nhận được, nhưng đối với hệ thống quy mô Internet hoặc hệ thống âm lượng lớn, hiệu suất có thể không được chấp nhận, trong trường hợp đó Ortner Designs có thể cần được xem xét.

22
00:04:14,950 --> 00:04:25,990
Tiếp theo tôi sẽ giới thiệu với các bạn thuật ngữ miền cộng tác.  Miền cộng tác là miền trong đó nhiều tác nhân gọi lệnh và thực hiện song song trên cùng một dữ liệu.

23
00:04:26,140 --> 00:04:40,530
Ví dụ về các miền như vậy là đấu thầu trực tuyến, đặt vé buổi hòa nhạc và hệ thống giao dịch trong đó nhiều tác nhân đang xem cùng một dữ liệu và thực hiện một số hành động nhất định trên dữ liệu đó.

24
00:04:40,660 --> 00:04:55,010
Các miền cộng tác song song có khả năng chấp nhận thấp đối với các lệnh làm giảm hiệu suất và các hệ thống như vậy có logic nghiệp vụ phức tạp và các lệnh được triển khai với mức độ chi tiết cuối cùng.

25
00:04:55,240 --> 00:05:09,660
Ngoài ra, logic nghiệp vụ và quy tắc nghiệp vụ thay đổi thường xuyên trong các miền cộng tác.  Mô hình phù hợp và đúng đắn cần được điều chỉnh để đáp ứng nhu cầu của các lĩnh vực hợp tác.

26
00:05:10,270 --> 00:05:24,850
Đã đến lúc đi qua những điểm chính.  Common Model được sử dụng để nhận xét và truy vấn.  Thông thường, hầu hết các hệ thống đều có nhiều yêu cầu truy vấn và các yêu cầu nhiều truy vấn này có thể cần thay đổi trong mô hình chung.

27
00:05:25,120 --> 00:05:33,400
Các chỉ mục thường được sử dụng để thực hiện các truy vấn nhưng điều đó ảnh hưởng đến hiệu suất của quyền.

28
00:05:33,640 --> 00:05:41,110
Các miền cộng tác có ít sự chấp nhận đối với quy định về hiệu suất và đối với các miền cộng tác cũng vậy.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000005.srt -->

1
00:00:00,150 --> 00:00:07,950
Trong bài học này về xây dựng và kiểm tra khả năng chỉ huy và Querrey, Allfirst đã thảo luận về sự cần thiết của lực lượng sở hữu tại Acme Travel.

2
00:00:08,370 --> 00:00:22,580
Sau đó, tôi sẽ hướng dẫn bạn mã trong các lớp để triển khai lệnh và truy vấn.  Và ở cuối bài giảng, bạn sẽ thấy lệnh và truy vấn hoạt động như thế nào trước khi tiếp tục.

3
00:00:22,590 --> 00:00:35,000
Hãy đảm bảo rằng bạn đã thiết lập một phiên bản của cơ sở dữ liệu PostgreSQL.  Nó đã được mô tả trong một trong những bài giảng trước đó và lẽ ra bạn nên thiết lập lớp dựa trên JDBC.

4
00:00:35,190 --> 00:00:58,110
Vì vậy nếu bạn chưa làm được thì hãy xem lại bài giảng thiết lập kho Getback nhé.  Mã mà tôi sắp hướng dẫn bạn trong bài giảng này có sẵn trong dữ liệu nhánh get, vì vậy hãy đảm bảo kiểm tra dữ liệu nhánh trước khi chuyển sang phần minh họa cách hoạt động của các lệnh và truy vấn.

5
00:00:58,440 --> 00:01:23,400
Trưởng nhóm EITE trong nhóm bán hàng Acme đã quyết định thành lập đội quân trong đội quân này.  Anh ấy muốn tạo một lệnh sẽ tạo đề xuất cho khách hàng trong cơ sở dữ liệu và anh ấy muốn tập hợp một số truy vấn phổ biến đối với các đề xuất đó và anh ấy quyết định giữ cho lệnh này linh hoạt cho các truy vấn trong tương lai.

6
00:01:23,670 --> 00:01:40,110
Vì vậy, ở cấp độ cao, anh ấy cần triển khai kho lưu trữ cho đề xuất và cho khách hàng.  Cả hai kho lưu trữ này đều sử dụng lệnh và truy vấn quan trọng nhất, đồng thời sử dụng các mô hình cho đề xuất và khách hàng.

7
00:01:40,160 --> 00:01:48,210
Nhưng chúng ta hãy xem Dikili triển khai lệnh và truy vấn như thế nào.  Có hai bảng quan tâm trong cơ sở dữ liệu này.

8
00:01:48,220 --> 00:01:59,640
Đầu tiên là bàn của khách hàng.  Bảng của khách hàng có ID gạch dưới của khách hàng, đây là số được tạo tự động khi chèn khách hàng.

9
00:01:59,910 --> 00:02:07,590
Sau đó là các thông tin cơ bản như tên, email, địa chỉ và số điện thoại và khóa chính là ID khách hàng.

10
00:02:07,800 --> 00:02:16,530
Bảng thứ hai là bảng đề xuất.  Nó có một đề xuất chăm sóc chính trên ID trường.  Một lần nữa, đây là số được tạo tự động.

11
00:02:16,680 --> 00:02:26,050
Vì vậy, điều đó có nghĩa là khi một đề xuất được chèn vào bảng đề xuất, một ý tưởng mới sẽ được tạo ra và gán cho vai trò mới được thêm vào bảng.

12
00:02:26,130 --> 00:02:35,310
Có một tham chiếu đến ID khách hàng.  Sau đó là một ý tưởng về gói kỳ nghỉ.  Đây là ID gói cho kỳ nghỉ mà đề xuất đang được tạo.

13
00:02:35,730 --> 00:02:54,330
Bây giờ, thay vì duy trì một bảng riêng cho hành khách, tôi quyết định giữ mọi thứ đơn giản và yêu cầu tất cả hành khách trong bảng đề xuất nhớ lại rằng thông tin hành khách được ghi lại ở định dạng rất hạn chế đối với các đề xuất xác nhận đặt chỗ.

14
00:02:54,360 --> 00:02:59,160
Đó là một câu chuyện khác.  Chúng tôi sẽ cần thêm thông tin về hành khách, nhưng không cần thêm thông tin về các đề xuất.

15
00:02:59,280 --> 00:03:08,520
Sau đó có ràng buộc khóa ngoại này.  Đề xuất đó chỉ có thể được tạo cho khách hàng nếu khách hàng đó tồn tại trong bảng của khách hàng.

16
00:03:09,000 --> 00:03:17,490
Tiếp theo sẽ tiếp tục và tạo bảng trong cơ sở dữ liệu bằng cách sử dụng tập lệnh có sẵn trong thư mục phần tiếp theo.

17
00:03:17,700 --> 00:03:32,040
Đề xuất chỗ ở chi tiết hoặc phần tiếp theo.  Đó là kịch bản.  Sao chép tập lệnh hoàn chỉnh, mở trình duyệt, dán tập lệnh vào trình duyệt tiếp theo và thực thi và truy vấn của chúng tôi đã hoàn thành.

18
00:03:32,040 --> 00:03:44,250
Điều đó có nghĩa là các bảng của chúng ta đã được tạo ở bước tiếp theo.  Chúng ta sẽ điền vào các bảng này một số dữ liệu bằng cách sử dụng kịch bản Achmat đề xuất phần tiếp theo của cụ Dumbledore.

19
00:03:44,850 --> 00:03:59,690
Vì vậy hãy tiếp tục và sao chép.  Chọn tất cả điều khiển hoặc lệnh.  Lưu máy Mac của riêng bạn.  Chuyển đến trình duyệt phần tiếp theo, chọn tất cả tập lệnh trước đó và dán tập lệnh mới và truy vấn đã hoàn tất thành công.

20
00:04:00,030 --> 00:04:05,910
Bây giờ, để đảm bảo rằng các bảng đã được tạo, chỉ cần làm mới, hãy nhấp vào các truy vấn trong bảng.

21
00:04:05,910 --> 00:04:14,070
Và như bạn có thể thấy bây giờ chúng ta có bốn bảng và nếu tôi chọn khách hàng, điều này sẽ tạo ra phần tiếp theo mà bạn có thể thực hiện.

22
00:04:14,700 --> 00:04:22,260
Và như bạn có thể thấy bây giờ, chúng ta có ba khách hàng được tạo trong bảng khách hàng mà chúng ta có thể sử dụng để thử nghiệm.

23
00:04:22,620 --> 00:04:30,240
Hãy nhớ rằng các đề xuất chỉ có thể được tạo cho các khách hàng trong bảng này do ràng buộc khóa ngoại.

24
00:04:30,480 --> 00:04:45,410
Vì vậy, để thử nghiệm, chúng tôi sẽ sử dụng một ID khách hàng.  Đây là sơ đồ lớp mô tả tất cả các lớp là một phần của PEOC, chúng ta có giao diện lệnh được thực hiện bởi tất cả các lệnh.

25
00:04:45,820 --> 00:05:00,580
Giao diện này hiển thị một quy trình chức năng, quy trình này sẽ đưa ra một ngoại lệ trong trường hợp có lỗi.  Không có giao diện cho các truy vấn vì chúng có thể có nhiều loại truy vấn khác nhau cần thiết trong mô hình.

26
00:05:00,850 --> 00:05:14,050
Nhưng tất cả các chức năng truy vấn sẽ được triển khai như một phần của Hoa Kỳ sẽ thông qua các ngoại lệ truy vấn.  Có hai kho lưu trữ kho lưu trữ khách hàng và kho lưu trữ đề xuất đang mở rộng lớp dựa trên JDBC.

27
00:05:14,230 --> 00:05:28,060
Các kho lưu trữ này đang triển khai các giao diện mô hình mà chúng tôi xác định trong mô hình bán hàng.  Đây là lệnh tạo đề xuất thực hiện giao diện lệnh và sử dụng các kho lưu trữ.

28
00:05:28,270 --> 00:05:38,630
Tương tự, có lớp truy vấn đề xuất này triển khai nhiều chức năng truy vấn và lớp truy vấn đề xuất cũng sử dụng các kho lưu trữ để thử nghiệm.

29
00:05:38,860 --> 00:05:54,160
Có hai lớp lệnh kiểm tra và truy vấn kiểm tra.  Sau khi ra tòa, chúng tôi sẽ thực thi lệnh kiểm tra để xem đề xuất được tạo trong cơ sở dữ liệu và khi chạy truy vấn kiểm tra, chúng tôi sẽ có thể truy vấn các đề xuất.

30
00:05:54,310 --> 00:06:06,430
Vì vậy, chúng ta hãy tiếp tục xem mã trong các lớp này.  Bây giờ, đây là giao diện lệnh và như bạn có thể thấy, nó chỉ có một quy trình chức năng và nó đưa ra một ngoại lệ.

31
00:06:06,670 --> 00:06:23,230
Ngoại lệ lệnh chỉ đơn giản là mở rộng lớp ngoại lệ.  Và sau đó chúng ta có ngoại lệ truy vấn cũng mở rộng ngoại lệ đó cho lớp kho lưu trữ của khách hàng đang mở rộng cơ sở JDBC và đang triển khai giao diện khách hàng.

32
00:06:23,260 --> 00:06:39,140
Tôi khuyên bạn nên tự mình xem qua mã trong lớp này và bạn sẽ thấy rằng nó chỉ đơn giản là tạo các câu lệnh tiếp theo và sau đó thực thi các câu lệnh tiếp theo bằng cách sử dụng các hàm chu trình thực thi do lớp cơ sở cung cấp.

33
00:06:39,250 --> 00:06:48,150
Tương tự, có một lớp kho lưu trữ đề xuất mở rộng cơ sở dữ liệu và triển khai giao diện đề xuất trong lớp này.

34
00:06:48,160 --> 00:06:58,510
Ngoài ra, bạn sẽ thấy rằng chúng tôi có các câu lệnh tiếp theo được tạo và sau đó được thực thi thông qua các hàm được lớp dựa trên GBC hiển thị.

35
00:06:59,140 --> 00:07:08,920
Lệnh đề xuất CREATE thực hiện giao diện lệnh.  Vì vậy, nếu chúng ta xem xét chức năng của quy trình, bạn sẽ thấy rằng chúng ta không làm được gì nhiều về vấn đề này trong quá trình triển khai thực tế.

36
00:07:09,160 --> 00:07:16,120
Lẽ ra chúng ta đã chuyển đổi, chuyển đổi yêu cầu sang đối tượng mô hình nếu cần, sẽ cần xác thực yêu cầu.

37
00:07:16,120 --> 00:07:23,090
Sau đó, chúng ta cần triển khai logic nghiệp vụ và thực hiện các hướng dẫn cho lệnh trong quá trình triển khai PEOC này.

38
00:07:23,410 --> 00:07:32,940
Chúng tôi chỉ đơn giản là tạo một phiên bản của kho đề xuất và sau đó thêm đề xuất vào cơ sở dữ liệu bằng cách gọi kho đề xuất.

39
00:07:33,100 --> 00:07:52,390
Và nếu điều này thành công thì chúng tôi đang thực hiện quá trình xử lý hậu kỳ.  Bây giờ, trong quá trình triển khai này, bạn sẽ thấy rằng chúng ta chỉ in ra một thông báo trong hàm xử lý bài đăng và chúng ta sẽ sử dụng hàm này trong quá trình triển khai lệnh sau này trong truy vấn đề xuất.

40
00:07:52,390 --> 00:08:06,240
Ngoài ra, chúng tôi còn có một số hàm truy vấn như nhận đề xuất bằng ID đề xuất và nhận Đề xuất cho khách hàng, hàm này trả về một tập hợp các đề xuất cho một khách hàng nhất định trong đề xuất GET.

41
00:08:06,250 --> 00:08:19,360
Chúng tôi đang tạo một phiên bản của kho lưu trữ đề xuất, sau đó lấy đề xuất có ID đề xuất làm đối số sau đó nếu đề xuất trả về là rỗng.

42
00:08:19,390 --> 00:08:37,060
Điều đó có nghĩa là đề xuất sẽ không phải là Fonzo.  Chúng tôi chỉ gửi lại một chuỗi đối tượng JSON trống.  Mặt khác, chúng tôi lấy tham chiếu khách hàng từ đề xuất rồi tạo một phiên bản của kho lưu trữ khách hàng lấy khách hàng dựa trên tham chiếu khách hàng.

43
00:08:37,090 --> 00:08:50,180
Sau đó, chúng tôi đang chuyển đổi đề xuất và các đối tượng mô hình khách hàng sang đối tượng liền kề.  Một phần lớn mã trong tệp này thực sự liên quan đến việc chuyển đổi các đối tượng mô hình sang chuỗi liền kề.

44
00:08:50,710 --> 00:09:02,660
Bây giờ, tôi khuyên bạn nên tự mình thực hiện chức năng truy vấn thứ hai, nhận đề xuất cho khách hàng và bạn sẽ thấy nó được triển khai trên cùng dòng với chức năng nhận đề xuất.

45
00:09:02,860 --> 00:09:11,230
Tiếp theo, tôi sẽ hướng dẫn bạn đến lớp lệnh kiểm tra.  Trong lớp lệnh kiểm tra.  Đầu tiên chúng tôi tạo ra một vài gói kỳ nghỉ giả.

46
00:09:11,680 --> 00:09:22,450
Sau đó, chúng ta tạo một đối tượng đề xuất, tạo một thể hiện của lớp lệnh tạo đề xuất và sau đó chỉ cần gọi process.

47
00:09:22,720 --> 00:09:35,180
Nếu điều này thành công thì một quy tắc sẽ được tạo trong bảng đề xuất.  Trong lớp Tuscany, bạn sẽ thấy rằng trong hàm chính, chúng ta đang tạo một phiên bản của truy vấn đề xuất.

48
00:09:35,800 --> 00:09:58,660
Sau đó, chúng ta có hai biến cục bộ này, ID đề xuất và ID khách hàng, được sử dụng để gọi các truy vấn mà chúng ta có thể sử dụng để lấy hàm đề xuất, lấy dữ liệu cho ID đề xuất đã chỉ định hoặc chúng ta có thể thực thi để lấy đề xuất cho khách hàng để nhận được tất cả  các đề xuất cho khách hàng, các thay đổi đối với các biến cục bộ để thay đổi khách hàng và đề xuất.

49
00:09:59,320 --> 00:10:08,290
Nếu những truy vấn này thành công thì chúng ta chỉ cần in kết quả.  Hãy tiếp tục và thử lệnh test.

50
00:10:08,500 --> 00:10:19,810
Phải.  Bấm vào lớp Lệnh kiểm tra và chạy lệnh kiểm tra.  Lệnh kiểm tra đã thành công.  Hãy tiếp tục và truy vấn dữ liệu để truy vấn.

51
00:10:20,080 --> 00:10:31,240
Tôi bấm vào truy vấn kiểm tra và chạy truy vấn kiểm tra.  Chúng tôi đang nhận được tất cả các đề xuất cho khách hàng và đây là tất cả các đề xuất cho khách hàng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000006.srt -->

1
00:00:00,210 --> 00:00:11,140
Chỉ huy, trách nhiệm, phân biệt, tôi sẽ bắt đầu bài học này bằng cách định nghĩa sự bảo mật và sau đó tôi sẽ đề cập đến những lợi ích và những cân nhắc thực hiện đối với sự bảo mật.

2
00:00:11,800 --> 00:00:23,460
An ninh là viết tắt của mệnh lệnh, trách nhiệm, sự phân biệt, an ninh áp dụng ý tưởng an ninh cho đạo đức chính hơn là hoạt động.

3
00:00:23,910 --> 00:00:35,010
Vì vậy, ở đây, thay vì chia các hoạt động thành lệnh và truy vấn, đề xuất là chia mô hình miền thành các mô hình lệnh và truy vấn.

4
00:00:35,340 --> 00:00:41,700
Mô hình lệnh còn được gọi là mô hình phù hợp và mô hình truy vấn được gọi là mô hình Reed.

5
00:00:42,180 --> 00:00:53,580
Ý tưởng này được đề xuất bởi Greg Young.  Bạn có thể đọc thêm về nó tại đây.  Bạn là một định nghĩa chính thức hơn về chứng khoán yêu cầu trách nhiệm.

6
00:00:53,580 --> 00:01:01,550
Sự phân chia gợi ý việc sử dụng các mô hình đọc và ghi riêng biệt để hiện thực hóa các miền cộng tác.

7
00:01:01,800 --> 00:01:17,790
Tôi đã nói về lĩnh vực cộng tác trong bài giảng trước.  Vì vậy, trong miền cộng tác, các đặc điểm điển hình được yêu cầu từ mô-đun lệnh là mức độ chi tiết cuối cùng và hỗ trợ cho các quy tắc kinh doanh luôn thay đổi.

8
00:01:18,030 --> 00:01:28,710
Tương tự, các đặc điểm mong muốn của mô hình Reed là nó có thể đáp ứng các yêu cầu khác nhau và cung cấp hiệu suất truy vấn ở mức rất cao.

9
00:01:29,400 --> 00:01:41,850
Để đọc và ghi các mô hình có thể sử dụng phiên bản chung của kho dữ liệu.  Điều này có thể dẫn đến mất khả năng tối ưu hóa cơ sở dữ liệu để đọc và ghi.

10
00:01:42,310 --> 00:01:58,560
Hãy để tôi giải thích nó bằng một ví dụ phổ biến.  Nếu bạn tạo quá nhiều chỉ mục trên cơ sở dữ liệu thì hiệu suất ở bên phải sẽ giảm và nếu bạn xóa chỉ mục khỏi cơ sở dữ liệu thì sẽ ảnh hưởng đến hiệu suất truy vấn.

11
00:01:58,830 --> 00:02:07,080
Vì vậy, nó giống như một hành động cân bằng.  Điều gì sẽ xảy ra nếu cả quyền và nội dung đọc đều có hiệu suất cao?

12
00:02:07,470 --> 00:02:14,660
Một giải pháp cho vấn đề này là sử dụng các kho dữ liệu độc lập cho bên phải và bên phải.

13
00:02:14,730 --> 00:02:29,580
Không chỉ vậy, tùy thuộc vào trường hợp sử dụng cho bên đọc và bên phải, các công nghệ cơ sở dữ liệu khác nhau có thể sử dụng các công nghệ cơ sở dữ liệu khác nhau trong cùng một miền đôi khi được gọi là tính bền vững đa ngôn ngữ.

14
00:02:30,030 --> 00:02:49,200
Đây là một ví dụ về lý do tại sao nên sử dụng các công nghệ cơ sở dữ liệu khác.  Giả sử yêu cầu đối với trang web phù hợp là phải có thuộc tính tài sản cho các giao dịch và mong muốn là không nên tạo bộ chỉ mục nào trên các bảng cơ sở dữ liệu để đạt được thông lượng cao cho trang web bên phải.

15
00:02:49,200 --> 00:03:07,380
Và ở phía bên phải, giả sử yêu cầu là phải có các truy vấn mối quan hệ có hiệu suất cao.  Trong trường hợp này, các nhà phát triển có thể quyết định sử dụng cơ sở dữ liệu RDBMS ở bên phải và cơ sở dữ liệu đồ thị trên trang đọc.

16
00:03:07,380 --> 00:03:15,150
Vì vậy, nếu thiết lập này, các nhà phát triển sẽ có thể đạt được các yêu cầu cho cả mô hình phù hợp và phù hợp.

17
00:03:15,330 --> 00:03:24,220
Một ưu điểm khác của việc sử dụng các kho dữ liệu độc lập ở bên phải và bên phải là mỗi bên có thể mở rộng quy mô một cách độc lập.

18
00:03:24,690 --> 00:03:35,370
Ví dụ: giả sử các nhà phát triển đang xử lý một ứng dụng nặng.  Trong trường hợp đó, họ có quyền lựa chọn chia tỷ lệ theo chiều ngang ở phía bên phải.

19
00:03:35,700 --> 00:03:44,640
Hoặc nếu điều đó vẫn chưa đủ thì họ có thể xem xét việc tạo bản sao trình đọc cho cơ sở dữ liệu trình đọc hoặc sử dụng phân đoạn.

20
00:03:44,850 --> 00:04:00,320
Vì hai bên độc lập nên các hành động được thực hiện ở một bên sẽ không ảnh hưởng đến bên kia.  Tiếp theo, tôi sẽ nói về những cân nhắc về hiệu suất, thông thường trong các ứng dụng có nhiều lượt đọc hơn là ghi.

21
00:04:00,330 --> 00:04:08,820
Theo kinh nghiệm của tôi, sự phân chia giữa đọc và ghi là khoảng 85% dẫn đến 15% ghi.

22
00:04:08,970 --> 00:04:17,010
Do đó, các nhà phát triển ứng dụng luôn tìm kiếm các lựa chọn để đạt được hiệu suất cao nhất.

23
00:04:17,130 --> 00:04:34,590
Các cách phổ biến để đạt được điều này là bằng cách lưu vào bộ nhớ đệm hoặc bằng cách cụ thể hóa các chế độ xem không yêu cầu dịch mô hình hoặc sử dụng các khớp nối phức tạp, vì dữ liệu chỉ được lưu giữ ở định dạng mà nó sẽ được cung cấp cho người yêu cầu.

24
00:04:34,770 --> 00:04:43,560
Nhưng đôi khi điều này có thể không đủ.  Ví dụ: có thể có nhiều loại truy vấn khác nhau cần được người đọc đáp ứng.

25
00:04:43,580 --> 00:04:59,580
Trích dẫn ví dụ về các truy vấn như vậy là các truy vấn văn bản miễn phí và báo cáo từ nhiều nguồn dữ liệu.  Trong trường hợp này, cùng loại cơ sở dữ liệu ở bên phải sẽ không thể xử lý hiệu quả tất cả các loại truy vấn khác nhau.

26
00:04:59,820 --> 00:05:08,850
Trong những trường hợp như vậy, chúng ta có thể cần chia mô hình Reid thành các mô hình độc lập và sử dụng các công cụ dữ liệu khác nhau.

27
00:05:09,180 --> 00:05:31,640
Vì vậy, trong ví dụ này, chúng tôi có thể sử dụng ElasticSearch để cung cấp khả năng truy vấn văn bản miễn phí và sử dụng kết hợp Hadoop và uy tín để cung cấp khả năng truy vấn dữ liệu từ nhiều nguồn trong một số trường hợp nhất định liên quan đến các ứng dụng cộng tác và động.

28
00:05:31,890 --> 00:05:46,570
Có thể cần phải thường xuyên thực hiện các thay đổi đối với mô hình đọc và ghi cho các ứng dụng đó.  Người ta có thể xem xét tận dụng các nhóm khác nhau để quản lý mô hình đọc và ghi một cách độc lập.

29
00:05:46,620 --> 00:06:01,590
Với kiểu thiết lập này, các nhóm có thể quản lý mã của riêng mình.  Họ không cần cộng tác với các nhóm khác để thực hiện các thay đổi đối với cơ sở mã mà họ đang quản lý và tất cả các hoạt động triển khai khác có thể được nhóm chủ sở hữu thực hiện một cách độc lập.

30
00:06:01,830 --> 00:06:11,280
Bây giờ, đây là một trường hợp đặc biệt của một ứng dụng có thể có một số yêu cầu nghiêm ngặt về tính khả dụng, tốc độ đưa ra thị trường và hiệu suất.

31
00:06:11,690 --> 00:06:23,250
Điều cuối cùng tôi muốn đề cập trong bài giảng này là một quan niệm sai lầm phổ biến.  Một quan niệm sai lầm phổ biến là trong thiết kế hướng miền, bạn phải luôn sử dụng Securus.

32
00:06:23,400 --> 00:06:31,020
Và điều đó không đúng.  Tất cả phụ thuộc vào yêu cầu bạn có trong trường hợp sử dụng và mục tiêu của bạn.

33
00:06:31,470 --> 00:06:38,820
Có một số cân nhắc nhất định mà bạn cần lưu ý khi quyết định giữa việc sử dụng hay không sử dụng Securus.

34
00:06:39,060 --> 00:06:57,470
Đầu tiên là bạn phải xác định rõ được lợi ích của việc sử dụng Securus.  Hãy nhớ rằng việc sử dụng Securus có nghĩa là chi phí cho giải pháp sẽ cao hơn và sẽ cần quản lý nhiều bộ phận cũng như thành phần chuyển động hơn trong suốt vòng đời của ứng dụng.

35
00:06:57,840 --> 00:07:16,280
Đã đến lúc ôn lại những điểm chính của bài học này.  Bạn có thể cân nhắc sử dụng Securus cho các miền cộng tác với Securus, với Securus, bên phải và bên phải có thể được quản lý độc lập từ góc độ hiệu suất, khả năng mở rộng và thay đổi.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000007.srt -->

1
00:00:00,330 --> 00:00:19,590
Securus, ứng dụng của họ trong bài học này, tôi sẽ nói về bất kỳ ứng dụng nào cần thiết cho Securus, sau đó tôi sẽ tìm hiểu sự khác biệt giữa ứng dụng Đồng bộ hóa và ứng dụng không đồng bộ và cuối cùng, tôi sẽ thảo luận về các tùy chọn công nghệ ứng dụng khác nhau.

2
00:00:19,980 --> 00:00:27,770
Khi có hai kho dữ liệu độc lập cho bên đọc và bên phải, bạn sẽ cần ứng dụng của mình nêu rõ ứng dụng của chúng tôi.

3
00:00:27,990 --> 00:00:47,760
Có thể là Synchronoss hoặc có thể không đồng bộ trong trường hợp sao chép đồng bộ.  Có thể có một số thách thức kỹ thuật vì tính năng sao chép đồng bộ có thể không có sẵn cho cơ sở dữ liệu bạn đang sử dụng hoặc nếu bạn đang sử dụng các công nghệ cơ sở dữ liệu khác nhau thì thậm chí có thể không thực hiện được.

4
00:00:47,760 --> 00:00:53,940
Ngay cả với công nghệ sao chép đồng bộ sẵn có, vẫn có thể có tác động đến hiệu suất phù hợp.

5
00:00:54,510 --> 00:01:08,940
Ví dụ về công nghệ hỗ trợ sao chép đồng bộ là Amazon.  A.W.  đã có cơ sở dữ liệu trong đó bạn có thể tạo các ứng dụng đọc trong cùng khu vực với bản sao đồng bộ.

6
00:01:09,150 --> 00:01:17,950
Loại cơ chế này được hỗ trợ cho nhiều cơ sở dữ liệu khu vực như Postgrads, Equal Mass, Equal SQL Server và Oracle.

7
00:01:18,300 --> 00:01:36,520
Bây giờ hãy nói về sao chép không đồng bộ trong sao chép không đồng bộ.  Phía bên phải ghi vào kho dữ liệu của nó và sau đó một loại cơ chế sao chép không đồng bộ nào đó sẽ hoạt động và lấy dữ liệu từ đúng trang và cập nhật ở phía bên phải.

8
00:01:36,540 --> 00:01:48,520
Kết quả là có thể có một số độ trễ và dữ liệu cuối cùng vẫn nhất quán.  Ý nghĩa của tính nhất quán cuối cùng là việc quyết định lại có thể không phản ánh trạng thái hiện tại của dữ liệu.

9
00:01:48,960 --> 00:02:02,130
Có nhiều tùy chọn sao chép dữ liệu có sẵn và quyết định sử dụng tùy chọn nào sẽ phụ thuộc vào trường hợp sử dụng và các yêu cầu phi chức năng, chẳng hạn như tính nhất quán của dữ liệu.

10
00:02:02,160 --> 00:02:09,960
Vì vậy, ví dụ: một số ứng dụng có thể không đáp ứng yêu cầu nếu cuối cùng chúng có tính nhất quán từ đầu đọc.

11
00:02:09,960 --> 00:02:16,860
Và trong trường hợp đó, bạn sẽ phải sử dụng một số loại công nghệ sao chép đồng bộ.  Vì vậy, chúng ta hãy đi qua một số tùy chọn.

12
00:02:16,860 --> 00:02:25,910
Bạn có thể sử dụng các công nghệ thu thập dữ liệu theo chuỗi cho phép bạn nắm bắt các thay đổi trong một kho dữ liệu và cập nhật kho dữ liệu khác.

13
00:02:25,980 --> 00:02:38,550
Bạn có thể sử dụng ứng dụng gốc như Amazon.  A.W.  có bản sao Artigas MySQL.  Bạn có thể sử dụng các công cụ của bên thứ ba như Click và A.W.  là dịch vụ di chuyển dữ liệu.

14
00:02:38,550 --> 00:02:54,540
Và sau đó là bản sao dựa trên luồng tin nhắn, trong đó bên phải bỏ qua việc cập nhật dữ liệu dưới dạng sự kiện và bên đọc nhận các đơn vị này để cập nhật kho dữ liệu của chính nó sau này.

15
00:02:54,540 --> 00:03:13,200
Bài giảng trong phần này sẽ cho bạn thấy cơ chế hoạt động này.  Trong bài học này, tôi đã nói về việc sao chép dữ liệu giữa kho dữ liệu đã đọc và kho dữ liệu phù hợp, điều này cần thiết khi bạn tách biệt lệnh và truy vấn cũng như sử dụng các kho dữ liệu khác nhau.

16
00:03:13,590 --> 00:03:28,320
Ứng dụng này có thể đồng bộ hoặc không đồng bộ.  Bạn sẽ cần xem xét các yêu cầu cụ thể và công nghệ hỗ trợ của mình để quyết định công nghệ sao chép nào sẽ phù hợp hơn với trường hợp sử dụng của bạn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000008.srt -->

1
00:00:00,510 --> 00:00:13,170
Việc triển khai quản lý đề xuất bằng mẫu Securus trong bài học này sẽ thảo luận về các yêu cầu khác nhau đối với việc quản lý đề xuất khiến nó trở thành ứng cử viên cho chứng khoán.

2
00:00:13,200 --> 00:00:21,900
Tôi cũng sẽ hướng dẫn bạn sơ đồ thành phần và sơ đồ trình tự để triển khai quản lý đề xuất kỳ nghỉ ACMS.

3
00:00:22,760 --> 00:00:34,640
Bộ giải mã mà tôi sắp hướng dẫn bạn trong bài giảng này có sẵn trong dữ liệu nhánh get, vì vậy hãy đảm bảo kiểm tra dữ liệu nhánh trước khi tiếp tục.

4
00:00:35,480 --> 00:00:54,470
Ý tưởng rằng Acme đang đánh giá khả năng áp dụng mẫu Securus để triển khai quản lý đề xuất nhằm hiểu rõ hơn về quản lý đề xuất, lý tưởng nhất là quyết định phỏng vấn các bên liên quan khác nhau tại Acme.

5
00:00:55,070 --> 00:01:07,370
John, một cố vấn du lịch, đã nói về thực tế rằng Acme đang ở trong một ngành có tính cạnh tranh cao và hiệu suất của các trang web cũng như ứng dụng của Acme rất quan trọng.

6
00:01:07,520 --> 00:01:23,030
Ông cũng thông báo ý tưởng rằng hoạt động kinh doanh sẽ thay đổi gần như hàng tuần.  Chalmers, thành viên của nhóm tình báo kinh doanh, đã thông báo cho giới thượng lưu da trắng rằng nhóm Buhr cần quyền truy cập vào tất cả các loại dữ liệu đề xuất.

7
00:01:23,060 --> 00:01:39,470
Cái mới cũng như lịch sử.  Và anh ấy cũng nói về thực tế là bảng điều khiển quản lý cần phải theo Thời gian thực và có hiệu suất cao vì rất nhiều quyết định do lãnh đạo tại Acme đưa ra đều phụ thuộc vào các bảng điều khiển quản lý này.

8
00:01:39,480 --> 00:01:47,350
Jack, từ bộ phận Tiếp thị và Bán hàng, đã nói về việc sử dụng dữ liệu hiện tại và lịch sử để hiểu xu hướng thị trường.

9
00:01:47,870 --> 00:02:10,210
Và anh ấy cũng nói về thực tế rằng việc truy cập dữ liệu lần đầu tiên là điều cần thiết để ACMC có thể gửi các đề nghị về thái độ cho khách hàng, phân tích tất cả thông tin mà anh ấy nhận được từ các bên liên quan này và đã quyết định triển khai quản lý đề xuất bằng cách sử dụng Securus.  mẫu.

10
00:02:10,850 --> 00:02:19,910
Lý do anh quyết định đi theo mô hình Securus là vì việc quản lý đề xuất có nhiều yêu cầu kinh doanh thay đổi.

11
00:02:20,300 --> 00:02:27,650
Có nhiều loại yêu cầu đọc và truy vấn.  Mức hiệu suất rất cao được mong đợi từ khu vực.

12
00:02:27,650 --> 00:02:44,330
Phải.  Ngoài ra, còn có cơ hội đạt được lợi thế cạnh tranh bằng cách quản lý các đề xuất bằng mẫu Securus, vì những thay đổi về quyền đọc và quyền sẽ được triển khai độc lập với nhau.

13
00:02:44,660 --> 00:03:01,040
Và điều đó có thể giảm thời gian tiếp thị và kết quả là mang lại lợi thế cạnh tranh cho ACMC.  Tiếp theo, tôi sẽ thảo luận về các thành phần Securus quản lý đề xuất mà ITV đã quyết định đưa ra đề xuất.

14
00:03:01,040 --> 00:03:11,690
Việc triển khai Securus sẽ được thực hiện trong ba đơn vị có thể triển khai độc lập, lệnh, người đăng ký chẵn và truy vấn trong lệnh.

15
00:03:12,020 --> 00:03:34,490
Sẽ có một lệnh được con người sử dụng để bắt đầu lệnh.  Việc thực thi lệnh hoặc bộ xử lý lệnh sẽ thực hiện việc thực thi các quy tắc nghiệp vụ và logic nghiệp vụ, sau đó ghi dữ liệu đề xuất vào bên phải, vào mô-đun lệnh tạo đề xuất mới cũng sẽ phát ra.

16
00:03:34,820 --> 00:03:46,400
Và thậm chí sự kiện này sẽ được xếp hàng đợi trên Robert MQ The Achmea.  Nó đã quyết định sử dụng Posterous bằng cho phía bên phải.

17
00:03:46,400 --> 00:03:57,800
DataStore và thậm chí cả người đăng ký sẽ là một quy trình độc lập sẽ đăng ký các thông báo đề xuất chống lại Rabbitt MQ khi nhận được đề xuất.

18
00:03:57,950 --> 00:04:06,950
Ngay cả người đăng ký cũng sẽ thực hiện một số xử lý trên đó và sau đó thêm đề xuất vào DataStore của trang đọc.

19
00:04:07,130 --> 00:04:20,450
Thành phần thuê bao chẵn này sẽ hoạt động như một lớp chống tham nhũng.  Nó sẽ chuyển đổi mô hình bên phải sang mô hình bên phải trước khi thêm nó vào kho dữ liệu bên phải.

20
00:04:20,570 --> 00:04:28,070
Về phía truy vấn, sẽ có một UID truy vấn dẫn đến việc gọi truy vấn đối với truy vấn đó.

21
00:04:28,070 --> 00:04:38,420
Quá trình của quá trình truy vấn này sẽ thực hiện truy xuất từ ​​dữ liệu trên đường phố được lưu trữ bằng cách tìm nạp hoặc chọn dựa trên tiêu chí.

22
00:04:38,570 --> 00:04:54,260
Lý tưởng nhất là Acme đã quyết định sử dụng Mongo DB để quyết định lại đó.  Đối với sơ đồ trình tự mô tả việc Enteron xử lý một đề xuất mới ở phía bên phải và phía bên phải.

23
00:04:54,260 --> 00:05:07,340
Lệnh là một phần của phía bên phải và lệnh được con người gọi ra đối với giao diện người dùng.  Giao diện người dùng tạo đối tượng lệnh và sau đó bắt đầu xử lý lệnh.

24
00:05:07,460 --> 00:05:22,160
Lệnh thêm một đề xuất mới vào dữ liệu bên phải được lưu trữ và sau đó xuất bản một đề xuất.  Ngay cả ở phía bên phải, chúng ta có hai thành phần người đăng ký và người đăng ký truy vấn đăng ký.

25
00:05:22,500 --> 00:05:41,460
Đề xuất, ngay cả khi nhận được đề xuất, ngay cả khi nó tiến hành xử lý tải trọng của sự kiện, chẳng hạn, nó có thể chuyển đổi sự kiện sang mô hình đã ngừng hoạt động và sau đó chèn đề xuất đã chuyển đổi vào Redecide DataStore.

26
00:05:42,440 --> 00:06:03,150
Một truy vấn được con người gọi ra đối với giao diện người dùng, bạn có thực hiện truy vấn, triển khai truy vấn, thực hiện tìm kiếm hoặc chọn phần tiếp theo đối với trình đọc khi nó nhận dữ liệu từ các gói kho dữ liệu vào phản hồi và gửi lại cho  giao diện người dùng.

27
00:06:04,160 --> 00:06:16,370
Điểm mấu chốt của bài học này là quyết định triển khai bảo mật phụ thuộc vào trường hợp sử dụng cũng như các đặc điểm LeDroit mong muốn trong bài giảng.

28
00:06:16,520 --> 00:06:25,670
Trong phần này, bạn sẽ thấy cách triển khai bảo mật End-To-End mà tôi đã thảo luận trong bài học này.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000009.srt -->

1
00:00:00,120 --> 00:00:08,130
Lệnh thử nghiệm Securus triệu trong bài giảng này, bạn sẽ thấy cách triển khai lệnh để bảo mật đang hoạt động.

2
00:00:08,710 --> 00:00:22,880
Có ba điều chúng tôi sẽ làm là thiết lập MQ 4 riêng tư, thậm chí cả nhắn tin.  Sau đó, tôi sẽ hướng dẫn bạn mã dành cho phiên bản hai của việc triển khai lệnh và sau đó sẽ kiểm tra phiên bản hai của việc triển khai lệnh.

3
00:00:22,900 --> 00:00:29,880
Xin lưu ý rằng mã mà tôi sẽ hướng dẫn bạn trong bài giảng này phụ thuộc vào trình tự sau đại học và Rabbitt MQ.

4
00:00:30,570 --> 00:00:41,400
Trong bài giảng trước, tôi đã mô tả cách thực hiện trong đề xuất.  Repo không thông thường, sử dụng postgresql, lệnh và đối tượng truy vấn.

5
00:00:41,550 --> 00:00:50,340
Sử dụng mô hình miền cho đề xuất và khách hàng cũng như các kho lưu trữ để cung cấp chức năng lệnh và truy vấn.

6
00:00:50,760 --> 00:01:12,820
Trong bài học này, chúng ta sẽ mở rộng việc triển khai trong đề xuất tạo.  Lệnh sẽ không chỉ chèn đề xuất vào cơ sở dữ liệu mà còn xuất bản và thậm chí là một chủ đề trên Rabbitt MQ vì phía đọc sẽ khác với phía bên phải trong quá trình triển khai này về sau.

7
00:01:12,960 --> 00:01:22,680
Mô hình được mô tả ở đây sẽ được gọi là mô hình phù hợp.  Tiếp theo, tôi sẽ hướng dẫn bạn cách triển khai thông báo trong lệnh đề xuất rõ ràng.

8
00:01:23,040 --> 00:01:40,200
Và bước đầu tiên chúng ta sẽ thiết lập là xe buýt trên con thỏ.  MQ sẽ thiết lập trao đổi chủ đề Q A và ràng buộc Q giữa trao đổi chủ đề và Q Đăng nhập vào tài khoản Amcu thỏ của bạn và nhấp vào Rabbit.

9
00:01:40,330 --> 00:01:52,710
Q Manager hãy truy cập vì chúng tôi sẽ tạo một Q mới Vì vậy, hãy cung cấp đề xuất tên hoặc người đọc chấm Q rồi nhấp vào thêm Q A Q được thêm vào.

10
00:01:52,710 --> 00:02:00,120
Vì vậy, hãy tiếp tục và tạo một chủ đề trao đổi.  Bấm vào trao đổi, cung cấp tên sẽ gọi nó là chủ đề khác của Acme.

11
00:02:00,120 --> 00:02:06,540
Thay đổi loại chủ đề.  Nếu bạn đã có trao đổi này, bạn chỉ cần xóa nó và tạo lại.

12
00:02:06,540 --> 00:02:17,850
Nhấp vào THÊM Exchange.  Bây giờ chúng ta cần thêm các ràng buộc, vì vậy hãy nhấp vào trao đổi mới được tạo để chọn trao đổi và đặt tên Q là trình đọc đề xuất.

13
00:02:17,910 --> 00:02:27,270
Q Và phím định tuyến sẽ được đề xuất cập nhật dấu chấm nhấp vào.  Ngay bây giờ chúng ta đã thiết lập xong chú thỏ Amcu và chúng ta đã sẵn sàng chuyển sang bước tiếp theo.

14
00:02:28,080 --> 00:02:45,870
Chuyển hướng sang lệnh tạo đề xuất mở rộng phiên bản một của lệnh tạo đề xuất.  Sự khác biệt duy nhất giữa hai lớp là các từ được sử dụng để ghi đè chức năng xử lý hậu kỳ mà tôi đã chỉ cho bạn trước đó trong chức năng xử lý hậu kỳ.

15
00:02:46,380 --> 00:03:04,230
Từ hai của lệnh tạo đề xuất sẽ tạo ra tải trọng đồng đều cho đề xuất mới được tạo và sau đó xuất bản sự kiện lên một chủ đề trên Rabbit Amcu bằng cách sử dụng dịch vụ để thử nghiệm phiên bản hai của Lệnh Tạo đề xuất.

16
00:03:04,530 --> 00:03:28,110
Có một lệnh kiểm tra lớp mới phiên bản hai thực thi lệnh tạo đề xuất và nó sẽ dẫn đến việc chèn một mũi tên và cơ sở dữ liệu Postgres, đồng thời xuất bản thông báo chẵn trên Q, phiên bản hai của Lệnh Tạo đề xuất mở rộng  phiên bản một của lệnh tạo đề xuất.

17
00:03:28,650 --> 00:03:37,560
Sự khác biệt duy nhất giữa phiên bản một và phiên bản hai là ở việc triển khai quá trình xử lý hậu kỳ.

18
00:03:37,560 --> 00:03:47,310
Trong quá trình thực hiện xử lý hậu kỳ.  Chúng tôi đang nhận được đề xuất, Jason, và sau đó sử dụng đề xuất này, Jason, để tạo tải trọng cho sự kiện.

19
00:03:47,310 --> 00:04:20,280
Vì vậy, như bạn có thể thấy ở đây, chúng tôi đang tạo đối tượng liền kề cho sự kiện bằng cách lấy ID đề xuất từ ​​ý tưởng đề xuất, Jason, sau đó tạo kho lưu trữ để nhận đề xuất, chuyển đổi đề xuất sang Jason, lấy thông tin khách hàng từ  kho lưu trữ của khách hàng, sau đó tạo tải trọng cho sự kiện, sau đó chỉ cần tạo một phiên bản về mục đích của dịch vụ, cung cấp các tham số MQ B và xuất bản sự kiện.

20
00:04:20,880 --> 00:04:34,560
Nếu mọi thứ đều ổn, dữ liệu sự kiện sẽ kết thúc trong sự kiện.  Q Không. Trước khi tiếp tục, vui lòng đảm bảo rằng bạn đã thiết lập tang lễ MQ cho Rabbit MPU một cách chính xác.

21
00:04:34,560 --> 00:04:48,750
Nếu bạn không cài đặt đúng cách, bạn sẽ nhận được một ngoại lệ hoặc thông báo có thể không xuất hiện trong phần Q. Ngoài ra, nếu bạn gặp bất kỳ vấn đề nào, hãy kiểm tra kỹ tên của sàn giao dịch và chủ đề.

22
00:04:48,750 --> 00:04:59,040
Chuyển đến tài khoản Rabbit Amcu của bạn và bạn sẽ tìm thấy thông tin thực tế trên trang chi tiết.  Chỉ cần sao chép từ đây và dán vào đây.

23
00:04:59,110 --> 00:05:20,890
Biến để kiểm tra lệnh như thế nào chúng ta sẽ sử dụng lệnh kiểm tra trong gói V2.  Sự khác biệt duy nhất giữa việc triển khai lệnh kiểm tra trong V1 và Rita là trong lệnh kiểm tra V hai, chúng tôi đang sử dụng phiên bản hai của lệnh CREATE đề xuất.

24
00:05:21,130 --> 00:05:28,990
Phần còn lại của mã là như nhau.  Vì vậy, hãy tiếp tục và thực hiện lệnh kiểm tra.  Phải.  Nhấp vào xung quanh Lệnh kiểm tra.

25
00:05:29,270 --> 00:05:40,670
Và như bạn có thể thấy ở đây, lần này khi thực hiện lệnh kiểm tra, chúng tôi đã nhận được thông báo quá trình xử lý hậu kỳ đã bắt đầu kiểm tra xem sự kiện đã được xuất bản hay chưa.

26
00:05:40,900 --> 00:05:50,280
Hãy tới Rabbitt MQ.  Mở trình quản lý thỏ Amcu trong trình quản lý Rabbit Amcu, nhấp vào Kyuss và như bạn có thể thấy ở đây, chúng tôi có một thông báo.

27
00:05:50,830 --> 00:06:04,570
Hãy tiếp tục và đọc tin nhắn.  Nhấp vào đề xuất, đọc Q, cuộn xuống và nhấp vào Nhận tin nhắn và đây là thông báo đề xuất của chúng tôi đã được lệnh xuất bản.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000010.srt -->

1
00:00:00,210 --> 00:00:11,930
Ngay cả đối tác tìm nguồn cung ứng trong bài học này, bạn cũng tìm hiểu về tìm nguồn cung ứng đồng đều và thậm chí cả các cửa hàng, đồng thời bạn cũng sẽ tìm hiểu về lợi ích của việc sử dụng mô hình tìm nguồn cung ứng đồng đều.

2
00:00:12,150 --> 00:00:21,120
Các ứng dụng truyền thống sử dụng các hệ thống bền bỉ theo định hướng trạng thái và các hệ thống dựa trên tính bền bỉ, định hướng trạng thái này.

3
00:00:21,480 --> 00:00:30,500
Chỉ có trạng thái hiện tại của đối tượng được duy trì.  Điều dẫn đến tình trạng hiện tại là thông tin lịch sử không được duy trì.

4
00:00:30,510 --> 00:00:38,240
Ví dụ: trong trường hợp hệ thống kiểm kê, bạn luôn có thể tìm thấy một số mặt hàng cụ thể trong kho.

5
00:00:38,370 --> 00:00:49,400
Bất cứ khi nào một mặt hàng mới được thêm vào kho, số lượng mặt hàng đó sẽ tăng lên và bất cứ khi nào một mặt hàng được bán, số lượng mặt hàng đó sẽ giảm.

6
00:00:49,800 --> 00:00:59,060
Vì vậy, chúng tôi không duy trì cách chúng tôi đạt được trạng thái hiện tại.  Chúng tôi chỉ duy trì trạng thái hiện tại của mặt hàng trong kho.

7
00:00:59,190 --> 00:01:06,300
Mặt khác, thậm chí còn có những hệ thống duy trì có nguồn gốc duy trì tất cả các thay đổi trạng thái.

8
00:01:06,510 --> 00:01:17,820
Vì vậy, khi phía Reid nhận được các sự kiện miền, chúng sẽ được thêm vào bộ lưu trữ liên tục.  Chúng ta hãy xem xét định nghĩa chính thức về nguồn cung ứng đồng đều.

9
00:01:18,330 --> 00:01:30,420
Ngay cả việc tìm nguồn cung ứng cũng đề xuất duy trì miền, ngay cả trong một cửa hàng đồng đều và sử dụng các sự kiện này để tạo lại trạng thái của đối tượng miền tại bất kỳ thời điểm nào.

10
00:01:30,930 --> 00:01:44,220
Ngay cả cửa hàng cũng là cách sử dụng nhật ký sự kiện duy nhất rõ ràng để duy trì các sự kiện đã nhận.  Hãy để tôi giải thích ngay cả việc tìm nguồn cung ứng và thậm chí lưu trữ bằng một ví dụ.

11
00:01:44,910 --> 00:02:04,680
Chúng ta hãy xem xét các giao dịch ngân hàng trong đó các sự kiện được mua bên đường bị bỏ qua bởi đúng trang web trong cửa hàng sự kiện khi khách hàng thực hiện giao dịch bằng tài khoản ngân hàng và thậm chí được chấp nhận thông qua cơ sở hạ tầng nhắn tin.

12
00:02:05,010 --> 00:02:26,820
Vì vậy, hãy xem xét một vài giao dịch.  Giả sử khách hàng đã gửi hàng trăm đô la và thậm chí bị bỏ qua và anh ta đã đi đúng hướng, được thêm vào cửa hàng khi giao dịch bắt đầu diễn ra, số tiền thậm chí được bên phải thừa nhận, bắt đầu được thêm vào cửa hàng sự kiện  .

13
00:02:27,060 --> 00:02:50,100
Phía bên phải có thể sử dụng những sự kiện này để tạo trạng thái tài khoản ngân hàng vào bất kỳ ngày nào.  Ví dụ: nếu câu hỏi là số dư của tài khoản ngân hàng vào cuối ngày ngày 3 tháng 5 là bao nhiêu, thì những giao dịch này có thể dễ dàng được tổng hợp để có được số dư cho tài khoản.

14
00:02:50,460 --> 00:02:56,240
Chúng ta có một trăm đô la cộng với một trăm đô la, trừ đi năm mươi và đó là số dư trong tài khoản đó.

15
00:02:56,820 --> 00:03:26,160
Chúng ta hãy xem một truy vấn khác.  Số dư cuối ngày ngày 5 tháng 5 là bao nhiêu?  Trong trường hợp này, chúng ta phải xem xét tất cả các giao dịch này, thực hiện phép toán đơn giản và chúng ta có số dư là 250 đô la với ví dụ này, bạn sẽ có ý tưởng về cách các sự kiện được lưu trữ và cách chúng có thể được lưu trữ.  được sử dụng để tạo trạng thái hiện tại hoặc trạng thái của đối tượng miền.

16
00:03:26,790 --> 00:03:38,430
Điều bạn có thể lo ngại rõ ràng vào thời điểm này là trạng thái hiện tại yêu cầu tổng hợp dữ liệu sự kiện và mối lo ngại đó là hợp lệ.

17
00:03:38,790 --> 00:03:50,760
Việc tạo lại trạng thái từ các sự kiện sẽ dẫn đến hiệu suất kém, đặc biệt nếu bạn phải tổng hợp một số lượng lớn sự kiện để giải quyết mối lo ngại liên quan đến hiệu suất.

18
00:03:51,000 --> 00:04:07,500
Ngay cả việc triển khai sau đó cũng quản lý trạng thái hiện tại trong một kho dữ liệu riêng biệt.  Vì vậy, trong trường hợp của ví dụ về ngân hàng, vì người quyết định lại sẽ nhận được các sự kiện nên số dư sẽ được tính toán và đặt trong một kho dữ liệu riêng biệt.

19
00:04:07,510 --> 00:04:16,410
Vì vậy, ở đây, ví dụ, vào ngày 1 tháng 5, số dư trong tài khoản là một trăm đô la.  Và điều đó được phản ánh trong kho dữ liệu trạng thái hiện tại.

20
00:04:16,710 --> 00:04:29,490
Vào ngày 2 tháng 5, người ta nhận được thêm 100 đô la nữa nên số dư đã trở thành 200 vào ngày 3 tháng 5.  Năm mươi đô la đã được rút ra, do đó số dư trở thành một trăm năm mươi, v.v.

21
00:04:29,640 --> 00:04:41,100
Ý tưởng là để truy vấn số dư, kho sự kiện sẽ không được truy vấn.  Thay vào đó, kho dữ liệu trạng thái hiện tại sẽ được truy vấn về số dư.

22
00:04:41,250 --> 00:04:50,310
Do đó, hiệu suất của truy vấn sẽ tốt hơn nhiều so với hiệu suất của truy vấn nếu nó được thực hiện đối với kho sự kiện.

23
00:04:50,550 --> 00:04:59,580
Trên thực tế, phía bên phải có thể tạo nhiều chế độ xem dữ liệu để tối ưu hóa hiệu suất truy vấn.  Xin lưu ý.

24
00:04:59,850 --> 00:05:08,680
Các chế độ xem ở đây không phải là chế độ xem cơ sở dữ liệu quan hệ, đây là các chế độ xem dữ liệu cần thiết cho người tiêu dùng trang web.

25
00:05:09,240 --> 00:05:26,210
Chúng ta hãy điểm qua những lợi ích của việc tìm nguồn cung ứng đồng đều.  Đầu tiên là các sự kiện có thể được phát lại để tạo trạng thái thời điểm, nhiều mô hình Reid và các chế độ xem có thể được lấy từ các sự kiện trong kho sự kiện.

26
00:05:26,880 --> 00:05:37,140
Ngay cả nước sốt cũng cung cấp thứ tự đặt hàng chính xác có sẵn trong cửa hàng sự kiện.  Nó cũng dẫn đến sự hòa giải được đơn giản hóa.

27
00:05:37,440 --> 00:05:45,660
Bên phải và bên phải có thể so sánh các sự kiện để đảm bảo rằng mỗi bên đang xử lý cùng một nhóm sự kiện.

28
00:05:45,990 --> 00:05:59,370
Ngay cả việc tìm nguồn cung ứng cũng cho phép thực hiện các truy vấn lịch sử phức tạp và tạm thời đối với sự kiện.  Bảo mật cửa hàng và thậm chí tìm nguồn cung ứng thường được sử dụng cùng nhau.

29
00:05:59,730 --> 00:06:05,570
Các sự kiện của nhà xuất bản bên phải được bên quyết định lại nhận được sẽ được thêm vào kho sự kiện.

30
00:06:06,060 --> 00:06:25,950
Và khi những sự kiện này diễn ra, các kho dữ liệu được xây dựng có mục đích sẽ được tạo và cập nhật.  Vì tất cả dữ liệu sự kiện đều có sẵn trong kho sự kiện nên các kho dữ liệu chuyên dụng mới có thể được thêm vào bất kỳ lúc nào để đáp ứng yêu cầu kinh doanh cụ thể cho trang web.

31
00:06:26,730 --> 00:06:39,590
Vậy thì không phải là câu hỏi.  Có nên sử dụng nước sốt đều không?  Và câu trả lời là nó phụ thuộc vào trường hợp sử dụng.  Bạn cần đánh giá trường hợp sử dụng của mình từ góc độ lợi ích tìm nguồn cung ứng đồng đều.

32
00:06:39,870 --> 00:06:48,570
Ví dụ, bạn có nhu cầu đơn giản hóa việc hòa giải không?  Có, ngay cả nước sốt cũng có thể là một ý tưởng hay.

33
00:06:49,020 --> 00:06:56,970
Hay bạn đang tìm cách tạo một kho lưu trữ dữ liệu có thể hỗ trợ các truy vấn lịch sử tạm thời hoặc phức tạp?

34
00:06:56,970 --> 00:07:14,720
Có, có thể là một ý tưởng tốt nếu sử dụng nguồn cung ứng đồng đều.  Mặt khác, nếu bạn không có nhu cầu quản lý các thay đổi trạng thái và bạn chỉ quan tâm đến trạng thái hiện tại của tài sản hoặc dữ liệu thì ngay cả việc tìm nguồn cung ứng cũng không thể mang lại cho bạn bất kỳ lợi ích nào.

35
00:07:14,760 --> 00:07:24,240
Tóm lại, hãy xem xét những lợi ích này và sau đó kiểm tra người dùng của bạn để hiểu liệu việc tìm nguồn cung ứng có hữu ích hay không.

36
00:07:24,840 --> 00:07:34,530
Bây giờ chúng ta hãy nói về các stoats chẵn.  Ngay cả các cửa hàng cũng có thể bị chôn vùi trên bất kỳ RDBMS truyền thống nào hoặc chất lượng công nghệ.

37
00:07:34,890 --> 00:07:49,200
Và cũng có một số cơ sở dữ liệu chuyên biệt được xây dựng để tìm nguồn cung ứng.  Một cơ sở dữ liệu như vậy thậm chí còn được lưu trữ và bạn có thể đọc thêm về nó tại W w w dot, thậm chí store dot com.

38
00:07:50,200 --> 00:07:57,510
Đã đến lúc xem lại nhanh những điểm chính trong bài học này, ngay cả hệ thống kiên trì của kiếm vẫn tồn tại.

39
00:07:57,520 --> 00:08:06,660
Tất cả các thay đổi trạng thái nhằm quản lý trạng thái hiện tại của đối tượng miền trong một kho dữ liệu riêng biệt vì lý do hiệu suất.

40
00:08:06,880 --> 00:08:17,530
Lợi ích của việc kiên trì như vậy là bạn sẽ thoát khỏi cơ chế kiểm tra hộp, cơ chế đối chiếu và hỗ trợ cho các truy vấn tạm thời.

41
00:08:18,040 --> 00:08:27,100
Các sự kiện được lưu trữ và thậm chí được lưu trữ.  Đó có thể là cơ sở dữ liệu truyền thống như RDBMS hoặc cơ sở dữ liệu cuộc gọi dễ dàng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000011.srt -->

1
00:00:00,180 --> 00:00:10,080
Thiết lập Mongo DB ở phía bên phải trong bài học này, chúng ta sẽ tạo một phiên bản của cơ sở dữ liệu Modiba trên cloud dot, mongo DB dot com.

2
00:00:10,530 --> 00:00:17,280
Sau đó tôi sẽ hướng dẫn bạn qua lớp Mongo DBA.  Và cuối cùng, chúng tôi sẽ kiểm tra thiết lập Mongo DB của mình.

3
00:00:17,520 --> 00:00:25,200
Xin lưu ý rằng mục đích của tôi trong bài học này không phải là dạy Mongo DB về mã này.  Bạn không cần phải biết Mongo DB.

4
00:00:25,380 --> 00:00:35,780
Tôi sẽ hướng dẫn bạn các thao tác cơ bản mà chúng ta sẽ sử dụng trong khóa học này.  Cordarrelle Vorkuta trong bài giảng này có sẵn trong dữ liệu nhánh get.

5
00:00:35,790 --> 00:00:45,330
Hãy đảm bảo kiểm tra dữ liệu chi nhánh nhận.  Cho đến nay, chúng tôi đã làm việc đúng hướng trong quá trình triển khai Securus của mình.

6
00:00:45,810 --> 00:00:54,240
Trong bài giảng Thực hành vừa qua, Lệnh Đề xuất Rõ ràng đã được cập nhật để xuất bản một thông báo tới Rabbit MQ.

7
00:00:54,240 --> 00:01:04,650
Bất cứ khi nào một đề xuất mới được tạo ra, bắt đầu từ bài giảng này sẽ tập trung vào phía bên phải là mỗi bên sẽ sử dụng Mongo DB để quản lý dữ liệu.

8
00:01:04,650 --> 00:01:13,190
Đến cuối bài giảng này, chúng ta sẽ có một trong các phiên bản OTV và sẽ có lớp tốt nhất để tương tác với Mongo DB.

9
00:01:14,010 --> 00:01:22,480
Chúng tôi sẽ tạo một phiên bản Mongo DB miễn phí trên cloud dot vongole.  Chúng ta chấm com như voi, bằng mây chấm mongo.

10
00:01:22,560 --> 00:01:32,820
Dot com là nhà cung cấp cơ sở dữ liệu dưới dạng dịch vụ cho Mongo DB.  Để tạo một phiên bản, chỉ cần truy cập cloud dot mongo db dot com.

11
00:01:33,670 --> 00:01:43,900
Bấm vào đăng ký, cung cấp thông tin, làm theo hướng dẫn là bạn sẽ có tài khoản, mình đã có tài khoản rồi nên mình chỉ cần đăng nhập thôi.

12
00:01:44,950 --> 00:01:51,140
Sau khi đăng nhập thành công, bạn có thể thấy đã có sẵn một cụm để sử dụng.

13
00:01:51,160 --> 00:02:04,330
Nếu không, bạn có thể nhấp vào cụm rồi nhấp vào xây dựng cụm, chọn cụm chia sẻ, nhấp chuột miễn phí vào W.S.  Nó sẽ tự động chọn khu vực gần bạn nhất.

14
00:02:04,430 --> 00:02:18,810
Gọi tất cả và cung cấp tên cụm.  Tôi sẽ gọi cụm này là rắc rối ackmann.  Bạn không cần phải tạo cụm nếu bạn đã nhấp chuột vào Tạo cụm và sẽ mất vài phút để tạo cụm.

15
00:02:19,160 --> 00:02:33,590
Lần này cụm được tạo.  Bây giờ một điều quan trọng mà tôi muốn cho bạn xem là trục mạng ở đây, cloud, dot, dot com đang tự động phát hiện địa chỉ IP của bạn và thêm địa chỉ IP đó vào danh sách trắng.

16
00:02:33,640 --> 00:02:42,430
Điều đó có nghĩa là nếu bạn cố gắng sử dụng cụm từ một số máy thông qua một số mạng khác, bạn sẽ gặp ngoại lệ.

17
00:02:42,580 --> 00:02:49,060
Ứng dụng của bạn sẽ không kết nối được.  Và nếu bạn muốn thực hiện bất kỳ thay đổi nào đối với địa chỉ IP này, chỉ cần nhấp vào THÊM.

18
00:02:49,360 --> 00:02:56,830
Cung cấp địa chỉ IP mới và điều đó sẽ thực hiện thủ thuật.  Bây giờ hãy quay lại cụm và tạo một số bộ sưu tập.

19
00:02:56,830 --> 00:03:07,300
Vì vậy hãy đến với cụm bấm vào bộ sưu tập.  Bây giờ ở đây trong cụm, chúng tôi sẽ thêm cơ sở dữ liệu của riêng mình.  Và để làm điều đó, chỉ cần nhấp vào Thêm dữ liệu của riêng tôi.

20
00:03:07,480 --> 00:03:16,960
Hãy đặt tên cơ sở dữ liệu là Achmad Travel và tạo một bộ sưu tập thử nghiệm.  Tôi sẽ chỉ gọi nó là test và chúng ta có một bộ sưu tập có tên test là bước tiếp theo.

21
00:03:16,990 --> 00:03:29,060
Chúng tôi sẽ thêm một số tài liệu vào nó.  Bấm vào chèn tài liệu và ở đây bạn có thể thêm một số dữ liệu.  Tôi có tên và tuổi rồi nhấp vào Chèn và đây là bản ghi đầu tiên của chúng tôi.

22
00:03:29,080 --> 00:03:40,420
Tôi khuyên bạn nên tự mình chơi với điều này.  Bây giờ chúng ta sẽ sử dụng thông tin cụm để kết nối với cơ sở dữ liệu từ các lớp kiểm tra Java.

23
00:03:40,660 --> 00:03:53,590
Tại thời điểm này, tôi khuyên bạn nên thử nghiệm một chút với phiên bản cơ sở dữ liệu của mình.  Lớp dựa trên McGreavy trừu tượng cung cấp các hoạt động cơ bản có thể được thực thi đối với cá thể McGarvie.

24
00:03:53,740 --> 00:04:01,390
Ý tưởng là các kho lưu trữ sử dụng Mongo DB sẽ mở rộng lớp dựa trên McGreavy để thử nghiệm.

25
00:04:01,570 --> 00:04:21,880
Chúng tôi sẽ sử dụng Mongul trong mọi cuộc biểu tình, mở rộng lớp dựa trên Mongar DV, sau đó thực hiện thao tác chèn và tìm đối với bộ sưu tập thử nghiệm trong cơ sở dữ liệu Akhmatova, lớp dựa trên Mông Cổ có sẵn và AKAM DOT hoặc Info Dot Mongo DB.

26
00:04:22,180 --> 00:04:46,030
Bạn sẽ thấy rằng nó sử dụng máy khách Mongo DB.  Có một tập hợp các biến chứa các tham số kết nối cho Mongo DB, chức năng chèn thực thi, chèn tài liệu liền kề và bộ sưu tập Mongo DB và hàm find tìm tập hợp các tài liệu phù hợp với tiêu chí đã chỉ định.

27
00:04:46,030 --> 00:04:54,850
Vì vậy, hãy tiếp tục và đảm bảo rằng các thông số của chúng tôi đều tốt.  Mở bảng điều khiển McGreavy, đi tới Cluster và sau đó nhấp vào Connect.

28
00:04:55,060 --> 00:05:01,690
Nhấp vào kết nối với ứng dụng của bạn.  Sau đó bạn sẽ thấy có một biến được định nghĩa trong ví dụ này.

29
00:05:01,690 --> 00:05:15,450
Sao chép cái này và dán nó vào máy chủ Mongar TV biến.  Chỉ sao chép phần máy chủ và sau đó thay thế máy chủ Mongul TV bằng máy chủ Mongo DB của riêng bạn và sau đó chỉ cần xóa phần này.

30
00:05:15,460 --> 00:05:34,060
Vì vậy, bây giờ máy chủ của chúng tôi là tốt vào thời điểm này.  Chúng tôi cần tạo một người dùng mới trong cơ sở dữ liệu của mình để làm điều đó.  Trong bảng điều hướng bên trái, nhấp vào truy cập cơ sở dữ liệu và sau đó nhấp vào THÊM Cơ sở dữ liệu mới. Người dùng cung cấp tên ở đây sẽ gọi cho người dùng mà người dùng repro đã nói mật khẩu để giữ mọi thứ dễ dàng.

31
00:05:34,090 --> 00:05:50,890
Tôi đã giữ mật khẩu.  Giống như tên người dùng, người dùng Lepo cuộn xuống và user.  Bây giờ chúng tôi đã thêm người dùng vào cơ sở dữ liệu và như bạn sẽ thấy tôi đã có người dùng repo là người dùng McGreavy và mật khẩu là người dùng repo.

32
00:05:51,010 --> 00:06:09,080
Một điều cuối cùng.  Đảm bảo tên cơ sở dữ liệu là Achmea Travel, vì vậy hãy nhấp vào Kluster.  Và như bạn có thể thấy, tên là Acme Travel và hiện tại lớp dựa trên McGreavy được thiết lập với các tham số bắt buộc để kết nối với Mongo DB Democratie.

33
00:06:09,080 --> 00:06:32,110
Chúng tôi báo cáo lớp thử nghiệm mở rộng cơ sở Mongo DB trong chức năng chính.  Ở đây, trước tiên chúng ta tạo một phiên bản của lớp kiểm tra Maghrib, sau đó tạo một tài liệu mà chúng ta sẽ chèn vào bộ sưu tập kiểm tra và sau đó chỉ cần thực hiện thao tác chèn thực thi để chèn tài liệu vào bộ sưu tập kiểm tra.

34
00:06:32,350 --> 00:06:38,500
Nếu điều này thành công, chúng ta sẽ thấy một thông báo cho biết tài liệu đã được chèn vào bộ sưu tập.

35
00:06:38,770 --> 00:06:57,130
Ở bước thứ hai, chúng ta đang thực thi hàm get by name.  Để có được tài liệu mới được chèn bằng tên bộ lọc bằng John bây giờ, khoảng cách rối loạn chức năng theo tên là một hàm cục bộ và bạn có thể tự mình truy cập mã này.

36
00:06:57,160 --> 00:07:06,540
Nó chỉ đơn giản là tạo một bộ lọc và sau đó tìm bộ sưu tập tài liệu, chuyển đổi nó thành chuỗi của Jason và quay lại nếu việc truy xuất thành công.

37
00:07:06,910 --> 00:07:13,180
Và sau đó chúng ta chỉ cần in ra ý chính và chuỗi nhận được từ Mongo DB trước khi chạy lớp này.

38
00:07:13,210 --> 00:07:22,000
Hãy tiếp tục và dọn dẹp bộ sưu tập thử nghiệm của chúng ta.  Vì vậy, hãy bắt đầu các bộ sưu tập.  Khi bạn kiếm tiền từ bộ sưu tập, bạn sẽ thấy biểu tượng xóa này.

39
00:07:22,240 --> 00:07:36,370
Chỉ cần nhấp vào nó để xóa bài kiểm tra bộ sưu tập này và bây giờ bộ sưu tập của chúng tôi đã bị xóa.  Sẽ tiếp tục và chạy thử nghiệm báo cáo Mongar TV của chúng tôi bằng cách nhấp chuột phải vào chạy thử nghiệm Báo cáo Mongo DB.

40
00:07:36,520 --> 00:07:45,760
Và như bạn có thể thấy, bước đầu tiên đã thành công ở bước thứ hai.  Chúng tôi có tài liệu Jason với dữ liệu từ Mongo DB quay lại bộ sưu tập.

41
00:07:45,760 --> 00:07:51,880
Đây là dữ liệu mà chúng tôi vừa chèn đề xuất bạn nên tự mình thử lớp học dựa trên Mongo TV.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000012.srt -->

1
00:00:00,390 --> 00:00:11,700
Iran đang xây dựng thuê bao ACL vào cuối bài học này.  Chúng tôi sẽ có một người đăng ký đang hoạt động đóng vai trò là luật chống tham nhũng cho Quyết định lại.

2
00:00:11,820 --> 00:00:24,120
Tôi sẽ hướng dẫn bạn về mã và đề xuất, đọc báo cáo, sau đó tôi sẽ hướng dẫn bạn về mã và người đăng ký đề xuất và ở cuối bài giảng sẽ thấy người đăng ký đề xuất hoạt động.

3
00:00:24,510 --> 00:00:47,400
Trong bài học này, chúng ta sẽ phát triển hơn nữa mô hình Reid.  Trong mô hình Reid, sẽ có một triển khai kho lưu trữ kết nối với Mongo DB. Một người đăng ký sẽ được tạo để nhận các tin nhắn chẵn từ Rabbitt Amcu và sau đó người đăng ký sẽ sử dụng kho lưu trữ để ghi các sự kiện vào Mongo DB.

4
00:00:47,820 --> 00:01:03,030
Lớp repo trình đọc đề xuất mở rộng đề xuất lớp tốt nhất.  Người đăng ký sử dụng lớp dịch vụ ngôi sao Pops để nhận ngay cả tin nhắn khi nhận được đề xuất sự kiện.

5
00:01:03,030 --> 00:01:22,380
Người đăng ký sử dụng trình đọc đề xuất Rupo để thêm dữ liệu đề xuất vào bộ sưu tập cơ sở dữ liệu.  Để kiểm tra thiết lập, chúng tôi sẽ sử dụng thuê bao thử nghiệm, nó sẽ khởi chạy một phiên bản của thuê bao đề xuất để nhận tin nhắn từ Rabbitt MQ.

6
00:01:23,290 --> 00:01:41,410
Đề xuất bãi bỏ lớp mở rộng cơ sở Mongo DB, một điểm quan trọng cần lưu ý ở đây là lớp này không triển khai giao diện đề xuất và đó là do Redecide độc ​​lập với mô hình ở phía bên phải.

7
00:01:41,500 --> 00:01:50,860
Lớp này xử lý hai bộ sưu tập, bộ sưu tập dành cho các sự kiện đề xuất và bộ sưu tập dành cho các đề xuất, thậm chí còn có chức năng đề xuất nghệ thuật.

8
00:01:51,160 --> 00:02:00,430
Và họ thậm chí còn cung cấp Gissen trong bộ sưu tập của đề xuất.  Và đề xuất quảng cáo sẽ thêm đề xuất được cung cấp.

9
00:02:00,440 --> 00:02:12,310
Jason, trong bộ sưu tập đề xuất.  Sau đó, có một số hàm truy vấn mà hàm đề xuất tìm thấy đề xuất trong bộ sưu tập đề xuất và trả về dưới dạng chuỗi liền kề.

10
00:02:12,370 --> 00:02:22,360
Đề xuất GET cho chức năng khách hàng tìm thấy tập hợp các đề xuất cho lòng trung thành của khách hàng đã chỉ định và trả về dưới dạng đối tượng liền kề.

11
00:02:22,370 --> 00:02:35,450
Bạn có thể tự mình xem qua mã này.  Nó chỉ đơn giản là lấy các tài liệu từ Mongo DB và sau đó chuyển đổi các tài liệu này thành chuỗi liền kề trước khi tôi hướng dẫn bạn mã trong phần đăng ký.

12
00:02:35,740 --> 00:02:47,880
Chúng ta hãy xem cấu trúc của đề xuất.  Mặc dù có nhiều thuộc tính cho thuộc tính hành động cho biết hành động dẫn đến việc bỏ qua sự kiện.

13
00:02:48,430 --> 00:02:56,090
Chúng tôi chỉ mới tạo thậm chí, nhưng chúng có thể được cập nhật cũng như xóa hành động và có dấu thời gian và tốt.

14
00:02:56,110 --> 00:03:04,930
Nguồn là nguồn của sự kiện, trong trường hợp của chúng tôi là đề xuất rõ ràng CAMAC.  Và sau đó là tải trọng thực tế của sự kiện.

15
00:03:05,380 --> 00:03:16,210
Lớp người đăng ký đề xuất là lớp chống tham nhũng nhằm ngăn chặn sự tham nhũng của trang web đã đọc bởi các mô hình ở phía bên phải.

16
00:03:16,420 --> 00:03:24,190
Lớp này lấy một phiên bản của dịch vụ bật lên để đăng ký các sự kiện từ các lệnh liên quan đến đề xuất.

17
00:03:24,460 --> 00:03:31,570
Quá trình đăng ký được xác định trong hàm START.  Điều đầu tiên xảy ra ở đây là một trình xử lý tin nhắn đang được tạo.

18
00:03:31,600 --> 00:03:45,310
Trình xử lý tin nhắn này đã được chuyển sang mục đích dịch vụ để đăng ký tin nhắn.  Khi có thông báo đến, điều đầu tiên xảy ra là kho lưu trữ trình đọc đề xuất được tạo và sự kiện đề xuất quảng cáo được gọi trên đó.

19
00:03:45,460 --> 00:04:02,320
Và điều đó dẫn đến việc thêm sự kiện vào bộ sưu tập sự kiện đề xuất.  Sau đó, sự kiện được xử lý bằng cách gọi sự kiện đề xuất quy trình, đây là một hàm cục bộ trong hàm cục bộ này để nhận chuỗi của Jason được chuyển đổi sang tài liệu liền kề.

20
00:04:02,330 --> 00:04:13,810
Một thông báo được in trên bảng điều khiển và sau đó việc xử lý được thực hiện dựa trên hành động.  Bây giờ, hành động có thể thực hiện đối với đề xuất đã được tạo, cập nhật và xóa.

21
00:04:14,110 --> 00:04:26,770
Và việc triển khai này chúng tôi chỉ tập trung vào việc tạo đề xuất.  Dữ liệu được trích xuất từ ​​trọng tải nước tiểu và sau đó được thêm vào bộ sưu tập đề xuất bằng cách sử dụng trình đọc đề xuất REPL.

22
00:04:27,740 --> 00:04:47,570
Thuê bao của nó có sẵn theo gói thuế Securus V2 trong thuê bao thử nghiệm.  Chúng tôi cần cung cấp các tham số kết nối MQ và trong chức năng chính, chúng tôi đang tạo một phiên bản về mục đích dịch vụ, tạo một phiên bản của người đăng ký này và gọi cổ phiếu trên đó.

23
00:04:47,660 --> 00:05:04,610
Bây giờ, hãy tiếp tục và thiết lập các thông số AQAP của chúng ta.  Mở thông tin chi tiết về con thỏ Amcu của bạn và trên trang chi tiết, bạn sẽ thấy văn phòng MQ chỉ cần sao chép Bức tường chiếm đóng và thay thế Eurail mà chúng tôi đã có trong mã.

24
00:05:04,760 --> 00:05:16,580
Và đó là những gì bạn cần làm.  Và bây giờ tôi giả định rằng bạn đã tạo sàn giao dịch Acme Sales Coppock và ràng buộc giữa đề xuất.

25
00:05:16,580 --> 00:05:24,050
Q và sự trao đổi.  Điều này đã được thảo luận trong một trong những bài giảng trước đó.  Tại thời điểm này chúng tôi đã sẵn sàng để thử nghiệm.

26
00:05:24,900 --> 00:05:30,780
Để kiểm tra, trước tiên thuê bao sẽ khởi động thuê bao thử nghiệm.  Sau đó chúng ta sẽ thực hiện lệnh kiểm tra.

27
00:05:30,960 --> 00:05:41,550
Điều này sẽ dẫn đến kết thúc buổi tối, người đăng ký thử nghiệm sẽ nhận được thông tin này và sau đó chúng tôi sẽ kiểm tra xem người đăng ký đã thêm dữ liệu vào bộ sưu tập hay chưa.

28
00:05:41,790 --> 00:05:56,000
Vì vậy, hãy tiếp tục và khởi chạy thuê bao thử nghiệm đã khởi chạy thuê bao thử nghiệm.  Phải.  Nhấp vào thuê bao Kiểm tra và chạy thuê bao kiểm tra sau khi thuê bao đã khởi chạy Thực hiện lệnh kiểm tra chạy lệnh kiểm tra.

29
00:05:56,280 --> 00:06:07,370
Và khi lệnh đã được thực thi, chúng ta sẽ thấy một thông báo trong bảng điều khiển ở đầu thuê bao.  Và đây là tin nhắn nhận được lời đề nghị.

30
00:06:07,380 --> 00:06:16,230
Mặc dù vậy, ở bước thứ ba, chúng ta cần kiểm tra xem dữ liệu đã được thêm vào Mongar DB hay chưa.  Vì vậy, hãy mở bộ sưu tập của bạn.

31
00:06:16,260 --> 00:06:27,650
Làm cho khỏe lại.  Và đây là hai đề xuất bộ sưu tập mới, thậm chí là cửa hàng và đề xuất.  Đây là dữ liệu mà người đăng ký đã thêm vào đề xuất, thậm chí là lưu trữ.

32
00:06:28,020 --> 00:06:38,580
Và nếu chúng ta nhìn vào bộ sưu tập đề xuất, chúng ta sẽ thấy dữ liệu chỉ dành cho đề xuất đó.  Vậy tại thời điểm này, người đăng ký có hoạt động như mong đợi không?

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\11MicroservicesDBPerformanceManagement_VVN\000000013.srt -->

1
00:00:00,250 --> 00:00:13,010
Securus quyết định lại truy vấn trong bài giảng này.  Tôi sẽ hướng dẫn bạn cách triển khai phiên bản hai của truy vấn đề xuất và sau đó chúng tôi sẽ thử nghiệm phiên bản hai của truy vấn đề xuất.

2
00:00:13,560 --> 00:00:23,060
Cho đến nay, quá trình triển khai Securus của chúng tôi đang ở trạng thái có người đăng ký nhận các sự kiện và đưa vào bộ sưu tập McGreavy.

3
00:00:23,610 --> 00:00:34,350
Bây giờ chúng tôi sẽ giới thiệu thành phần truy vấn, thành phần này sẽ cung cấp chức năng truy vấn các đề xuất từ ​​bộ sưu tập McGreavy.

4
00:00:34,830 --> 00:00:43,560
Sự tận tâm đối với truy vấn đề xuất hiển thị các chức năng truy vấn giống như một trong những người dùng lớp truy vấn đề xuất truy vấn đề xuất.

5
00:00:43,560 --> 00:00:50,310
Kho lưu trữ trình đọc đề xuất để thực hiện các truy vấn đối với bộ sưu tập Mongo DB nhằm thử nghiệm truy vấn đề xuất.

6
00:00:50,550 --> 00:00:57,900
Chúng tôi sẽ sử dụng phiên bản hai của truy vấn thử nghiệm.  Ngoài ra, đây là cách triển khai lớp truy vấn đề xuất.

7
00:00:58,020 --> 00:01:06,120
Hàm đề xuất Gap lấy id đề xuất làm đối số và trả về chuỗi Jasons cho đề xuất.

8
00:01:06,210 --> 00:01:18,680
Điều đầu tiên nó làm là tạo một thể hiện của repo đề xuất và sau đó gọi đề xuất get trên đối tượng repo trả về số tiền Jason nhận được từ đối tượng repo.

9
00:01:18,690 --> 00:01:47,570
Tương tự, trong đề xuất GET cho khách hàng, nó được nhận làm đối số, một phiên bản của repo trình đọc đề xuất được tạo để nhận đề xuất cho khách hàng được gọi trên đối tượng repo và đối tượng liền kề được trả về hàm chính trong truy vấn thử nghiệm  Đầu tiên, lớp tạo đối tượng lớp truy vấn đề xuất và sau đó gọi các hàm truy vấn trên đối tượng truy vấn.

10
00:01:47,580 --> 00:01:55,910
Ở đây chúng tôi nhận được tất cả các đề xuất cho khách hàng bằng một và sau đó in ra kết quả nhận được.

11
00:01:55,920 --> 00:02:03,990
Jason, hãy tiếp tục và chạy truy vấn thử nghiệm.  Phải, nhấp vào truy vấn kiểm tra và chạy.  Và đây là kết quả từ truy vấn.

12
00:02:04,230 --> 00:02:15,120
Một điều bạn cần lưu ý ở đây là cấu trúc liền kề cho phiên bản hai của truy vấn khác với cấu trúc liền kề của phiên bản, một trong những cách triển khai truy vấn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12 Microservices Managing the Data Integrity\001 Introduction to Reliable Messaging.en.srt -->

1

00:00:00,210 --> 00:00:07,890

In the last section, you learn how the data gets replicated across multiple databases using messaging



2

00:00:08,040 --> 00:00:08,940

in this setup.



3

00:00:09,120 --> 00:00:15,400

There is a potential for the loss of message if the MQ or the messaging broker is unavailable.



4

00:00:15,720 --> 00:00:17,910

Let's say you are using Rabbitt MQ.



5

00:00:18,030 --> 00:00:24,630

The right side writes the data to its database, but is unable to put the message on the queue.



6

00:00:24,780 --> 00:00:28,360

Now the read side will never receive the message.



7

00:00:28,380 --> 00:00:36,120

As a result, the data across the two database instances is now in an inconsistent state.



8

00:00:36,510 --> 00:00:42,670

This kind of data loss may be prevented by using reliable messaging pattern in this pattern.



9

00:00:43,020 --> 00:00:45,750

The message is guaranteed to be delivered.



10

00:00:46,080 --> 00:00:54,480

The idea is that when the right side encounters a failure on the message send, it continues to retry



11

00:00:54,930 --> 00:00:57,680

till it is successful in sending the message.



12

00:00:57,870 --> 00:01:05,450

These retries may cause a delay in getting to a consistent state of data across the database instances,



13

00:01:05,850 --> 00:01:10,660

but the data will eventually be consistent across the database instances.



14

00:01:11,550 --> 00:01:16,270

Let's go over another scenario that may lead to inconsistent state in this scenario.



15

00:01:16,770 --> 00:01:24,810

The right site sends duplicate messages and redecide processes the same message more than once, and



16

00:01:24,810 --> 00:01:27,300

that may lead to inconsistent state.



17

00:01:27,870 --> 00:01:32,880

In the section, you will learn how to address the two failure scenarios that I have discussed.



18

00:01:32,910 --> 00:01:35,850

Let's go over the learning objectives in the first lecture.



19

00:01:35,880 --> 00:01:41,360

You learn the design for failure principle will go over the reliable messaging pattern.



20

00:01:41,370 --> 00:01:47,220

You learn how to handle duplicate messages and as we progress through the lectures, will address the



21

00:01:47,250 --> 00:01:48,270

Ackmann proposal.



22

00:01:48,280 --> 00:01:51,510

Securus design flaw that you will soon learn about.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12 Microservices Managing the Data Integrity\002 Designing for Failure.en.srt -->

1

00:00:00,150 --> 00:00:06,660

Designing for failure in this lesson, I'll discussed the concept of designing for failure, then I'll



2

00:00:06,660 --> 00:00:09,680

provide an overview of Two-Faced comment.



3

00:00:09,690 --> 00:00:13,080

After that, I'll discuss the reliable messaging pattern.



4

00:00:13,620 --> 00:00:20,190

The concept of design for failure suggests that you should always anticipate that there will be failures.



5

00:00:20,850 --> 00:00:27,510

As a designer of the software, you should identify the failure points in your architecture.



6

00:00:27,690 --> 00:00:29,610

Let's go over a quick example.



7

00:00:29,970 --> 00:00:36,510

Let's say you have a Microsoft Office that is talking to Microsoft Office B over a message box.



8

00:00:36,510 --> 00:00:43,040

And let's say Microsoft is a also depends on an external service to which it connects by way of rest



9

00:00:43,140 --> 00:00:43,890

HTP.



10

00:00:44,130 --> 00:00:47,560

Now, if you look at this diagram, what can go wrong here?



11

00:00:47,700 --> 00:00:49,830

That is where are the failure points?



12

00:00:50,070 --> 00:00:57,030

If you look at the Microsoft, is it the database may go down or even the network may not be available



13

00:00:57,240 --> 00:01:01,420

to Microsoft as a way to connect with the message boards and the external service.



14

00:01:01,740 --> 00:01:02,820

What else can go wrong?



15

00:01:02,970 --> 00:01:08,760

Microsoft will be may not be available and on the same lines, even if the network is available, the



16

00:01:08,760 --> 00:01:10,700

external service may not be available.



17

00:01:10,740 --> 00:01:17,850

So the suggestion is that once you have identified the failure points in your architecture, proactively



18

00:01:17,880 --> 00:01:20,360

address all of the failure points.



19

00:01:20,760 --> 00:01:26,690

Time for a quiz in this component diagram that are discussed in one of the earlier lectures, the command



20

00:01:26,700 --> 00:01:32,260

object is writing to the database and then publishing a message to a topic.



21

00:01:32,280 --> 00:01:37,940

Your goal is to identify all of the failure points in this architecture.



22

00:01:38,400 --> 00:01:40,740

Please post a video and try it out.



23

00:01:41,010 --> 00:01:41,550

All right.



24

00:01:41,820 --> 00:01:44,240

I'll discuss the solution next.



25

00:01:44,550 --> 00:01:50,580

The best way to find out the failure point in an architecture are to assume that there will be failures



26

00:01:50,880 --> 00:01:53,600

and all interfaces and components.



27

00:01:54,210 --> 00:02:00,990

So in this diagram, looking at it from the right side perspective, the network may not be available



28

00:02:00,990 --> 00:02:02,400

to the command object.



29

00:02:03,120 --> 00:02:07,770

As a result, it will not be able to update the database and publish a message.



30

00:02:07,770 --> 00:02:16,080

Even though the network is up at all times, the database server may have issues, it may go down or



31

00:02:16,080 --> 00:02:18,270

it may run out of resources.



32

00:02:18,570 --> 00:02:21,460

And there are many other things that can happen to the database.



33

00:02:21,810 --> 00:02:28,290

Similarly, even if the network is up, the command object may not be able to publish a message to Amcu



34

00:02:28,500 --> 00:02:30,550

due to the failure of the Amcu server.



35

00:02:30,570 --> 00:02:33,840

And then there may be failures on the Reid side.



36

00:02:34,080 --> 00:02:41,250

In this lesson, my focus will be on the right side only and I'll discuss the redecide failures in a



37

00:02:41,250 --> 00:02:42,050

later lecture.



38

00:02:42,300 --> 00:02:48,600

No, as a software designer, once you have identified the failure points, you need to think about



39

00:02:48,750 --> 00:02:50,820

the impact of those failure points.



40

00:02:51,120 --> 00:02:56,070

So we will zoom in on the failure of availability of Amcu.



41

00:02:56,580 --> 00:03:03,900

In this scenario, the command will be invoked and the command will be able to write to the database,



42

00:03:04,260 --> 00:03:10,050

but when it try to publish a message to the Amcu, it will fail.



43

00:03:10,350 --> 00:03:12,500

Now if you think about it, what is the result?



44

00:03:12,510 --> 00:03:19,650

The result is that the data is on the right side is updated, but the subscriber on the right side will



45

00:03:19,650 --> 00:03:21,360

never receive the event.



46

00:03:22,050 --> 00:03:28,700

And so this has led to the right and the right side going out of sync.



47

00:03:29,520 --> 00:03:34,790

The bottom line is that our Securus implementation for proposals is flawed.



48

00:03:35,040 --> 00:03:42,600

There is a potential of loss of event and that will lead to the proposal being available on the right



49

00:03:42,600 --> 00:03:42,990

side.



50

00:03:43,110 --> 00:03:47,370

But that same proposal will not be available on the Reid site.



51

00:03:47,520 --> 00:03:51,690

Next, I'll discuss some solutions to address this particular type of failure.



52

00:03:52,110 --> 00:04:00,480

One way to address this failure would be to write to the database and publish a message to the AMCU



53

00:04:00,480 --> 00:04:04,140

in a single unit of work or a transaction to face.



54

00:04:04,380 --> 00:04:12,150

It is a mechanism that can be used for carrying out the Debride and Anku publish in a single unit of



55

00:04:12,150 --> 00:04:13,230

work or transaction.



56

00:04:13,740 --> 00:04:18,350

Two-Faced face has been in use for the past almost three decades now.



57

00:04:18,930 --> 00:04:26,310

In first comment or distributed algorithm is used for coordinating all the processes involved in the



58

00:04:26,310 --> 00:04:27,630

distributed transaction.



59

00:04:27,990 --> 00:04:34,560

It is also referred to as the extended architecture or just exit for short interface.



60

00:04:34,950 --> 00:04:41,490

There is a transaction manager that coordinates the transaction across all of the involved resources.



61

00:04:41,790 --> 00:04:47,130

In this case, the resources are the database and the AMCU bus.



62

00:04:47,490 --> 00:04:54,210

The challenge with Two-Faced comment is that it is quite complex to implement and a bigger challenge



63

00:04:54,210 --> 00:04:59,610

is that it is not even available for many commonly used distributed to.



64

00:04:59,830 --> 00:05:08,350

Ologies Rabbit Amcu, Amazon, Rescuer's, Mongo, TV are just some of the examples of technologies



65

00:05:08,620 --> 00:05:17,080

that do not support Two-Faced comic due to these challenges, the two faced climate is not very popular



66

00:05:17,410 --> 00:05:20,330

with the designers of the distributed systems.



67

00:05:20,590 --> 00:05:28,570

The alternative would be to break the database right and MQ publish in two steps and use local database



68

00:05:28,570 --> 00:05:29,320

transactions.



69

00:05:29,440 --> 00:05:36,100

Since there is no common name for this pattern, I'll call it a reliable messaging pattern.



70

00:05:36,430 --> 00:05:45,610

In this pattern, the right side writes the domain object data and the event data in the database tables



71

00:05:45,910 --> 00:05:53,500

with a local transaction, and then the events are replayed against the queuing system in a separate



72

00:05:53,500 --> 00:05:53,920

step.



73

00:05:54,190 --> 00:05:59,440

Let me walk you to an illustration which will make this pattern very clear.



74

00:05:59,830 --> 00:06:07,540

You're already familiar with this illustration in which the Creel Proposal Command is writing the proposal



75

00:06:07,540 --> 00:06:14,860

data to the database and then publishing a message in the post processing step to use the reliable messaging



76

00:06:14,860 --> 00:06:20,110

pattern declared proposal command will no more publish a message to MQ.



77

00:06:20,500 --> 00:06:27,520

Instead, we will introduce a new table in the database alongside the proposals.



78

00:06:27,520 --> 00:06:31,240

Table will call this table proposal even table.



79

00:06:31,330 --> 00:06:38,400

When the cleared proposal command will be invoked, it would write the proposals data to the proposals



80

00:06:38,410 --> 00:06:44,980

table and it write the proposal, even payload to the proposal, even table.



81

00:06:45,220 --> 00:06:48,310

And these rights will be carried out in a local transaction.



82

00:06:48,310 --> 00:06:54,910

In other words, either both the rights will succeed or both the rights will fail, will introduce a



83

00:06:54,910 --> 00:06:57,220

new component, even processor.



84

00:06:57,640 --> 00:07:06,130

The even processor will be implemented as a standalone process that would periodically check the proposal.



85

00:07:06,250 --> 00:07:15,160

Even table for unprocessed even's unprocessed even's are the ones that have not been published to Amcu



86

00:07:15,400 --> 00:07:24,070

for each of the unprocessed events, the events processor will publish the even payload to Amcu.



87

00:07:24,820 --> 00:07:34,170

If the Amcu publish are successful, then the event Processo will mark the event in the proposal, even



88

00:07:34,200 --> 00:07:36,250

stable as processed.



89

00:07:36,580 --> 00:07:43,990

And once the event is marked as process, it will no more be used for publishing the event.



90

00:07:44,530 --> 00:07:48,940

So let's think about how this would help prevent the event loss.



91

00:07:48,940 --> 00:07:56,320

The way it'll work is, let's say the rabbit Amcu goes down in the scenario and even Processo will try



92

00:07:56,320 --> 00:07:58,060

to publish a message.



93

00:07:58,060 --> 00:08:05,220

It'll fail and since there will be a failure on publish, the event will not be marked as processed.



94

00:08:05,230 --> 00:08:14,320

As a result, the even status is still unprocessed and in the next cycle the even processor will again



95

00:08:14,470 --> 00:08:19,720

pick up the unprocessed even and try to publish it to Amcu.



96

00:08:20,050 --> 00:08:27,160

Eventually the publish will be successful and the status of the event will be updated and the database



97

00:08:27,400 --> 00:08:30,130

as a result, even loss will be prevented.



98

00:08:31,330 --> 00:08:38,140

Next, I'll walk you to the event processor logic, the even processer is implemented as an independent



99

00:08:38,140 --> 00:08:39,540

standalone process.



100

00:08:40,090 --> 00:08:45,070

It continuously looks for the unprocessed events in the database.



101

00:08:45,640 --> 00:08:52,960

So the first thing it does is invoker select or find against the database to get all the unprocessed



102

00:08:53,140 --> 00:08:53,680

events.



103

00:08:53,980 --> 00:09:03,040

If there are no unprocessed events, then the even processor goes to sleep for some time and then wakes



104

00:09:03,040 --> 00:09:03,910

up after the sleep.



105

00:09:03,910 --> 00:09:09,610

Time again, checks for the unprocessed events and this loop continues.



106

00:09:10,220 --> 00:09:19,420

If the even processor finds an unprocessed event, then it publishes the even to MQ in case there is



107

00:09:19,420 --> 00:09:21,760

a failure in the published part.



108

00:09:22,240 --> 00:09:28,420

Then the further actions are aborted and the even processor goes back to sleep.



109

00:09:29,140 --> 00:09:32,740

After a while, it again checks for unprocessed events.



110

00:09:32,920 --> 00:09:39,880

But if the publishers are successful, then the event is marked as processed in the database.



111

00:09:40,240 --> 00:09:47,350

After all of the unprocessed events have been published, even Processor goes back to sleep for some



112

00:09:47,350 --> 00:09:51,820

time and continues to check for unprocessed events.



113

00:09:52,780 --> 00:09:54,430

Time to go over the key points.



114

00:09:54,430 --> 00:10:02,740

From this lesson, you must identify failure points in your architecture and you must proactively address



115

00:10:02,740 --> 00:10:03,890

those failure points.



116

00:10:04,360 --> 00:10:08,020

This is the concept of designing for failure to face.



117

00:10:08,290 --> 00:10:14,980

It can be used for executing distributed transactions across multiple resources.



118

00:10:15,430 --> 00:10:22,000

But keep in mind, there are multiple challenges in using Two-Faced comic for preventing the loss of



119

00:10:22,000 --> 00:10:23,530

messages or events.



120

00:10:23,530 --> 00:10:25,900

You may use reliable messaging pattern.



121

00:10:26,500 --> 00:10:33,010

In the next few lectures you will see the reliable messaging pattern in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12 Microservices Managing the Data Integrity\003 Exercise _ Address ACME CQRS Write side failures.en.srt -->

1

00:00:00,210 --> 00:00:05,040

We will carry out right side up in the security implementation.



2

00:00:05,070 --> 00:00:12,070

We will enhance the security right side to prevent the evil message loss in this lesson.



3

00:00:12,090 --> 00:00:15,130

I'll provide you a high level overview of the implementation.



4

00:00:15,180 --> 00:00:23,070

Then I'll walk you through the code in the event processer and other classes, and then you will see



5

00:00:23,400 --> 00:00:26,760

the reliable messaging pattern in action.



6

00:00:27,660 --> 00:00:32,210

The code covered in this lecture is available under the get branch data.



7

00:00:32,640 --> 00:00:36,630

So please make sure that you have checked out the gate branch data.



8

00:00:36,900 --> 00:00:44,940

In the last Hands-On lecture, you learn how the I.T. team built the Securus pattern and as they started



9

00:00:44,940 --> 00:00:51,690

to test the securest pattern, they realized that if the rabbit Anchia was down or if there was a network



10

00:00:51,690 --> 00:00:55,130

connected issue with rabbit, MQ messages were lost.



11

00:00:55,290 --> 00:01:03,060

So they have decided to use reliable messaging pattern to fix the Securus implementation in this lecture.



12

00:01:03,330 --> 00:01:09,510

I'll discuss the changes that were made to the Securus implementation version to.



13

00:01:10,480 --> 00:01:16,810

When they cleared proposal command will be invoked, it will write to do database tables, the two robots



14

00:01:16,810 --> 00:01:22,210

tables will be the proposal, their table and the even payload.



15

00:01:22,390 --> 00:01:23,210

There are tables.



16

00:01:23,380 --> 00:01:27,740

These two rights will be carried out in a local database transaction.



17

00:01:27,760 --> 00:01:33,850

So what that means is either both rights will be successful or both will fail.



18

00:01:34,300 --> 00:01:41,200

As you can not hear, the command processor is not directly interacting with the message, but for that



19

00:01:41,200 --> 00:01:43,090

we will have even processer.



20

00:01:43,240 --> 00:01:52,000

The even processor is a standalone process which will periodically check the unpublished events in the



21

00:01:52,120 --> 00:01:54,010

event payload data table.



22

00:01:54,010 --> 00:02:01,870

If it will find events that have not been published, it will publish those events to the message boards



23

00:02:02,470 --> 00:02:08,740

and then update the status of the events in the database table as published.



24

00:02:09,160 --> 00:02:16,060

But this set up non-availability of messaging will not lead to a missing out of the event.



25

00:02:17,950 --> 00:02:25,000

Here is how the database table for the Even's will look like we will have the Eventide and the proposal



26

00:02:25,000 --> 00:02:26,170

lady proposal.



27

00:02:26,200 --> 00:02:30,150

It is the proposal for which the events is getting published.



28

00:02:30,430 --> 00:02:36,330

Every event will have a unique ID which is represented by even underscore.



29

00:02:36,340 --> 00:02:36,880

Good.



30

00:02:36,880 --> 00:02:43,360

Then we have the payload for the even the processed flag is set to default by default to indicate that



31

00:02:43,360 --> 00:02:45,870

the event has not yet been published.



32

00:02:45,880 --> 00:02:50,890

And when the event will be published, the processed flag will be set to true.



33

00:02:51,280 --> 00:02:57,780

Creator date is the timestamp when the event data was added to the proposals.



34

00:02:57,820 --> 00:03:04,420

Even table and process date is the timestamp when the event was successfully published.



35

00:03:04,540 --> 00:03:11,800

And then we have the primary key, which is the event ID and a constraint indicating that proposal ID



36

00:03:12,160 --> 00:03:15,120

must exist in the proposals table.



37

00:03:15,280 --> 00:03:17,350

Let's go ahead and create this table.



38

00:03:17,860 --> 00:03:25,250

The sequel for Table Creation is available under the sequel folder Reliable Dash Messaging Dash, DDL



39

00:03:25,270 --> 00:03:25,960

or sequel.



40

00:03:26,410 --> 00:03:29,530

Just copy the entire sequel to The Clipboard.



41

00:03:29,530 --> 00:03:37,930

Go to the console for Elephant sequel, open up the browser, paste the detail and execute and the query



42

00:03:37,930 --> 00:03:38,860

was completed.



43

00:03:39,190 --> 00:03:41,560

So that means we have the table created.



44

00:03:42,100 --> 00:03:49,360

The version three of the Create Proposal Command uses the version three of the proposal repository.



45

00:03:49,690 --> 00:03:58,840

This proposal repository version three has a big change in how the proposal data gets added to the proposals



46

00:03:58,870 --> 00:03:59,350

table.



47

00:03:59,590 --> 00:04:07,600

This implementation now execute to insert statements within a single transaction and this will become



48

00:04:07,600 --> 00:04:09,520

clear when you will see the code.



49

00:04:10,060 --> 00:04:13,870

The even processor class is under its own package.



50

00:04:14,050 --> 00:04:21,460

It will run as a separate process and use the proposal, even repository, to select the events that



51

00:04:21,460 --> 00:04:23,650

have not been processed or published.



52

00:04:24,070 --> 00:04:26,500

Let's go ahead and look at these classes.



53

00:04:27,220 --> 00:04:34,030

The classes that I'm going to discuss are available under the Securus Vetri package here will start



54

00:04:34,030 --> 00:04:41,650

with the repository because the customer repository is extending the version to of customer repo and



55

00:04:41,650 --> 00:04:42,580

there is no change.



56

00:04:42,970 --> 00:04:49,210

But the change is there in the proposal repository, which is extending the version two of proposal



57

00:04:49,210 --> 00:04:54,970

repository, overriding the ACC proposal function in the proposal function.



58

00:04:55,060 --> 00:04:59,770

We are first creating the insert sequel for the proposals.



59

00:05:00,070 --> 00:05:06,610

If you would like to check it out, take a look at the version two of Proposal REPL as a next step.



60

00:05:06,610 --> 00:05:15,130

We are creating the even payload and creating the sequel statement for inserting the event data in the



61

00:05:15,130 --> 00:05:17,140

proposal even table.



62

00:05:17,500 --> 00:05:19,000

Let's take a quick look at it.



63

00:05:19,150 --> 00:05:28,180

You will see that most of the code in the clear event, payload and sequel is for creating the JSON



64

00:05:28,180 --> 00:05:30,160

representation of the event.



65

00:05:30,340 --> 00:05:33,220

And then we have the sequel statement.



66

00:05:33,340 --> 00:05:39,520

Now, one important thing that I would like you to take a look at is that I'm encoding the even payload



67

00:05:39,820 --> 00:05:41,230

to base64.



68

00:05:41,230 --> 00:05:47,140

And the reason I'm doing that is because there are caught in the string and that would cause problem



69

00:05:47,350 --> 00:05:50,740

when I enter the data into the database table.



70

00:05:50,750 --> 00:05:57,550

Now, there are other ways to address this challenge, but I have taken the simplest path.



71

00:05:57,550 --> 00:06:03,790

In fact, you could also create jobs and data type columns and postgrads equal, but I want to keep



72

00:06:03,790 --> 00:06:05,770

it independent of the database.



73

00:06:05,980 --> 00:06:09,580

So this is where the combined cycle statement is getting created.



74

00:06:09,580 --> 00:06:17,710

As you can see, I'm using the word close but equal for the proposal and the sequel for the proposal.



75

00:06:17,710 --> 00:06:26,410

Even we will print this sequel on the console and then execute it in a single transaction.



76

00:06:26,410 --> 00:06:32,920

And as a result, either both the proposal and the proposal, even data will be added to the respective



77

00:06:32,920 --> 00:06:35,290

tables or they will both fail.



78

00:06:35,620 --> 00:06:41,110

The command implementation is under the three that command package, and this implementation is same



79

00:06:41,110 --> 00:06:47,740

as the version two of the implementation, except that it is using version three of the proposal repo



80

00:06:47,740 --> 00:06:48,190

class.



81

00:06:48,520 --> 00:06:54,850

And it is not carrying out any kind of post-processing because now the post-processing has been moved



82

00:06:54,850 --> 00:06:56,390

to the even processor.



83

00:06:56,410 --> 00:06:58,700

Next, I'll walk you through the even processa.



84

00:06:59,170 --> 00:07:07,260

The process processor classes are available under the Securus Dot Vetri DOT command or even package.



85

00:07:07,570 --> 00:07:11,320

You will find three classes under the proposal.



86

00:07:11,320 --> 00:07:16,840

Even class is the model for the data in the proposal even.



87

00:07:17,630 --> 00:07:19,860

Then we have the proposal, even triple.



88

00:07:20,060 --> 00:07:26,240

This class is extending the GBC based class, there are two functions in it.



89

00:07:26,900 --> 00:07:34,220

First function is to get the unprocessed Even's from the proposal table, and the second function is



90

00:07:34,220 --> 00:07:39,560

for marking the specified event as processed.



91

00:07:39,920 --> 00:07:44,390

I suggest that you go through the code in this class on your own.



92

00:07:44,810 --> 00:07:48,010

The main class is the events processor class.



93

00:07:48,590 --> 00:07:51,590

This class implements the Runnable interface.



94

00:07:51,610 --> 00:07:56,600

So what that means is that it needs to implement the round function.



95

00:07:56,880 --> 00:08:04,400

It holds an instance of the pops of service class, which is passed to it as part of the constructor.



96

00:08:04,550 --> 00:08:08,430

It also holds an instance of the proposal, even people.



97

00:08:08,750 --> 00:08:16,090

So when a third is started with an instance of this class, the run function is executed and the run



98

00:08:16,100 --> 00:08:24,410

function is a never ending while loop in which the first thing we are doing is getting all the unprocessed



99

00:08:24,590 --> 00:08:31,880

events, printing out the number of unprocessed events on the console and then processing each of the



100

00:08:32,210 --> 00:08:32,790

events.



101

00:08:33,200 --> 00:08:36,600

Let's take a quick look at what is happening in the processing of the events.



102

00:08:37,190 --> 00:08:44,960

The first thing that happens in the process, even function, is that the event payload is decoded from



103

00:08:44,960 --> 00:08:48,080

base64 to UTF eight string.



104

00:08:48,590 --> 00:08:55,690

Then the event payload is printed on the console and after that the even gets published.



105

00:08:56,180 --> 00:09:01,370

If there is a failure on publish, the next statement will not be executed.



106

00:09:01,730 --> 00:09:08,480

But if the publisher successful, then this statement will be executed and the statement is marking



107

00:09:08,480 --> 00:09:10,500

the event as processed.



108

00:09:10,820 --> 00:09:17,640

So now once the event is marked as processed, it'll no more be picked up as an unprocessed event.



109

00:09:18,020 --> 00:09:19,760

Now let's go back to the one function.



110

00:09:20,030 --> 00:09:28,010

Once all of the unprocessed events have been processed, destroyed, goes to sleep for the sleep time,



111

00:09:28,280 --> 00:09:35,360

the sleep time is defined as the final static variable, which is set to 10 seconds in this implementation.



112

00:09:35,670 --> 00:09:43,520

Let's go ahead and try out our modified Securus Rightside implementation to test out the implementation.



113

00:09:43,520 --> 00:09:50,240

We will use the test command class and the test even processor class available under the test.



114

00:09:50,240 --> 00:09:53,090

Not Securus, not Vetri package.



115

00:09:53,420 --> 00:10:00,200

In the test command implementation, you will find that there is no code difference from version two



116

00:10:00,200 --> 00:10:07,090

of the command, except that in this class we are using version three of the clear proposal command



117

00:10:07,370 --> 00:10:10,310

and sort of version to the test.



118

00:10:10,310 --> 00:10:13,400

Even processor class has the MQ parameters.



119

00:10:13,400 --> 00:10:15,950

Make sure that you have set up the right Eurail here.



120

00:10:16,340 --> 00:10:24,740

And in the main function we are creating an instance of the pops of service, creating an instance of



121

00:10:24,740 --> 00:10:31,040

the even processor but the pops of service and then simply starting the track.



122

00:10:31,160 --> 00:10:37,730

Once the threat starts, it wakes up every 10 seconds, looks for the unprocessed events and if it finds



123

00:10:37,730 --> 00:10:40,420

the UN process, even then it publishes it.



124

00:10:40,760 --> 00:10:48,170

Let's go ahead and check if we have anything in our queue to go to Rabbitt MQ Manager click on Cuz check



125

00:10:48,170 --> 00:10:52,760

the proposal, read a Q and as you can see there are zero messages.



126

00:10:52,760 --> 00:11:02,150

Let's go ahead and the even processa right click on test even processor run test, even processor or



127

00:11:02,150 --> 00:11:09,550

even processor has started and as you can see at this time it is finding zero unprocessed events.



128

00:11:09,560 --> 00:11:13,580

The next thing that we are going to do is run the test, come in and run the test.



129

00:11:13,580 --> 00:11:14,170

Come on.



130

00:11:14,180 --> 00:11:14,540

Right.



131

00:11:14,540 --> 00:11:17,840

Click on Test Command and run test command.



132

00:11:17,870 --> 00:11:20,360

Let's go back to our even processor.



133

00:11:20,510 --> 00:11:24,320

And we should see even popping up here any second now.



134

00:11:24,320 --> 00:11:28,370

So here is the event that our test even processor has received.



135

00:11:28,370 --> 00:11:34,130

And if everything has gone fine, we should be able to find this even in the queue.



136

00:11:34,130 --> 00:11:40,760

And as you can see, we do have one message and we can get the message by clicking on that message.



137

00:11:41,270 --> 00:11:42,980

And here is our message.



138

00:11:43,190 --> 00:11:49,100

Let's go to the sequel browser and select the proposal events.



139

00:11:49,460 --> 00:11:51,620

And we should see one event here.



140

00:11:51,710 --> 00:11:57,350

And as you can see here, we have one event here and the process is set to true.



141

00:11:57,860 --> 00:12:02,690

This is the best 64 and quarter payload for the event.



142

00:12:02,930 --> 00:12:08,150

And so at this point, our reliable messaging partners seem to be working.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12 Microservices Managing the Data Integrity\004 Exercise _ Address ACME CQRS Read side failures.en.srt -->

1

00:00:00,240 --> 00:00:06,210

In the last couple of lectures, you learned about the right site failures in this lesson, I talk about



2

00:00:06,210 --> 00:00:13,950

the redecide failure scenarios and I'll also discuss one Rightside failure scenario that leads to Messers



3

00:00:13,950 --> 00:00:16,980

duplication issue on the Reid site.



4

00:00:17,250 --> 00:00:22,750

As part of the discussion, I'll cover the solution to these failure scenarios.



5

00:00:23,220 --> 00:00:28,850

Please note that the discussion in this lesson is for messaging based replication only.



6

00:00:29,130 --> 00:00:33,990

I'm not covering the native replication mechanism or third party replication mechanism.



7

00:00:34,200 --> 00:00:39,120

Also, the discussion on messaging is not applicable to Cafcass Streams.



8

00:00:39,360 --> 00:00:41,370

I'll start the lesson with a quiz.



9

00:00:41,520 --> 00:00:45,300

Identify the failure points on the Reid site.



10

00:00:45,630 --> 00:00:48,040

Please pause the video if you need more time.



11

00:00:48,450 --> 00:00:50,340

Next, I'll discuss the solution.



12

00:00:50,550 --> 00:00:56,160

There may be failure in the network between the replicator and MQ.



13

00:00:56,400 --> 00:00:59,450

The replicator itself may have failure.



14

00:00:59,550 --> 00:01:06,060

For example, the process may crash or there may be issues on the machine hosting the process.



15

00:01:06,060 --> 00:01:12,810

The network between the replicator and the database may become unavailable due to the replicator will



16

00:01:12,810 --> 00:01:18,510

not be able to reach the database and the database itself may have issues overall.



17

00:01:18,810 --> 00:01:26,100

The impact of these issues is that there may be loss of events due to which the Reed site and the right



18

00:01:26,100 --> 00:01:28,130

side will go out of sync.



19

00:01:28,140 --> 00:01:35,850

The other impact may be they may be delays in the Reed site becoming consistent with the right side.



20

00:01:36,030 --> 00:01:41,600

Let's call for potential solutions for addressing some of these challenges.



21

00:01:42,060 --> 00:01:48,390

Let's start with a scenario where the network connectivity between the replicator and the MQ is lost



22

00:01:48,420 --> 00:01:53,730

or the replicator process itself is down due to some challenge.



23

00:01:53,730 --> 00:02:00,390

One potential solution for this problem would be to use message, persistence and time to live.



24

00:02:00,400 --> 00:02:02,340

Let me explain what I mean by that.



25

00:02:02,460 --> 00:02:06,780

The idea is that most MQ systems allow message persistence.



26

00:02:06,780 --> 00:02:14,160

In other words, the messages are written to the desk for persistence and they're available for a longer



27

00:02:14,160 --> 00:02:15,030

time duration.



28

00:02:15,270 --> 00:02:20,340

The duration for which the message is available is determined by time to live.



29

00:02:20,520 --> 00:02:25,710

This time to live can be set on the MQ queue or at the message level.



30

00:02:26,040 --> 00:02:32,520

The idea is simple that the party will decide how long the messaging system will retain the message



31

00:02:32,550 --> 00:02:33,210

on the queue.



32

00:02:33,540 --> 00:02:37,700

Once the time to leave has expired, the message will be lost.



33

00:02:37,710 --> 00:02:45,900

So as the designer of a distributed system using MQ, you must think about persistence, determine what



34

00:02:45,900 --> 00:02:48,780

is an appropriate time to live for your messages.



35

00:02:49,050 --> 00:02:53,310

For other time, you are provided the link where you can get some more information.



36

00:02:53,970 --> 00:03:00,540

The next scenario that are discussed involves successful read of the message by the replicator, but



37

00:03:00,540 --> 00:03:03,350

failure on writing to the database.



38

00:03:03,390 --> 00:03:11,130

This kind of a failure may be addressed by using the reject or the rollback mechanism available on Incubus.



39

00:03:11,310 --> 00:03:18,420

The idea is that when the replicator or subscriber receives the message, it does not automatically



40

00:03:18,450 --> 00:03:19,340

acknowledge it.



41

00:03:19,650 --> 00:03:21,900

It first tries to write it to the database.



42

00:03:22,200 --> 00:03:29,100

And if the database right is successful, then the replicator acknowledges the message, which leads



43

00:03:29,100 --> 00:03:36,030

to the removal of message from MQ boss in case of a failure to replicate or may reject the message.



44

00:03:36,330 --> 00:03:41,820

What that means is that the message will be put back on the queue and will not be lost.



45

00:03:42,120 --> 00:03:49,590

The rejection mechanism is very specific to the messaging system for every time you can read more about



46

00:03:49,590 --> 00:03:51,020

it at this link.



47

00:03:51,330 --> 00:03:56,490

Now, a couple of considerations to keep in mind when you are using rejection.



48

00:03:56,670 --> 00:04:00,630

The first one is that the queue typically has a capacity.



49

00:04:01,290 --> 00:04:05,820

So, for example, let's say a queue has a capacity of five thousand messages.



50

00:04:06,060 --> 00:04:13,950

And so if there are only 5000 messages and the replicator rejects the message, that message will be



51

00:04:13,950 --> 00:04:15,840

put back on the queue.



52

00:04:16,140 --> 00:04:23,130

But because there are already 5000 messages, one of the messages will be removed to accommodate this



53

00:04:23,130 --> 00:04:24,110

rejected message.



54

00:04:24,120 --> 00:04:29,460

Not every queuing system has a different way of deciding which message will be removed.



55

00:04:29,610 --> 00:04:31,440

So I won't go into the details of that.



56

00:04:31,860 --> 00:04:37,470

You just need to keep in mind that it is a possibility, especially when you replicator is known for



57

00:04:37,470 --> 00:04:42,150

a long period of time and there is a large volume of messages coming into the queue.



58

00:04:42,630 --> 00:04:48,420

The other thing that the messaging system may do is move the message to the dead letter.



59

00:04:48,420 --> 00:04:52,010

Q And this can happen for a couple of reasons.



60

00:04:52,020 --> 00:04:57,270

One common reason is that there is a retrial or pre-delivery count on the message.



61

00:04:57,600 --> 00:04:59,510

And again, as I said earlier, this is a.



62

00:04:59,640 --> 00:05:07,740

Depending on the messaging system, this retry or pre-delivery has a maximum limit, and so if you exceed



63

00:05:07,740 --> 00:05:14,240

that retries by that maximum limit, the message is pushed to the deadly attack.



64

00:05:14,640 --> 00:05:18,660

You can read more about that later, cuz at this link for Rabbitt MQ.



65

00:05:19,670 --> 00:05:26,030

Sometime a failure on the right side may have an impact on the right side.



66

00:05:26,270 --> 00:05:34,190

Consider the scenario where the even processer is able to publish the message to Amcu, but it could



67

00:05:34,190 --> 00:05:39,850

not update the status of the event in the database as processed.



68

00:05:39,980 --> 00:05:43,830

So the question is, will there be any impact on the right side?



69

00:05:43,850 --> 00:05:47,660

And if there will be an impact on the right side, what will be the impact?



70

00:05:49,790 --> 00:05:58,010

For understanding the impact, let's take a look at the implementation of the even processa, even processa



71

00:05:58,160 --> 00:06:04,280

finds the event that need to be published and so it publishes the event after publishing the event,



72

00:06:04,280 --> 00:06:04,820

it checks.



73

00:06:04,820 --> 00:06:11,450

If the publish was successful, it was bought before it could update the status of the event in the



74

00:06:11,450 --> 00:06:12,020

database.



75

00:06:12,380 --> 00:06:19,540

The database went back as a result, when the even processor tried to update the database, it failed.



76

00:06:20,180 --> 00:06:28,760

So the impact will be that the message is in the queue and since its status has not been updated, it'll



77

00:06:28,760 --> 00:06:33,730

be picked up again by the even processor and published to MQ.



78

00:06:33,740 --> 00:06:39,440

As a result, the site will receive the same event more than one time.



79

00:06:39,620 --> 00:06:44,630

A solution need to be put in place to avoid duplication of events.



80

00:06:45,290 --> 00:06:52,630

A follow up question at this point is which side should put in a fix to address the problem of duplicates?



81

00:06:52,640 --> 00:06:58,640

Should it be the right side or the right side, especially if there are two different teams that are



82

00:06:58,640 --> 00:07:01,630

independently managing the two sites?



83

00:07:01,790 --> 00:07:08,780

Well, both the sides should consider putting in a fix, but if I have to pick one of the two teams,



84

00:07:09,080 --> 00:07:14,690

then I would say that the right side must take care of the duplicate events.



85

00:07:14,840 --> 00:07:21,800

They cannot depend on the right side team to fix a problem that they have observed in a system that



86

00:07:21,800 --> 00:07:23,180

they are responsible for.



87

00:07:23,630 --> 00:07:32,420

A simple solution on the right side would be to ignore the duplicate events or lock the duplicate events



88

00:07:32,720 --> 00:07:36,160

in a separate database for further investigation.



89

00:07:36,170 --> 00:07:43,700

Now, in order to identify an event as duplicate, each event must have a unique identity.



90

00:07:43,880 --> 00:07:51,290

If you look back at the structure of our event, there is only a unique identity assigned to each event.



91

00:07:51,380 --> 00:07:57,650

It is the goed or the good attribute in the message paillard.



92

00:07:57,920 --> 00:08:04,160

So every message that gets originated on the right side will have a unique gwede.



93

00:08:04,520 --> 00:08:10,250

And this is what we are going to use to check if the message has already been processed or not.



94

00:08:10,850 --> 00:08:16,430

The logic in the event subscriber on the right side would look something like this.



95

00:08:16,580 --> 00:08:23,960

The subscriber will receive the event, then it will check the event store to see if the event with



96

00:08:23,960 --> 00:08:27,230

the specified GUI already exists or not.



97

00:08:27,530 --> 00:08:33,110

If the event is already there in the event store, that means it has been processed.



98

00:08:33,290 --> 00:08:40,210

So the event will be ignored, otherwise the event will be processed and added to the event store.



99

00:08:40,220 --> 00:08:46,730

With this logic, the duplicate events are getting ignored and never getting added to the database.



100

00:08:46,730 --> 00:08:53,870

On the right side, you will see this implementation in action in next lecture to key points that I



101

00:08:53,870 --> 00:08:55,970

would like to highlight from this lesson.



102

00:08:55,970 --> 00:09:04,220

The first is that certain type of failures may not have direct impact on the components where the failure



103

00:09:04,370 --> 00:09:04,880

occurred.



104

00:09:05,390 --> 00:09:10,010

The impact may be felt by the downstream systems or components.



105

00:09:10,640 --> 00:09:17,630

The second one is that each team within a distributed system must design for failures.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12 Microservices Managing the Data Integrity\005 Hands On _ Handling Duplicate Messages.en.srt -->

1

00:00:00,120 --> 00:00:07,070

In this lesson, I'll walk you through the class diagram and a sequence diagram for the updated read



2

00:00:07,110 --> 00:00:15,390

side implementation and then you'll see the updated code in action Achmea sales team.



3

00:00:15,660 --> 00:00:22,830

After making changes to the right side, out testing and the testing revealed that events are getting



4

00:00:22,830 --> 00:00:25,290

duplicated on the Reid site.



5

00:00:25,500 --> 00:00:29,780

So they decided to update the route site as well.



6

00:00:30,090 --> 00:00:36,810

And in this lesson, I'll walk you through the updates made to the Reid site version.



7

00:00:36,810 --> 00:00:41,970

Three of proposals subscriber extends the version two of proposal subscriber.



8

00:00:42,210 --> 00:00:48,300

It overrides the message handling function in the message handling function, the proposal subscriber



9

00:00:48,300 --> 00:00:54,320

checks if the even already exists in the proposal events collection.



10

00:00:54,510 --> 00:01:02,490

This is done by way of comparing the Guity for the received even and the idea of the events that are



11

00:01:02,490 --> 00:01:03,990

already in the collection.



12

00:01:04,260 --> 00:01:12,030

The version three of Proposal Reader Repo extends the version two of Proposal Reader Repo and it introduces



13

00:01:12,030 --> 00:01:18,780

a new function, even Good Exists, which checks the collection for the specified event.



14

00:01:19,230 --> 00:01:23,130

I suggest that you go to the code in these classes on your own.



15

00:01:23,460 --> 00:01:27,020

Next, I'll walk you to the end to end flow of the event.



16

00:01:27,270 --> 00:01:33,030

IT task you are invokes the create proposal command as part of the processing of the command.



17

00:01:33,210 --> 00:01:38,850

The proposal data is inserted in the proposals table and the proposals.



18

00:01:39,060 --> 00:01:43,110

Even data is inserted in the proposal, even stable.



19

00:01:43,530 --> 00:01:48,030

And both these inserts are carried out by way of a local database transaction.



20

00:01:48,120 --> 00:01:51,690

The status of the event is Sacto unprocessed.



21

00:01:51,900 --> 00:01:55,500

Even publishing is carried out by the event processor.



22

00:01:55,980 --> 00:02:04,110

The even processor continuously checks the database for unpublished events or unprocessed events.



23

00:02:04,290 --> 00:02:10,350

When it finds the unprocessed events, it loop through the set of unpublished events.



24

00:02:10,890 --> 00:02:18,210

For each event, it publishes the event and then updates the status of the event in the database.



25

00:02:18,750 --> 00:02:22,530

The event subscription is carried out on the read side.



26

00:02:22,800 --> 00:02:29,670

The message subscriber receives the events from the message, but it then checks if the event already



27

00:02:29,670 --> 00:02:32,970

exists in the proposal events collection.



28

00:02:33,240 --> 00:02:36,690

If it exists, then the event is just ignored.



29

00:02:36,930 --> 00:02:45,060

Otherwise the even gets added to the even stored collection as well as it gets processed and added to



30

00:02:45,060 --> 00:02:49,350

other collections in the REDECIDE database before running.



31

00:02:49,350 --> 00:02:51,900

The test will carry out some clean up activities.



32

00:02:51,900 --> 00:02:58,260

The first thing we are going to do is delete all of the records from the proposal, even table on the



33

00:02:58,260 --> 00:03:02,820

right side, and we will delete the proposal collections on the read site.



34

00:03:03,210 --> 00:03:06,030

Let's go over the steps that we will carry out for testing.



35

00:03:06,030 --> 00:03:09,360

The first step will be to launch the event processor.



36

00:03:09,990 --> 00:03:12,330

Then we will launch the Aerin subscriber.



37

00:03:12,690 --> 00:03:18,440

After that, we are going to execute the test command and as a last step, we are going to simulate



38

00:03:18,450 --> 00:03:20,640

publishing of the duplicate event.



39

00:03:21,000 --> 00:03:28,770

And the way we are going to do it is by changing the status of the event in the proposal, even table



40

00:03:29,160 --> 00:03:37,230

by setting the process field to false clean up our proposal, even table on the right side.



41

00:03:37,350 --> 00:03:43,560

So let's go ahead and delete these events, delete from proposal events and execute.



42

00:03:43,680 --> 00:03:48,240

At this time, we do not have any more rules in the proposal, even table.



43

00:03:48,330 --> 00:03:55,260

Next, we are going to delete the collections on the right side, so will delete the proposal events



44

00:03:55,260 --> 00:03:58,440

store and we will also delete the proposals.



45

00:03:58,620 --> 00:04:04,440

So both our collections are deleted now and we are ready to launch the even processor and the subscriber.



46

00:04:04,440 --> 00:04:11,820

So let's go ahead, launch even processor and launch the subscriber or even processor has launched and



47

00:04:11,820 --> 00:04:18,080

our subscriber is also waiting for the messages and the next step will go ahead and run a test command.



48

00:04:18,270 --> 00:04:23,640

The even processor will pick up the event from the proposal, even stable.



49

00:04:23,640 --> 00:04:26,360

And here, as you can see, the event was picked up.



50

00:04:26,640 --> 00:04:31,710

The even processor showed up with a message in MQ, which will be picked up by the subscriber.



51

00:04:31,710 --> 00:04:39,300

And here, as you can see, the subscriber picked up the event and the proposal in that event is equal



52

00:04:39,300 --> 00:04:40,740

to one twenty six.



53

00:04:40,740 --> 00:04:48,180

So what we are going to do next is check the proposal, even table for the events, select staff from



54

00:04:48,180 --> 00:04:49,440

proposal events.



55

00:04:49,440 --> 00:04:51,390

And here is our event.



56

00:04:51,810 --> 00:04:59,010

As you can see here, the proposal idea is one twenty six and the process start is true, not dissimilar.



57

00:04:59,030 --> 00:04:59,370

The.



58

00:04:59,650 --> 00:05:06,250

Sending off a duplicate event, we're going to change the process strategies for this event to false



59

00:05:06,250 --> 00:05:11,920

and what we are doing it is because even processa will pick up this event again and publish it again,



60

00:05:12,280 --> 00:05:15,860

and the subscriber on receiving the event should ignore it.



61

00:05:15,880 --> 00:05:18,190

So let's go ahead and try it out.



62

00:05:18,200 --> 00:05:25,710

So we're going to replace this with update and replace this with set process equal to false execute.



63

00:05:25,720 --> 00:05:28,280

And let's go back to our even processa.



64

00:05:28,300 --> 00:05:32,070

So as you can see, the even process, I just picked up the message again.



65

00:05:32,470 --> 00:05:38,650

Let's see what the subscriber has done, the subscriber on receiving the even phone that the event with



66

00:05:38,650 --> 00:05:40,600

this grid already exist.



67

00:05:40,900 --> 00:05:43,990

As a result, it just ignored that event.



68

00:05:44,020 --> 00:05:49,330

And so the redecide will ensure that the duplicate events are ignored.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12MicroservicesManagingtheDataIntegrity_VVN\000000001.srt -->

1
00:00:00,210 --> 00:00:08,940
Trong phần cuối cùng, bạn tìm hiểu cách dữ liệu được sao chép trên nhiều cơ sở dữ liệu bằng cách sử dụng tính năng nhắn tin trong thiết lập này.

2
00:00:09,120 --> 00:00:17,910
Có khả năng mất tin nhắn nếu MQ hoặc nhà môi giới nhắn tin không có sẵn.  Giả sử bạn đang sử dụng Rabbitt MQ.

3
00:00:18,030 --> 00:00:28,360
Phía bên phải ghi dữ liệu vào cơ sở dữ liệu của nó nhưng không thể đưa tin nhắn vào hàng đợi.  Bây giờ phía đọc sẽ không bao giờ nhận được tin nhắn.

4
00:00:28,380 --> 00:00:42,670
Kết quả là dữ liệu trên hai phiên bản cơ sở dữ liệu hiện ở trạng thái không nhất quán.  Loại mất dữ liệu này có thể được ngăn chặn bằng cách sử dụng mẫu tin nhắn đáng tin cậy trong mẫu này.

5
00:00:43,020 --> 00:00:57,680
Tin nhắn được đảm bảo sẽ được gửi đi.  Ý tưởng là khi phía bên phải gặp lỗi khi gửi tin nhắn, nó sẽ tiếp tục thử lại cho đến khi gửi tin nhắn thành công.

6
00:00:57,870 --> 00:01:10,660
Những lần thử lại này có thể gây ra sự chậm trễ trong việc đạt được trạng thái dữ liệu nhất quán trên các phiên bản cơ sở dữ liệu, nhưng cuối cùng dữ liệu sẽ nhất quán trên các phiên bản cơ sở dữ liệu.

7
00:01:11,550 --> 00:01:27,300
Chúng ta hãy xem xét một kịch bản khác có thể dẫn đến trạng thái không nhất quán trong kịch bản này.  Trang web phù hợp sẽ gửi các thông báo trùng lặp và quyết định lại các quá trình xử lý cùng một thông báo nhiều lần và điều đó có thể dẫn đến trạng thái không nhất quán.

8
00:01:27,870 --> 00:01:35,850
Trong phần này, bạn sẽ học cách giải quyết hai tình huống thất bại mà tôi đã thảo luận.  Chúng ta hãy đi qua các mục tiêu học tập trong bài giảng đầu tiên.

9
00:01:35,880 --> 00:01:48,270
Bạn tìm hiểu nguyên tắc thiết kế cho lỗi sẽ xem xét mẫu thông báo đáng tin cậy.  Bạn học cách xử lý các tin nhắn trùng lặp và khi chúng ta tiếp tục các bài giảng, sẽ đề cập đến đề xuất của Ackmann.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12MicroservicesManagingtheDataIntegrity_VVN\000000002.srt -->

1
00:00:00,150 --> 00:00:09,680
Thiết kế cho thất bại Trong bài học này, tôi sẽ thảo luận về khái niệm thiết kế cho thất bại, sau đó tôi sẽ đưa ra cái nhìn tổng quan về nhận xét Hai Mặt.

2
00:00:09,690 --> 00:00:20,190
Sau đó, tôi sẽ thảo luận về mẫu tin nhắn đáng tin cậy.  Khái niệm thiết kế cho sự thất bại gợi ý rằng bạn nên luôn lường trước rằng sẽ có những thất bại.

3
00:00:20,850 --> 00:00:29,610
Với tư cách là nhà thiết kế phần mềm, bạn nên xác định các điểm lỗi trong kiến ​​trúc của mình.  Hãy xem qua một ví dụ nhanh.

4
00:00:29,970 --> 00:00:43,890
Giả sử bạn có Microsoft Office đang nói chuyện với Microsoft Office B qua hộp thông báo.  Và giả sử Microsoft cũng phụ thuộc vào dịch vụ bên ngoài mà nó kết nối bằng HTP còn lại.

5
00:00:44,130 --> 00:01:01,420
Bây giờ, nếu bạn nhìn vào sơ đồ này, điều gì có thể sai ở đây?  Đó là điểm thất bại ở đâu?  Nếu bạn nhìn vào Microsoft, có phải cơ sở dữ liệu có thể bị hỏng hoặc thậm chí mạng có thể không có sẵn đối với Microsoft như một cách để kết nối với bảng tin và dịch vụ bên ngoài.

6
00:01:01,740 --> 00:01:10,700
Những gì khác có thể đi sai?  Microsoft sẽ có thể không có sẵn và trên cùng một đường dây, ngay cả khi mạng có sẵn, dịch vụ bên ngoài có thể không có sẵn.

7
00:01:10,740 --> 00:01:20,360
Vì vậy, gợi ý là khi bạn đã xác định được các điểm lỗi trong kiến ​​trúc của mình, hãy chủ động giải quyết tất cả các điểm lỗi đó.

8
00:01:20,760 --> 00:01:32,260
Đã đến lúc thực hiện một bài kiểm tra trong sơ đồ thành phần được thảo luận ở một trong những bài giảng trước đó, đối tượng lệnh đang ghi vào cơ sở dữ liệu rồi xuất bản một thông báo lên một chủ đề.

9
00:01:32,280 --> 00:01:40,740
Mục tiêu của bạn là xác định tất cả các điểm lỗi trong kiến ​​trúc này.  Hãy đăng một video và thử nó.

10
00:01:41,010 --> 00:01:53,600
Được rồi.  Tôi sẽ thảo luận về giải pháp tiếp theo.  Cách tốt nhất để tìm ra điểm lỗi trong một kiến ​​trúc là giả định rằng sẽ có lỗi ở tất cả các giao diện và thành phần.

11
00:01:54,210 --> 00:02:02,400
Vì vậy, trong sơ đồ này, nhìn từ góc độ bên phải, mạng có thể không khả dụng đối với đối tượng lệnh.

12
00:02:03,120 --> 00:02:18,270
Kết quả là nó sẽ không thể cập nhật cơ sở dữ liệu và xuất bản tin nhắn.  Mặc dù mạng luôn hoạt động nhưng máy chủ cơ sở dữ liệu có thể gặp sự cố, có thể ngừng hoạt động hoặc có thể hết tài nguyên.

13
00:02:18,570 --> 00:02:30,550
Và còn rất nhiều điều khác có thể xảy ra với cơ sở dữ liệu.  Tương tự, ngay cả khi mạng không hoạt động, đối tượng lệnh có thể không xuất bản được tin nhắn tới Amcu do máy chủ Amcu bị lỗi.

14
00:02:30,570 --> 00:02:42,050
Và sau đó có thể có những thất bại về phía Reid.  Trong bài học này, sự tập trung của tôi sẽ chỉ ở phía bên phải và tôi sẽ thảo luận về những thất bại quyết định lại trong bài giảng sau.

15
00:02:42,300 --> 00:02:50,820
Không, với tư cách là một nhà thiết kế phần mềm, một khi bạn đã xác định được những điểm sai sót, bạn cần suy nghĩ về tác động của những điểm sai sót đó.

16
00:02:51,120 --> 00:03:10,050
Vì vậy, chúng tôi sẽ tập trung vào vấn đề không có sẵn của Amcu.  Trong trường hợp này, lệnh sẽ được gọi và lệnh sẽ có thể ghi vào cơ sở dữ liệu, nhưng khi cố gắng xuất bản một tin nhắn lên Amcu thì sẽ không thành công.

17
00:03:10,350 --> 00:03:21,360
Bây giờ nếu bạn nghĩ về nó, kết quả là gì?  Kết quả là dữ liệu ở bên phải được cập nhật nhưng người đăng ký ở bên phải sẽ không bao giờ nhận được sự kiện.

18
00:03:22,050 --> 00:03:34,790
Và điều này đã dẫn đến bên phải và bên phải không đồng bộ.  Điểm mấu chốt là việc triển khai Securus cho các đề xuất của chúng tôi có sai sót.

19
00:03:35,040 --> 00:03:42,990
Có khả năng mất sự kiện và điều đó sẽ dẫn đến đề xuất có sẵn ở phía bên phải.

20
00:03:43,110 --> 00:03:51,690
Nhưng đề xuất tương tự sẽ không có trên trang Reid.  Tiếp theo, tôi sẽ thảo luận về một số giải pháp để giải quyết loại lỗi cụ thể này.

21
00:03:52,110 --> 00:04:04,140
Một cách để giải quyết lỗi này là ghi vào cơ sở dữ liệu và xuất bản một thông báo tới AMCU trong một đơn vị công việc hoặc một giao dịch phải đối mặt.

22
00:04:04,380 --> 00:04:13,230
Đó là một cơ chế có thể được sử dụng để thực hiện xuất bản Debride và Anku trong một đơn vị công việc hoặc giao dịch.

23
00:04:13,740 --> 00:04:27,630
Khuôn mặt hai mặt đã được sử dụng trong gần ba thập kỷ qua.  Trong nhận xét đầu tiên hoặc thuật toán phân tán được sử dụng để điều phối tất cả các quy trình liên quan đến giao dịch phân tán.

24
00:04:27,990 --> 00:04:41,490
Nó còn được gọi là kiến ​​trúc mở rộng hay chỉ là lối thoát cho giao diện ngắn.  Có một người quản lý giao dịch điều phối giao dịch trên tất cả các tài nguyên liên quan.

25
00:04:41,790 --> 00:04:59,610
Trong trường hợp này, tài nguyên là cơ sở dữ liệu và bus AMCU.  Thách thức với nhận xét Hai mặt là nó khá phức tạp để thực hiện và thách thức lớn hơn là nó thậm chí không có sẵn cho nhiều người được phân phối phổ biến.

26
00:04:59,830 --> 00:05:20,330
Ologies Rabbit Amcu, Amazon, Rescuer's, Mongo, TV chỉ là một số ví dụ về công nghệ không hỗ trợ truyện tranh Hai mặt do những thách thức này, khí hậu hai mặt không phổ biến lắm với các nhà thiết kế hệ thống phân tán.

27
00:05:20,590 --> 00:05:29,320
Giải pháp thay thế là phá vỡ quyền cơ sở dữ liệu và xuất bản MQ theo hai bước và sử dụng các giao dịch cơ sở dữ liệu cục bộ.

28
00:05:29,440 --> 00:05:53,920
Vì không có tên chung cho mẫu này nên tôi sẽ gọi nó là mẫu tin nhắn đáng tin cậy.  Trong mẫu này, phía bên phải ghi dữ liệu đối tượng miền và dữ liệu sự kiện vào các bảng cơ sở dữ liệu bằng một giao dịch cục bộ, sau đó các sự kiện được phát lại trên hệ thống xếp hàng trong một bước riêng biệt.

29
00:05:54,190 --> 00:06:20,110
Hãy để tôi dẫn bạn đến một minh họa sẽ làm cho mô hình này trở nên rất rõ ràng.  Bạn đã quen với hình minh họa này, trong đó Lệnh Đề xuất Creel đang ghi dữ liệu đề xuất vào cơ sở dữ liệu và sau đó xuất bản một thông báo trong bước xử lý bài đăng để sử dụng mẫu thông báo đáng tin cậy đã khai báo lệnh đề xuất sẽ không còn xuất bản một thông báo tới MQ nữa.

30
00:06:20,500 --> 00:06:31,240
Thay vào đó, chúng tôi sẽ giới thiệu một bảng mới trong cơ sở dữ liệu cùng với các đề xuất.  Bảng sẽ gọi bảng này là bảng chẵn.

31
00:06:31,330 --> 00:06:44,980
Khi lệnh đề xuất đã xóa được gọi, nó sẽ ghi dữ liệu đề xuất vào bảng đề xuất và ghi đề xuất, thậm chí tải trọng vào bảng đề xuất, thậm chí.

32
00:06:45,220 --> 00:06:57,220
Và các quyền này sẽ được thực hiện trong một giao dịch địa phương.  Nói cách khác, cả hai quyền sẽ thành công hoặc cả hai quyền sẽ không thành công, sẽ giới thiệu một thành phần mới, thậm chí là bộ xử lý.

33
00:06:57,640 --> 00:07:06,130
Bộ xử lý chẵn sẽ được triển khai như một quy trình độc lập để kiểm tra đề xuất định kỳ.

34
00:07:06,250 --> 00:07:24,070
Bảng chẵn dành cho số chẵn chưa được xử lý, số chẵn chưa được xử lý là bảng chưa được xuất bản lên Amcu cho mỗi sự kiện chưa được xử lý, bộ xử lý sự kiện sẽ xuất bản tải trọng chẵn cho Amcu.

35
00:07:24,820 --> 00:07:36,250
Nếu việc xuất bản Amcu thành công thì sự kiện Processo sẽ đánh dấu sự kiện trong đề xuất, thậm chí ổn định khi được xử lý.

36
00:07:36,580 --> 00:07:48,940
Và khi sự kiện được đánh dấu là đang xử lý, nó sẽ không còn được sử dụng để xuất bản sự kiện nữa.  Vì vậy, hãy suy nghĩ xem điều này sẽ giúp ngăn chặn sự kiện bị mất như thế nào.

37
00:07:48,940 --> 00:07:58,060
Cách nó sẽ hoạt động là, giả sử con thỏ Amcu rơi vào tình huống và thậm chí Processo sẽ cố gắng xuất bản một tin nhắn.

38
00:07:58,060 --> 00:08:19,720
Nó sẽ không thành công và vì sẽ xảy ra lỗi khi xuất bản nên sự kiện sẽ không được đánh dấu là đã xử lý.  Do đó, trạng thái chẵn vẫn chưa được xử lý và trong chu kỳ tiếp theo, bộ xử lý chẵn sẽ lại nhận trạng thái chẵn chưa được xử lý và cố gắng xuất bản nó lên Amcu.

39
00:08:20,050 --> 00:08:30,130
Cuối cùng, việc xuất bản sẽ thành công và trạng thái của sự kiện sẽ được cập nhật và kết quả là cơ sở dữ liệu sẽ được ngăn chặn, thậm chí mất mát.

40
00:08:31,330 --> 00:08:39,540
Tiếp theo, tôi sẽ hướng dẫn bạn về logic của bộ xử lý sự kiện, bộ xử lý chẵn được triển khai như một quy trình độc lập.

41
00:08:40,090 --> 00:08:53,680
Nó liên tục tìm kiếm các sự kiện chưa được xử lý trong cơ sở dữ liệu.  Vì vậy, điều đầu tiên nó làm là người gọi chọn hoặc tìm đối với cơ sở dữ liệu để lấy tất cả các sự kiện chưa được xử lý.

42
00:08:53,980 --> 00:09:03,910
Nếu không có sự kiện nào chưa được xử lý thì bộ xử lý chẵn sẽ chuyển sang chế độ ngủ trong một thời gian và sau đó thức dậy sau khi ngủ.

43
00:09:03,910 --> 00:09:21,760
Một lần nữa, kiểm tra các sự kiện chưa được xử lý và vòng lặp này tiếp tục.  Nếu bộ xử lý chẵn tìm thấy một sự kiện chưa được xử lý thì nó sẽ xuất bản sự kiện chẵn lên MQ trong trường hợp có lỗi trong phần đã xuất bản.

44
00:09:22,240 --> 00:09:32,740
Sau đó, các hành động tiếp theo sẽ bị hủy bỏ và bộ xử lý chẵn sẽ chuyển sang chế độ ngủ.  Sau một thời gian, nó lại kiểm tra các sự kiện chưa được xử lý.

45
00:09:32,920 --> 00:09:51,820
Nhưng nếu nhà xuất bản thành công thì sự kiện sẽ được đánh dấu là đã xử lý trong cơ sở dữ liệu.  Sau khi tất cả các sự kiện chưa được xử lý đã được xuất bản, ngay cả Bộ xử lý cũng sẽ chuyển sang chế độ ngủ trong một thời gian và tiếp tục kiểm tra các sự kiện chưa được xử lý.

46
00:09:52,780 --> 00:10:03,890
Đã đến lúc đi qua những điểm chính.  Từ bài học này, bạn phải xác định các điểm lỗi trong kiến ​​trúc của mình và bạn phải chủ động giải quyết những điểm lỗi đó.

47
00:10:04,360 --> 00:10:14,980
Đây là khái niệm thiết kế để đối mặt với thất bại.  Nó có thể được sử dụng để thực hiện các giao dịch phân tán trên nhiều tài nguyên.

48
00:10:15,430 --> 00:10:23,530
Nhưng hãy nhớ, có nhiều thách thức trong việc sử dụng truyện tranh Hai mặt để ngăn chặn việc mất thông điệp hoặc sự kiện.

49
00:10:23,530 --> 00:10:33,010
Bạn có thể sử dụng mẫu tin nhắn đáng tin cậy.  Trong một số bài giảng tiếp theo, bạn sẽ thấy mô hình nhắn tin đáng tin cậy đang hoạt động.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12MicroservicesManagingtheDataIntegrity_VVN\000000003.srt -->

1
00:00:00,210 --> 00:00:12,070
Chúng tôi sẽ thực hiện đúng đắn trong việc triển khai bảo mật.  Chúng ta sẽ tăng cường bảo mật bên phải để ngăn chặn tình trạng mất tin nhắn xấu trong bài học này.

2
00:00:12,090 --> 00:00:26,760
Tôi sẽ cung cấp cho bạn một cái nhìn tổng quan cấp cao về việc triển khai.  Sau đó, tôi sẽ hướng dẫn bạn mã trong bộ xử lý sự kiện và các lớp khác, sau đó bạn sẽ thấy mẫu thông báo đáng tin cậy đang hoạt động.

3
00:00:27,660 --> 00:00:36,630
Mã được đề cập trong bài giảng này có sẵn trong dữ liệu nhánh get.  Vì vậy hãy đảm bảo rằng bạn đã kiểm tra dữ liệu chi nhánh cổng.

4
00:00:36,900 --> 00:00:55,130
Trong bài giảng Thực hành vừa qua, bạn sẽ tìm hiểu cách I.T.  nhóm đã xây dựng mẫu Securus và khi bắt đầu thử nghiệm mẫu an toàn nhất, họ nhận ra rằng nếu thỏ Anchia không hoạt động hoặc nếu có sự cố kết nối mạng với thỏ thì tin nhắn MQ sẽ bị mất.

5
00:00:55,290 --> 00:01:03,060
Vì vậy, họ đã quyết định sử dụng mẫu thông báo đáng tin cậy để khắc phục việc triển khai Securus trong bài giảng này.

6
00:01:03,330 --> 00:01:22,210
Tôi sẽ thảo luận về những thay đổi đã được thực hiện đối với phiên bản triển khai Securus.  Khi họ xóa lệnh đề xuất sẽ được gọi, nó sẽ ghi vào các bảng cơ sở dữ liệu, hai bảng robot sẽ là đề xuất, bảng của chúng và tải trọng chẵn.

7
00:01:22,390 --> 00:01:33,850
Có bàn.  Hai quyền này sẽ được thực hiện trong một giao dịch cơ sở dữ liệu cục bộ.  Vì vậy, điều đó có nghĩa là cả hai quyền sẽ thành công hoặc cả hai sẽ thất bại.

8
00:01:34,300 --> 00:01:43,090
Vì bạn không thể nghe thấy nên bộ xử lý lệnh không tương tác trực tiếp với tin nhắn, nhưng chúng tôi thậm chí sẽ có bộ xử lý để làm điều đó.

9
00:01:43,240 --> 00:01:54,010
Bộ xử lý chẵn là một quy trình độc lập sẽ kiểm tra định kỳ các sự kiện chưa được xuất bản trong bảng dữ liệu tải trọng sự kiện.

10
00:01:54,010 --> 00:02:08,740
Nếu tìm thấy các sự kiện chưa được công bố, nó sẽ công bố các sự kiện đó lên bảng tin và sau đó cập nhật trạng thái của các sự kiện trong bảng cơ sở dữ liệu như đã công bố.

11
00:02:09,160 --> 00:02:26,170
Tuy nhiên, việc thiết lập tính năng không có sẵn tính năng nhắn tin này sẽ không dẫn đến việc bỏ lỡ sự kiện.  Đây là cách bảng cơ sở dữ liệu cho Even's sẽ trông như thế nào, chúng ta sẽ có Eventide và lời cầu hôn của người phụ nữ cầu hôn.

12
00:02:26,200 --> 00:02:36,330
Đó là đề xuất mà các sự kiện sẽ được công bố.  Mỗi sự kiện sẽ có một ID duy nhất được biểu thị bằng dấu gạch dưới chẵn.

13
00:02:36,340 --> 00:02:45,870
Tốt.  Sau đó, chúng tôi có tải trọng cho cờ chẵn đã được xử lý được đặt thành mặc định theo mặc định để cho biết rằng sự kiện chưa được xuất bản.

14
00:02:45,880 --> 00:02:57,780
Và khi sự kiện được xuất bản, cờ được xử lý sẽ được đặt thành đúng.  Ngày tạo là dấu thời gian khi dữ liệu sự kiện được thêm vào đề xuất.

15
00:02:57,820 --> 00:03:15,120
Ngày chẵn và ngày xử lý là dấu thời gian khi sự kiện được xuất bản thành công.  Và sau đó chúng ta có khóa chính là ID sự kiện và một ràng buộc chỉ ra rằng ID đề xuất phải tồn tại trong bảng đề xuất.

16
00:03:15,280 --> 00:03:25,960
Hãy tiếp tục và tạo bảng này.  Phần tiếp theo của Tạo bảng có sẵn trong thư mục phần tiếp theo Tin nhắn Dash đáng tin cậy Dash, DDL hoặc phần tiếp theo.

17
00:03:26,410 --> 00:03:38,860
Chỉ cần sao chép toàn bộ phần tiếp theo vào The Clipboard.  Đi tới bảng điều khiển dành cho phần tiếp theo của Elephant, mở trình duyệt, dán chi tiết và thực thi và truy vấn đã hoàn tất.

18
00:03:39,190 --> 00:03:49,360
Như vậy có nghĩa là chúng ta đã tạo xong bảng.  Phiên bản ba của Lệnh Tạo Đề xuất sử dụng phiên bản ba của kho lưu trữ đề xuất.

19
00:03:49,690 --> 00:03:59,350
Kho lưu trữ đề xuất phiên bản thứ ba này có thay đổi lớn về cách thêm dữ liệu đề xuất vào bảng đề xuất.

20
00:03:59,590 --> 00:04:09,520
Việc triển khai này hiện thực thi để chèn các câu lệnh trong một giao dịch và điều này sẽ trở nên rõ ràng khi bạn nhìn thấy mã.

21
00:04:10,060 --> 00:04:23,650
Lớp bộ xử lý chẵn nằm trong gói riêng của nó.  Nó sẽ chạy như một quy trình riêng biệt và sử dụng đề xuất, thậm chí cả kho lưu trữ, để chọn các sự kiện chưa được xử lý hoặc xuất bản.

22
00:04:24,070 --> 00:04:42,580
Chúng ta hãy tiếp tục và xem xét các lớp này.  Các lớp mà tôi sắp thảo luận có sẵn trong gói Securus Vetri ở đây sẽ bắt đầu với kho lưu trữ vì kho lưu trữ của khách hàng đang mở rộng phiên bản sang kho lưu trữ của khách hàng và không có thay đổi nào.

23
00:04:42,970 --> 00:04:54,970
Nhưng có sự thay đổi trong kho đề xuất, đang mở rộng phiên bản hai của kho đề xuất, ghi đè chức năng đề xuất ACC trong chức năng đề xuất.

24
00:04:55,060 --> 00:05:06,610
Trước tiên, chúng tôi tạo phần tiếp theo chèn cho các đề xuất.  Nếu bạn muốn kiểm tra nó, hãy xem phiên bản hai của REPL đề xuất ở bước tiếp theo.

25
00:05:06,610 --> 00:05:17,140
Chúng tôi đang tạo tải trọng chẵn và tạo câu lệnh tiếp theo để chèn dữ liệu sự kiện vào bảng chẵn đề xuất.

26
00:05:17,500 --> 00:05:30,160
Chúng ta hãy xem nhanh nó.  Bạn sẽ thấy rằng hầu hết mã trong sự kiện rõ ràng, phần tải trọng và phần tiếp theo là để tạo bản trình bày JSON của sự kiện.

27
00:05:30,340 --> 00:05:41,230
Và sau đó chúng ta có tuyên bố tiếp theo.  Bây giờ, một điều quan trọng mà tôi muốn bạn xem xét là tôi đang mã hóa tải trọng chẵn thành base64.

28
00:05:41,230 --> 00:05:50,740
Và lý do tôi làm điều đó là vì có những chuỗi bị mắc vào và điều đó sẽ gây ra vấn đề khi tôi nhập dữ liệu vào bảng cơ sở dữ liệu.

29
00:05:50,750 --> 00:06:05,770
Hiện tại có nhiều cách khác để giải quyết thách thức này nhưng tôi đã chọn con đường đơn giản nhất.  Trên thực tế, bạn cũng có thể tạo các công việc, cột kiểu dữ liệu và sinh viên sau đại học bằng nhau, nhưng tôi muốn giữ nó độc lập với cơ sở dữ liệu.

30
00:06:05,980 --> 00:06:17,710
Vì vậy, đây là nơi câu lệnh chu trình kết hợp được tạo.  Như bạn có thể thấy, tôi đang sử dụng từ đóng nhưng bình đẳng cho đề xuất và phần tiếp theo cho đề xuất.

31
00:06:17,710 --> 00:06:35,290
Thậm chí chúng tôi sẽ in phần tiếp theo này trên bảng điều khiển và sau đó thực hiện nó trong một giao dịch duy nhất.  Và kết quả là cả đề xuất và đề xuất, thậm chí dữ liệu sẽ được thêm vào các bảng tương ứng hoặc cả hai đều thất bại.

32
00:06:35,620 --> 00:06:48,190
Việc triển khai lệnh nằm trong ba gói lệnh đó và việc triển khai này giống như phiên bản hai của quá trình triển khai, ngoại trừ việc nó đang sử dụng phiên bản ba của lớp repo đề xuất.

33
00:06:48,520 --> 00:06:56,390
Và nó không thực hiện bất kỳ loại xử lý hậu kỳ nào vì hiện tại quá trình xử lý hậu kỳ đã được chuyển sang bộ xử lý chẵn.

34
00:06:56,410 --> 00:07:07,260
Tiếp theo, tôi sẽ hướng dẫn bạn quy trình chẵn.  Các lớp bộ xử lý quy trình có sẵn theo lệnh Securus Dot Vetri DOT hoặc thậm chí gói.

35
00:07:07,570 --> 00:07:16,840
Bạn sẽ tìm thấy ba lớp theo đề xuất.  Lớp chẵn là mô hình cho dữ liệu trong đề xuất.

36
00:07:17,630 --> 00:07:26,240
Sau đó, chúng tôi có đề xuất, thậm chí gấp ba lần.  Lớp này đang mở rộng lớp dựa trên GBC, có hai hàm trong đó.

37
00:07:26,900 --> 00:07:39,560
Chức năng đầu tiên là lấy số chẵn chưa được xử lý từ bảng đề xuất và chức năng thứ hai là đánh dấu sự kiện được chỉ định là đã xử lý.

38
00:07:39,920 --> 00:07:48,010
Tôi khuyên bạn nên tự mình xem qua mã trong lớp này.  Lớp chính là lớp xử lý sự kiện.

39
00:07:48,590 --> 00:07:56,600
Lớp này triển khai giao diện Runnable.  Vì vậy, điều đó có nghĩa là nó cần triển khai hàm vòng.

40
00:07:56,880 --> 00:08:04,400
Nó chứa một thể hiện của các lớp dịch vụ, được truyền cho nó như một phần của hàm tạo.

41
00:08:04,550 --> 00:08:32,790
Nó cũng chứa một ví dụ về đề xuất, thậm chí cả con người.  Vì vậy, khi phần thứ ba được bắt đầu với một thể hiện của lớp này, hàm run sẽ được thực thi và hàm run là một vòng lặp while không bao giờ kết thúc, trong đó điều đầu tiên chúng ta làm là lấy tất cả các sự kiện chưa được xử lý, in ra số lượng sự kiện chưa được xử lý  trên bảng điều khiển rồi xử lý từng sự kiện.

42
00:08:33,200 --> 00:08:48,080
Chúng ta hãy xem nhanh những gì đang xảy ra trong quá trình xử lý các sự kiện.  Điều đầu tiên xảy ra trong quy trình, thậm chí cả chức năng, là tải trọng sự kiện được giải mã từ chuỗi tám base64 sang UTF.

43
00:08:48,590 --> 00:09:01,370
Sau đó, tải trọng sự kiện được in trên bảng điều khiển và sau đó thậm chí sẽ được xuất bản.  Nếu xảy ra lỗi khi xuất bản, câu lệnh tiếp theo sẽ không được thực thi.

44
00:09:01,730 --> 00:09:10,500
Nhưng nếu nhà xuất bản thành công thì câu lệnh này sẽ được thực thi và câu lệnh đánh dấu sự kiện là đã được xử lý.

45
00:09:10,820 --> 00:09:19,760
Vì vậy, bây giờ khi sự kiện được đánh dấu là đã xử lý, sự kiện đó sẽ không còn được chọn là sự kiện chưa được xử lý nữa.  Bây giờ chúng ta hãy quay trở lại một chức năng.

46
00:09:20,030 --> 00:09:35,360
Khi tất cả các sự kiện chưa được xử lý đã được xử lý, hủy bỏ, chuyển sang chế độ ngủ trong thời gian ngủ, thời gian ngủ được xác định là biến tĩnh cuối cùng, được đặt thành 10 giây trong quá trình triển khai này.

47
00:09:35,670 --> 00:09:43,520
Hãy tiếp tục và thử triển khai Securus Rightside đã sửa đổi của chúng tôi để kiểm tra quá trình triển khai.

48
00:09:43,520 --> 00:09:53,090
Chúng tôi sẽ sử dụng lớp lệnh kiểm tra và lớp bộ xử lý thậm chí kiểm tra có sẵn trong quá trình kiểm tra.  Không phải Securus, không phải gói Vetri.

49
00:09:53,420 --> 00:10:10,310
Trong quá trình triển khai lệnh kiểm tra, bạn sẽ thấy rằng không có sự khác biệt về mã so với phiên bản hai của lệnh, ngoại trừ việc trong lớp này chúng tôi đang sử dụng phiên bản ba của lệnh đề xuất rõ ràng và loại phiên bản để kiểm tra.

50
00:10:10,310 --> 00:10:31,040
Ngay cả lớp bộ xử lý cũng có các tham số MQ.  Đảm bảo rằng bạn đã thiết lập đúng Eurail tại đây.  Và trong chức năng chính, chúng ta đang tạo một phiên bản của pops of service, tạo một phiên bản của bộ xử lý chẵn nhưng pops của dịch vụ và sau đó chỉ cần bắt đầu theo dõi.

51
00:10:31,160 --> 00:10:40,420
Khi mối đe dọa bắt đầu, nó sẽ thức dậy sau mỗi 10 giây, tìm kiếm các sự kiện chưa được xử lý và nếu tìm thấy quy trình của Liên Hợp Quốc, thậm chí sau đó nó sẽ công bố nó.

52
00:10:40,760 --> 00:10:52,760
Hãy tiếp tục và kiểm tra xem chúng ta có thứ gì trong hàng đợi để đến Trình quản lý MQ của Rabbitt không, hãy nhấp vào Cuz kiểm tra đề xuất, đọc Q và như bạn có thể thấy không có tin nhắn nào.

53
00:10:52,760 --> 00:11:09,550
Hãy tiếp tục và quy trình chẵn - nhấp chuột phải vào kiểm tra ngay cả kiểm tra chạy bộ xử lý, thậm chí bộ xử lý hoặc thậm chí bộ xử lý đã bắt đầu và như bạn có thể thấy tại thời điểm này, nó không tìm thấy sự kiện nào chưa được xử lý.

54
00:11:09,560 --> 00:11:17,840
Việc tiếp theo chúng ta sẽ làm là chạy thử nghiệm, vào và chạy thử nghiệm.  Cố lên.  Phải.  Bấm vào Lệnh kiểm tra và chạy lệnh kiểm tra.

55
00:11:17,870 --> 00:11:28,370
Hãy quay trở lại bộ xử lý chẵn của chúng tôi.  Và chúng ta sẽ thấy nó xuất hiện ở đây bất cứ lúc nào.  Vì vậy, đây là sự kiện mà bộ xử lý thử nghiệm của chúng tôi đã nhận được.

56
00:11:28,370 --> 00:11:40,760
Và nếu mọi thứ đều ổn, chúng ta sẽ có thể tìm thấy cái này ngay cả trong hàng đợi.  Và như bạn có thể thấy, chúng ta có một tin nhắn và chúng ta có thể nhận được tin nhắn đó bằng cách nhấp vào tin nhắn đó.

57
00:11:41,270 --> 00:11:51,620
Và đây là thông điệp của chúng tôi.  Hãy đi tới trình duyệt phần tiếp theo và chọn các sự kiện đề xuất.  Và chúng ta sẽ thấy một sự kiện ở đây.

58
00:11:51,710 --> 00:12:02,690
Và như bạn có thể thấy ở đây, chúng ta có một sự kiện ở đây và quy trình được đặt thành đúng.  Đây là tải trọng 64 và quý tốt nhất cho sự kiện.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12MicroservicesManagingtheDataIntegrity_VVN\000000004.srt -->

1
00:00:00,240 --> 00:00:16,980
Trong một số bài giảng trước, bạn đã học về các lỗi phù hợp với trang web trong bài học này. Tôi nói về các kịch bản lỗi xác định lại và tôi cũng sẽ thảo luận về một kịch bản lỗi Rightside dẫn đến vấn đề trùng lặp Messers trên trang Reid.

2
00:00:17,250 --> 00:00:28,850
Là một phần của cuộc thảo luận, tôi sẽ đề cập đến giải pháp cho những tình huống thất bại này.  Xin lưu ý rằng cuộc thảo luận trong bài học này chỉ nhằm mục đích sao chép dựa trên thông báo.

3
00:00:29,130 --> 00:00:39,120
Tôi không đề cập đến cơ chế sao chép gốc hoặc cơ chế sao chép của bên thứ ba.  Ngoài ra, cuộc thảo luận về nhắn tin không áp dụng cho Luồng Cafcass.

4
00:00:39,360 --> 00:00:48,040
Tôi sẽ bắt đầu bài học bằng một câu đố.  Xác định các điểm thất bại trên trang Reid.  Vui lòng tạm dừng video nếu bạn cần thêm thời gian.

5
00:00:48,450 --> 00:00:59,450
Tiếp theo, tôi sẽ thảo luận về giải pháp.  Có thể có lỗi trong mạng giữa bộ sao chép và MQ.  Bản thân bộ sao chép có thể bị lỗi.

6
00:00:59,550 --> 00:01:18,510
Ví dụ: quy trình có thể gặp sự cố hoặc có thể có sự cố trên máy lưu trữ quy trình.  Mạng giữa bộ sao chép và cơ sở dữ liệu có thể không khả dụng do bộ sao chép không thể truy cập cơ sở dữ liệu và bản thân cơ sở dữ liệu có thể gặp sự cố tổng thể.

7
00:01:18,810 --> 00:01:28,130
Tác động của những vấn đề này là có thể xảy ra hiện tượng mất các sự kiện do trang Reed và phía bên phải sẽ không đồng bộ.

8
00:01:28,140 --> 00:01:35,850
Tác động khác có thể là sự chậm trễ ở địa điểm Reed trở nên nhất quán với phía bên phải.

9
00:01:36,030 --> 00:01:53,730
Hãy kêu gọi các giải pháp tiềm năng để giải quyết một số thách thức này.  Hãy bắt đầu với một tình huống trong đó kết nối mạng giữa bộ sao chép và MQ bị mất hoặc bản thân quá trình sao chép bị hỏng do một số thách thức.

10
00:01:53,730 --> 00:02:02,340
Một giải pháp tiềm năng cho vấn đề này là sử dụng thông điệp, sự kiên trì và thời gian để sống.  Hãy để tôi giải thích điều tôi muốn nói.

11
00:02:02,460 --> 00:02:15,030
Ý tưởng là hầu hết các hệ thống MQ đều cho phép duy trì thông điệp.  Nói cách khác, các tin nhắn được ghi vào bàn để duy trì lâu dài và chúng có sẵn trong thời gian dài hơn.

12
00:02:15,270 --> 00:02:25,710
Khoảng thời gian mà tin nhắn có sẵn được xác định theo thời gian tồn tại.  Thời gian tồn tại này có thể được đặt trên hàng đợi MQ hoặc ở cấp độ tin nhắn.

13
00:02:26,040 --> 00:02:33,210
Ý tưởng rất đơn giản là cả nhóm sẽ quyết định hệ thống nhắn tin sẽ giữ tin nhắn trên hàng đợi trong bao lâu.

14
00:02:33,540 --> 00:02:48,780
Hết thời gian rời đi, tin nhắn sẽ bị mất.  Vì vậy, với tư cách là người thiết kế hệ thống phân tán sử dụng MQ, bạn phải suy nghĩ về tính kiên trì, xác định đâu là thời điểm thích hợp để tồn tại cho các thông điệp của mình.

15
00:02:49,050 --> 00:03:03,350
Vào lúc khác, bạn sẽ được cung cấp liên kết để bạn có thể biết thêm thông tin.  Kịch bản tiếp theo được thảo luận liên quan đến việc bộ sao chép đọc thành công thông báo nhưng không ghi được vào cơ sở dữ liệu.

16
00:03:03,390 --> 00:03:11,130
Loại lỗi này có thể được giải quyết bằng cách sử dụng cơ chế từ chối hoặc khôi phục có sẵn trên Incubus.

17
00:03:11,310 --> 00:03:19,340
Ý tưởng là khi người sao chép hoặc người đăng ký nhận được tin nhắn, nó sẽ không tự động xác nhận nó.

18
00:03:19,650 --> 00:03:36,030
Đầu tiên nó cố gắng ghi nó vào cơ sở dữ liệu.  Và nếu quyền cơ sở dữ liệu thành công thì bộ sao chép sẽ xác nhận thông báo, điều này dẫn đến việc xóa thông báo khỏi ông chủ MQ trong trường hợp không sao chép được hoặc có thể từ chối thông báo.

19
00:03:36,330 --> 00:03:51,020
Điều đó có nghĩa là tin nhắn sẽ được đưa trở lại hàng đợi và không bị mất.  Cơ chế từ chối rất cụ thể đối với hệ thống nhắn tin, mỗi lần bạn có thể đọc thêm về nó tại liên kết này.

20
00:03:51,330 --> 00:04:00,630
Bây giờ, có một số điều cần lưu ý khi bạn sử dụng từ chối.  Điều đầu tiên là hàng đợi thường có sức chứa.

21
00:04:01,290 --> 00:04:15,840
Vì vậy, ví dụ: giả sử một hàng đợi có sức chứa năm nghìn tin nhắn.  Và vì vậy nếu chỉ có 5000 tin nhắn và bộ sao chép từ chối tin nhắn thì tin nhắn đó sẽ được đưa trở lại hàng đợi.

22
00:04:16,140 --> 00:04:24,110
Nhưng vì đã có 5000 tin nhắn nên một trong những tin nhắn sẽ bị xóa để thay thế cho tin nhắn bị từ chối này.

23
00:04:24,120 --> 00:04:31,440
Không phải mọi hệ thống xếp hàng đều có cách khác nhau để quyết định tin nhắn nào sẽ bị xóa.  Vì vậy tôi sẽ không đi vào chi tiết về điều đó.

24
00:04:31,860 --> 00:04:42,150
Bạn chỉ cần lưu ý rằng đó là một khả năng có thể xảy ra, đặc biệt khi trình sao chép của bạn đã được biết đến trong một thời gian dài và có một lượng lớn thư được đưa vào hàng đợi.

25
00:04:42,630 --> 00:04:52,010
Một điều khác mà hệ thống nhắn tin có thể làm là chuyển tin nhắn đến thư chết.  Q Và điều này có thể xảy ra vì một vài lý do.

26
00:04:52,020 --> 00:04:59,510
Một lý do phổ biến là thư có số lần thử lại hoặc số lần gửi trước.  Và một lần nữa, như tôi đã nói trước đó, đây là a.

27
00:04:59,640 --> 00:05:14,240
Tùy thuộc vào hệ thống nhắn tin, lần thử lại hoặc gửi trước này có giới hạn tối đa và do đó, nếu bạn vượt quá giới hạn tối đa đó, thì tin nhắn sẽ bị đẩy đến mức tấn công chết người.

28
00:05:14,640 --> 00:05:26,030
Bạn có thể đọc thêm về điều đó sau, vì tại liên kết này dành cho Rabbitt MQ.  Đôi khi sự thất bại ở phía bên phải có thể gây ảnh hưởng đến phía bên phải.

29
00:05:26,270 --> 00:05:39,850
Hãy xem xét tình huống trong đó bộ xử lý chẵn có thể xuất bản thông báo tới Amcu, nhưng nó không thể cập nhật trạng thái của sự kiện trong cơ sở dữ liệu khi được xử lý.

30
00:05:39,980 --> 00:05:47,660
Vậy câu hỏi đặt ra là liệu có tác động gì về phía bên phải không?  Và nếu có tác động về phía bên phải thì tác động sẽ như thế nào?

31
00:05:49,790 --> 00:06:04,820
Để hiểu tác động, chúng ta hãy xem việc triển khai quy trình chẵn, quy trình chẵn tìm thấy sự kiện cần được xuất bản và do đó, nó xuất bản sự kiện sau khi xuất bản sự kiện, nó sẽ kiểm tra.

32
00:06:04,820 --> 00:06:12,020
Nếu xuất bản thành công, nó sẽ được mua trước khi có thể cập nhật trạng thái của sự kiện trong cơ sở dữ liệu.

33
00:06:12,380 --> 00:06:19,540
Kết quả là cơ sở dữ liệu đã hoạt động trở lại, khi bộ xử lý thậm chí cố gắng cập nhật cơ sở dữ liệu thì không thành công.

34
00:06:20,180 --> 00:06:33,730
Vì vậy, tác động sẽ là tin nhắn nằm trong hàng đợi và vì trạng thái của nó chưa được cập nhật nên nó sẽ được bộ xử lý chẵn chọn lại và xuất bản lên MQ.

35
00:06:33,740 --> 00:06:44,630
Kết quả là trang web sẽ nhận được cùng một sự kiện nhiều lần.  Cần có giải pháp để tránh sự trùng lặp các sự kiện.

36
00:06:45,290 --> 00:06:52,630
Câu hỏi tiếp theo tại thời điểm này là bên nào nên đưa ra bản sửa lỗi để giải quyết vấn đề trùng lặp?

37
00:06:52,640 --> 00:07:01,630
Nên là bên phải hay bên phải, đặc biệt nếu có hai nhóm khác nhau đang quản lý hai địa điểm này một cách độc lập?

38
00:07:01,790 --> 00:07:14,690
Chà, cả hai bên nên cân nhắc đưa ra cách khắc phục, nhưng nếu tôi phải chọn một trong hai đội thì tôi sẽ nói rằng bên phải phải xử lý các sự kiện trùng lặp.

39
00:07:14,840 --> 00:07:23,180
Họ không thể phụ thuộc vào nhóm bên phải để khắc phục sự cố mà họ đã quan sát thấy trong hệ thống mà họ chịu trách nhiệm.

40
00:07:23,630 --> 00:07:36,160
Một giải pháp đơn giản ở phía bên phải là bỏ qua các sự kiện trùng lặp hoặc khóa các sự kiện trùng lặp trong cơ sở dữ liệu riêng biệt để điều tra thêm.

41
00:07:36,170 --> 00:07:51,290
Bây giờ, để xác định một sự kiện là trùng lặp, mỗi sự kiện phải có một danh tính duy nhất.  Nếu bạn nhìn lại cấu trúc sự kiện của chúng ta, chỉ có một danh tính duy nhất được gán cho mỗi sự kiện.

42
00:07:51,380 --> 00:08:04,160
Đó là thuộc tính tốt hoặc tốt trong paillard thông báo.  Vì vậy, mọi tin nhắn được bắt nguồn ở phía bên phải sẽ có một gwede duy nhất.

43
00:08:04,520 --> 00:08:16,430
Và đây là những gì chúng ta sẽ sử dụng để kiểm tra xem tin nhắn đã được xử lý hay chưa.  Logic của người đăng ký sự kiện ở phía bên phải sẽ trông giống như thế này.

44
00:08:16,580 --> 00:08:27,230
Người đăng ký sẽ nhận được sự kiện, sau đó nó sẽ kiểm tra kho sự kiện để xem sự kiện với GUI được chỉ định đã tồn tại hay chưa.

45
00:08:27,530 --> 00:08:40,210
Nếu sự kiện đã có trong cửa hàng sự kiện, điều đó có nghĩa là nó đã được xử lý.  Vì vậy sự kiện sẽ bị bỏ qua, nếu không sự kiện sẽ được xử lý và thêm vào kho sự kiện.

46
00:08:40,220 --> 00:08:55,970
Với logic này, các sự kiện trùng lặp sẽ bị bỏ qua và không bao giờ được thêm vào cơ sở dữ liệu.  Ở phía bên phải, bạn sẽ thấy cách triển khai này được thực hiện trong bài giảng tiếp theo về những điểm chính mà tôi muốn nhấn mạnh trong bài học này.

47
00:08:55,970 --> 00:09:04,880
Đầu tiên là một số loại lỗi nhất định có thể không ảnh hưởng trực tiếp đến các bộ phận xảy ra lỗi.

48
00:09:05,390 --> 00:09:17,630
Tác động có thể được cảm nhận bởi các hệ thống hoặc thành phần hạ nguồn.  Điều thứ hai là mỗi nhóm trong hệ thống phân tán phải thiết kế để xử lý các lỗi.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\12MicroservicesManagingtheDataIntegrity_VVN\000000005.srt -->

1
00:00:00,120 --> 00:00:15,390
Trong bài học này, tôi sẽ hướng dẫn bạn qua sơ đồ lớp và sơ đồ trình tự để triển khai bên đọc được cập nhật và sau đó bạn sẽ thấy mã được cập nhật trong hoạt động của nhóm bán hàng Achmea.

2
00:00:15,660 --> 00:00:25,290
Sau khi thực hiện các thay đổi ở phía bên phải, quá trình kiểm tra và thử nghiệm cho thấy các sự kiện đang bị trùng lặp trên trang Reid.

3
00:00:25,500 --> 00:00:36,810
Vì vậy, họ quyết định cập nhật trang web tuyến đường.  Và trong bài học này, tôi sẽ hướng dẫn bạn các bản cập nhật được thực hiện cho phiên bản trang Reid.

4
00:00:36,810 --> 00:00:54,320
Ba trong số những người đăng ký đề xuất mở rộng phiên bản hai của người đăng ký đề xuất.  Nó ghi đè chức năng xử lý tin nhắn trong chức năng xử lý tin nhắn, người đăng ký đề xuất sẽ kiểm tra xem thậm chí đã tồn tại trong bộ sưu tập sự kiện đề xuất hay chưa.

5
00:00:54,510 --> 00:01:03,990
Điều này được thực hiện bằng cách so sánh Guity với số tiền chẵn nhận được và ý tưởng về các sự kiện đã có trong bộ sưu tập.

6
00:01:04,260 --> 00:01:18,780
Phiên bản ba của Proposal Reader Repo mở rộng phiên bản hai của Proposal Reader Repo và nó giới thiệu một chức năng mới, thậm chí là Good Exists, kiểm tra bộ sưu tập cho sự kiện được chỉ định.

7
00:01:19,230 --> 00:01:27,020
Tôi khuyên bạn nên tự mình đi đến mã trong các lớp này.  Tiếp theo, tôi sẽ hướng dẫn bạn từ đầu đến cuối của sự kiện.

8
00:01:27,270 --> 00:01:38,850
Nhiệm vụ CNTT mà bạn đang gọi lệnh tạo đề xuất như một phần của quá trình xử lý lệnh.  Dữ liệu đề xuất được chèn vào bảng đề xuất và các đề xuất.

9
00:01:39,060 --> 00:01:48,030
Thậm chí dữ liệu còn được đưa vào đề xuất, thậm chí còn ổn định.  Và cả hai thao tác chèn này đều được thực hiện bằng giao dịch cơ sở dữ liệu cục bộ.

10
00:01:48,120 --> 00:01:55,500
Trạng thái của sự kiện là Sacto chưa được xử lý.  Ngay cả việc xuất bản cũng được thực hiện bởi bộ xử lý sự kiện.

11
00:01:55,980 --> 00:02:10,350
Bộ xử lý chẵn liên tục kiểm tra cơ sở dữ liệu để tìm các sự kiện chưa được công bố hoặc các sự kiện chưa được xử lý.  Khi tìm thấy các sự kiện chưa được xử lý, nó sẽ lặp qua tập hợp các sự kiện chưa được xuất bản.

12
00:02:10,890 --> 00:02:22,530
Đối với mỗi sự kiện, nó xuất bản sự kiện và sau đó cập nhật trạng thái của sự kiện trong cơ sở dữ liệu.  Việc đăng ký sự kiện được thực hiện ở phía đọc.

13
00:02:22,800 --> 00:02:32,970
Người đăng ký tin nhắn nhận được các sự kiện từ tin nhắn, nhưng sau đó nó sẽ kiểm tra xem sự kiện đó đã tồn tại trong bộ sưu tập sự kiện đề xuất hay chưa.

14
00:02:33,240 --> 00:02:49,350
Nếu nó tồn tại thì sự kiện sẽ bị bỏ qua.  Mặt khác, nó thậm chí còn được thêm vào bộ sưu tập được lưu trữ đồng đều cũng như được xử lý và thêm vào các bộ sưu tập khác trong cơ sở dữ liệu REDECIDE trước khi chạy.

15
00:02:49,350 --> 00:03:02,820
Bài kiểm tra sẽ thực hiện một số hoạt động dọn dẹp.  Điều đầu tiên chúng ta sẽ làm là xóa tất cả các bản ghi khỏi đề xuất, thậm chí cả bảng ở bên phải và chúng ta sẽ xóa các bộ sưu tập đề xuất trên trang đã đọc.

16
00:03:03,210 --> 00:03:09,360
Hãy cùng xem qua các bước mà chúng tôi sẽ thực hiện để thử nghiệm.  Bước đầu tiên sẽ là khởi chạy bộ xử lý sự kiện.

17
00:03:09,990 --> 00:03:20,640
Sau đó chúng tôi sẽ khởi chạy thuê bao Aerin.  Sau đó, chúng tôi sẽ thực thi lệnh kiểm tra và bước cuối cùng, chúng tôi sẽ mô phỏng việc xuất bản sự kiện trùng lặp.

18
00:03:21,000 --> 00:03:37,230
Và cách chúng ta sẽ thực hiện là thay đổi trạng thái của sự kiện trong đề xuất, bảng chẵn bằng cách đặt trường quy trình thành xóa sai đề xuất của chúng tôi, bảng chẵn ở bên phải.

19
00:03:37,350 --> 00:03:48,240
Vì vậy, hãy tiếp tục xóa các sự kiện này, xóa khỏi các sự kiện đề xuất và thực hiện.  Tại thời điểm này, chúng tôi không có thêm bất kỳ quy tắc nào trong đề xuất, thậm chí cả bảng.

20
00:03:48,330 --> 00:03:58,440
Tiếp theo, chúng tôi sẽ xóa các bộ sưu tập ở bên phải, do đó, chúng tôi sẽ xóa kho sự kiện đề xuất và chúng tôi cũng sẽ xóa các đề xuất.

21
00:03:58,620 --> 00:04:04,440
Vì vậy, cả hai bộ sưu tập của chúng tôi đều bị xóa ngay bây giờ và chúng tôi đã sẵn sàng khởi chạy bộ xử lý chẵn và người đăng ký.

22
00:04:04,440 --> 00:04:18,080
Vì vậy, hãy tiếp tục, khởi chạy bộ xử lý và khởi chạy thuê bao hoặc thậm chí bộ xử lý đã khởi chạy và thuê bao của chúng tôi cũng đang chờ tin nhắn và bước tiếp theo sẽ tiếp tục và chạy lệnh kiểm tra.

23
00:04:18,270 --> 00:04:26,360
Bộ xử lý chẵn sẽ tiếp nhận sự kiện từ đề xuất, thậm chí ổn định.  Và ở đây, như bạn có thể thấy, sự kiện đã được chọn.

24
00:04:26,640 --> 00:04:40,740
Bộ xử lý chẵn xuất hiện với một thông báo trong MQ, thông báo này sẽ được người đăng ký nhận.  Và ở đây, như bạn có thể thấy, người đăng ký đã chọn sự kiện và đề xuất trong sự kiện đó bằng một hai mươi sáu.

25
00:04:40,740 --> 00:04:49,440
Vì vậy, những gì chúng ta sẽ làm tiếp theo là kiểm tra đề xuất, thậm chí lập bảng cho các sự kiện, chọn nhân viên từ các sự kiện đề xuất.

26
00:04:49,440 --> 00:04:59,010
Và đây là sự kiện của chúng tôi.  Như bạn có thể thấy ở đây, ý tưởng đề xuất là một trong hai mươi sáu và quá trình bắt đầu quá trình là đúng, không có gì khác biệt.

27
00:04:59,030 --> 00:05:15,860
Các.  Gửi đi một sự kiện trùng lặp, chúng tôi sẽ thay đổi chiến lược quy trình cho sự kiện này thành sai và những gì chúng tôi đang làm là bởi vì ngay cả quy trình cũng sẽ chọn lại sự kiện này và xuất bản lại và người đăng ký nhận sự kiện sẽ bỏ qua nó  .

28
00:05:15,880 --> 00:05:25,710
Vì vậy chúng ta hãy tiếp tục và thử nó.  Vì vậy, chúng tôi sẽ thay thế cái này bằng bản cập nhật và thay thế cái này bằng quy trình thiết lập bằng với việc thực thi sai.

29
00:05:25,720 --> 00:05:32,070
Và hãy quay lại quy trình chẵn của chúng ta.  Như bạn có thể thấy, trong quá trình đồng đều, tôi vừa nhận lại tin nhắn.

30
00:05:32,470 --> 00:05:40,600
Hãy xem thuê bao đã làm gì, thuê bao khi nhận được điện thoại chẵn rằng sự kiện với lưới này đã tồn tại.

31
00:05:40,900 --> 00:05:49,330
Kết quả là nó chỉ bỏ qua sự kiện đó.  Và do đó, việc quyết định lại sẽ đảm bảo rằng các sự kiện trùng lặp sẽ bị bỏ qua.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\001 Use of Kafka in Microservices.en.srt -->

1

00:00:00,390 --> 00:00:07,410

Kafka is a streaming platform which is extremely popular with micro services designers and developers,



2

00:00:07,830 --> 00:00:15,960

many of the Kavkaz features overlap with the capabilities offered by other messaging platforms such



3

00:00:15,960 --> 00:00:18,390

as Rabbit MQ and Active MQ.



4

00:00:18,420 --> 00:00:26,220

A services designer need to make a decision on whether to use Cafcass streaming or to use a messaging



5

00:00:26,220 --> 00:00:31,170

broker like Rabbitt MQ or active MQ for their micro services.



6

00:00:31,260 --> 00:00:38,880

To answer this question, the micro services designer must understand the capabilities of Cafcass streaming



7

00:00:39,180 --> 00:00:44,430

versus the capabilities offered by these other message brokers.



8

00:00:44,850 --> 00:00:51,210

In an earlier section, you learn about Rabbitt MQ, which is an implementation of the MQ B protocol.



9

00:00:51,570 --> 00:00:58,470

In the section you learn about the Cafcass streaming, and my hope is that by the end of the section



10

00:00:58,710 --> 00:01:05,970

you'll be in a good position to make a decision on whether to use Kafka or Rabbit MQ for your micro



11

00:01:05,970 --> 00:01:06,550

services.



12

00:01:06,810 --> 00:01:09,720

Let's go over the learning objectives for this section.



13

00:01:09,930 --> 00:01:12,120

You will learn the concepts you learn.



14

00:01:12,120 --> 00:01:15,870

The differences between Kafka and MGP are discussed.



15

00:01:15,870 --> 00:01:23,850

Multiple micro services use cases in which Kafka is much more appropriate compared to an cupie and you



16

00:01:23,850 --> 00:01:26,100

will see Kafka in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\002 Kafka Overview.en.srt -->

1

00:00:00,390 --> 00:00:03,370

COFCO, one on one, a quick introduction to Kafka.



2

00:00:03,390 --> 00:00:06,930

I'll start the lesson by answering the question, what is Kafka?



3

00:00:07,410 --> 00:00:14,220

Then I'll discuss how LinkedIn is using Kafka will then go over the core capabilities of Kafka.



4

00:00:14,850 --> 00:00:18,910

Please note that this is a high level overview of Kafka.



5

00:00:19,050 --> 00:00:22,920

I will be covering concepts of Kafka in later lectures.



6

00:00:23,070 --> 00:00:28,710

Kafka is a high performance, open source distributed, even streaming platform.



7

00:00:28,890 --> 00:00:32,910

Kafka can ingest up to two million messages per second.



8

00:00:33,210 --> 00:00:39,380

Kafka cluster consists of multiple nodes or machines that are spread across a wide network.



9

00:00:39,600 --> 00:00:44,970

Even streaming here refers to the pops of messaging model at a high level.



10

00:00:45,270 --> 00:00:52,430

The Kafka cluster exposes absorb messaging capability to the producers and the consumers.



11

00:00:52,440 --> 00:00:58,620

Now, you may say that this looks very similar to a typical messaging platform, and you are right,



12

00:00:58,620 --> 00:01:01,110

but that's where the similarities end.



13

00:01:01,110 --> 00:01:06,650

Kafka cluster may consist of thousands of machines spread across a wide network.



14

00:01:06,690 --> 00:01:09,930

They may be tens of thousands of topics.



15

00:01:10,050 --> 00:01:15,120

The message data in the topic is spread across multiple partitions.



16

00:01:15,330 --> 00:01:17,340

Think of the partition as a shock.



17

00:01:17,940 --> 00:01:23,610

The data and the partition is replicated across multiple machines in the Kafka cluster.



18

00:01:23,940 --> 00:01:28,580

As a result, the Kafka cluster is highly tolerant.



19

00:01:29,280 --> 00:01:34,890

Kafka was developed at LinkedIn and Open Source and 2011.



20

00:01:35,370 --> 00:01:42,240

To give you an idea on how LinkedIn is using Kafka, I'll share some numbers I have picked up from a



21

00:01:42,240 --> 00:01:44,190

blog written by Arlington, Virginia.



22

00:01:44,190 --> 00:01:52,680

In 2019, Linden processed seven trillion messages a day across one hundred Kafka clusters that had



23

00:01:52,950 --> 00:01:55,380

4000 brokers or machines.



24

00:01:55,500 --> 00:02:00,870

They had one hundred thousand topics which are split into seven million participants.



25

00:02:01,080 --> 00:02:05,960

So this is the kind of scale for which Kafka was built ground up.



26

00:02:06,940 --> 00:02:09,650

Let's go over the core capabilities of Kafka.



27

00:02:09,910 --> 00:02:15,590

It provides high messaging throughput with latencies as low as two milliseconds.



28

00:02:16,180 --> 00:02:17,470

It's highly scalable.



29

00:02:17,770 --> 00:02:24,790

You can easily add more machines or broker nodes to the cluster to scale it as by your requirements,



30

00:02:25,420 --> 00:02:34,300

it can handle trillions of messages per day and it can handle petabytes of data, Kafka cluster stores,



31

00:02:34,300 --> 00:02:38,080

all of the messaging data and persistent storage.



32

00:02:38,080 --> 00:02:40,750

So messages are not lost due to server failure.



33

00:02:41,590 --> 00:02:49,660

It's highly available, the data is replicated and failure of broken nodes does not impact the producers



34

00:02:49,660 --> 00:02:50,690

and the consumers.



35

00:02:50,920 --> 00:02:57,910

I suggest that you please visit Kafka, wrote Apache DOT or to read up more on these aspects of Kafka



36

00:02:57,910 --> 00:03:04,780

as well as to get a better feel of how the industry is using Kafka for their specific use cases.



37

00:03:05,660 --> 00:03:12,050

In this lesson, I provided you a very high level overview of what is GAFCON in the next lecture?



38

00:03:12,080 --> 00:03:18,350

I'll be covering the concepts of Kafka, followed by hands on experience with Kafka, wherein you will



39

00:03:18,350 --> 00:03:26,660

try out Kafka from Java and then I'll compare Kaw covid Amcu followed by Microsoft says Use cases for



40

00:03:26,660 --> 00:03:30,590

Kafka if you already have experience with Kafka.



41

00:03:30,800 --> 00:03:37,580

Feel free to skip the lectures on Kafka concepts, but please do follow the lectures on hands on experience



42

00:03:37,580 --> 00:03:44,270

with Kafka as he will be creating a Kafka cluster that we are going to use in later lectures.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\003 Kafka Concepts.en.srt -->

1

00:00:00,660 --> 00:00:08,370

Concepts, by the end of this lecture, you should be able to explain the common terms used in the context



2

00:00:08,370 --> 00:00:09,790

of a Kafka cluster.



3

00:00:10,140 --> 00:00:18,230

Please note, my intent here is to provide you a high level overview of essential Kafka concepts if



4

00:00:18,240 --> 00:00:20,470

you'd like to learn more about these concepts.



5

00:00:20,700 --> 00:00:23,760

I suggest that you carry out your own research.



6

00:00:24,270 --> 00:00:30,750

A Kafka cluster consist of one or both broker notes introduction.



7

00:00:30,750 --> 00:00:36,240

A minimum of three broker nodes are recommended when a topic is defined on the cluster.



8

00:00:36,570 --> 00:00:40,740

That topic is replicated across all of the brokers.



9

00:00:40,980 --> 00:00:48,960

The topic data is partitioned into multiple partitions, which are replicated across the broken nodes.



10

00:00:49,170 --> 00:00:53,580

Producer connects to the cluster and publishes a message.



11

00:00:53,820 --> 00:01:01,970

Consumers connect to the cluster and get the data pushed into the partitions for the specific topic



12

00:01:01,980 --> 00:01:03,280

that they have subscribed to.



13

00:01:03,510 --> 00:01:07,830

Let's dive deeper into the details of how the cluster works.



14

00:01:08,430 --> 00:01:15,990

When a message is published by the producer, that message gets added to the partition and the partition



15

00:01:16,260 --> 00:01:19,690

is then replicated across multiple brokers.



16

00:01:20,160 --> 00:01:28,830

So in this illustration, let's say the topic has three partitions and all of these three partitions



17

00:01:28,830 --> 00:01:31,730

are replicated across the three brokers.



18

00:01:32,220 --> 00:01:38,910

We have the replica, one in Broca, one replicative and broker two and replicate three in Broecker



19

00:01:38,910 --> 00:01:39,300

three.



20

00:01:39,870 --> 00:01:47,520

Since the partition is replicated across three brokers, the replication factor is set to be three.



21

00:01:47,910 --> 00:01:54,840

If we are configured this cluster to replicate the partition only across, let's say, two brokers,



22

00:01:55,440 --> 00:02:02,550

then the replication factor will be set to be to the benefit of this replication is that if there is



23

00:02:02,550 --> 00:02:10,350

a failure of one of the brokers, the data in the topic will still be available and the consumers will



24

00:02:10,350 --> 00:02:13,070

not be impacted due to this failure.



25

00:02:13,320 --> 00:02:19,320

So the idea is the higher the application factor, the more fault tolerant is your cluster.



26

00:02:19,530 --> 00:02:26,070

But obviously you will need to allocate more resources to your cluster at any point in time.



27

00:02:26,610 --> 00:02:34,800

Each partition has one broken node assigned as a leader, and this little broken node is responsible



28

00:02:34,800 --> 00:02:38,660

for all of the reads and writes to that partition.



29

00:02:39,300 --> 00:02:44,580

So in this illustration for partition one, let's say the leader node is Broca one.



30

00:02:44,700 --> 00:02:51,930

In that case, whenever a message will be published to topic A and if the data gets added to partition



31

00:02:51,930 --> 00:02:59,970

one, then the broker, no one will be responsible for replicating the data for partition one to other



32

00:03:00,120 --> 00:03:06,570

broker nodes in the cluster in case of failure of the leader node, one of the other available broker



33

00:03:06,580 --> 00:03:10,340

nodes take up the role of the leader for that partition.



34

00:03:10,380 --> 00:03:17,880

All of this happens under the covers and is transparent to the producers and the consumers of the messages.



35

00:03:18,630 --> 00:03:26,220

Message data is partition on the message e.g. this message key is provided by the producer as part of



36

00:03:26,220 --> 00:03:27,810

the publishing of the message.



37

00:03:28,440 --> 00:03:30,180

The message key is optional.



38

00:03:30,450 --> 00:03:35,880

So let's talk about the scenario in which the producer provides the message key.



39

00:03:36,270 --> 00:03:42,900

Let's say the producer publishes a message for customer ID one, two, three as the key.



40

00:03:43,170 --> 00:03:51,390

In that case, the broker calculates the hash value for the key provided by the producer, and then



41

00:03:51,390 --> 00:03:57,480

the broker uses the hash value to determine which partition the message data will go to.



42

00:03:57,510 --> 00:04:01,740

So in this case, Brocco pushed the message right to partition one.



43

00:04:02,100 --> 00:04:09,480

Let's say the producer now publishes a message with key call to customer seven eight nine.



44

00:04:09,700 --> 00:04:16,950

Again, the broker will calculate the hash value and may decide to push this message with key equal



45

00:04:16,950 --> 00:04:19,950

to Cosmati seven, eight, nine in partition number two.



46

00:04:19,950 --> 00:04:26,730

And so what this means is that every time the same key is used, the message will be pushed to the same



47

00:04:26,730 --> 00:04:27,380

partition.



48

00:04:27,390 --> 00:04:33,720

So if, let's say another message is published by the producer with key equal to Cosmati, one, two,



49

00:04:33,720 --> 00:04:37,560

three, then that new message will end up in partition number one.



50

00:04:37,650 --> 00:04:42,380

Now, let's talk about a scenario in which the producer does not provide the key.



51

00:04:42,810 --> 00:04:48,780

In that case, the broker carries out the partition assignment in a Round-Robin fashion.



52

00:04:48,780 --> 00:04:52,690

So what that means is that the first message will end up in partition.



53

00:04:52,770 --> 00:04:55,410

One second will end up in partition number two.



54

00:04:55,560 --> 00:04:57,420

Third will end up in partition number three.



55

00:04:57,660 --> 00:04:59,820

And the fourth message will again end up.



56

00:05:00,050 --> 00:05:07,240

Partition number one, typical messaging systems do not retain the order in which the messages are sent,



57

00:05:07,820 --> 00:05:13,250

but in the case of Kafka, messages are ordered within a partition.



58

00:05:13,460 --> 00:05:18,570

The key here is to understand that this ordering is guaranteed only within a partition.



59

00:05:18,620 --> 00:05:23,940

The other way of saying this would be that messages are not ordered across partitions.



60

00:05:23,990 --> 00:05:30,590

So here is a scenario in which a consumer is reading the messages from partition number two.



61

00:05:30,740 --> 00:05:37,850

So this consumer will have the guarantee that all messages will be received by it in the order they



62

00:05:37,850 --> 00:05:38,510

were published.



63

00:05:38,660 --> 00:05:44,980

This order and guarantee is one reason for picking up Kafka over a typical messaging platform.



64

00:05:45,680 --> 00:05:50,750

Each message in a partition is a sign then offset within the partition.



65

00:05:51,140 --> 00:05:53,360

Let me explain this with an example.



66

00:05:53,690 --> 00:06:00,230

Let's say the producer publishes a message with key equal to one, two, three, and the broker decides



67

00:06:00,230 --> 00:06:03,180

to push this message into partition number one.



68

00:06:03,980 --> 00:06:07,090

So this is the first message and partition number one.



69

00:06:07,460 --> 00:06:10,270

So the offset for this message is set to zero.



70

00:06:10,700 --> 00:06:14,560

Let's say another message with equal to one, two, three is published.



71

00:06:14,990 --> 00:06:18,090

This new message will have an offset equal to one.



72

00:06:18,440 --> 00:06:22,850

Now the producer publishes a message with key equal to four, five, six.



73

00:06:23,270 --> 00:06:27,310

Now, this message may end up in, let's say, partition number two.



74

00:06:27,650 --> 00:06:32,990

And since this is the first message and partition number two, it'll have an offset equal to zero.



75

00:06:33,210 --> 00:06:39,740

Another message with key equal to four, five six when published by producer will end up in partition



76

00:06:39,740 --> 00:06:46,730

number two with an offset equal to one oh, let's say the next messages with the key equal to one,



77

00:06:46,730 --> 00:06:47,140

two, three.



78

00:06:47,420 --> 00:06:52,880

In that case, the message will end up in partition number one, with offset equal to two.



79

00:06:53,480 --> 00:07:00,440

Next, let's say the producer publishes a message with key equal to six, seven, eight, and the broker



80

00:07:00,440 --> 00:07:03,430

decides to push it and partition number three.



81

00:07:03,480 --> 00:07:08,870

Now, since this is the first message and partition number three, it'll be assigned and offset equal



82

00:07:08,870 --> 00:07:09,650

to zero.



83

00:07:10,690 --> 00:07:16,130

A Kafka cluster allows maximum of one act of consumer protection.



84

00:07:16,150 --> 00:07:23,080

So in this illustration, we have consumer receiving messages from Partition one and Consumer B receiving



85

00:07:23,080 --> 00:07:24,730

messages from partition to.



86

00:07:25,330 --> 00:07:30,910

The reason for this is that with a single consumer, the order of the messages is guaranteed.



87

00:07:31,000 --> 00:07:38,390

Kafka cluster maintains the current offset of the message that has been read by the consumer.



88

00:07:38,830 --> 00:07:46,240

So here in this table, you see that the consumer is reading from partition one and as the message arrives,



89

00:07:46,630 --> 00:07:49,270

the offset is set to zero one.



90

00:07:49,270 --> 00:07:56,320

Consumer A has read the message as new messages arrive, the current offset changes for consumer and



91

00:07:56,320 --> 00:08:03,760

consumer B by maintaining the current offset on part consumer basis, Kafka is able to avoid sending



92

00:08:03,760 --> 00:08:09,670

duplicate messages to the consumer message reads in Kafka or nondestructive.



93

00:08:09,680 --> 00:08:13,660

That is, when the consumer reads the message from the topic.



94

00:08:14,020 --> 00:08:22,810

The message is not deleted, only the offset gets updated and consumer can at any time reset the offset.



95

00:08:23,140 --> 00:08:29,350

And what that means is that by resetting the offset, consumer can replace the log.



96

00:08:29,350 --> 00:08:35,940

Messages from any offset messages on the topic are not retained indefinitely.



97

00:08:36,250 --> 00:08:43,420

There is a retention period which is associated with the topic that basically defines the time to live



98

00:08:43,690 --> 00:08:47,740

for the message after the retention period has expired.



99

00:08:47,740 --> 00:08:52,420

For the message, the message is automatically deleted from the topic.



100

00:08:52,570 --> 00:09:00,940

Although COFCO maintains the current offset on part consumer base is consumer also has the option of



101

00:09:01,210 --> 00:09:06,210

managing the offset on its own outside of the cluster.



102

00:09:07,100 --> 00:09:15,740

In messaging systems, it is common for multiple instances of the consumers to read messages of a common



103

00:09:15,740 --> 00:09:16,180

cue.



104

00:09:16,460 --> 00:09:21,510

This is done for high performance and high throughput in COFCO.



105

00:09:21,530 --> 00:09:24,740

It can be done by way of grouping the consumers.



106

00:09:24,740 --> 00:09:32,120

And the idea is that each message in the topic is received by only one of the consumers in the group.



107

00:09:32,180 --> 00:09:36,660

This grouping of consumers is carried out by way of group idea.



108

00:09:36,770 --> 00:09:43,160

So here in this illustration, we have three consumers and all of these three consumers are assigned



109

00:09:43,190 --> 00:09:50,840

a common group and COFCO will make sure that each message is received by only one of the consumers.



110

00:09:51,020 --> 00:09:58,400

Hence there won't be any duplication of messages since COFCO allows only one consumer per partition,



111

00:09:58,820 --> 00:10:04,860

the maximum number of consumers in a group is equal to the number of participants.



112

00:10:05,060 --> 00:10:10,030

So in this illustration, we have a topic here which has three participants.



113

00:10:10,340 --> 00:10:14,120

So at the most we can have three consumers in a group.



114

00:10:14,310 --> 00:10:21,980

If a fourth consumer is added, it'll go into the red state, which means that it will not receive any



115

00:10:21,980 --> 00:10:27,320

messages until one of the consumer dies or stops listening for the messages.



116

00:10:27,650 --> 00:10:30,200

Let's go over the key points from this lesson.



117

00:10:31,360 --> 00:10:40,000

Kafka reads, are nondestructive the message is written in the Kafka topic, partition for the retention



118

00:10:40,000 --> 00:10:42,300

period defined on the topic.



119

00:10:42,430 --> 00:10:44,530

Topics are split into partitions.



120

00:10:44,980 --> 00:10:52,660

Producer can specify the message key, which determines the partition to which the message data gets



121

00:10:52,660 --> 00:10:53,290

added.



122

00:10:53,290 --> 00:11:03,640

Kafka maintains the offset of the last message on consumer basis, consumer can reset this offset.



123

00:11:03,910 --> 00:11:08,110

The consumer can maintain the offset on its own.



124

00:11:08,140 --> 00:11:13,720

Consumers can read the messages from a topic as a group by way of group ID.



125

00:11:13,750 --> 00:11:21,820

In the next lecture, we will create a Kafka cluster and you will see all of these concepts in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\004 Hands On _ Create a Kafka Cluster.en.srt -->

1

00:00:00,510 --> 00:00:02,590

Cluster set up in this lecture.



2

00:00:02,880 --> 00:00:09,300

I'll walk you through the steps for creating a free COFCO cluster on the cloud.



3

00:00:09,330 --> 00:00:12,360

Then I'll walk you through the console for the COFCO.



4

00:00:12,390 --> 00:00:19,290

Cluster will also try out the pops of messaging in the browser available on the console.



5

00:00:19,320 --> 00:00:26,010

I suggest that you please follow along so that by the end of this lecture you will have your own instance



6

00:00:26,010 --> 00:00:30,650

of the coffeecake cluster to create the free cluster on the cloud.



7

00:00:30,690 --> 00:00:35,060

Go to w w w dot cloud Kafka dot com.



8

00:00:35,520 --> 00:00:39,300

Please pay attention to the spellings here as it's a little confusing.



9

00:00:40,710 --> 00:00:48,660

Click on log in and then you can either sign in with your GitHub or your Google account or you can create



10

00:00:48,870 --> 00:00:50,880

an account by clicking on sign up.



11

00:00:51,090 --> 00:00:56,580

Hey, you provide your email address and you will receive an email, follow the instructions to create



12

00:00:56,580 --> 00:00:57,180

the account.



13

00:00:57,480 --> 00:01:01,080

I already have the account, so I will go ahead and log in.



14

00:01:01,290 --> 00:01:05,280

I already have an instance created for my testing.



15

00:01:05,580 --> 00:01:06,810

To create your own instance.



16

00:01:06,810 --> 00:01:09,240

Click on the create new instance.



17

00:01:09,240 --> 00:01:15,960

Provide the instance name, stick to the free plan and then click on Select Region in the Select Region.



18

00:01:16,230 --> 00:01:23,790

Select the nearest region to you and click on review and then click on Create Instance.



19

00:01:23,790 --> 00:01:27,570

It will take a couple of minutes to create an instance for you.



20

00:01:27,720 --> 00:01:33,900

Once you have the instance created, you will see your instance in the list of instances.



21

00:01:34,350 --> 00:01:36,060

Click on the instance.



22

00:01:36,190 --> 00:01:37,680

So here are all the details.



23

00:01:37,680 --> 00:01:40,470

For the instance, click on the download link.



24

00:01:40,680 --> 00:01:47,040

This will download the credentials that you will need for connecting to COFCO from the Java code.



25

00:01:47,250 --> 00:01:48,420

We'll use it later.



26

00:01:48,630 --> 00:01:53,640

This is the hostname for your coffeecake cluster, the user name and then there is a password.



27

00:01:53,730 --> 00:01:59,640

All this information is contained in the file that was downloaded with the download link here.



28

00:01:59,790 --> 00:02:04,620

Please note that some of the options here will not be available in the free account.



29

00:02:04,710 --> 00:02:10,370

For example, as you can see here, the Kafka configuration is only available in the dedicated plan.



30

00:02:10,770 --> 00:02:16,410

Similarly, you will not be able to see the Matrix information, but we won't be going into all these



31

00:02:16,410 --> 00:02:16,920

details.



32

00:02:16,920 --> 00:02:21,240

So it's OK for not having this information available to us.



33

00:02:21,780 --> 00:02:23,580

Next, let's check out the topics.



34

00:02:23,580 --> 00:02:24,570

Click on topics.



35

00:02:24,750 --> 00:02:28,350

You will see that there is a default topic created.



36

00:02:28,350 --> 00:02:34,050

For instance, the name of the topic is your username Dasch Default.



37

00:02:34,350 --> 00:02:41,580

There are five partitions for this topic and each of the partition is replicated across three nodes



38

00:02:41,580 --> 00:02:42,560

retention bytes.



39

00:02:42,570 --> 00:02:48,660

Here is the maximum amount of message data that will be retained in the topic.



40

00:02:48,660 --> 00:02:51,480

In case you exceed this retention bytes.



41

00:02:51,480 --> 00:02:57,810

No, some of your earlier messages will be pruned and there may be additional restrictions put on the



42

00:02:57,840 --> 00:02:58,920

three instance.



43

00:02:58,920 --> 00:03:00,510

So just be aware of it.



44

00:03:00,720 --> 00:03:04,260

This is not a production grid instance that we are using.



45

00:03:04,440 --> 00:03:09,840

The retention millisecond is the amount of time for which the message will be retained.



46

00:03:10,230 --> 00:03:16,430

This translates into twenty eight days and you may actually change these numbers.



47

00:03:16,440 --> 00:03:21,420

For example, I can change this to let's say 5000 and just click on object.



48

00:03:21,420 --> 00:03:27,090

I want updated, but if you are interested in experimentation, go ahead and try it out.



49

00:03:27,450 --> 00:03:33,810

Next, I'll show you how you can test out the consumer and producer in the browser.



50

00:03:33,810 --> 00:03:36,420

Click on the browser here.



51

00:03:36,420 --> 00:03:38,730

You provide the name of the topic.



52

00:03:38,730 --> 00:03:40,640

You can copy it from the topics.



53

00:03:40,680 --> 00:03:41,850

Click on Consume.



54

00:03:41,880 --> 00:03:47,490

Now you have a Kafka consumer listening for messages on this topic.



55

00:03:47,490 --> 00:03:54,270

And when it received the message, those messages will show up here to send a message, simply provide



56

00:03:54,270 --> 00:03:58,290

the message that's a text message and click on produce.



57

00:03:58,440 --> 00:04:00,480

And here is our text message.



58

00:04:01,110 --> 00:04:07,690

So as you can see here, this new message was put and partition for an within the partition.



59

00:04:07,920 --> 00:04:11,970

The message offset is seven and no key was specified.



60

00:04:12,360 --> 00:04:18,230

And there is an offset the seven errors, because I've been playing with this topic for a while.



61

00:04:18,540 --> 00:04:23,970

So if you have created a new topic, you should see an offset of one here.



62

00:04:24,300 --> 00:04:27,240

Now click on Cloud Kafka manager.



63

00:04:27,570 --> 00:04:34,110

Now, the number of consumers here are showing up at fourteen, and the reason is because we are on



64

00:04:34,110 --> 00:04:35,790

a shared infrastructure.



65

00:04:36,210 --> 00:04:40,980

So there are other consumers attached to this shared cluster.



66

00:04:41,250 --> 00:04:45,480

But your topic is isolated from these other consumers.



67

00:04:45,510 --> 00:04:51,780

There is one topic in the cluster and three brokers total topic size is five point six cabi.



68

00:04:51,960 --> 00:04:57,510

The message count is fifty nine and the reason it's fifty nine is because I have been playing with this



69

00:04:57,510 --> 00:04:59,790

cluster for a while now and there is.



70

00:04:59,980 --> 00:05:06,800

One user click on the topic, and here you see that one topic that we tried out earlier.



71

00:05:06,910 --> 00:05:11,090

Click on the topic name and it'll show you some details.



72

00:05:11,500 --> 00:05:14,860

There are five partitions that application factories three.



73

00:05:15,280 --> 00:05:19,540

And these are details about each of the participants.



74

00:05:19,690 --> 00:05:26,710

So, for example, for partition number zero, the leader is broken, number two, and the start of



75

00:05:26,710 --> 00:05:30,130

set is zero and the end of that is 13.



76

00:05:30,280 --> 00:05:37,810

So what that means is that after the creation of this topic, 13 messages have been pushed into this



77

00:05:37,810 --> 00:05:38,500

partition.



78

00:05:38,530 --> 00:05:44,380

Similarly, if you look at partition number three, node number two is the leader start of the zero



79

00:05:44,380 --> 00:05:49,660

and Offsiders 16, meaning that 16 messages have been pushed into partition.



80

00:05:49,660 --> 00:05:56,820

Number three, click on the consumers and you will see a list of consumers attached to the shared infrastructure.



81

00:05:57,070 --> 00:06:01,200

Click on the brokers to check out the brokers in the cluster.



82

00:06:01,210 --> 00:06:02,800

And these are the nodes.



83

00:06:03,070 --> 00:06:09,020

In a later lecture, we will connect from our Java code to this cluster as an exercise.



84

00:06:09,040 --> 00:06:17,860

I suggest that you create a topic and to do that, go back to your cloud craft console, click on topics,



85

00:06:17,980 --> 00:06:25,660

provide the topic name here, set the parameters and just create time to publish some messages to that



86

00:06:25,660 --> 00:06:31,030

topic and start a consumer in the browser to see how things work.



87

00:06:31,090 --> 00:06:32,380

Explore this console.



88

00:06:32,810 --> 00:06:34,470

I'll see you in the next lecture.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\005 Hands On _ Working with Kafka Producer.en.srt -->

1

00:00:00,480 --> 00:00:03,520

Coproducer in action in this lesson.



2

00:00:03,810 --> 00:00:09,240

I'll walk you through the class diagram for a set of utility classes that are put together for testing



3

00:00:09,240 --> 00:00:10,110

or Kafka.



4

00:00:10,290 --> 00:00:17,030

I'll walk you through the code in the producers of this class, and then we will execute the producers



5

00:00:17,040 --> 00:00:20,650

of this class to send messages to the Kafka cluster.



6

00:00:21,570 --> 00:00:28,860

The COFCO utility classes are available under Commodore Akhmadov in Product COFCO package Kafka configuration



7

00:00:28,860 --> 00:00:35,380

interface holds the variables with configuration parameters for the COFCO cluster.



8

00:00:35,610 --> 00:00:42,300

So this is where you need to make a change for pointing the Java consumer and producers to your own



9

00:00:42,300 --> 00:00:43,240

coffeecake cluster.



10

00:00:43,590 --> 00:00:48,960

So make sure that you make changes to this interface for testing out your Cafcass set up.



11

00:00:49,530 --> 00:00:58,080

The Cafcass service is an abstract class that has one function set up configuration that sets up the



12

00:00:58,080 --> 00:01:05,670

cluster configuration for the producer and the consumer consumer service and the producer service extends



13

00:01:05,820 --> 00:01:07,560

the Cafcass service class.



14

00:01:07,800 --> 00:01:15,120

The producer service exposes the public functions for publishing of the messages to a topic.



15

00:01:15,330 --> 00:01:22,670

Similarly, the consumer service has a subscriber function that subscribes to a topic on the Kafka cluster.



16

00:01:22,860 --> 00:01:30,360

When the message arrives at the consumer service delegates, the processing of the message to the instance



17

00:01:30,360 --> 00:01:32,120

of message handler.



18

00:01:32,340 --> 00:01:34,680

Let's go over the code and try it out.



19

00:01:35,190 --> 00:01:38,930

Open the Commodore Akhmad in for the package.



20

00:01:38,940 --> 00:01:41,420

Click on Kafka configuration.



21

00:01:41,790 --> 00:01:50,580

Now recall that we downloaded the configuration for our COFCO cluster from the details page.



22

00:01:50,580 --> 00:01:56,700

And if you haven't done that, click on the download here and this will download a text file and this



23

00:01:56,700 --> 00:02:03,630

text file will have the configuration information that we need to set up here, copy the information



24

00:02:03,810 --> 00:02:11,820

for the brokers and replace what you see here and then copy the user name and password.



25

00:02:11,970 --> 00:02:17,970

Once you have done that, make sure the configuration is saved and we are ready to check out the code



26

00:02:17,970 --> 00:02:19,110

and Cafcass service.



27

00:02:19,470 --> 00:02:22,380

Cafcass Service is an abstract class.



28

00:02:22,380 --> 00:02:28,920

It holds some protected variables for topic and the group it this group, it will be used by the consumer



29

00:02:28,920 --> 00:02:29,310

only.



30

00:02:29,790 --> 00:02:38,670

And there is this set of properties protected function that simply creates properties object with all



31

00:02:38,670 --> 00:02:42,150

the parameters needed for connecting to the COFCO cluster.



32

00:02:42,450 --> 00:02:47,680

And this function is used by the classes for consumer and producer.



33

00:02:47,850 --> 00:02:50,850

Next, we'll check out the producers service, the producer.



34

00:02:50,860 --> 00:02:54,030

So extend the Cafcass service class.



35

00:02:54,210 --> 00:03:00,510

There is an instance of decaf coproducer which is maintained as a private instant's variable within



36

00:03:00,510 --> 00:03:06,180

this class constructor takes the topic and creates the coproducer.



37

00:03:06,300 --> 00:03:11,670

Notice here that the properties are right from the Cafcass service class.



38

00:03:11,970 --> 00:03:14,640

There are a couple of published functions in this class.



39

00:03:14,910 --> 00:03:16,050

These public functions.



40

00:03:16,290 --> 00:03:23,880

Take an instance of the callback object, which is asynchronously invoked after the method has been



41

00:03:24,000 --> 00:03:24,630

published.



42

00:03:25,440 --> 00:03:32,880

This function here is for publishing a message without key, and this function is for publishing a message



43

00:03:32,940 --> 00:03:33,620

with the key.



44

00:03:34,110 --> 00:03:37,670

The implementation of these two functions is quite similar.



45

00:03:38,130 --> 00:03:44,190

An instance of the produce record is created and the second function is called On the carpet coproducer



46

00:03:44,490 --> 00:03:45,660

with the producer record.



47

00:03:45,810 --> 00:03:51,570

And if the callback is provided, then the callback is also specified in this hand function.



48

00:03:51,600 --> 00:03:57,790

To test out this class, you will find that there is a main function defined within the class.



49

00:03:57,790 --> 00:04:00,000

First, we are setting up the topic.



50

00:04:00,120 --> 00:04:01,830

Make sure that this topic exists.



51

00:04:02,040 --> 00:04:08,340

Sassella underscore username is the name assigned on the Cloud Kafka cluster.



52

00:04:08,370 --> 00:04:14,460

Here we are creating the an instance of the producer service, setting up the callback, which is simply



53

00:04:14,460 --> 00:04:18,580

printing out the metadata information for the published message.



54

00:04:18,810 --> 00:04:26,010

This is for publishing a message without the key and this is the publishing of the message with the



55

00:04:26,010 --> 00:04:27,840

key will try out both of them.



56

00:04:28,410 --> 00:04:33,690

Go to Cloud Krake, click on your instance, click on the topics.



57

00:04:34,020 --> 00:04:37,710

We will pick up the default topic names or copy this topic.



58

00:04:37,710 --> 00:04:39,090

Name to the clipboard.



59

00:04:39,090 --> 00:04:44,090

Click on browser will pass the name of the topic here and click on Consume.



60

00:04:44,100 --> 00:04:46,620

Now at this point we have a consumer running.



61

00:04:46,740 --> 00:04:49,290

We are going to go back to a producer service, right?



62

00:04:49,290 --> 00:04:51,240

Click on produce a service run.



63

00:04:51,660 --> 00:04:58,230

The execution of the produce or service has completed and two messages were published as expected.



64

00:04:58,440 --> 00:05:04,920

And the partition and also the information for the published messages was printed on the console from



65

00:05:04,920 --> 00:05:05,580

the callback.



66

00:05:05,820 --> 00:05:10,500

One message is without the key and another message is with the key.



67

00:05:10,950 --> 00:05:12,270

Let's go back to a browser.



68

00:05:12,720 --> 00:05:18,330

And as you can see here, the consumer has received two messages suggest that you try out the producer



69

00:05:18,330 --> 00:05:19,740

class on your own.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\006 Hands On _ Working with Kafka Consumer Groups.en.srt -->

1

00:00:00,210 --> 00:00:03,790

Kafka Consumer Group and action in this lesson.



2

00:00:04,170 --> 00:00:11,340

I'll start by explaining how the Kafka rebalancing protocol works, then I'll walk you to the court



3

00:00:11,640 --> 00:00:19,560

and the consumer service class, and then we will run the code for the Kafka consumer and the coproducer



4

00:00:19,920 --> 00:00:23,520

to check out how Kafka rebalancing protocol works.



5

00:00:24,180 --> 00:00:26,020

Kafka Rebalancing Protocol.



6

00:00:26,400 --> 00:00:34,590

Recall that Kafka allows only one consumer for partition when the consumers are launched in a consumer



7

00:00:34,590 --> 00:00:34,940

group.



8

00:00:35,130 --> 00:00:43,590

Kafka ensures that each consumer in a group is attached to zero or more partitions any time a new consumer



9

00:00:43,590 --> 00:00:47,830

is added to the group or an existing consumer is removed from the group.



10

00:00:48,060 --> 00:00:53,860

The Kafka rebalancing protocol ensures that the partitions are reassigned.



11

00:00:53,880 --> 00:01:00,840

For example, if you remove the consumer listening on partition, no one from the consumer group, the



12

00:01:00,990 --> 00:01:08,070

consumer group will automatically rebalance and that partition one will be assigned to one of the other



13

00:01:08,310 --> 00:01:09,480

active consumers.



14

00:01:09,900 --> 00:01:11,460

Let's go over how this works.



15

00:01:11,820 --> 00:01:15,720

Let's say we have a topic with two partitions.



16

00:01:16,140 --> 00:01:22,230

When the first consumer is launched in a consumer group, it will receive messages from both the participants.



17

00:01:22,470 --> 00:01:26,450

Now, let's say a new consumer is added to the consumer group.



18

00:01:26,460 --> 00:01:33,120

The rebalancing will happen under the covers, and each of the consumers in the consumer group will



19

00:01:33,120 --> 00:01:35,940

listen for messages on one of the partitions.



20

00:01:36,090 --> 00:01:43,110

So here consumer is listening for messages from partition one and consumer will be is assigned partition



21

00:01:43,110 --> 00:01:50,860

to, let's say a third consumer is not added, since there can be only one consumer power partition.



22

00:01:50,910 --> 00:01:58,650

This new consumer consumer C will not be assigned any partition, but if consumer and consumer B goes



23

00:01:58,650 --> 00:02:05,010

down, then consumer C will automatically be assigned the partition on which there is no consumer.



24

00:02:06,920 --> 00:02:13,100

Focus in this lecture is on the consumers of his class and for testing out the rebalancing, we will



25

00:02:13,100 --> 00:02:19,160

use the consumer service class as well as the producers of this class that I walked you to earlier.



26

00:02:20,000 --> 00:02:24,310

The consumer service class extends the customer service based class.



27

00:02:24,320 --> 00:02:31,580

It has to constructor's the first constructor takes just a topic as an argument, and the second constructor



28

00:02:31,580 --> 00:02:35,390

takes two arguments, the topic and the group ID.



29

00:02:35,690 --> 00:02:41,960

So if you create the consumer service instance with the group ID, it'll be part of a group.



30

00:02:42,170 --> 00:02:45,500

And this is the constructor that we are going to use in our testing.



31

00:02:45,710 --> 00:02:51,860

The subscribe function takes depolarization and an instance of the message, and the first thing that



32

00:02:51,860 --> 00:02:58,370

happens in this function is the creation of the consumer with the properties received from the best



33

00:02:58,370 --> 00:02:58,790

class.



34

00:02:58,970 --> 00:03:04,560

Then the subscribe function is getting invoked on the consumer with a list of topics.



35

00:03:04,580 --> 00:03:11,310

So what that means is that a consumer can subscribe to multiple topics within the same call.



36

00:03:11,480 --> 00:03:13,690

This here is the pulling loop.



37

00:03:13,700 --> 00:03:20,030

The first thing that is happening is we are getting the partition assignments for this consumer and



38

00:03:20,030 --> 00:03:25,880

simply printing out those assignments to the console, calling the poll function with the whole duration.



39

00:03:26,420 --> 00:03:33,530

And this will receive zero or more messages from Kafka go through the set of messages received from



40

00:03:33,530 --> 00:03:39,550

Kafka by invoking the handle function on the instance of the handler.



41

00:03:39,710 --> 00:03:45,030

The testing forward for this class is in the main function within the consumer service class.



42

00:03:45,050 --> 00:03:50,930

The first thing that's happening here is setting up off the topic, setting up of the group the creation



43

00:03:50,930 --> 00:03:53,810

of the consumer service instance with the topic and the group.



44

00:03:54,380 --> 00:04:01,160

And then there is this creation of the message handler instance, which is printing out the information



45

00:04:01,160 --> 00:04:06,920

for the message on the console and then call to the subscribe function with the polling.



46

00:04:06,920 --> 00:04:14,210

Durational one second or one thousand millisecond to test out Kafka, rebalancing will carry out three



47

00:04:14,210 --> 00:04:19,220

steps and step number one will create a new topic with two partitions.



48

00:04:19,730 --> 00:04:27,530

Then we will set up our consumer service class to listen to this new topic and we will create two instances



49

00:04:27,800 --> 00:04:29,530

of the consumer service class.



50

00:04:29,540 --> 00:04:37,250

So in effect, there will be two subscribers and then we will set up our producer class to send messages



51

00:04:37,640 --> 00:04:45,080

to this new topic, and we will send out messages with different keys to see which consumer will receive



52

00:04:45,080 --> 00:04:46,270

those messages.



53

00:04:46,310 --> 00:04:56,300

So let's go ahead and create a new topic on the cloud traffick click on the topics and provide a new



54

00:04:56,300 --> 00:04:56,690

topic.



55

00:04:56,690 --> 00:05:04,700

Name will call it new change the number of partitions to two and keep the replica at one just had create.



56

00:05:05,090 --> 00:05:08,270

And now we have a new topic on our cluster.



57

00:05:08,720 --> 00:05:10,040

Go to the consumer class.



58

00:05:10,040 --> 00:05:12,470

Change this before to new.



59

00:05:12,830 --> 00:05:17,990

So now our consumer will listen for messages on this new topic.



60

00:05:18,230 --> 00:05:18,590

Right?



61

00:05:18,590 --> 00:05:21,170

Click on the consumer service and run.



62

00:05:21,500 --> 00:05:26,300

Our consumer has launched and there is one instance of the consumer running at this time.



63

00:05:26,300 --> 00:05:32,870

Click on the produce or service, go all the way down to the main function and change the topic name



64

00:05:32,870 --> 00:05:41,830

to new from default and then come down and just comment out the call to publish without the key.



65

00:05:42,230 --> 00:05:45,860

Now, the idea here is that we will always send a message with the key.



66

00:05:46,040 --> 00:05:49,120

So here we have the key to customer dash.



67

00:05:49,160 --> 00:05:49,970

One, two, three.



68

00:05:49,970 --> 00:05:55,220

So let's see what happens when we send a message to that one consumer that is listening.



69

00:05:55,640 --> 00:06:01,180

So run produce a service, go back to the consumer and a consumer received the message.



70

00:06:01,220 --> 00:06:08,570

Now pay attention to the partitions assigned this one consumer is assigned to both the partition, partition



71

00:06:08,570 --> 00:06:09,890

and mosiello and partition.



72

00:06:09,890 --> 00:06:13,100

No one now will launch another consumer right.



73

00:06:13,100 --> 00:06:15,380

Click on consumer service run.



74

00:06:15,680 --> 00:06:18,760

So this will launch another instance of the consumer.



75

00:06:19,010 --> 00:06:25,430

Now our second instance of the consumer is running and Kafka will internally carry out the rebalancing.



76

00:06:25,430 --> 00:06:28,910

So this is our consumer one that received the first message.



77

00:06:29,300 --> 00:06:35,450

And this is a consumer two, which is also waiting for the messages on the same topic.



78

00:06:35,450 --> 00:06:37,250

Go back to the producer service.



79

00:06:37,820 --> 00:06:45,110

Let's change this customer one, two, three to four, five, six, and see which one of these consumers



80

00:06:45,110 --> 00:06:46,340

will receive the message.



81

00:06:46,790 --> 00:06:48,230

Right, click, run.



82

00:06:48,380 --> 00:06:55,370

And what I see here is that our consumer one has received the message with the customer key four, five,



83

00:06:55,370 --> 00:06:55,790

six.



84

00:06:56,180 --> 00:07:01,340

Now let's try seven, eight, nine, and hopefully this time our consumer two will receive it.



85

00:07:01,550 --> 00:07:01,850

Right.



86

00:07:01,850 --> 00:07:06,140

Click on producer Andron and this time our consumer.



87

00:07:06,300 --> 00:07:13,380

Who has received the message not pay attention to the partition assigned consumer who is listening for



88

00:07:13,380 --> 00:07:20,190

messages on partition zero, and if you go to consumer one, the consumer one is listening for messages



89

00:07:20,190 --> 00:07:21,280

on partition one.



90

00:07:21,690 --> 00:07:24,300

Now, let's go ahead and kill one of these consumers.



91

00:07:24,330 --> 00:07:26,550

Let me just call the first consumer.



92

00:07:26,730 --> 00:07:35,100

And at this point, Kafka is going to rebalance the consumers and we should see that all messages will



93

00:07:35,100 --> 00:07:38,460

be received by the only consumer that is running.



94

00:07:38,490 --> 00:07:39,000

So, right.



95

00:07:39,000 --> 00:07:41,310

Click on produce a service run again.



96

00:07:41,700 --> 00:07:46,560

And as expected, the message was received by the only consumer that is running.



97

00:07:46,560 --> 00:07:53,250

Pay attention to the partition assigned and you will see that now we have only one consumer in the group



98

00:07:53,580 --> 00:07:58,390

and that consumer is listening for messages on both the partitions.



99

00:07:58,440 --> 00:08:06,240

So this was a demonstration of how Kafka carries out the rebalancing automatically within a consumer



100

00:08:06,240 --> 00:08:06,600

group.



101

00:08:06,600 --> 00:08:12,270

So just that you play with this on your own to get a better understanding of how rebalancing works.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\007 Kafka vs AMQP (RabbitMQ).en.srt -->

1

00:00:00,150 --> 00:00:07,410

Courthouse's M. Cupie, in this lesson, Al Gore, the differences between COFCO message streaming platform



2

00:00:07,410 --> 00:00:14,790

and AM based messaging systems such as Rabbitt Amcu and active Amcu, I'll start this lesson with a



3

00:00:14,790 --> 00:00:15,420

question.



4

00:00:15,660 --> 00:00:22,200

Now that you know about Kafka and M Cupie, which one of these would you use for your micro services?



5

00:00:22,240 --> 00:00:26,550

No, I'm not going to discuss response to this question in this lesson.



6

00:00:26,970 --> 00:00:32,160

Rather, I suggest that you keep this question in mind as you go through the content in this lecture.



7

00:00:32,550 --> 00:00:39,030

We will be discussing the response in the next lecture when a message was sent to a Kafka topic.



8

00:00:39,040 --> 00:00:42,470

It has always persisted in the long term story.



9

00:00:42,480 --> 00:00:45,390

Method expires after the set duration.



10

00:00:45,420 --> 00:00:50,610

On the Kafka topic, messages are not removed on read.



11

00:00:50,880 --> 00:00:57,810

So what that means is that the consumer or the message can reread the message now comparing it with



12

00:00:57,810 --> 00:01:05,220

an cupie, once the message is read from a Q on let's say Rabbit and Q or active Amcu, the message



13

00:01:05,220 --> 00:01:06,810

is deleted from the Q.



14

00:01:07,500 --> 00:01:11,400

Kafka uses a custom binary protocol or TCP.



15

00:01:11,640 --> 00:01:13,380

The keyword here is custom.



16

00:01:13,380 --> 00:01:19,860

What that means is that it is not a standard protocol which is in use by multiple products.



17

00:01:20,130 --> 00:01:23,840

This particular protocol is in use only by Kafka.



18

00:01:24,030 --> 00:01:31,170

On the other hand, AM Cupie is a standard protocol that is implemented by multiple messaging platforms



19

00:01:31,170 --> 00:01:33,780

such as active MQ and Rabbitt MQ.



20

00:01:34,470 --> 00:01:41,430

Although Kafka is a messaging platform, it does not have a concept of Q it supports only publish subscriber



21

00:01:41,430 --> 00:01:48,300

messaging pattern, whereas m QB based messaging platforms such as Rabbit and Q support both point to



22

00:01:48,300 --> 00:01:51,210

point and publish subscribe messaging patterns.



23

00:01:51,420 --> 00:01:53,730

COFCO does not support routing.



24

00:01:54,060 --> 00:02:00,390

You may use dynamic routing, but it is not available out of the box, on the other hand, and CUPIE



25

00:02:00,390 --> 00:02:02,970

has a very flexible routing mechanism.



26

00:02:02,970 --> 00:02:12,120

Recall that in the case of Rabbit Q we could create the exchanges of different types and then associate



27

00:02:12,540 --> 00:02:15,030

Qs with the exchanges with bindings.



28

00:02:15,390 --> 00:02:18,940

This kind of mechanism is not available on Kafka.



29

00:02:19,830 --> 00:02:26,910

So in other words, Kafka has no concept of exchanges clause binding or message priority Kafka consumers



30

00:02:27,180 --> 00:02:34,050

always pull messages from the broker by way of pulling consumers, subscribe for the messages and pull



31

00:02:34,050 --> 00:02:38,760

for specific duration and receive messages in batches.



32

00:02:38,910 --> 00:02:46,380

On the other hand, in Amcu based platforms, there is support for both push and pull models for receiving



33

00:02:46,380 --> 00:02:47,370

the messages.



34

00:02:47,820 --> 00:02:52,150

COFCO Bodiford guarantees message ordering within a partition.



35

00:02:52,650 --> 00:02:54,900

Let me explain this with an illustration.



36

00:02:55,210 --> 00:02:59,730

Let's say there is a topic that has two partitions and there are two consumers.



37

00:03:00,000 --> 00:03:05,550

Consumer A is attached to partition one and Consumer B is attached to partition two.



38

00:03:06,120 --> 00:03:13,140

For the sake of this discussion, let's assume that the producer is sending messages with key call to



39

00:03:13,140 --> 00:03:19,920

the customer Idy and Kazuma is receiving customer ID one, two, three messages and consumer bills,



40

00:03:19,920 --> 00:03:23,690

receiving the messages for consumer ID for five six.



41

00:03:24,030 --> 00:03:32,130

Now, what the guaranteed message ordering implies is that Consumer A will receive all of the messages



42

00:03:32,130 --> 00:03:36,020

for customer ID one, two, three in the order they were published.



43

00:03:36,390 --> 00:03:38,640

And same thing applies to consumer.



44

00:03:38,880 --> 00:03:45,960

Consumer B will receive all of the messages for customer three, four, five, six in the order they



45

00:03:45,960 --> 00:03:46,710

were published.



46

00:03:47,110 --> 00:03:55,920

This is an extremely important feature of Kafka as it will allow you to build systems that require a



47

00:03:56,250 --> 00:03:57,390

message ordering.



48

00:03:57,780 --> 00:04:03,780

Important thing to keep in mind is that AQAP based messaging platforms do not support message ordering.



49

00:04:04,260 --> 00:04:09,920

So in case of Arabic, Amcu message in AQ may be read by multiple consumers.



50

00:04:10,110 --> 00:04:16,830

Each of these consumers process the received message independent of the other consumers.



51

00:04:17,250 --> 00:04:23,520

As a result, the order in which these messages get processed is not guaranteed, whereas in the case



52

00:04:23,520 --> 00:04:27,790

of Kafka, there is only one consumer for partition.



53

00:04:28,200 --> 00:04:36,210

As a result, the order in which the messages get processed is the same as the order in which the messages



54

00:04:36,210 --> 00:04:36,990

were published.



55

00:04:37,440 --> 00:04:39,960

Time to go over the key points from this lesson.



56

00:04:39,960 --> 00:04:48,150

When the messages are read by the consumer from a topic, the messages are not deleted from the topic.



57

00:04:48,150 --> 00:04:48,990

They are retained.



58

00:04:48,990 --> 00:04:57,690

Kafka does not support the cupie concepts such as Kyuss exchanges, routing priorities, etc. Kafka



59

00:04:57,690 --> 00:05:00,540

uses a custom binary TCP protocol.



60

00:05:00,570 --> 00:05:06,600

What that means is that there is no other platform that is using the Cafcass protocol.



61

00:05:06,600 --> 00:05:10,710

Cafcass supports only pops up and full based messages.



62

00:05:10,950 --> 00:05:15,030

Kafka guarantees message order within a partition.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13 Microservices and Kafka\008 Exercise _ Messaging for Microservices.en.srt -->

1

00:00:00,180 --> 00:00:07,320

Cough, cough, or micro services in this lecture underscores the common use cases for Kafka, and then



2

00:00:07,320 --> 00:00:09,570

we'll have a fun activity in this fun activity.



3

00:00:09,900 --> 00:00:12,420

I'm going to ask you scenario based questions.



4

00:00:12,720 --> 00:00:19,630

And you, as the designer of micro services, will decide whether you would use Kafka or Rabbit MQ.



5

00:00:19,830 --> 00:00:25,560

I'll start this lesson by revisiting the question I asked you in the previous lecture.



6

00:00:26,130 --> 00:00:29,040

Which one of these would you use for micro services?



7

00:00:30,400 --> 00:00:39,130

It all depends on the use case for your microcircuits, Kafka and Abe platforms have their own strengths



8

00:00:39,130 --> 00:00:40,360

as well as features.



9

00:00:40,690 --> 00:00:48,190

And depending on the use case, you may select Kafka or MGP or in fact, you may even select both Kafka



10

00:00:48,280 --> 00:00:49,410

and Cupie.



11

00:00:49,800 --> 00:00:51,820

It all depends on your use case.



12

00:00:52,690 --> 00:00:56,650

Next, I'll discuss some of the common use cases for Kafka.



13

00:00:56,860 --> 00:01:04,540

Kafka was built ground up for large scale messaging applications, for example, and Iot application



14

00:01:04,540 --> 00:01:08,650

that is consuming tens of thousands of messages per second.



15

00:01:09,310 --> 00:01:16,090

Kafka provides strong durability for the messages, and it offers unlimited scaling by way of topics



16

00:01:16,090 --> 00:01:17,080

and partitions.



17

00:01:17,590 --> 00:01:25,100

So if you Microsoft servers, has a need for ingesting a large number of events per second than Kafka.



18

00:01:25,120 --> 00:01:28,720

Maybe a better choice over AM cupie based platforms.



19

00:01:29,320 --> 00:01:35,140

Kafka is commonly used for website tracking, also known as the Clickstream Analysis.



20

00:01:35,290 --> 00:01:41,350

Activities on the website are set up in such a way that every time a user takes an action, such as



21

00:01:41,350 --> 00:01:47,590

clicking a button or clicking on a link on the website, leads to the generation of an event which is



22

00:01:47,590 --> 00:01:49,230

ingested by Kafka.



23

00:01:49,360 --> 00:01:54,950

The data is then pushed into analytics platforms such as Hadoop for further processing.



24

00:01:55,600 --> 00:01:58,740

In fact, this was the original use case for Kafka.



25

00:01:59,290 --> 00:02:07,570

Another common use case for Kafka is for log aggregation and stream processing log even from applications



26

00:02:07,570 --> 00:02:14,020

and servers may be ingested by Kafka for real time, even processing the real time.



27

00:02:14,020 --> 00:02:21,640

Even processing may lead to the identification of anomalies or issues that may then be used for raising



28

00:02:21,640 --> 00:02:26,020

alerts for the operations team are discussed even sourcing.



29

00:02:26,020 --> 00:02:33,370

In one of the earlier lectures, Kafka is a natural in store for building, even sourcing.



30

00:02:33,910 --> 00:02:38,350

It provides a time ordered sequence of events or records.



31

00:02:38,710 --> 00:02:46,210

And these events are retained in Kafka for a long duration of time and may be replayed by the consumers.



32

00:02:46,930 --> 00:02:53,620

Kafka provides an out of the box comic log capability for any application or might or service.



33

00:02:53,620 --> 00:03:00,760

It provides this comic log for a distributed system wherein data is replicated between nodes and in



34

00:03:00,760 --> 00:03:06,410

case of a node failure, the consumers are not impacted and transparent to the consumer.



35

00:03:06,730 --> 00:03:12,730

The field nodes recover by getting the data from the available nodes.



36

00:03:12,730 --> 00:03:17,410

If you need to commit logs, I suggest that you carry out your own research on the Internet.



37

00:03:17,830 --> 00:03:21,340

In the rest of this lecture, I'm going to ask you some questions.



38

00:03:21,700 --> 00:03:28,000

These questions will consist of a scenario and the messaging requirements for the scenario.



39

00:03:28,390 --> 00:03:34,000

And based on these requirements, you will need to decide your messaging platform.



40

00:03:34,180 --> 00:03:37,630

You will pick up either Casca or Rabbitt MQ.



41

00:03:38,440 --> 00:03:40,240

So here is scenario number one.



42

00:03:40,240 --> 00:03:46,540

Microsoft needs to talk to Microsoft Visby or request response messaging Pappan.



43

00:03:46,870 --> 00:03:52,360

Let's assume that the number of messages is less than thousand per second.



44

00:03:52,690 --> 00:03:54,250

Which one would you go for?



45

00:03:54,400 --> 00:03:55,350

COFCO or.



46

00:03:55,540 --> 00:03:56,020

Thank you.



47

00:03:56,230 --> 00:03:58,810

I will go for the Rabbit MQ.



48

00:03:59,170 --> 00:04:00,520

A couple of quick reasons.



49

00:04:00,520 --> 00:04:02,020

The message volume is not high.



50

00:04:02,350 --> 00:04:06,970

IQ is better suited for request response compared to a topic.



51

00:04:07,090 --> 00:04:11,020

So Robert MQ will make more sense in this scenario.



52

00:04:11,500 --> 00:04:18,280

Scenario number two involves a Microsoft Office that is publishing a message to a topic which is subscribed



53

00:04:18,280 --> 00:04:19,900

to by multiple other.



54

00:04:19,900 --> 00:04:28,070

Microsoft says the volume of messages is going to be a maximum of fifty events per second, and this



55

00:04:28,090 --> 00:04:33,130

even load is not expected to change in the next three years.



56

00:04:33,340 --> 00:04:36,490

What would you go for, Robert MQ or Kafka?



57

00:04:37,760 --> 00:04:42,990

I would go for Rabbitt Amcu, and the reason is that the message volume is quite low.



58

00:04:43,610 --> 00:04:46,870

No, let's revisit the scenario with one change.



59

00:04:46,880 --> 00:04:53,420

Let's say the message volume is 50000 events per second and this message volume is expected to grow



60

00:04:53,600 --> 00:04:54,290

over time.



61

00:04:54,530 --> 00:04:55,820

Now what would you go for?



62

00:04:56,780 --> 00:05:04,450

Well, in this case, it's a clear case of large scale messaging application, so I would go for Kafka



63

00:05:05,240 --> 00:05:06,090

next scenario.



64

00:05:06,260 --> 00:05:13,440

We have a metro service which is publishing events to a topic, let's say, roughly 20 events per second.



65

00:05:14,060 --> 00:05:18,630

There is another microcircuits service which is receiving these messages or events.



66

00:05:19,450 --> 00:05:27,050

The requirement here is to carry out Real-Time analysis of the events to generate alerts.



67

00:05:27,470 --> 00:05:28,670

Which one would you go for?



68

00:05:28,760 --> 00:05:29,890

Kafka or.



69

00:05:29,900 --> 00:05:30,470

Abbi, thank you.



70

00:05:30,950 --> 00:05:36,230

Well, I will go with Kafka because there are many tools available for Real-Time.



71

00:05:36,230 --> 00:05:38,230

Analysis of the even streams.



72

00:05:38,660 --> 00:05:45,760

These tools are highly scalable and can take care of analyzing tens of thousands of events per second.



73

00:05:46,100 --> 00:05:49,830

Examples of such tools are Apache, Spark and Stone.



74

00:05:50,150 --> 00:05:56,960

Please do your own research to understand how these tools work for realtime analysis of the Cafcass



75

00:05:56,960 --> 00:05:59,280

streams in this next scenario.



76

00:05:59,360 --> 00:06:05,630

Let's say you're designing a micro service that needs to provide standard based messaging interface



77

00:06:06,020 --> 00:06:12,610

and the consumers of the service are already used to using Java jammers and prefer simplicity.



78

00:06:12,890 --> 00:06:15,240

Which one would you go for in the scenario?



79

00:06:15,500 --> 00:06:17,290

I would go for Rabbitt MQ.



80

00:06:17,480 --> 00:06:25,970

It's an M cupie standard based implementation and may be replaced by any other M QB implementation,



81

00:06:25,970 --> 00:06:28,960

such as active MQ compared to Kafka.



82

00:06:29,270 --> 00:06:33,080

It is much more simpler to set up and manage.



83

00:06:34,110 --> 00:06:40,350

In this next scenario, let's assume that the messaging requirements for your micro services is such



84

00:06:40,350 --> 00:06:44,310

that it can be fulfilled by by both the messaging platforms.



85

00:06:44,310 --> 00:06:49,210

So you approach your team and discuss which messaging platform should be used.



86

00:06:49,230 --> 00:06:55,690

Your developers have indicated that they would like to have full control on routing of even data.



87

00:06:55,800 --> 00:07:00,120

Now, given this assumption, which one would you prefer?



88

00:07:00,120 --> 00:07:01,340

Kafka or Rabbit?



89

00:07:01,350 --> 00:07:02,330

MQ Why?



90

00:07:02,550 --> 00:07:04,290

I will go with Rabbit Amcu.



91

00:07:04,740 --> 00:07:11,670

And the reason is because Rabbit Amcu provides full control on message routing to the developers.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000001.srt -->

1
00:00:00,390 --> 00:00:18,390
Kafka là một nền tảng phát trực tuyến cực kỳ phổ biến với các nhà thiết kế và phát triển dịch vụ vi mô, nhiều tính năng của Kavkaz trùng lặp với các khả năng được cung cấp bởi các nền tảng nhắn tin khác như Rabbit MQ và Active MQ.

2
00:00:18,420 --> 00:00:31,170
Nhà thiết kế dịch vụ cần đưa ra quyết định về việc nên sử dụng tính năng phát trực tuyến Cafcass hay sử dụng nhà môi giới nhắn tin như Rabbitt MQ hoặc MQ hoạt động cho các dịch vụ vi mô của họ.

3
00:00:31,260 --> 00:00:44,430
Để trả lời câu hỏi này, người thiết kế dịch vụ vi mô phải hiểu khả năng phát trực tuyến Cafcass so với khả năng được cung cấp bởi các nhà môi giới tin nhắn khác này.

4
00:00:44,850 --> 00:01:06,550
Trong phần trước, bạn tìm hiểu về Rabbitt MQ, đây là một triển khai của giao thức MQ B.  Trong phần bạn tìm hiểu về phát trực tuyến Cafcass và tôi hy vọng rằng đến cuối phần này, bạn sẽ có thể đưa ra quyết định về việc nên sử dụng Kafka hay Rabbit MQ cho các dịch vụ vi mô của mình.

5
00:01:06,810 --> 00:01:15,870
Chúng ta hãy đi qua các mục tiêu học tập cho phần này.  Bạn sẽ học các khái niệm bạn học.  Sự khác biệt giữa Kafka và MGP sẽ được thảo luận.

6
00:01:15,870 --> 00:01:26,100
Nhiều trường hợp sử dụng dịch vụ vi mô trong đó Kafka phù hợp hơn nhiều so với cupie và bạn sẽ thấy Kafka hoạt động.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000002.srt -->

1
00:00:00,390 --> 00:00:06,930
COFCO, từng người một, giới thiệu nhanh về Kafka.  Tôi sẽ bắt đầu bài học bằng việc trả lời câu hỏi Kafka là gì?

2
00:00:07,410 --> 00:00:18,910
Sau đó, tôi sẽ thảo luận về cách LinkedIn sử dụng Kafka, sau đó sẽ xem xét các khả năng cốt lõi của Kafka.  Xin lưu ý rằng đây là tổng quan cấp cao về Kafka.

3
00:00:19,050 --> 00:00:28,710
Tôi sẽ đề cập đến các khái niệm về Kafka trong các bài giảng sau.  Kafka là một nền tảng phát trực tuyến đồng đều, phân tán mã nguồn mở, hiệu suất cao.

4
00:00:28,890 --> 00:00:39,380
Kafka có thể xử lý tới hai triệu tin nhắn mỗi giây.  Cụm Kafka bao gồm nhiều nút hoặc máy trải rộng trên một mạng rộng.

5
00:00:39,600 --> 00:00:52,430
Ngay cả tính năng phát trực tuyến ở đây cũng đề cập đến sự phổ biến của mô hình nhắn tin ở mức cao.  Cụm Kafka thể hiện khả năng nhắn tin hấp dẫn cho nhà sản xuất và người tiêu dùng.

6
00:00:52,440 --> 00:01:01,110
Bây giờ, bạn có thể nói rằng nền tảng này trông rất giống với một nền tảng nhắn tin thông thường và bạn đã đúng, nhưng điểm tương đồng chỉ dừng lại ở đó.

7
00:01:01,110 --> 00:01:09,930
Cụm Kafka có thể bao gồm hàng nghìn máy trải rộng trên một mạng rộng.  Chúng có thể là hàng chục ngàn chủ đề.

8
00:01:10,050 --> 00:01:17,340
Dữ liệu tin nhắn trong chủ đề được trải rộng trên nhiều phân vùng.  Hãy coi việc phân vùng như một cú sốc.

9
00:01:17,940 --> 00:01:28,580
Dữ liệu và phân vùng được sao chép trên nhiều máy trong cụm Kafka.  Kết quả là cụm Kafka có khả năng chịu đựng cao.

10
00:01:29,280 --> 00:01:44,190
Kafka được phát triển tại LinkedIn và Open Source vào năm 2011. Để cho bạn biết về cách LinkedIn đang sử dụng Kafka, tôi sẽ chia sẻ một số con số mà tôi đã chọn được từ một blog được viết bởi Arlington, Virginia.

11
00:01:44,190 --> 00:01:55,380
Năm 2019, Linden đã xử lý bảy nghìn tỷ tin nhắn mỗi ngày trên một trăm cụm Kafka có 4000 nhà môi giới hoặc máy móc.

12
00:01:55,500 --> 00:02:05,960
Họ có một trăm nghìn chủ đề được chia thành bảy triệu người tham gia.  Vì vậy đây chính là loại thang đo mà Kafka đã xây dựng nền tảng cho nó.

13
00:02:06,940 --> 00:02:15,590
Hãy cùng điểm qua các khả năng cốt lõi của Kafka.  Nó cung cấp thông lượng nhắn tin cao với độ trễ thấp tới hai mili giây.

14
00:02:16,180 --> 00:02:38,080
Nó có khả năng mở rộng cao.  Bạn có thể dễ dàng thêm nhiều máy hoặc nút môi giới vào cụm để mở rộng quy mô theo yêu cầu của mình. Cụm này có thể xử lý hàng nghìn tỷ tin nhắn mỗi ngày và có thể xử lý hàng petabyte dữ liệu, kho lưu trữ cụm Kafka, tất cả dữ liệu nhắn tin và bộ lưu trữ liên tục.

15
00:02:38,080 --> 00:02:50,690
Vì vậy tin nhắn không bị mất do lỗi máy chủ.  Nó có tính sẵn sàng cao, dữ liệu được sao chép và lỗi của các nút bị hỏng không ảnh hưởng đến nhà sản xuất và người tiêu dùng.

16
00:02:50,920 --> 00:03:04,780
Tôi khuyên bạn nên truy cập Kafka, viết Apache DOT hoặc để đọc thêm về các khía cạnh này của Kafka cũng như để hiểu rõ hơn về cách ngành sử dụng Kafka cho các trường hợp sử dụng cụ thể của họ.

17
00:03:05,660 --> 00:03:30,590
Trong bài học này, tôi đã cung cấp cho bạn một cái nhìn tổng quan ở mức độ rất cao về GAFCON trong bài giảng tiếp theo?  Tôi sẽ trình bày các khái niệm về Kafka, sau đó là trải nghiệm thực tế với Kafka, trong đó bạn sẽ dùng thử Kafka từ Java và sau đó tôi sẽ so sánh Kaw Covid Amcu, sau đó là Microsoft cho biết Các trường hợp sử dụng cho Kafka nếu bạn đã có kinh nghiệm với Kafka.

18
00:03:30,800 --> 00:03:44,270
Vui lòng bỏ qua các bài giảng về khái niệm Kafka, nhưng vui lòng theo dõi các bài giảng về trải nghiệm thực tế với Kafka vì anh ấy sẽ tạo ra một cụm Kafka mà chúng ta sẽ sử dụng trong các bài giảng sau.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000003.srt -->

1
00:00:00,660 --> 00:00:09,790
Các khái niệm, khi kết thúc bài giảng này, bạn sẽ có thể giải thích các thuật ngữ phổ biến được sử dụng trong bối cảnh cụm Kafka.

2
00:00:10,140 --> 00:00:20,470
Xin lưu ý, mục đích của tôi ở đây là cung cấp cho bạn cái nhìn tổng quan ở cấp độ cao về các khái niệm Kafka thiết yếu nếu bạn muốn tìm hiểu thêm về những khái niệm này.

3
00:00:20,700 --> 00:00:30,750
Tôi đề nghị bạn nên thực hiện nghiên cứu của riêng bạn.  Một cụm Kafka bao gồm một hoặc cả hai phần giới thiệu ghi chú của người môi giới.

4
00:00:30,750 --> 00:00:40,740
Nên sử dụng tối thiểu ba nút môi giới khi một chủ đề được xác định trên cụm.  Chủ đề đó được nhân rộng trên tất cả các nhà môi giới.

5
00:00:40,980 --> 00:00:48,960
Dữ liệu chủ đề được phân vùng thành nhiều phân vùng, được sao chép trên các nút bị hỏng.

6
00:00:49,170 --> 00:01:03,280
Nhà sản xuất kết nối với cụm và xuất bản một thông báo.  Người tiêu dùng kết nối với cụm và lấy dữ liệu được đẩy vào các phân vùng cho chủ đề cụ thể mà họ đã đăng ký.

7
00:01:03,510 --> 00:01:19,690
Hãy đi sâu hơn vào chi tiết về cách hoạt động của cụm.  Khi một thông báo được nhà sản xuất xuất bản, thông báo đó sẽ được thêm vào phân vùng và phân vùng sau đó được sao chép trên nhiều nhà môi giới.

8
00:01:20,160 --> 00:01:31,730
Vì vậy, trong hình minh họa này, giả sử chủ đề có ba phân vùng và tất cả ba phân vùng này đều được sao chép trên ba nhà môi giới.

9
00:01:32,220 --> 00:01:39,300
Chúng tôi có bản sao, một ở Broca, một bản sao và môi giới hai và bản sao ba ở Broecker ba.

10
00:01:39,870 --> 00:02:13,070
Vì phân vùng được sao chép qua ba nhà môi giới nên hệ số sao chép được đặt là ba.  Nếu chúng tôi được định cấu hình cụm này để chỉ sao chép phân vùng trên, giả sử, hai nhà môi giới, thì hệ số sao chép sẽ được đặt thành lợi ích của việc sao chép này là nếu có lỗi của một trong các nhà môi giới, thì dữ liệu trong  chủ đề sẽ vẫn có sẵn và người tiêu dùng sẽ không bị ảnh hưởng do lỗi này.

11
00:02:13,320 --> 00:02:26,070
Vì vậy, ý tưởng là hệ số ứng dụng càng cao thì cụm của bạn càng có khả năng chịu lỗi cao hơn.  Nhưng rõ ràng là bạn sẽ cần phân bổ nhiều tài nguyên hơn cho cụm của mình bất kỳ lúc nào.

12
00:02:26,610 --> 00:02:38,660
Mỗi phân vùng có một nút bị hỏng được chỉ định làm nút dẫn đầu và nút bị hỏng nhỏ này chịu trách nhiệm cho tất cả các thao tác đọc và ghi vào phân vùng đó.

13
00:02:39,300 --> 00:03:10,340
Vì vậy, trong hình minh họa cho phân vùng một này, giả sử nút dẫn đầu là nút Broca.  Trong trường hợp đó, bất cứ khi nào một thông báo sẽ được xuất bản lên chủ đề A và nếu dữ liệu được thêm vào phân vùng một thì nhà môi giới sẽ không chịu trách nhiệm sao chép dữ liệu cho phân vùng một sang các nút môi giới khác trong cụm trong trường hợp thất bại  của nút lãnh đạo, một trong các nút môi giới có sẵn khác sẽ đảm nhận vai trò lãnh đạo cho phân vùng đó.

14
00:03:10,380 --> 00:03:17,880
Tất cả điều này xảy ra một cách bí mật và minh bạch đối với người sản xuất cũng như người tiêu dùng thông điệp.

15
00:03:18,630 --> 00:03:27,810
Dữ liệu tin nhắn là phân vùng trên tin nhắn, ví dụ:  khóa tin nhắn này được nhà sản xuất cung cấp như một phần của việc xuất bản tin nhắn.

16
00:03:28,440 --> 00:03:35,880
Phím tin nhắn là tùy chọn.  Vì vậy, hãy nói về tình huống trong đó nhà sản xuất cung cấp khóa thông báo.

17
00:03:36,270 --> 00:03:57,480
Giả sử nhà sản xuất xuất bản một thông báo cho ID khách hàng một, hai, ba làm khóa.  Trong trường hợp đó, nhà môi giới tính toán giá trị băm cho khóa do nhà sản xuất cung cấp, sau đó nhà môi giới sử dụng giá trị băm để xác định phân vùng mà dữ liệu tin nhắn sẽ đi đến.

18
00:03:57,510 --> 00:04:09,480
Vì vậy, trong trường hợp này, Brocco đã chuyển tin nhắn sang phân vùng một.  Giả sử nhà sản xuất hiện xuất bản một tin nhắn có cuộc gọi chính tới khách hàng bảy tám chín.

19
00:04:09,700 --> 00:04:19,950
Một lần nữa, nhà môi giới sẽ tính toán giá trị băm và có thể quyết định đẩy thông báo này có khóa bằng Cosmati bảy, tám, chín trong phân vùng số hai.

20
00:04:19,950 --> 00:04:27,380
Và điều này có nghĩa là mỗi khi sử dụng cùng một khóa, tin nhắn sẽ được đẩy vào cùng một phân vùng.

21
00:04:27,390 --> 00:04:37,560
Vì vậy, giả sử một thông báo khác được nhà sản xuất xuất bản có khóa bằng Cosmati, một, hai, ba, thì thông báo mới đó sẽ kết thúc ở phân vùng số một.

22
00:04:37,650 --> 00:04:48,780
Bây giờ hãy nói về một tình huống trong đó nhà sản xuất không cung cấp khóa.  Trong trường hợp đó, nhà môi giới thực hiện việc phân chia phân vùng theo kiểu Round-Robin.

23
00:04:48,780 --> 00:04:55,410
Vậy điều đó có nghĩa là tin nhắn đầu tiên sẽ nằm trong phân vùng.  Một giây sẽ kết thúc ở phân vùng số hai.

24
00:04:55,560 --> 00:05:13,250
Thứ ba sẽ kết thúc ở phân vùng số ba.  Và tin nhắn thứ tư sẽ lại kết thúc.  Phân vùng số một, các hệ thống nhắn tin thông thường không giữ lại thứ tự gửi tin nhắn, nhưng trong trường hợp của Kafka, các tin nhắn được sắp xếp trong một phân vùng.

25
00:05:13,460 --> 00:05:23,940
Chìa khóa ở đây là phải hiểu rằng thứ tự này chỉ được đảm bảo trong một phân vùng.  Nói cách khác điều này là các tin nhắn không được sắp xếp theo thứ tự trên các phân vùng.

26
00:05:23,990 --> 00:05:38,510
Vì vậy, đây là một tình huống trong đó người tiêu dùng đang đọc tin nhắn từ phân vùng số hai.  Vì vậy, người tiêu dùng này sẽ có sự đảm bảo rằng tất cả các tin nhắn sẽ được nó nhận theo thứ tự chúng được xuất bản.

27
00:05:38,660 --> 00:05:50,750
Đơn đặt hàng và sự đảm bảo này là một lý do để chọn Kafka thay vì nền tảng nhắn tin thông thường.  Mỗi tin nhắn trong một phân vùng là một dấu hiệu được bù đắp trong phân vùng đó.

28
00:05:51,140 --> 00:06:03,180
Hãy để tôi giải thích điều này bằng một ví dụ.  Giả sử nhà sản xuất xuất bản một thông báo có khóa bằng một, hai, ba và nhà môi giới quyết định đẩy thông báo này vào phân vùng số một.

29
00:06:03,980 --> 00:06:10,270
Vì vậy, đây là tin nhắn đầu tiên và phân vùng số một.  Vì vậy, phần bù cho thông báo này được đặt thành 0.

30
00:06:10,700 --> 00:06:18,090
Giả sử một tin nhắn khác có giá trị bằng một, hai, ba được xuất bản.  Tin nhắn mới này sẽ có giá trị chênh lệch bằng một.

31
00:06:18,440 --> 00:06:27,310
Bây giờ nhà sản xuất xuất bản một tin nhắn có khóa bằng bốn, năm, sáu.  Bây giờ, tin nhắn này có thể nằm ở phân vùng số hai.

32
00:06:27,650 --> 00:06:47,140
Và vì đây là thông báo đầu tiên và phân vùng số hai nên nó sẽ có giá trị chênh lệch bằng 0.  Một tin nhắn khác có khóa bằng bốn, năm sáu khi được nhà sản xuất xuất bản sẽ kết thúc ở phân vùng số hai với phần bù bằng một ồ, giả sử các tin nhắn tiếp theo có khóa bằng một, hai, ba.

33
00:06:47,420 --> 00:07:03,430
Trong trường hợp đó, tin nhắn sẽ kết thúc ở phân vùng số một, với offset bằng hai.  Tiếp theo, giả sử nhà sản xuất xuất bản một thông báo có khóa bằng sáu, bảy, tám và nhà môi giới quyết định đẩy nó và phân vùng số ba.

34
00:07:03,480 --> 00:07:09,650
Bây giờ, vì đây là thông báo đầu tiên và phân vùng số ba nên nó sẽ được gán và offset bằng 0.

35
00:07:10,690 --> 00:07:24,730
Cụm Kafka cho phép tối đa một hành động bảo vệ người tiêu dùng.  Vì vậy, trong hình minh họa này, chúng ta có người tiêu dùng nhận tin nhắn từ Phân vùng một và Người tiêu dùng B nhận tin nhắn từ phân vùng tới.

36
00:07:25,330 --> 00:07:38,390
Lý do cho điều này là với một người tiêu dùng duy nhất, thứ tự của các tin nhắn được đảm bảo.  Cụm Kafka duy trì phần bù hiện tại của tin nhắn đã được người tiêu dùng đọc.

37
00:07:38,830 --> 00:07:49,270
Vì vậy, ở đây trong bảng này, bạn sẽ thấy rằng người dùng đang đọc từ phân vùng một và khi có thông báo đến, giá trị offset được đặt thành 0.

38
00:07:49,270 --> 00:08:09,670
Người tiêu dùng A đã đọc tin nhắn khi có tin nhắn mới đến, phần bù hiện tại thay đổi cho người tiêu dùng và người tiêu dùng B bằng cách duy trì phần bù hiện tại trên cơ sở một phần người tiêu dùng, Kafka có thể tránh gửi các tin nhắn trùng lặp đến tin nhắn của người tiêu dùng đọc bằng Kafka hoặc không phá hủy.

39
00:08:09,680 --> 00:08:22,810
Đó là khi người tiêu dùng đọc tin nhắn từ chủ đề.  Tin nhắn không bị xóa, chỉ phần bù được cập nhật và người tiêu dùng có thể đặt lại phần bù bất cứ lúc nào.

40
00:08:23,140 --> 00:08:35,940
Và điều đó có nghĩa là bằng cách đặt lại phần bù, người tiêu dùng có thể thay thế nhật ký.  Tin nhắn từ bất kỳ tin nhắn bù đắp nào về chủ đề này sẽ không được lưu giữ vô thời hạn.

41
00:08:36,250 --> 00:08:47,740
Có một khoảng thời gian lưu giữ liên quan đến chủ đề về cơ bản xác định thời gian tồn tại của thư sau khi hết thời gian lưu giữ.

42
00:08:47,740 --> 00:09:06,210
Đối với tin nhắn, tin nhắn sẽ tự động bị xóa khỏi chủ đề.  Mặc dù COFCO duy trì khoản bù đắp hiện tại trên cơ sở người tiêu dùng một phần nhưng người tiêu dùng cũng có tùy chọn tự quản lý khoản bù đắp bên ngoài cụm.

43
00:09:07,100 --> 00:09:16,180
Trong các hệ thống nhắn tin, thông thường có nhiều trường hợp người tiêu dùng đọc tin nhắn của một tín hiệu chung.

44
00:09:16,460 --> 00:09:24,740
Điều này được thực hiện để mang lại hiệu suất cao và thông lượng cao trong COFCO.  Nó có thể được thực hiện bằng cách phân nhóm người tiêu dùng.

45
00:09:24,740 --> 00:09:32,120
Và ý tưởng là mỗi tin nhắn trong chủ đề chỉ được nhận bởi một người tiêu dùng trong nhóm.

46
00:09:32,180 --> 00:09:50,840
Việc phân nhóm người tiêu dùng này được thực hiện bằng ý tưởng nhóm.  Vì vậy, ở đây trong hình minh họa này, chúng ta có ba người tiêu dùng và cả ba người tiêu dùng này được chỉ định vào một nhóm chung và COFCO sẽ đảm bảo rằng mỗi tin nhắn chỉ được một trong số những người tiêu dùng nhận.

47
00:09:51,020 --> 00:10:04,860
Do đó sẽ không có bất kỳ sự trùng lặp nào về thông báo vì COFCO chỉ cho phép một người tiêu dùng trên mỗi phân vùng, số lượng người tiêu dùng tối đa trong một nhóm bằng số lượng người tham gia.

48
00:10:05,060 --> 00:10:14,120
Vì vậy, trong hình minh họa này, chúng ta có một chủ đề ở đây có ba người tham gia.  Vì vậy, nhiều nhất chúng ta có thể có ba người tiêu dùng trong một nhóm.

49
00:10:14,310 --> 00:10:27,320
Nếu người tiêu dùng thứ tư được thêm vào, nó sẽ chuyển sang trạng thái màu đỏ, có nghĩa là nó sẽ không nhận được bất kỳ tin nhắn nào cho đến khi một trong những người tiêu dùng chết hoặc ngừng nghe tin nhắn.

50
00:10:27,650 --> 00:10:42,300
Chúng ta hãy điểm qua những điểm chính từ bài học này.  Kafka đọc, không phá hủy, thông báo được viết trong chủ đề Kafka, phân vùng cho khoảng thời gian lưu giữ được xác định về chủ đề.

51
00:10:42,430 --> 00:10:53,290
Các chủ đề được chia thành các phân vùng.  Nhà sản xuất có thể chỉ định khóa tin nhắn để xác định phân vùng mà dữ liệu tin nhắn sẽ được thêm vào.

52
00:10:53,290 --> 00:11:08,110
Kafka duy trì phần bù của tin nhắn cuối cùng trên cơ sở người tiêu dùng, người tiêu dùng có thể đặt lại phần bù này.  Người tiêu dùng có thể tự mình duy trì khoản bù đắp.

53
00:11:08,140 --> 00:11:21,820
Người tiêu dùng có thể đọc tin nhắn từ một chủ đề dưới dạng nhóm bằng ID nhóm.  Trong bài giảng tiếp theo, chúng ta sẽ tạo một cụm Kafka và bạn sẽ thấy tất cả các khái niệm này đang hoạt động.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000004.srt -->

1
00:00:00,510 --> 00:00:09,300
Cụm thiết lập trong bài giảng này.  Tôi sẽ hướng dẫn bạn các bước để tạo cụm COFCO miễn phí trên đám mây.

2
00:00:09,330 --> 00:00:19,290
Sau đó tôi sẽ hướng dẫn bạn qua bảng điều khiển của COFCO.  Cluster cũng sẽ thử các tính năng nhắn tin trong trình duyệt có sẵn trên bảng điều khiển.

3
00:00:19,320 --> 00:00:30,650
Tôi khuyên bạn nên làm theo để đến cuối bài giảng này, bạn sẽ có phiên bản cụm bánh cà phê của riêng mình để tạo cụm miễn phí trên đám mây.

4
00:00:30,690 --> 00:00:39,300
Đi tới w w w dot cloud Kafka dot com.  Hãy chú ý đến cách viết ở đây vì nó hơi khó hiểu.

5
00:00:40,710 --> 00:00:50,880
Nhấp vào đăng nhập và sau đó bạn có thể đăng nhập bằng GitHub hoặc tài khoản Google của mình hoặc bạn có thể tạo tài khoản bằng cách nhấp vào đăng ký.

6
00:00:51,090 --> 00:00:57,180
Này, bạn cung cấp địa chỉ email và bạn sẽ nhận được email, hãy làm theo hướng dẫn để tạo tài khoản.

7
00:00:57,480 --> 00:01:05,280
Tôi đã có tài khoản nên tôi sẽ tiếp tục và đăng nhập. Tôi đã tạo một phiên bản để thử nghiệm.

8
00:01:05,580 --> 00:01:15,960
Để tạo phiên bản của riêng bạn.  Bấm vào tạo phiên bản mới.  Cung cấp tên phiên bản, tuân theo gói miễn phí và sau đó nhấp vào Chọn khu vực trong Chọn khu vực.

9
00:01:16,230 --> 00:01:27,570
Chọn khu vực gần bạn nhất và nhấp vào đánh giá rồi nhấp vào Tạo phiên bản.  Sẽ mất vài phút để tạo một phiên bản cho bạn.

10
00:01:27,720 --> 00:01:36,060
Sau khi tạo phiên bản, bạn sẽ thấy phiên bản của mình trong danh sách phiên bản.  Bấm vào ví dụ.

11
00:01:36,190 --> 00:01:47,040
Vì vậy, đây là tất cả các chi tiết.  Ví dụ: nhấp vào liên kết tải xuống.  Thao tác này sẽ tải xuống thông tin xác thực mà bạn cần để kết nối với COFCO từ mã Java.

12
00:01:47,250 --> 00:01:53,640
Chúng ta sẽ sử dụng nó sau.  Đây là tên máy chủ cho cụm bánh cà phê của bạn, tên người dùng và sau đó là mật khẩu.

13
00:01:53,730 --> 00:02:04,620
Tất cả thông tin này có trong tệp đã được tải xuống kèm theo liên kết tải xuống tại đây.  Xin lưu ý rằng một số tùy chọn ở đây sẽ không có sẵn trong tài khoản miễn phí.

14
00:02:04,710 --> 00:02:16,920
Ví dụ: như bạn có thể thấy ở đây, cấu hình Kafka chỉ khả dụng trong gói dành riêng.  Tương tự, bạn sẽ không thể xem thông tin Ma trận, nhưng chúng tôi sẽ không đi sâu vào tất cả các chi tiết này.

15
00:02:16,920 --> 00:02:24,570
Vì vậy, việc không cung cấp thông tin này cho chúng tôi là điều bình thường.  Tiếp theo, hãy kiểm tra các chủ đề.  Bấm vào các chủ đề.

16
00:02:24,750 --> 00:02:34,050
Bạn sẽ thấy có một chủ đề mặc định được tạo.  Ví dụ: tên chủ đề là tên người dùng Dasch Default của bạn.

17
00:02:34,350 --> 00:02:42,560
Có năm phân vùng cho chủ đề này và mỗi phân vùng được sao chép qua ba byte lưu giữ nút.

18
00:02:42,570 --> 00:02:51,480
Đây là lượng dữ liệu tin nhắn tối đa sẽ được giữ lại trong chủ đề.  Trong trường hợp bạn vượt quá số byte lưu giữ này.

19
00:02:51,480 --> 00:02:58,920
Không, một số tin nhắn trước đó của bạn sẽ bị cắt bớt và có thể có thêm các hạn chế đối với ba phiên bản.

20
00:02:58,920 --> 00:03:09,840
Vì vậy, chỉ cần nhận thức được nó.  Đây không phải là phiên bản lưới sản xuất mà chúng tôi đang sử dụng.  Mili giây lưu giữ là khoảng thời gian mà tin nhắn sẽ được giữ lại.

21
00:03:10,230 --> 00:03:21,420
Điều này có nghĩa là 28 ngày và bạn thực sự có thể thay đổi những con số này.  Ví dụ: tôi có thể thay đổi giá trị này thành giả sử là 5000 và chỉ cần nhấp vào đối tượng.

22
00:03:21,420 --> 00:03:33,810
Tôi muốn cập nhật, nhưng nếu bạn quan tâm đến việc thử nghiệm, hãy tiếp tục và dùng thử.  Tiếp theo, tôi sẽ chỉ cho bạn cách bạn có thể kiểm tra người tiêu dùng và nhà sản xuất trong trình duyệt.

23
00:03:33,810 --> 00:03:41,850
Bấm vào trình duyệt ở đây.  Bạn cung cấp tên chủ đề.  Bạn có thể sao chép nó từ các chủ đề.  Bấm vào Tiêu thụ.

24
00:03:41,880 --> 00:03:58,290
Bây giờ bạn có một người tiêu dùng Kafka đang lắng nghe tin nhắn về chủ đề này.  Và khi nhận được tin nhắn thì những tin nhắn đó sẽ hiện lên đây để gửi tin nhắn, bạn chỉ cần cung cấp tin nhắn đó là tin nhắn văn bản và nhấn vào xuất.

25
00:03:58,440 --> 00:04:07,690
Và đây là tin nhắn văn bản của chúng tôi.  Vì vậy, như bạn có thể thấy ở đây, tin nhắn mới này đã được đặt và phân vùng cho một phân vùng bên trong.

26
00:04:07,920 --> 00:04:18,230
Độ lệch thông báo là bảy và không có khóa nào được chỉ định.  Và có một sự bù đắp cho bảy lỗi, bởi vì tôi đã nghiên cứu chủ đề này được một thời gian.

27
00:04:18,540 --> 00:04:27,240
Vì vậy, nếu bạn đã tạo một chủ đề mới, bạn sẽ thấy phần bù của một chủ đề ở đây.  Bây giờ hãy nhấp vào trình quản lý Cloud Kafka.

28
00:04:27,570 --> 00:04:35,790
Hiện tại, số lượng người tiêu dùng ở đây đang là 14 người, và lý do là vì chúng tôi đang sử dụng cơ sở hạ tầng dùng chung.

29
00:04:36,210 --> 00:04:45,480
Vì vậy, có những người tiêu dùng khác gắn liền với cụm chia sẻ này.  Nhưng chủ đề của bạn bị cô lập với những người tiêu dùng khác.

30
00:04:45,510 --> 00:04:59,790
Có một chủ đề trong cụm và tổng kích thước chủ đề của ba nhà môi giới là năm phẩy sáu cabi.  Số lượng tin nhắn là năm mươi chín và lý do là năm mươi chín là vì tôi đã chơi với cụm này được một thời gian và vẫn còn đó.

31
00:04:59,980 --> 00:05:11,090
Một người dùng nhấp vào chủ đề và ở đây bạn thấy một chủ đề mà chúng tôi đã thử trước đó.  Nhấp vào tên chủ đề và nó sẽ hiển thị cho bạn một số chi tiết.

32
00:05:11,500 --> 00:05:19,540
Có năm phân vùng ứng dụng đó ba nhà máy.  Và đây là thông tin chi tiết về từng người tham gia.

33
00:05:19,690 --> 00:05:30,130
Vì vậy, ví dụ, đối với phân vùng số 0, phần dẫn đầu bị hỏng, số hai và phần bắt đầu của tập hợp là 0 và phần cuối của số đó là 13.

34
00:05:30,280 --> 00:05:38,500
Vậy điều đó có nghĩa là sau khi tạo chủ đề này, 13 tin nhắn đã được đẩy vào phân vùng này.

35
00:05:38,530 --> 00:05:49,660
Tương tự, nếu bạn nhìn vào phân vùng số ba, nút số hai là điểm bắt đầu dẫn đầu của số 0 và Offsiders 16, nghĩa là 16 tin nhắn đã được đẩy vào phân vùng.

36
00:05:49,660 --> 00:05:56,820
Thứ ba, nhấp vào người tiêu dùng và bạn sẽ thấy danh sách người tiêu dùng được đính kèm với cơ sở hạ tầng dùng chung.

37
00:05:57,070 --> 00:06:09,020
Nhấp vào các nhà môi giới để kiểm tra các nhà môi giới trong cụm.  Và đây là các nút.  Trong bài giảng sau, chúng ta sẽ kết nối từ mã Java của mình với cụm này như một bài tập.

38
00:06:09,040 --> 00:06:31,030
Tôi khuyên bạn nên tạo một chủ đề và để làm điều đó, hãy quay lại bảng điều khiển cloud craft của bạn, nhấp vào chủ đề, cung cấp tên chủ đề ở đây, đặt tham số và chỉ cần tạo thời gian để xuất bản một số thông báo cho chủ đề đó và bắt đầu người tiêu dùng trong  trình duyệt để xem mọi thứ hoạt động như thế nào.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000005.srt -->

1
00:00:00,480 --> 00:00:10,110
Nhà đồng sản xuất đang hoạt động trong bài học này.  Tôi sẽ hướng dẫn bạn qua sơ đồ lớp của một tập hợp các lớp tiện ích được tập hợp lại để thử nghiệm hoặc Kafka.

2
00:00:10,290 --> 00:00:20,650
Tôi sẽ hướng dẫn bạn mã trong các nhà sản xuất của lớp này và sau đó chúng tôi sẽ thực thi các nhà sản xuất của lớp này để gửi tin nhắn đến cụm Kafka.

3
00:00:21,570 --> 00:00:35,380
Các lớp tiện ích COFCO có sẵn trong Commodore Akhmadov trong gói Sản phẩm COFCO Giao diện cấu hình Kafka chứa các biến với các tham số cấu hình cho cụm COFCO.

4
00:00:35,610 --> 00:00:43,240
Vì vậy, đây là lúc bạn cần thực hiện thay đổi để hướng người tiêu dùng và nhà sản xuất Java tới cụm bánh cà phê của riêng bạn.

5
00:00:43,590 --> 00:01:07,560
Vì vậy, hãy đảm bảo rằng bạn thực hiện các thay đổi đối với giao diện này để kiểm tra thiết lập Cafcass của mình.  Dịch vụ Cafcass là một lớp trừu tượng có một cấu hình thiết lập chức năng để thiết lập cấu hình cụm cho nhà sản xuất và dịch vụ tiêu dùng tiêu dùng, đồng thời dịch vụ nhà sản xuất mở rộng lớp dịch vụ Cafcass.

6
00:01:07,800 --> 00:01:22,670
Dịch vụ sản xuất hiển thị các chức năng công khai để xuất bản tin nhắn đến một chủ đề.  Tương tự, dịch vụ tiêu dùng có chức năng người đăng ký đăng ký một chủ đề trên cụm Kafka.

7
00:01:22,860 --> 00:01:32,120
Khi tin nhắn đến các đại biểu dịch vụ tiêu dùng, việc xử lý tin nhắn đến phiên bản của trình xử lý tin nhắn.

8
00:01:32,340 --> 00:01:41,420
Chúng ta hãy xem qua mã và thử nó.  Mở Commodore Akhmad để lấy gói hàng.  Bấm vào cấu hình Kafka.

9
00:01:41,790 --> 00:02:11,820
Bây giờ hãy nhớ lại rằng chúng tôi đã tải xuống cấu hình cho cụm COFCO của mình từ trang chi tiết.  Và nếu bạn chưa làm thì bấm vào tải xuống ở đây nó sẽ tải xuống một tệp văn bản và tệp văn bản này sẽ có thông tin cấu hình mà chúng tôi cần thiết lập ở đây, sao chép thông tin cho các nhà môi giới và thay thế những gì bạn thấy ở đây  và sau đó sao chép tên người dùng và mật khẩu.

10
00:02:11,970 --> 00:02:19,110
Khi bạn đã hoàn thành việc đó, hãy đảm bảo cấu hình đã được lưu và chúng tôi sẵn sàng kiểm tra mã và dịch vụ Cafcass.

11
00:02:19,470 --> 00:02:29,310
Dịch vụ Cafcass là một lớp trừu tượng.  Nó chứa một số biến được bảo vệ cho chủ đề và nhóm nó vào nhóm này, nó sẽ chỉ được người tiêu dùng sử dụng.

12
00:02:29,790 --> 00:02:42,150
Và có bộ chức năng bảo vệ thuộc tính này chỉ đơn giản tạo đối tượng thuộc tính với tất cả các tham số cần thiết để kết nối với cụm COFCO.

13
00:02:42,450 --> 00:02:50,850
Và chức năng này được các lớp sử dụng cho người tiêu dùng và nhà sản xuất.  Tiếp theo, chúng ta sẽ kiểm tra dịch vụ của nhà sản xuất, nhà sản xuất.

14
00:02:50,860 --> 00:03:06,180
Vì vậy hãy mở rộng lớp dịch vụ Cafcass.  Có một phiên bản của trình đồng sản xuất decaf được duy trì dưới dạng biến tức thời riêng tư trong hàm tạo của lớp này lấy chủ đề và tạo trình đồng sản xuất.

15
00:03:06,300 --> 00:03:14,640
Lưu ý ở đây rằng các thuộc tính đều đúng từ lớp dịch vụ Cafcass.  Có một vài chức năng được xuất bản trong lớp này.

16
00:03:14,910 --> 00:03:24,630
Những chức năng công cộng này.  Lấy một phiên bản của đối tượng gọi lại, được gọi không đồng bộ sau khi phương thức được xuất bản.

17
00:03:25,440 --> 00:03:33,620
Chức năng này ở đây là để xuất bản một tin nhắn không có khóa và chức năng này là để xuất bản một tin nhắn có khóa.

18
00:03:34,110 --> 00:03:45,660
Việc thực hiện hai chức năng này khá giống nhau.  Một phiên bản của bản ghi sản phẩm được tạo và hàm thứ hai được gọi là Trình đồng sản xuất trên thảm cùng với bản ghi nhà sản xuất.

19
00:03:45,810 --> 00:03:57,790
Và nếu lệnh gọi lại được cung cấp thì lệnh gọi lại cũng được chỉ định trong hàm tay này.  Để kiểm tra lớp này, bạn sẽ thấy rằng có một hàm chính được xác định trong lớp.

20
00:03:57,790 --> 00:04:08,340
Đầu tiên chúng ta đang thiết lập chủ đề.  Hãy chắc chắn rằng chủ đề này tồn tại.  Tên người dùng gạch dưới Sassella là tên được gán trên cụm Cloud Kafka.

21
00:04:08,370 --> 00:04:18,580
Ở đây, chúng tôi đang tạo một phiên bản của dịch vụ sản xuất, thiết lập lệnh gọi lại, thao tác này chỉ đơn giản là in ra thông tin siêu dữ liệu cho thông báo đã xuất bản.

22
00:04:18,810 --> 00:04:27,840
Cái này dành cho việc xuất bản một tin nhắn không có khóa và đây là việc xuất bản một tin nhắn có chìa khóa sẽ thử cả hai.

23
00:04:28,410 --> 00:04:37,710
Đi tới Cloud Krake, nhấp vào phiên bản của bạn, nhấp vào chủ đề.  Chúng ta sẽ chọn tên chủ đề mặc định hoặc sao chép chủ đề này.

24
00:04:37,710 --> 00:04:46,620
Đặt tên vào clipboard.  Nhấp vào trình duyệt sẽ chuyển tên chủ đề vào đây và nhấp vào Tiêu thụ.  Bây giờ tại thời điểm này chúng tôi có một người tiêu dùng đang chạy.

25
00:04:46,740 --> 00:04:58,230
Chúng ta sẽ quay trở lại với dịch vụ sản xuất, phải không?  Bấm vào sản xuất một dịch vụ chạy.  Quá trình thực thi sản phẩm hoặc dịch vụ đã hoàn tất và hai thông báo đã được xuất bản như mong đợi.

26
00:04:58,440 --> 00:05:05,580
Và phân vùng cũng như thông tin về các tin nhắn đã xuất bản đã được in trên bảng điều khiển từ lệnh gọi lại.

27
00:05:05,820 --> 00:05:19,740
Một tin nhắn không có chìa khóa và một tin nhắn khác có chìa khóa.  Hãy quay trở lại trình duyệt.  Và như bạn có thể thấy ở đây, người tiêu dùng đã nhận được hai thông báo đề nghị bạn tự mình thử lớp nhà sản xuất.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000006.srt -->

1
00:00:00,210 --> 00:00:23,520
Nhóm người tiêu dùng Kafka và hành động trong bài học này.  Tôi sẽ bắt đầu bằng cách giải thích cách hoạt động của giao thức tái cân bằng Kafka, sau đó tôi sẽ hướng dẫn bạn đến tòa án và lớp dịch vụ tiêu dùng, sau đó chúng tôi sẽ chạy mã cho người tiêu dùng Kafka và nhà sản xuất đồng sản xuất để kiểm tra cách hoạt động của giao thức tái cân bằng Kafka.

2
00:00:24,180 --> 00:00:34,940
Giao thức tái cân bằng Kafka.  Hãy nhớ lại rằng Kafka chỉ cho phép một người tiêu dùng phân vùng khi những người tiêu dùng đó được khởi chạy trong một nhóm người tiêu dùng.

3
00:00:35,130 --> 00:00:47,830
Kafka đảm bảo rằng mỗi người tiêu dùng trong một nhóm được gắn vào 0 hoặc nhiều phân vùng bất cứ khi nào người tiêu dùng mới được thêm vào nhóm hoặc người tiêu dùng hiện tại bị xóa khỏi nhóm.

4
00:00:48,060 --> 00:01:09,480
Giao thức tái cân bằng Kafka đảm bảo rằng các phân vùng được gán lại.  Ví dụ: nếu bạn loại bỏ người tiêu dùng đang nghe trên phân vùng, không có ai trong nhóm người tiêu dùng, nhóm người tiêu dùng sẽ tự động cân bằng lại và phân vùng đó sẽ được gán cho một trong những người tiêu dùng đang hoạt động khác.

5
00:01:09,900 --> 00:01:22,230
Chúng ta hãy xem xét cách thức hoạt động của nó.  Giả sử chúng ta có một chủ đề có hai phân vùng.  Khi người tiêu dùng đầu tiên được đưa vào nhóm người tiêu dùng, nó sẽ nhận được tin nhắn từ cả hai người tham gia.

6
00:01:22,470 --> 00:01:35,940
Bây giờ, giả sử một người tiêu dùng mới được thêm vào nhóm người tiêu dùng.  Việc tái cân bằng sẽ diễn ra một cách bí mật và mỗi người tiêu dùng trong nhóm người tiêu dùng sẽ lắng nghe tin nhắn trên một trong các phân vùng.

7
00:01:36,090 --> 00:01:50,860
Vì vậy, ở đây người tiêu dùng đang nghe tin nhắn từ phân vùng một và người tiêu dùng sẽ được chỉ định phân vùng, giả sử người tiêu dùng thứ ba không được thêm vào, vì chỉ có thể có một phân vùng sức mạnh tiêu dùng.

8
00:01:50,910 --> 00:02:05,010
Người tiêu dùng C mới này sẽ không được chỉ định bất kỳ phân vùng nào, nhưng nếu người tiêu dùng và người tiêu dùng B không hoạt động, thì người tiêu dùng C sẽ tự động được chỉ định phân vùng mà không có người tiêu dùng nào.

9
00:02:06,920 --> 00:02:19,160
Trọng tâm của bài giảng này là về người tiêu dùng thuộc tầng lớp của anh ấy và để kiểm tra quá trình tái cân bằng, chúng ta sẽ sử dụng tầng lớp dịch vụ tiêu dùng cũng như các nhà sản xuất của tầng lớp này mà tôi đã hướng dẫn bạn trước đó.

10
00:02:20,000 --> 00:02:35,390
Lớp dịch vụ tiêu dùng mở rộng lớp dựa trên dịch vụ khách hàng.  Nó phải có hàm tạo của hàm tạo, hàm tạo đầu tiên chỉ lấy một chủ đề làm đối số và hàm tạo thứ hai lấy hai đối số, chủ đề và ID nhóm.

11
00:02:35,690 --> 00:02:45,500
Vì vậy, nếu bạn tạo phiên bản dịch vụ tiêu dùng có ID nhóm thì phiên bản đó sẽ là một phần của nhóm.  Và đây là hàm tạo mà chúng ta sẽ sử dụng trong quá trình thử nghiệm của mình.

12
00:02:45,710 --> 00:02:58,790
Hàm đăng ký thực hiện khử cực và một phiên bản của thông báo, và điều đầu tiên xảy ra trong hàm này là tạo ra người tiêu dùng với các thuộc tính nhận được từ lớp tốt nhất.

13
00:02:58,970 --> 00:03:11,310
Sau đó, hàm subscribe sẽ được gọi tới người tiêu dùng với một danh sách các chủ đề.  Vì vậy, điều đó có nghĩa là người tiêu dùng có thể đăng ký nhiều chủ đề trong cùng một cuộc gọi.

14
00:03:11,480 --> 00:03:25,880
Đây là vòng kéo.  Điều đầu tiên đang xảy ra là chúng tôi nhận các bài tập phân vùng cho ứng dụng tiêu dùng này và chỉ cần in các bài tập đó ra bảng điều khiển, gọi hàm thăm dò trong toàn bộ thời lượng.

15
00:03:26,420 --> 00:03:39,550
Và điều này sẽ không nhận được hoặc nhiều tin nhắn từ Kafka đi qua tập hợp các tin nhắn nhận được từ Kafka bằng cách gọi hàm xử lý trên phiên bản của trình xử lý.

16
00:03:39,710 --> 00:03:53,810
Quá trình thử nghiệm tiếp theo cho lớp này nằm trong chức năng chính trong lớp dịch vụ tiêu dùng.  Điều đầu tiên đang diễn ra ở đây là thiết lập chủ đề, thiết lập nhóm để tạo phiên bản dịch vụ tiêu dùng với chủ đề và nhóm.

17
00:03:54,380 --> 00:04:06,920
Và sau đó là việc tạo phiên bản trình xử lý tin nhắn, in ra thông tin cho tin nhắn trên bảng điều khiển và sau đó gọi hàm đăng ký bằng cách bỏ phiếu.

18
00:04:06,920 --> 00:04:19,220
Kéo dài một giây hoặc một nghìn mili giây để kiểm tra Kafka, việc cân bằng lại sẽ thực hiện ba bước và bước số một sẽ tạo một chủ đề mới với hai phân vùng.

19
00:04:19,730 --> 00:04:29,530
Sau đó, chúng ta sẽ thiết lập lớp dịch vụ người tiêu dùng để nghe chủ đề mới này và chúng ta sẽ tạo hai phiên bản của lớp dịch vụ người tiêu dùng.

20
00:04:29,540 --> 00:04:46,270
Vì vậy, trên thực tế, sẽ có hai người đăng ký và sau đó chúng tôi sẽ thiết lập lớp nhà sản xuất của mình để gửi tin nhắn đến chủ đề mới này và chúng tôi sẽ gửi tin nhắn với các khóa khác nhau để xem người tiêu dùng nào sẽ nhận được những tin nhắn đó.

21
00:04:46,310 --> 00:04:56,690
Vì vậy, hãy tiếp tục và tạo chủ đề mới trên lưu lượng truy cập đám mây, nhấp vào chủ đề đó và cung cấp chủ đề mới.

22
00:04:56,690 --> 00:05:04,700
Tên sẽ gọi nó là mới, thay đổi số lượng phân vùng thành hai và giữ bản sao ở mức vừa tạo.

23
00:05:05,090 --> 00:05:17,990
Và bây giờ chúng tôi có một chủ đề mới trên cụm của chúng tôi.  Đi đến lớp người tiêu dùng.  Thay đổi điều này trước đây thành mới.  Vì vậy, bây giờ người tiêu dùng của chúng tôi sẽ lắng nghe tin nhắn về chủ đề mới này.

24
00:05:18,230 --> 00:05:26,300
Phải?  Bấm vào dịch vụ tiêu dùng và chạy.  Người tiêu dùng của chúng tôi đã khởi chạy và có một phiên bản của người tiêu dùng đang chạy vào thời điểm này.

25
00:05:26,300 --> 00:05:41,830
Nhấp vào sản phẩm hoặc dịch vụ, đi xuống chức năng chính và thay đổi tên chủ đề thành mới theo mặc định, sau đó đi xuống và chỉ nhận xét lệnh gọi xuất bản mà không cần khóa.

26
00:05:42,230 --> 00:05:49,120
Bây giờ, ý tưởng ở đây là chúng ta sẽ luôn gửi tin nhắn có khóa.  Vì vậy, ở đây chúng tôi có chìa khóa để truy cập khách hàng.

27
00:05:49,160 --> 00:05:55,220
Một hai ba.  Vì vậy, hãy xem điều gì sẽ xảy ra khi chúng tôi gửi tin nhắn đến một người tiêu dùng đang lắng nghe.

28
00:05:55,640 --> 00:06:09,890
Vì vậy, hãy chạy sản xuất một dịch vụ, quay lại người tiêu dùng và người tiêu dùng đã nhận được tin nhắn.  Bây giờ hãy chú ý đến các phân vùng được chỉ định, một người tiêu dùng này được chỉ định cho cả phân vùng, phân vùng và mosiello và phân vùng.

29
00:06:09,890 --> 00:06:18,760
Bây giờ không ai sẽ tung ra một quyền tiêu dùng khác.  Bấm vào chạy dịch vụ tiêu dùng.  Vì vậy, điều này sẽ khởi chạy một phiên bản khác của người tiêu dùng.

30
00:06:19,010 --> 00:06:25,430
Bây giờ, phiên bản người tiêu dùng thứ hai của chúng tôi đang chạy và Kafka sẽ thực hiện việc tái cân bằng nội bộ.

31
00:06:25,430 --> 00:06:35,450
Vì vậy, đây là người tiêu dùng của chúng tôi đã nhận được tin nhắn đầu tiên.  Và đây là hai người tiêu dùng cũng đang chờ đợi những tin nhắn có cùng chủ đề.

32
00:06:35,450 --> 00:06:46,340
Quay trở lại dịch vụ sản xuất.  Hãy thay đổi khách hàng này một, hai, ba thành bốn, năm, sáu và xem ai trong số những người tiêu dùng này sẽ nhận được tin nhắn.

33
00:06:46,790 --> 00:06:55,790
Phải, bấm, chạy.  Và những gì tôi thấy ở đây là người tiêu dùng của chúng ta đã nhận được tin nhắn có mã khách hàng là 4, 5, 6.

34
00:06:56,180 --> 00:07:06,140
Bây giờ chúng ta hãy thử bảy, tám, chín và hy vọng lần này người tiêu dùng hai của chúng ta sẽ nhận được nó.  Phải.  Nhấp vào nhà sản xuất Andron và lần này là người tiêu dùng của chúng tôi.

35
00:07:06,300 --> 00:07:21,280
Ai đã nhận được tin nhắn, đừng chú ý đến phân vùng được chỉ định của người tiêu dùng đang nghe tin nhắn trên phân vùng số 0 và nếu bạn đi đến phân vùng dành cho người tiêu dùng, người tiêu dùng đang nghe tin nhắn trên phân vùng một.

36
00:07:21,690 --> 00:07:38,460
Bây giờ, hãy tiếp tục và tiêu diệt một trong những người tiêu dùng này.  Hãy để tôi gọi cho người tiêu dùng đầu tiên.  Và tại thời điểm này, Kafka sẽ tái cân bằng người tiêu dùng và chúng ta sẽ thấy rằng tất cả tin nhắn sẽ được nhận bởi người tiêu dùng duy nhất đang chạy.

37
00:07:38,490 --> 00:07:46,560
Quá đúng.  Bấm vào tạo một dịch vụ chạy lại.  Và đúng như dự đoán, tin nhắn đã được nhận bởi người tiêu dùng duy nhất đang chạy.

38
00:07:46,560 --> 00:07:58,390
Hãy chú ý đến phân vùng được chỉ định và bạn sẽ thấy rằng bây giờ chúng tôi chỉ có một người tiêu dùng trong nhóm và người tiêu dùng đó đang nghe tin nhắn trên cả hai phân vùng.

39
00:07:58,440 --> 00:08:06,600
Vì vậy, đây là minh chứng cho thấy cách Kafka thực hiện việc tái cân bằng một cách tự động trong một nhóm người tiêu dùng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000007.srt -->

1
00:00:00,150 --> 00:00:15,420
M. Cupie của Courthouse, trong bài học này, Al Gore, sự khác biệt giữa nền tảng truyền phát tin nhắn COFCO và các hệ thống nhắn tin dựa trên AM như Rabbitt Amcu và Amcu đang hoạt động, tôi sẽ bắt đầu bài học này bằng một câu hỏi.

2
00:00:15,660 --> 00:00:22,200
Bây giờ bạn đã biết về Kafka và M Cupie, bạn sẽ sử dụng dịch vụ vi mô nào trong số này?

3
00:00:22,240 --> 00:00:32,160
Không, tôi sẽ không thảo luận về câu trả lời cho câu hỏi này trong bài học này.  Đúng hơn, tôi khuyên bạn nên ghi nhớ câu hỏi này khi xem qua nội dung của bài giảng này.

4
00:00:32,550 --> 00:00:42,470
Chúng ta sẽ thảo luận về phản hồi trong bài giảng tiếp theo khi một tin nhắn được gửi đến một chủ đề Kafka.  Nó luôn tồn tại trong câu chuyện dài hạn.

5
00:00:42,480 --> 00:01:06,810
Phương thức hết hạn sau khoảng thời gian đã đặt.  Về chủ đề Kafka, tin nhắn không bị xóa khi đọc.  Vì vậy, điều đó có nghĩa là người tiêu dùng hoặc tin nhắn có thể đọc lại tin nhắn bây giờ và so sánh nó với một chiếc cupie, sau khi tin nhắn được đọc từ Q trên giả sử Rabbit và Q hoặc Amcu đang hoạt động, tin nhắn sẽ bị xóa khỏi Q.

6
00:01:07,500 --> 00:01:19,860
Kafka sử dụng giao thức nhị phân tùy chỉnh hoặc TCP.  Từ khóa ở đây là tùy chỉnh.  Điều đó có nghĩa là nó không phải là một giao thức chuẩn được nhiều sản phẩm sử dụng.

7
00:01:20,130 --> 00:01:33,780
Giao thức cụ thể này chỉ được Kafka sử dụng.  Mặt khác, AM Cupie là một giao thức tiêu chuẩn được triển khai bởi nhiều nền tảng nhắn tin như MQ hoạt động và Rabbitt MQ.

8
00:01:34,470 --> 00:01:51,210
Mặc dù Kafka là một nền tảng nhắn tin nhưng nó không có khái niệm về Q nhưng nó chỉ hỗ trợ xuất bản mẫu tin nhắn của người đăng ký, trong khi các nền tảng nhắn tin dựa trên m QB như Rabbit và Q hỗ trợ cả điểm tới điểm và xuất bản các mẫu tin nhắn đăng ký.

9
00:01:51,420 --> 00:02:02,970
COFCO không hỗ trợ định tuyến.  Mặt khác, bạn có thể sử dụng định tuyến động, nhưng nó không có sẵn và CUPIE có cơ chế định tuyến rất linh hoạt.

10
00:02:02,970 --> 00:02:15,030
Hãy nhớ lại rằng trong trường hợp của Rabbit Q, chúng ta có thể tạo các loại trao đổi khác nhau và sau đó liên kết Q với các trao đổi bằng các ràng buộc.

11
00:02:15,390 --> 00:02:38,760
Loại cơ chế này không có trên Kafka.  Vì vậy, nói cách khác, Kafka không có khái niệm về ràng buộc mệnh đề trao đổi hoặc ưu tiên tin nhắn. Người tiêu dùng Kafka luôn lấy tin nhắn từ nhà môi giới bằng cách kéo người tiêu dùng, đăng ký tin nhắn và kéo trong thời lượng cụ thể và nhận tin nhắn theo đợt.

12
00:02:38,910 --> 00:02:47,370
Mặt khác, trong các nền tảng dựa trên Amcu, có hỗ trợ cho cả mô hình đẩy và kéo để nhận tin nhắn.

13
00:02:47,820 --> 00:02:54,900
COFCO Bodiford đảm bảo thứ tự tin nhắn trong một phân vùng.  Hãy để tôi giải thích điều này bằng một minh họa.

14
00:02:55,210 --> 00:03:05,550
Giả sử có một chủ đề có hai phân vùng và có hai người tiêu dùng.  Người tiêu dùng A được gắn vào phân vùng một và Người tiêu dùng B được gắn vào phân vùng hai.

15
00:03:06,120 --> 00:03:23,690
Để phục vụ cuộc thảo luận này, hãy giả sử rằng nhà sản xuất đang gửi tin nhắn có cuộc gọi chính tới khách hàng Idy và Kazuma đang nhận một, hai, ba tin nhắn ID khách hàng và hóa đơn tiêu dùng, nhận tin nhắn về ID người tiêu dùng trong năm sáu.

16
00:03:24,030 --> 00:03:36,020
Bây giờ, thứ tự tin nhắn được đảm bảo ngụ ý rằng Người tiêu dùng A sẽ nhận được tất cả các tin nhắn cho ID khách hàng một, hai, ba theo thứ tự chúng được xuất bản.

17
00:03:36,390 --> 00:03:46,710
Và điều tương tự cũng áp dụng cho người tiêu dùng.  Người tiêu dùng B sẽ nhận được tất cả tin nhắn dành cho khách hàng thứ ba, bốn, năm, sáu theo thứ tự chúng được xuất bản.

18
00:03:47,110 --> 00:03:57,390
Đây là một tính năng cực kỳ quan trọng của Kafka vì nó sẽ cho phép bạn xây dựng các hệ thống yêu cầu sắp xếp thông điệp.

19
00:03:57,780 --> 00:04:03,780
Điều quan trọng cần lưu ý là nền tảng nhắn tin dựa trên AQAP không hỗ trợ sắp xếp tin nhắn.

20
00:04:04,260 --> 00:04:16,830
Vì vậy, trong trường hợp bằng tiếng Ả Rập, nhiều người tiêu dùng có thể đọc tin nhắn Amcu trong AQ.  Mỗi người tiêu dùng này xử lý tin nhắn nhận được một cách độc lập với những người tiêu dùng khác.

21
00:04:17,250 --> 00:04:27,790
Do đó, thứ tự xử lý các tin nhắn này không được đảm bảo, trong khi trong trường hợp của Kafka, chỉ có một người tiêu dùng cho phân vùng.

22
00:04:28,200 --> 00:04:36,990
Do đó, thứ tự xử lý tin nhắn sẽ giống với thứ tự tin nhắn được xuất bản.

23
00:04:37,440 --> 00:04:48,150
Đã đến lúc ôn lại những điểm chính của bài học này.  Khi người tiêu dùng đọc tin nhắn từ một chủ đề, tin nhắn sẽ không bị xóa khỏi chủ đề.

24
00:04:48,150 --> 00:05:00,540
Họ được giữ lại.  Kafka không hỗ trợ các khái niệm cupie như trao đổi Kyuss, ưu tiên định tuyến, v.v. Kafka sử dụng giao thức TCP nhị phân tùy chỉnh.

25
00:05:00,570 --> 00:05:10,710
Điều đó có nghĩa là không có nền tảng nào khác đang sử dụng giao thức Cafcass.  Cafcass chỉ hỗ trợ các tin nhắn bật lên và đầy đủ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\13MicroservicesandKafka_VVN\000000008.srt -->

1
00:00:00,180 --> 00:00:09,570
Ho, ho hoặc các dịch vụ vi mô trong bài giảng này nhấn mạnh các trường hợp sử dụng phổ biến của Kafka và sau đó chúng ta sẽ có một hoạt động thú vị trong hoạt động vui nhộn này.

2
00:00:09,900 --> 00:00:19,630
Tôi sẽ hỏi bạn những câu hỏi dựa trên kịch bản.  Và bạn, với tư cách là người thiết kế các dịch vụ vi mô, sẽ quyết định xem bạn sẽ sử dụng Kafka hay Rabbit MQ.

3
00:00:19,830 --> 00:00:29,040
Tôi sẽ bắt đầu bài học này bằng cách xem lại câu hỏi tôi đã hỏi bạn ở bài giảng trước.  Bạn sẽ sử dụng dịch vụ nào trong số này cho các dịch vụ vi mô?

4
00:00:30,400 --> 00:00:40,360
Tất cả phụ thuộc vào trường hợp sử dụng vi mạch của bạn, nền tảng Kafka và Abe có những điểm mạnh cũng như tính năng riêng.

5
00:00:40,690 --> 00:00:49,410
Và tùy thuộc vào trường hợp sử dụng, bạn có thể chọn Kafka hoặc MGP hoặc trên thực tế, bạn thậm chí có thể chọn cả Kafka và Cupie.

6
00:00:49,800 --> 00:01:08,650
Tất cả phụ thuộc vào trường hợp sử dụng của bạn.  Tiếp theo, tôi sẽ thảo luận về một số trường hợp sử dụng phổ biến của Kafka.  Ví dụ: Kafka được xây dựng nền tảng cho các ứng dụng nhắn tin quy mô lớn và ứng dụng Iot đang tiêu thụ hàng chục nghìn tin nhắn mỗi giây.

7
00:01:09,310 --> 00:01:17,080
Kafka mang lại độ bền cao cho tin nhắn và cung cấp khả năng mở rộng không giới hạn theo chủ đề và phân vùng.

8
00:01:17,590 --> 00:01:25,100
Vì vậy, nếu bạn là máy chủ của Microsoft, có nhu cầu tiếp nhận một số lượng lớn sự kiện mỗi giây hơn Kafka.

9
00:01:25,120 --> 00:01:35,140
Có lẽ là sự lựa chọn tốt hơn trên nền tảng dựa trên AM cupie.  Kafka thường được sử dụng để theo dõi trang web, còn được gọi là Phân tích dòng nhấp chuột.

10
00:01:35,290 --> 00:01:49,230
Các hoạt động trên trang web được thiết lập theo cách mà mỗi khi người dùng thực hiện một hành động, chẳng hạn như nhấp vào nút hoặc nhấp vào liên kết trên trang web, sẽ dẫn đến việc tạo ra một sự kiện được Kafka tiếp thu.

11
00:01:49,360 --> 00:01:58,740
Dữ liệu sau đó được đẩy vào các nền tảng phân tích như Hadoop để xử lý thêm.  Trên thực tế, đây là trường hợp sử dụng ban đầu của Kafka.

12
00:01:59,290 --> 00:02:14,020
Một trường hợp sử dụng phổ biến khác của Kafka là để tổng hợp nhật ký và xử lý luồng nhật ký ngay cả từ các ứng dụng và máy chủ có thể được Kafka sử dụng trong thời gian thực, thậm chí xử lý theo thời gian thực.

13
00:02:14,020 --> 00:02:26,020
Ngay cả việc xử lý cũng có thể dẫn đến việc xác định các điểm bất thường hoặc các vấn đề mà sau đó có thể được sử dụng để đưa ra cảnh báo cho nhóm vận hành, thậm chí còn thảo luận về việc tìm nguồn cung ứng.

14
00:02:26,020 --> 00:02:38,350
Trong một trong những bài giảng trước đó, Kafka là nguồn sẵn có cho việc xây dựng, thậm chí là tìm nguồn cung ứng.  Nó cung cấp một chuỗi các sự kiện hoặc bản ghi theo thứ tự thời gian.

15
00:02:38,710 --> 00:02:46,210
Và những sự kiện này được lưu giữ trong Kafka trong một thời gian dài và có thể được người tiêu dùng phát lại.

16
00:02:46,930 --> 00:03:06,410
Kafka cung cấp khả năng ghi nhật ký truyện tranh vượt trội cho bất kỳ ứng dụng, sức mạnh hoặc dịch vụ nào.  Nó cung cấp nhật ký truyện tranh này cho một hệ thống phân tán trong đó dữ liệu được sao chép giữa các nút và trong trường hợp nút bị lỗi, người tiêu dùng không bị ảnh hưởng và minh bạch đối với người tiêu dùng.

17
00:03:06,730 --> 00:03:17,410
Các nút trường phục hồi bằng cách lấy dữ liệu từ các nút có sẵn.  Nếu bạn cần ghi nhật ký, tôi khuyên bạn nên thực hiện nghiên cứu của riêng mình trên Internet.

18
00:03:17,830 --> 00:03:28,000
Trong phần còn lại của bài giảng này, tôi sẽ hỏi bạn một số câu hỏi.  Những câu hỏi này sẽ bao gồm một kịch bản và các yêu cầu về thông điệp cho kịch bản đó.

19
00:03:28,390 --> 00:03:37,630
Và dựa trên những yêu cầu này, bạn sẽ cần quyết định nền tảng nhắn tin của mình.  Bạn sẽ chọn Casca hoặc Rabbitt MQ.

20
00:03:38,440 --> 00:03:46,540
Vì vậy, đây là kịch bản số một.  Microsoft cần nói chuyện với Microsoft Visby hoặc yêu cầu nhắn tin phản hồi Pappan.

21
00:03:46,870 --> 00:03:54,250
Giả sử số lượng tin nhắn nhỏ hơn nghìn mỗi giây.  Bạn sẽ chọn cái nào?

22
00:03:54,400 --> 00:04:02,020
COFCO hoặc.  Cảm ơn.  Tôi sẽ chọn Rabbit MQ.  Một vài lý do nhanh chóng.  Âm lượng tin nhắn không cao.

23
00:04:02,350 --> 00:04:11,020
IQ phù hợp hơn để đáp ứng yêu cầu so với một chủ đề.  Vì vậy Robert MQ sẽ hợp lý hơn trong kịch bản này.

24
00:04:11,500 --> 00:04:19,900
Kịch bản số hai liên quan đến một Microsoft Office đang xuất bản một thông báo tới một chủ đề được nhiều người khác đăng ký.

25
00:04:19,900 --> 00:04:33,130
Microsoft cho biết khối lượng tin nhắn sẽ đạt tối đa 50 sự kiện mỗi giây và lượng tải thậm chí này dự kiến ​​sẽ không thay đổi trong ba năm tới.

26
00:04:33,340 --> 00:04:42,990
Bạn sẽ chọn gì, Robert MQ hay Kafka?  Tôi sẽ chọn Rabbitt Amcu và lý do là lượng tin nhắn khá thấp.

27
00:04:43,610 --> 00:04:54,290
Không, hãy xem lại kịch bản với một thay đổi.  Giả sử khối lượng tin nhắn là 50000 sự kiện mỗi giây và khối lượng tin nhắn này dự kiến ​​sẽ tăng theo thời gian.

28
00:04:54,530 --> 00:05:06,090
Bây giờ bạn sẽ làm gì?  Chà, trong trường hợp này, đây là một trường hợp rõ ràng về ứng dụng nhắn tin quy mô lớn, vì vậy tôi sẽ chọn kịch bản tiếp theo của Kafka.

29
00:05:06,260 --> 00:05:13,440
Chúng tôi có một dịch vụ metro đang xuất bản các sự kiện theo một chủ đề, giả sử, khoảng 20 sự kiện mỗi giây.

30
00:05:14,060 --> 00:05:27,050
Có một dịch vụ vi mạch khác đang nhận những tin nhắn hoặc sự kiện này.  Yêu cầu ở đây là thực hiện phân tích các sự kiện theo thời gian thực để tạo cảnh báo.

31
00:05:27,470 --> 00:05:36,230
Bạn sẽ chọn cái nào?  Kafka hoặc.  Abbi, cảm ơn bạn.  Chà, tôi sẽ chọn Kafka vì có rất nhiều công cụ có sẵn cho Thời gian thực.

32
00:05:36,230 --> 00:05:45,760
Phân tích các dòng chẵn  Những công cụ này có khả năng mở rộng cao và có thể đảm nhiệm việc phân tích hàng chục nghìn sự kiện mỗi giây.

33
00:05:46,100 --> 00:05:59,280
Ví dụ về các công cụ như vậy là Apache, Spark và Stone.  Vui lòng thực hiện nghiên cứu của riêng bạn để hiểu cách các công cụ này hoạt động để phân tích thời gian thực các luồng Cafcass trong kịch bản tiếp theo.

34
00:05:59,360 --> 00:06:12,610
Giả sử bạn đang thiết kế một dịch vụ vi mô cần cung cấp giao diện nhắn tin dựa trên tiêu chuẩn và người tiêu dùng dịch vụ này đã quen với việc sử dụng các trình gây nhiễu Java và thích sự đơn giản hơn.

35
00:06:12,890 --> 00:06:28,960
Bạn sẽ chọn cái nào trong kịch bản?  Tôi sẽ chọn Rabbitt MQ.  Đây là cách triển khai dựa trên tiêu chuẩn M cupie và có thể được thay thế bằng bất kỳ triển khai M QB nào khác, chẳng hạn như MQ hoạt động so với Kafka.

36
00:06:29,270 --> 00:06:44,310
Nó đơn giản hơn nhiều để thiết lập và quản lý.  Trong trường hợp tiếp theo này, hãy giả sử rằng các yêu cầu nhắn tin cho dịch vụ vi mô của bạn sao cho cả hai nền tảng nhắn tin đều có thể đáp ứng.

37
00:06:44,310 --> 00:06:55,690
Vì vậy, bạn tiếp cận nhóm của mình và thảo luận xem nên sử dụng nền tảng nhắn tin nào.  Các nhà phát triển của bạn đã cho biết rằng họ muốn có toàn quyền kiểm soát việc định tuyến dữ liệu chẵn.

38
00:06:55,800 --> 00:07:04,290
Bây giờ, với giả định này, bạn thích cái nào hơn?  Kafka hay Thỏ?  MQ Tại sao?  Tôi sẽ đi với Rabbit Amcu.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\001 Distributed Transactions with SAGA.en.srt -->

1

00:00:00,120 --> 00:00:06,870

In earlier sections, you learn that it is not always possible for micro services to use to face Cummock



2

00:00:07,110 --> 00:00:08,640

for transaction management.



3

00:00:09,270 --> 00:00:12,770

The alternative is to use the saga pattern.



4

00:00:13,530 --> 00:00:17,940

The challenge with building sagas is that they are complicated.



5

00:00:18,390 --> 00:00:23,240

But the good news is there are frameworks available for the realisation of sagas.



6

00:00:23,550 --> 00:00:29,050

These frameworks hide all the complexities needed for the realisation of this pattern.



7

00:00:29,460 --> 00:00:36,180

I've decided not to use any framework, and the reason is because I would like to show you the inner



8

00:00:36,180 --> 00:00:38,120

workings of the Saagar pattern.



9

00:00:38,490 --> 00:00:41,450

Let's go over the learning objectives for this section.



10

00:00:41,460 --> 00:00:43,290

You learn the saga pattern.



11

00:00:43,620 --> 00:00:45,840

You'll learn the types of Saagar pattern.



12

00:00:46,110 --> 00:00:51,420

There are multiple implementation considerations that you need to keep in mind while building sagas.



13

00:00:51,660 --> 00:00:57,330

And you will see the saga in action for Achmea sales booking transaction.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\002 SAGA Pattern for distributed transactions.en.srt -->

1

00:00:00,420 --> 00:00:06,420

The consistency in distributor transactions in one of the earlier lectures are disclosed to Facebook,



2

00:00:06,810 --> 00:00:12,560

which can be used for managing data consistency within a single database.



3

00:00:12,960 --> 00:00:19,170

But in the case of distributed transactions, there may be multiple databases across multiple micro



4

00:00:19,170 --> 00:00:19,740

services.



5

00:00:19,920 --> 00:00:27,570

In this lesson, I'll discuss the challenges associated with managing the data consistency across micro



6

00:00:27,570 --> 00:00:34,380

services, and then I'll introduce you to the Psagot pattern that provides a solution for managing the



7

00:00:34,530 --> 00:00:39,030

data consistency across micro services designed for failure.



8

00:00:39,030 --> 00:00:44,790

Principle suggests that you should always anticipate that there will be failures.



9

00:00:44,970 --> 00:00:51,960

You should proactively identify the failure points in your architecture involving distributed components



10

00:00:52,110 --> 00:00:58,380

or micro services, and then you should address all of the failure points in your architecture.



11

00:00:58,440 --> 00:01:02,190

This is a best practice for building distributed systems.



12

00:01:02,790 --> 00:01:10,050

The idea is that since each micro service has its own database, if failures are not addressed, it



13

00:01:10,050 --> 00:01:17,400

will lead to an inconsistent state of data across the multiple databases owned by the micro services.



14

00:01:17,460 --> 00:01:20,070

This need to be avoided at all costs.



15

00:01:20,250 --> 00:01:21,400

Let me give you an example.



16

00:01:22,260 --> 00:01:25,560

Consider this example of an e-commerce website.



17

00:01:26,100 --> 00:01:28,230

Customer pays for the order.



18

00:01:29,240 --> 00:01:37,050

The auto service axed the order to the orders database and then hammered out an event which is received



19

00:01:37,050 --> 00:01:44,000

by the payment service to process the payment once the payment is processed successfully, the payment



20

00:01:44,010 --> 00:01:50,120

service adds the order information, along with the payment information in its own database.



21

00:01:50,390 --> 00:01:53,390

After that, the shipment service gets invoked.



22

00:01:53,690 --> 00:02:00,230

The shipment service tries to add the order information and the shipment information in its own database.



23

00:02:00,230 --> 00:02:04,650

And let's say there is a failure on the insert as a result.



24

00:02:04,770 --> 00:02:10,870

Now, the shipment data is not in sync with the payment data and the orders data.



25

00:02:11,150 --> 00:02:17,600

The net impact of this scenario will be that the customer paid for the items, but this customer will



26

00:02:17,600 --> 00:02:20,540

never receive their order and result.



27

00:02:20,550 --> 00:02:27,920

We will have one unhappy customer and such a website that does not cater to such failure scenarios will



28

00:02:27,920 --> 00:02:29,680

not be able to survive for long.



29

00:02:31,160 --> 00:02:38,360

The designer of the distributed system must ensure that the data is consistent across all of the distributed



30

00:02:38,360 --> 00:02:40,220

services or micro services.



31

00:02:40,700 --> 00:02:43,490

Going back to the example of the e-commerce website.



32

00:02:43,730 --> 00:02:49,060

What this means is that order should be marked successful in all three databases.



33

00:02:49,340 --> 00:02:55,220

If there is a failure, let's say the shipment database done, that failure should lead to a change



34

00:02:55,220 --> 00:03:02,090

in state and the other databases payment should be refunded to the customer and the order should be



35

00:03:02,240 --> 00:03:03,770

marked as failed.



36

00:03:03,980 --> 00:03:09,870

The customer should either be informed or the order service should be tried at the end of the day.



37

00:03:10,190 --> 00:03:15,080

The state of the order should be consistent across all of the three databases.



38

00:03:15,230 --> 00:03:21,200

It can all be successful or it can all be failures, but it cannot be a mix of success and failure.



39

00:03:21,710 --> 00:03:27,170

One important point to keep in mind is that local transactions cannot be used for avoiding the state



40

00:03:27,170 --> 00:03:28,400

of the database.



41

00:03:28,550 --> 00:03:35,270

So in this scenario, the payment service and the order or service cannot use local database transactions



42

00:03:35,360 --> 00:03:37,880

to roll back the changes in the database.



43

00:03:38,930 --> 00:03:45,830

Saga Pattern provides a solution for managing data consistency across micro services.



44

00:03:45,950 --> 00:03:50,780

It involves use of local transactions coupled with compensating transactions.



45

00:03:51,230 --> 00:03:53,570

Let me explain it with an illustration.



46

00:03:53,580 --> 00:03:55,910

Let's say we have three micro services.



47

00:03:55,910 --> 00:04:03,230

The flow of transaction begin with the invocation of an API on Microsoft's IT, which has a transaction



48

00:04:03,230 --> 00:04:08,930

T1 that gets executed and it's a local transaction against a database.



49

00:04:08,990 --> 00:04:16,370

This transaction leads to the mitting of an event which is received by Microsoft as B and in response



50

00:04:16,370 --> 00:04:21,710

Microsoft's B Execute Transaction T2 against its local database.



51

00:04:21,710 --> 00:04:28,130

T2 leads to the meeting of the event, which is received by Microsoft as C and in response, Microsoft



52

00:04:28,140 --> 00:04:32,970

C executes Transaction D three against its local database.



53

00:04:32,990 --> 00:04:39,580

So far, things have gone good and the data is inconsistent state across all the three databases.



54

00:04:39,680 --> 00:04:44,740

Now each of these transactions will have a corresponding compensating transaction.



55

00:04:44,750 --> 00:04:49,250

The role of these compensating transactions is to reward the database changes.



56

00:04:49,250 --> 00:04:55,130

And the way it works out is that when there is a failure in the transaction, for example, if there



57

00:04:55,130 --> 00:05:02,660

was a failure in the transaction, T-3 decompensating transaction will be executed and an event will



58

00:05:02,660 --> 00:05:03,410

be omitted.



59

00:05:03,440 --> 00:05:12,410

This event will be received by Microsoft as A and B, and each of these micro services will then execute



60

00:05:12,620 --> 00:05:15,020

their corresponding compensating transactions.



61

00:05:15,200 --> 00:05:24,020

So it will execute C one and B will execute C two to reverse the changes in their own respective databases.



62

00:05:24,020 --> 00:05:31,100

And by way of these compensating transactions, the consistency of data will be achieved across all



63

00:05:31,100 --> 00:05:32,450

of the three databases.



64

00:05:32,480 --> 00:05:39,420

So what this means is that each transaction would require a corresponding compensating transaction.



65

00:05:39,740 --> 00:05:43,480

Let me give you an example of decompensating transactions.



66

00:05:43,700 --> 00:05:50,330

Consider this e-commerce scenario where we have three micro services or service, receives the order



67

00:05:50,330 --> 00:05:57,570

from the customer and then leads to invocation of transactions on payment service and inventory service.



68

00:05:57,590 --> 00:06:03,440

So the order service will have a transaction that I have the order to its local database and there will



69

00:06:03,440 --> 00:06:09,650

be a corresponding compensating transaction to remove the order from the local database or to mark the



70

00:06:09,650 --> 00:06:11,200

order as failed.



71

00:06:11,480 --> 00:06:18,050

The payment service will have a transaction that will lead to the charging of the credit card and updating



72

00:06:18,050 --> 00:06:19,430

of the local database.



73

00:06:19,610 --> 00:06:26,360

And the corresponding compensating transaction will be to reform the credit card and make changes to



74

00:06:26,360 --> 00:06:30,950

the local database to reflect that the charge has been refunded.



75

00:06:31,250 --> 00:06:38,240

The inventory service will have a transaction to reduce the item count, and if there is a failure in



76

00:06:38,240 --> 00:06:44,960

the payment service, the corresponding compensating transaction in the inventory service will increase



77

00:06:44,960 --> 00:06:48,710

the item count for the order that was refunded or cancelled.



78

00:06:48,980 --> 00:06:52,880

Saagar Pattern may be applied to monolithic and distributed systems.



79

00:06:53,150 --> 00:06:58,370

When the saga pattern is applied to distributed systems, it is sometimes referred to as distributed



80

00:06:58,370 --> 00:06:58,900

saga.



81

00:06:59,240 --> 00:07:04,130

In this case, I will be using Soga and distributed Saga interchangeably.



82

00:07:04,370 --> 00:07:08,630

But in the context of micro services, we are referring to distributed services.



83

00:07:08,780 --> 00:07:10,690

Saagar Parathion is not new.



84

00:07:10,700 --> 00:07:14,630

It was introduced in a paper published in eighty seven.



85

00:07:14,960 --> 00:07:16,270

It is the link to the paper.



86

00:07:16,580 --> 00:07:20,000

If you are interested in digging deeper into this pattern.



87

00:07:20,300 --> 00:07:23,420

In this lesson I introduce you to the Psagot pattern.



88

00:07:23,420 --> 00:07:28,460

Saga pattern is used for managing data consistency across micro services.



89

00:07:28,490 --> 00:07:30,410

It involves use of.



90

00:07:30,670 --> 00:07:38,140

Local transactions for persisting transaction data to the data bases, and it involves use of compensating



91

00:07:38,140 --> 00:07:45,340

transactions for revoting, the database changes in case of failures, the reason compensating transactions



92

00:07:45,340 --> 00:07:52,150

are used is because it is not possible to use a database transaction roll back for revoting.



93

00:07:52,450 --> 00:07:55,660

The database changes in the next lesson.



94

00:07:56,050 --> 00:08:00,250

I'll discuss the various ways in which Taga pattern may be realized.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\003 SAGA Choreography Vs. Orchestration.en.srt -->

1

00:00:00,180 --> 00:00:04,090

There are two ways to build, Saagar, coal flows in this lesson.



2

00:00:04,230 --> 00:00:11,130

I'll discuss how to build safeguards using even choreography and command orchestrators.



3

00:00:11,610 --> 00:00:14,040

Asaka is implemented in two ways.



4

00:00:14,040 --> 00:00:20,010

The first way is to use what is referred to as the ear and choreography in which there is no central



5

00:00:20,010 --> 00:00:22,170

component to manage the transactions.



6

00:00:22,470 --> 00:00:28,890

And the second way to do it is by way of command orchestration in which there is a central component



7

00:00:29,130 --> 00:00:31,200

for managing the flow of Soga.



8

00:00:31,560 --> 00:00:36,360

The central component is referred to as the Saga Execution Coordinator.



9

00:00:36,570 --> 00:00:39,120

Let's get into the details of each of these.



10

00:00:39,810 --> 00:00:41,580

In the event choreography saga.



11

00:00:41,910 --> 00:00:50,790

The micro services emit and receive domain events and these events are then processed by each of these



12

00:00:50,790 --> 00:00:51,510

services.



13

00:00:51,660 --> 00:00:59,190

Independently services may for events of interest and react to those events in an autonomous fashion



14

00:00:59,460 --> 00:01:04,710

and as part of the transaction processing these services may emit new events.



15

00:01:05,590 --> 00:01:11,860

Although the use of even choreography leads to highly decoupled services, but there are challenges.



16

00:01:11,890 --> 00:01:16,330

The first one is that it is difficult to implement, test and debug.



17

00:01:16,450 --> 00:01:23,770

Next one is that events are omitted and consumed by each of the services in the saga in an independent



18

00:01:23,770 --> 00:01:27,160

fashion, and that can lead to out of sequence events.



19

00:01:27,550 --> 00:01:34,480

Each of the services in the event choreography needs to make sure that out of sequence events are handled



20

00:01:34,480 --> 00:01:35,110

properly.



21

00:01:35,290 --> 00:01:42,760

Handling the failure scenarios and even choreography is difficult because there is no centralized service



22

00:01:43,000 --> 00:01:50,470

coordinating the recovery from failure scenarios in a command orchestration saga implementation, a



23

00:01:50,470 --> 00:01:55,080

central component manages the calls to services in Saagar.



24

00:01:55,510 --> 00:02:02,770

There are two ways in which command orchestration saga may be built in the first method a domain object,



25

00:02:02,920 --> 00:02:09,630

which is part of the domain model X as the central component for managing the calls to other services



26

00:02:09,640 --> 00:02:10,870

in the second method.



27

00:02:10,900 --> 00:02:18,220

There is a dedicated orchestrator which is defined outside of the command module to coordinate the calls



28

00:02:18,220 --> 00:02:19,910

to services in the saga.



29

00:02:20,140 --> 00:02:25,600

This central component is sometimes referred to as the Saga Execution coordinator.



30

00:02:26,410 --> 00:02:32,200

Next, I'll discuss how a key domain object can play the role of Soga execution coordinator.



31

00:02:32,380 --> 00:02:36,040

Consider this example for the retail domain here.



32

00:02:36,490 --> 00:02:42,000

The Horrors Object can act as the execution coordinator.



33

00:02:42,010 --> 00:02:48,910

It can manage the state of the orders and take the responsibility of initiating the transaction on the



34

00:02:48,910 --> 00:02:51,400

payment and the shipment services.



35

00:02:51,400 --> 00:02:57,160

In case of failures, the orders service can coordinate with the payment and the shipment service to



36

00:02:57,160 --> 00:03:03,280

achieve order consistency across all the services for interacting with the services.



37

00:03:03,280 --> 00:03:10,510

The orders object will use the command reply pattern and will ensure that the reliable messaging pattern



38

00:03:10,510 --> 00:03:13,390

is in use so that the evens are not lost.



39

00:03:13,870 --> 00:03:20,470

All of these state management and logic will lead to a complex domain object, and this complexity is



40

00:03:20,470 --> 00:03:27,820

the reason why an external coordinator is preferred over a coordinator built into the domain object.



41

00:03:29,430 --> 00:03:34,860

The external Psagot execution coordinator is also referred to as the orchestrator.



42

00:03:35,830 --> 00:03:42,880

It is a genetic component that does not have any kind of business logic, it provides certain capabilities



43

00:03:42,880 --> 00:03:51,430

to define the flow and it carries out the invocation of the services by way of the floor defined by



44

00:03:51,430 --> 00:03:53,230

the designer of the micro services.



45

00:03:53,380 --> 00:04:00,730

It also carries out the state management in its own dedicated, persistent storage that has no relationship



46

00:04:00,970 --> 00:04:02,900

with the domain data storage.



47

00:04:03,580 --> 00:04:10,060

There are multiple external orchestrators that may be used for building saga with micro services.



48

00:04:10,120 --> 00:04:13,240

Examples are of BPM or workflow tool.



49

00:04:13,940 --> 00:04:16,020

WEF functions is another one.



50

00:04:16,180 --> 00:04:21,510

If you are using a W.S. cloud, then this is a quick way to build sagas.



51

00:04:21,560 --> 00:04:28,030

Then there are multiple frameworks in different languages for Java Sprink framework, maybe use for



52

00:04:28,030 --> 00:04:29,020

building sagas.



53

00:04:29,830 --> 00:04:34,690

Let's call the example of A.W. have functions, LWR functions.



54

00:04:34,990 --> 00:04:40,240

Let the developer define the business process by way of Jason.



55

00:04:40,840 --> 00:04:46,910

There's also a visualization tool that shows the flow of these service calls.



56

00:04:47,050 --> 00:04:54,250

Typically the business logic, which is the transaction and the compensating transactions are implemented



57

00:04:54,400 --> 00:05:02,830

in LAMDA functions, the stop function service in a enablers coordinate the execution of the transactions



58

00:05:02,830 --> 00:05:04,760

and the compensating transactions.



59

00:05:04,810 --> 00:05:11,810

This is how the Eroglu staff function workflow may look like for the vacation package booking.



60

00:05:11,860 --> 00:05:18,400

These are the services that are called as part of the saga and these are the compensating transactions



61

00:05:18,730 --> 00:05:21,270

which reverse the effect of these service calls.



62

00:05:21,310 --> 00:05:27,130

So as you can see here, we have a process payment and the refund payment is the compensating transaction



63

00:05:27,130 --> 00:05:30,850

and these are the corresponding transactions for flight.



64

00:05:30,850 --> 00:05:37,960

And currently the commander orchestrator based Saagar implementation is less decoupled compared to the



65

00:05:38,200 --> 00:05:40,410

even choreography based saga.



66

00:05:40,690 --> 00:05:44,610

Also, the command orchestrator introduces a single point of failure.



67

00:05:45,010 --> 00:05:51,670

But even with those weaknesses, command orchestrators are much more simpler to work with.



68

00:05:52,090 --> 00:05:59,740

Since there is a central component that defines the flow of the service calls, developers can quickly



69

00:05:59,770 --> 00:06:06,370

understand how the command orchestrator saga is working and as a result, they are simple to build,



70

00:06:06,760 --> 00:06:08,050

test and manage.



71

00:06:08,290 --> 00:06:15,940

Failure scenarios may also be handled much more easily in command orchestrators compared to the even



72

00:06:15,940 --> 00:06:17,680

choreography based sagas.



73

00:06:18,010 --> 00:06:25,780

Some Soga execution coordinators or workflow engines also provide a centralized way to check state of



74

00:06:25,780 --> 00:06:26,680

the flow.



75

00:06:27,820 --> 00:06:33,850

In this lesson, I talked about how to build Saga using the even choreography pattern in which there



76

00:06:33,850 --> 00:06:41,320

is no central coordinator for the flow of transactions, the other way to build Saga is to use the command



77

00:06:41,320 --> 00:06:48,430

orchestrator paradigm in which there is a component that acts as the coordinator for the flow of transactions.



78

00:06:48,430 --> 00:06:51,130

A domain object may act as the saga.



79

00:06:51,130 --> 00:06:59,350

Execution coordinator for an external computer such as workflow, engine or framework may be used as



80

00:06:59,350 --> 00:07:01,600

the saga execution coordinator.



81

00:07:01,690 --> 00:07:07,600

In the later lectures, you will see the command orchestrate a pattern in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\004 SAGA Implementation Considerations.en.srt -->

1

00:00:00,450 --> 00:00:07,140

Saagar, implementation considerations in this lesson are touched on various aspects that you need to



2

00:00:07,140 --> 00:00:14,280

think through for implementing distributed transactions using Psagot, Baton Synchronoss versus asynchronous



3

00:00:14,280 --> 00:00:23,220

court services in the Psagot may expose the command by way of apps, for example, RESTABILIZE and these



4

00:00:23,240 --> 00:00:28,550

restabilize may be invoked, but orchestrator in a synchronized fashion.



5

00:00:28,920 --> 00:00:36,100

So this is feasible, but asynchronous mechanisms such as messaging is the preferred way to go.



6

00:00:36,480 --> 00:00:42,990

So the bottom line is that whenever possible use messaging instead of synchronous protocols such as



7

00:00:43,000 --> 00:00:50,970

restaurant SCDP, each transaction in a Soga should be assigned a unique identity.



8

00:00:51,930 --> 00:00:59,460

The idea behind this unique identity is that it helps with even sourcing and the services in the saga



9

00:00:59,730 --> 00:01:03,090

may use it to identify duplicate transactions.



10

00:01:03,210 --> 00:01:04,380

The idea is simple.



11

00:01:04,530 --> 00:01:12,390

If the transaction with the specific ID has already been processed, then it doesn't need to be processed



12

00:01:12,520 --> 00:01:13,020

again.



13

00:01:13,830 --> 00:01:20,550

I'd importance is the property of certain operations in mathematics and computer science where they



14

00:01:20,550 --> 00:01:27,390

can be applied multiple times without changing the result beyond the initial application.



15

00:01:27,750 --> 00:01:32,040

This is the definition of important from Wikipedia.



16

00:01:32,790 --> 00:01:36,990

In a saga, the service transactions must be quite important.



17

00:01:37,650 --> 00:01:45,060

The unique identity given to each of the messages can help in achieving the right important behavior



18

00:01:45,240 --> 00:01:46,320

of the transactions.



19

00:01:46,680 --> 00:01:55,380

Let me explain how services may retain the processed transactions in a log when a request transaction



20

00:01:55,380 --> 00:02:02,580

is received, the service will check if the transaction ID has already been processed.



21

00:02:02,820 --> 00:02:07,470

If it has not been processed, then the transaction will be processed.



22

00:02:07,860 --> 00:02:13,050

A response will be created and saved to the database and sent back to the call.



23

00:02:13,740 --> 00:02:20,630

Now let's say another request comes in with a transaction ID that has already been processed.



24

00:02:20,760 --> 00:02:24,920

In this case, the service will not process the transaction again.



25

00:02:24,930 --> 00:02:30,420

Rather, it will pick up the pass response from the database and send it back to the caller.



26

00:02:31,530 --> 00:02:33,270

Now let's talk about failures.



27

00:02:33,540 --> 00:02:40,950

Service request failures are OK if they are followed by compensating transactions, but decompensating



28

00:02:40,950 --> 00:02:43,050

transactions cannot fail.



29

00:02:43,170 --> 00:02:45,870

They must execute successfully.



30

00:02:46,320 --> 00:02:53,160

Otherwise, the data across the micro services will get into inconsistent state in order to build the



31

00:02:53,160 --> 00:02:57,950

capability for recovering from failed compensating transactions.



32

00:02:58,350 --> 00:03:01,020

Consider using even saucing.



33

00:03:01,980 --> 00:03:09,440

In an earlier lecture, I discussed how the AWB staff functions may be used for building command orchestrator



34

00:03:09,440 --> 00:03:10,890

of this, Saagar flows.



35

00:03:11,190 --> 00:03:18,000

Now, if you're not using AWB, you may still use certain frameworks that provide the foundational components



36

00:03:18,270 --> 00:03:20,520

for building distributed transactions.



37

00:03:20,820 --> 00:03:26,610

Here are some examples of frameworks that you can use in your micro services.



38

00:03:26,640 --> 00:03:33,750

I suggest that you visit the website for these frameworks to learn how they can be leveraged for accelerating



39

00:03:33,750 --> 00:03:39,080

the development of Microsoft is it's time to go with the key points from this lesson.



40

00:03:39,210 --> 00:03:45,240

Messaging is preffered for the intercommunication between the services in a saga.



41

00:03:45,510 --> 00:03:52,980

Each transaction should have a unique identity which helps these services achieve Eitam potency.



42

00:03:53,190 --> 00:03:59,760

That means some transaction may be executed multiple times without the loss of data consistency.



43

00:03:59,790 --> 00:04:07,170

Transactions can fail, but if a transaction fails, then the compensating transactions must be executed.



44

00:04:07,470 --> 00:04:10,550

Compensating transaction itself cannot fail.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\005 Exercise _ ACME Sales Booking Transaction SAGA.en.srt -->

1

00:00:00,150 --> 00:00:07,040

In all your lectures, you have learned that achmea cells prepare multiple proposals for the customer



2

00:00:07,290 --> 00:00:10,270

when the customer confirms a proposal.



3

00:00:10,470 --> 00:00:12,840

The booking process is initiated.



4

00:00:12,840 --> 00:00:19,590

The booking process involves charging the customer's credit card and making reservations for all parts



5

00:00:19,590 --> 00:00:20,920

of the vacation package.



6

00:00:21,120 --> 00:00:26,190

In this lesson, you will learn about how the booking process may be implemented.



7

00:00:26,190 --> 00:00:31,950

Using the saga pattern will go over the success and failure scenarios in the booking.



8

00:00:31,950 --> 00:00:37,020

Saagar Flow and then you will see the booking Saagar floor in action.



9

00:00:37,620 --> 00:00:44,170

The Acme I.T. team has decided to build the booking process as a saga.



10

00:00:44,880 --> 00:00:49,890

They understand that it is difficult to implement Saga without a framework.



11

00:00:50,220 --> 00:00:57,300

So they will take an evolutionary approach in which they will be working one of booking saga without



12

00:00:57,300 --> 00:01:05,380

any framework and will keep things as simple as possible so that they can understand how the saga pattern



13

00:01:05,400 --> 00:01:05,970

works.



14

00:01:06,210 --> 00:01:12,690

This lesson discusses how they have implemented the version one of booking Saagar Float.



15

00:01:13,110 --> 00:01:19,200

The booking flow saga will consist of three services booking Soga service, payment service and the



16

00:01:19,200 --> 00:01:20,280

reservation service.



17

00:01:20,610 --> 00:01:26,150

Each of these services will maintain their state in a separate database for this version.



18

00:01:26,160 --> 00:01:31,800

One implementation, instead of maintaining the state in separate databases, will maintain the state



19

00:01:31,800 --> 00:01:34,170

and the collections in a common database.



20

00:01:34,350 --> 00:01:41,460

The saga is initiated when a transaction is invoked on the booking saga service, the search for adding



21

00:01:41,460 --> 00:01:42,320

the booking.



22

00:01:42,840 --> 00:01:49,200

This will lead to the mitting of an event which will be received by both the payment service and reservation



23

00:01:49,200 --> 00:01:49,650

service.



24

00:01:49,860 --> 00:01:56,010

Reservation service will ignore this even, whereas the payment service will execute the transaction



25

00:01:56,010 --> 00:01:59,550

for processing the payment on successful processing of payment.



26

00:01:59,700 --> 00:02:06,420

The payment service will permit an event which will be received by the reservation service and in response



27

00:02:06,420 --> 00:02:12,290

to the successful payment, the reservation service will execute the transaction to process the reservations.



28

00:02:12,300 --> 00:02:17,940

If everything goes fine, then the booking will be confirmed in the booking saga.



29

00:02:18,450 --> 00:02:25,770

But let's say there is a failure in reservation service, in which case the reservations that were successful



30

00:02:25,980 --> 00:02:32,430

will be cancelled and an event will be omitted by the reservation service, which will be received by



31

00:02:32,430 --> 00:02:35,090

both the booking saga and the payment service.



32

00:02:35,340 --> 00:02:41,400

The payment service will refund the payment to the customer since the reservations were unsuccessful



33

00:02:41,400 --> 00:02:45,210

and the booking saga will mark the booking as failed.



34

00:02:46,080 --> 00:02:52,440

Next, let's call it a scenario in which all of the transactions in the booking saga flow were successful.



35

00:02:52,920 --> 00:02:58,410

The booking Saagar Flow gets triggered when a booking is added to the booking.



36

00:02:58,410 --> 00:03:04,410

Saagar service the booking, Saagar Service, Emmet's and even even booking added.



37

00:03:04,920 --> 00:03:07,440

This event is received by the payment service.



38

00:03:07,440 --> 00:03:10,860

The payment service carries out the processing of the payment.



39

00:03:10,950 --> 00:03:14,160

It charges the customer's credit card.



40

00:03:14,310 --> 00:03:21,570

Successful processing leads to the mitting of the Payment Success event, which is received by the reservation



41

00:03:21,570 --> 00:03:22,050

service.



42

00:03:22,050 --> 00:03:26,190

The reservation service carries out the processing of the reservations.



43

00:03:26,550 --> 00:03:33,840

For example, if the package contains hotel and car rental, it will carry out the reservation for both



44

00:03:34,230 --> 00:03:35,940

the hotel and the car rental.



45

00:03:36,180 --> 00:03:43,230

If all other reservations are successful, it omits the reservation success event, which is received



46

00:03:43,230 --> 00:03:46,590

by both the Booking Saagar service and the payment service.



47

00:03:46,590 --> 00:03:51,840

The Booking Saagar Service on receiving even reservation success event marks.



48

00:03:51,840 --> 00:03:53,450

The booking is successful.



49

00:03:54,420 --> 00:03:58,140

Next, let's call what a scenario in which the payment service failed.



50

00:03:58,260 --> 00:04:05,070

So Booking Saagar Service omits the even booking added the payment service tries to process it and there



51

00:04:05,070 --> 00:04:05,820

is a failure.



52

00:04:06,210 --> 00:04:14,100

So the payment service executes a compensating transaction and omits the payment, failed even which



53

00:04:14,100 --> 00:04:15,450

is received by the booking.



54

00:04:15,450 --> 00:04:17,070

Saagar Service the booking.



55

00:04:17,070 --> 00:04:20,480

Saagar Service marks the booking as failed.



56

00:04:20,700 --> 00:04:27,630

Next, let's consider the scenario in which the reservations service failed booking Saagar Service Emmott's.



57

00:04:27,630 --> 00:04:31,740

The booking added, which is received by the payment service.



58

00:04:31,740 --> 00:04:37,830

The payment service carries out the processing and gets the even payment success which is received by



59

00:04:37,830 --> 00:04:39,810

the reservations service.



60

00:04:40,290 --> 00:04:46,530

The reservations service tries to resolve the various parts of the vacation package.



61

00:04:46,530 --> 00:04:53,490

For example, if the vacation package consists of car rental and hotel to try to resolve both the car



62

00:04:53,490 --> 00:04:54,990

rental as well as the hotel.



63

00:04:55,290 --> 00:04:59,370

If all reservations are successful, then the reservation.



64

00:04:59,710 --> 00:05:07,750

Considers that as a successful transaction, if any one of the reservations failed, then the reservation



65

00:05:07,750 --> 00:05:10,760

service considers that as a failure.



66

00:05:10,870 --> 00:05:17,740

In this scenario, let's say the car rental was successful, but the hotel rental was not successful



67

00:05:17,740 --> 00:05:18,770

in that scenario.



68

00:05:19,300 --> 00:05:26,110

The reservation service will execute the compensating transaction to cancel the reservation for the



69

00:05:26,110 --> 00:05:26,800

car rental.



70

00:05:27,160 --> 00:05:34,660

And then amid the event, reservation failed, which will be received by both the payment service and



71

00:05:34,660 --> 00:05:36,040

the booking Saagar service.



72

00:05:36,040 --> 00:05:40,380

And both of these services will then execute their compensating transaction.



73

00:05:40,810 --> 00:05:46,260

The booking Saagar Service will mark the booking as field next.



74

00:05:46,270 --> 00:05:49,570

Let's talk about the implementation stock for the booking.



75

00:05:49,570 --> 00:05:50,320

Saagar Flow.



76

00:05:50,470 --> 00:05:57,220

In the version one of the implementation, a common topic will be used for all events.



77

00:05:57,550 --> 00:05:59,900

The name of the topic is booking saga.



78

00:06:00,220 --> 00:06:06,420

Recall that if you are using Cloud COFCO, we need to follow this naming convention for the topic.



79

00:06:06,440 --> 00:06:10,540

All of the events will be published with the key Sacto booking it.



80

00:06:10,750 --> 00:06:17,230

And what that means is that for a specific booking, all of the events will end up in the same partition



81

00:06:17,560 --> 00:06:20,500

and the order of the events will be guaranteed.



82

00:06:20,920 --> 00:06:27,610

Each of the services maintain their own state and independent collections in a common mongerer with



83

00:06:27,610 --> 00:06:30,100

their office that we already have in place.



84

00:06:30,100 --> 00:06:37,480

In later versions, you may consider implementing this floor with multiple topics and multiple databases.



85

00:06:37,480 --> 00:06:42,190

But please keep in mind in version one, we are going with a common database and a common topic.



86

00:06:42,910 --> 00:06:47,440

Before I show you the booking saga in action, let me show you how it's implemented.



87

00:06:47,710 --> 00:06:50,200

There are three main service classes, the booking.



88

00:06:50,200 --> 00:06:53,530

Saagar Class manages the state of the booking saga.



89

00:06:54,040 --> 00:07:01,240

The payments service simulates the processing of payments and the reservation service simulates the



90

00:07:01,240 --> 00:07:02,710

processing of reservations.



91

00:07:02,950 --> 00:07:10,810

Deran Saagar Test Class executes the ad booking transaction on the booking SAAGAR Service to initiate



92

00:07:10,810 --> 00:07:12,790

the flow of the booking saga.



93

00:07:12,910 --> 00:07:16,210

I've already created a topic on cloud traffick.



94

00:07:16,510 --> 00:07:24,370

This topic is used for publishing of events from the booking Saagar Repository Payment Repository and



95

00:07:24,370 --> 00:07:25,780

Reservation Repository.



96

00:07:26,170 --> 00:07:28,720

The three services listen for the events.



97

00:07:29,110 --> 00:07:36,160

So the booking SAAGAR class, the payment service and the reservation service are implemented as message



98

00:07:36,160 --> 00:07:38,030

handlers for the topic.



99

00:07:38,140 --> 00:07:44,380

All are the repository classes, extend the manually based class, write and read from their respective



100

00:07:44,380 --> 00:07:48,370

collections in the travel database and Mongo DB.



101

00:07:48,490 --> 00:07:50,740

So let's go ahead and see the booking.



102

00:07:50,740 --> 00:07:54,550

Saagar flow and action as a first step.



103

00:07:54,550 --> 00:08:01,790

I'm going to launch the three services that are part of the Saga Booking Saga, Payment Service and



104

00:08:01,790 --> 00:08:03,820

the reservation service.



105

00:08:04,090 --> 00:08:06,730

While this is launching, let me show you the topic.



106

00:08:07,060 --> 00:08:10,030

This is the topic to which these services will publish.



107

00:08:10,480 --> 00:08:19,600

Click on the browser and we're going to listen to the messages on this topic consume and all the messages



108

00:08:19,720 --> 00:08:22,660

which will be published by the three services will appear over here.



109

00:08:22,870 --> 00:08:29,290

Now, the test, we will use the run, Saagar, to service set the booking idea to one well executed



110

00:08:29,300 --> 00:08:29,560

run.



111

00:08:29,560 --> 00:08:30,490

Saagar test.



112

00:08:30,790 --> 00:08:38,680

It is going to trigger a transaction on the booking saga object and that will start the flow of events.



113

00:08:38,800 --> 00:08:41,710

So let's go ahead and execute.



114

00:08:41,710 --> 00:08:42,070

Run.



115

00:08:42,070 --> 00:08:46,450

Saagar, Test will watch for the events appearing in the consumer here.



116

00:08:46,720 --> 00:08:50,950

This is our first event came from the booking saga object.



117

00:08:51,100 --> 00:08:57,640

The event is booking added and then the payment processor picked up the event, successfully processed



118

00:08:57,640 --> 00:09:02,290

the payment, omitted the even booking payment success, not even booking payment.



119

00:09:02,290 --> 00:09:09,610

Success was picked up by the reservation service and it simulated a successful reservation that led



120

00:09:09,610 --> 00:09:15,370

to the admitting of even booking reservation success, which was then picked up by the booking Saagar



121

00:09:15,670 --> 00:09:20,020

and booking saga then omitted the even booking confirmed.



122

00:09:20,440 --> 00:09:23,740

The key here, as you can observe, is the booking ID one.



123

00:09:24,430 --> 00:09:29,200

Each of the three services created a collection in the travel database.



124

00:09:29,500 --> 00:09:31,540

This is the collection for booking Psagot.



125

00:09:31,840 --> 00:09:35,980

And as you can see here, we have the information on the booking.



126

00:09:35,980 --> 00:09:40,030

The booking it is one the current state is booking confirmed.



127

00:09:40,360 --> 00:09:47,200

So the next step will try to simulate a failure in the reservation to see how the compensations will



128

00:09:47,200 --> 00:09:47,560

work.



129

00:09:48,250 --> 00:09:55,090

To simulate failure on reservation, click on reservation service and you see the similar success.



130

00:09:55,090 --> 00:09:56,380

Person 65.



131

00:09:56,380 --> 00:09:58,480

That means 65 percent of the time.



132

00:09:59,150 --> 00:10:02,590

There will be a successful reservation, so let me change this to zero.



133

00:10:02,680 --> 00:10:06,000

So what that means is that there is a 100 percent chance of failure.



134

00:10:06,010 --> 00:10:13,690

So we will kill the reservation service so that this change is picked up, rerun it, go back to run,



135

00:10:13,690 --> 00:10:14,110

Saagar.



136

00:10:14,120 --> 00:10:20,530

Test changes to, let's say to and we are ready to run our test before running this test.



137

00:10:20,680 --> 00:10:26,650

Let's go back to the console, click on Consumer again so that the earlier messages are clear.



138

00:10:26,710 --> 00:10:30,420

Now we are ready to run the test, go back to the browser.



139

00:10:30,580 --> 00:10:37,570

It is the even booking and payment processors processing and the payment processor was successful,



140

00:10:37,810 --> 00:10:40,150

amateur even booking payment success.



141

00:10:40,300 --> 00:10:47,470

And here is the event booking reservation failure, which was picked up by both booking Psagot and the



142

00:10:47,650 --> 00:10:50,320

payment service booking saga ATM.



143

00:10:50,330 --> 00:10:53,680

The even booking failed in the booking saga collection.



144

00:10:54,100 --> 00:10:59,890

As you can see, the current state is booking fair for booking it too.



145

00:11:00,130 --> 00:11:06,400

If you look at the reservations, the success flag for booking it to, it's hard to fault the confirmation



146

00:11:06,400 --> 00:11:09,610

code is set to fail the payment collection.



147

00:11:09,700 --> 00:11:10,960

We should see a refund.



148

00:11:10,960 --> 00:11:18,550

And as you can see here, the transaction was successful, but it was eventually refunded as a result



149

00:11:18,550 --> 00:11:20,320

of the failure of reservations.



150

00:11:20,320 --> 00:11:24,330

So our saga seemed to be working in the next lesson.



151

00:11:24,490 --> 00:11:29,980

I'll walk you through the code and design of the booking saga implementation.



152

00:11:30,190 --> 00:11:36,460

I'll also show you the steps that we need to carry out in order for testing out this floor locally.



153

00:11:36,460 --> 00:11:38,260

So join me in the next lesson.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14 Managing Distributed Transactions with SAGA\006 Hands On _ UML & Code walkthrough of Booking SAGA.en.srt -->

1

00:00:00,090 --> 00:00:07,080

Booking saga, implementation walkthrough in this lecture, I'll provide you an overview of the classes



2

00:00:07,260 --> 00:00:08,970

and the implementation.



3

00:00:09,330 --> 00:00:15,600

Then I'll give you a quick walkthrough of the court, followed by the steps that you can carry out for



4

00:00:15,600 --> 00:00:17,310

testing the booking.



5

00:00:17,310 --> 00:00:20,000

Saagar, flow locally in your environment.



6

00:00:20,730 --> 00:00:25,380

The booking saga implementation uses Mongo, DB and COFCO.



7

00:00:25,950 --> 00:00:33,930

The assumption here is that you've already set up the Akhmatova's database on your cloud Mongo DB instance



8

00:00:34,500 --> 00:00:40,020

and you're Mongolia based class pointing to your own Akhmatova's database.



9

00:00:40,320 --> 00:00:47,730

The other assumption is that you have already set up an account on Cloud Karaka and the interface Kafka



10

00:00:47,730 --> 00:00:51,280

configuration is pointing to your own coffeecake cluster.



11

00:00:51,300 --> 00:00:58,380

Both of these setups were discussed in earlier lectures in the package conrod achmad or simulation not.



12

00:00:58,860 --> 00:01:06,180

There is an interface by the name booking Saagar topic that has our final static variable that points



13

00:01:06,180 --> 00:01:09,120

to the name of the topic in Kafka.



14

00:01:09,150 --> 00:01:14,760

This topic will be used by all of the services in the Saagar flow around.



15

00:01:14,760 --> 00:01:23,540

Saagar Test executes the ad booking on the booking repository to initiate the booking Saagar Flow.



16

00:01:24,630 --> 00:01:30,450

Each time you execute the run Saagar test, you must provide a different booking ID.



17

00:01:30,840 --> 00:01:37,590

If you use the same booking ID, the transaction will be ignored and you will not see any even flowing



18

00:01:37,590 --> 00:01:38,700

through the booking saga.



19

00:01:39,270 --> 00:01:39,650

They don't.



20

00:01:39,900 --> 00:01:45,360

A test class has a main function wherein we are setting the booking ID.



21

00:01:45,660 --> 00:01:50,400

Every time you run this class, make sure you change that to a different booking ID.



22

00:01:50,760 --> 00:01:55,110

Otherwise you will not see the in action to initiate the flow.



23

00:01:55,710 --> 00:02:02,730

A new instance of the booking Soga repository is getting created and a new booking is getting added



24

00:02:02,880 --> 00:02:04,600

by way of this repository.



25

00:02:05,010 --> 00:02:10,470

This is how the flow gets kicked off in the booking Saagar topic.



26

00:02:10,770 --> 00:02:16,170

You will see the variable that holds the name of the Kafka topic.



27

00:02:16,170 --> 00:02:18,030

I've already created that topic.



28

00:02:18,390 --> 00:02:25,770

And once you will create the topic, you need to make sure that the name of the topic matches with this



29

00:02:25,770 --> 00:02:26,370

variable.



30

00:02:26,790 --> 00:02:33,390

Otherwise your events will be lost and you will not see the fly in action in the package.



31

00:02:33,390 --> 00:02:36,870

Kamelot, Achmad or dissimulation, not Saagar or booking.



32

00:02:37,290 --> 00:02:39,030

There are two classes of interest.



33

00:02:39,660 --> 00:02:45,630

The Booking Saagar class is the saga execution coordinator.



34

00:02:46,410 --> 00:02:50,550

It handles events from all of the components.



35

00:02:51,090 --> 00:02:55,650

So these are the list of events which this class is handling.



36

00:02:56,250 --> 00:03:01,050

The booking Saagar Repository extends the Mongo DB based class.



37

00:03:01,260 --> 00:03:05,790

It takes care of managing the state of the booking in the booking.



38

00:03:05,790 --> 00:03:06,720

Saagar Collection.



39

00:03:07,140 --> 00:03:10,890

The repository also omits appropriate events.



40

00:03:10,890 --> 00:03:14,970

And these are the events which get omitted from the booking.



41

00:03:14,970 --> 00:03:16,100

Saagar Repository.



42

00:03:16,230 --> 00:03:21,570

This interface has the definition of all the states that the booking transitions to.



43

00:03:21,870 --> 00:03:25,950

Let's take a look at the state diagram when the booking is added to the booking.



44

00:03:25,950 --> 00:03:29,160

Psagot, IT state is set to payment pending.



45

00:03:29,550 --> 00:03:34,980

If the payment fails to process, then the state is set to booking fail.



46

00:03:35,190 --> 00:03:41,700

If the payment is successful, the state of the booking is set to reservation pending a failure of reservation



47

00:03:41,700 --> 00:03:48,840

leads to the booking failed state and a successful reservation leads to the booking conformed state.



48

00:03:49,590 --> 00:03:53,160

The booking Saagar class implements the Kafka message handle.



49

00:03:53,280 --> 00:03:57,540

A bulk of the code in this class is in the handle function.



50

00:03:57,720 --> 00:04:04,860

The handle function is receiving events from the payment service and the reservation service based on



51

00:04:04,860 --> 00:04:05,400

the event.



52

00:04:05,520 --> 00:04:10,350

Either the transaction gets executed or the compensating transaction gets executed.



53

00:04:10,740 --> 00:04:15,750

The logic for these transactions and compensating transactions are in the booking.



54

00:04:15,750 --> 00:04:19,470

Saagar Repository that extends the Mongo DV based class.



55

00:04:19,890 --> 00:04:26,430

I suggest that you go to this class on your own as it is very similar to other repositories.



56

00:04:27,360 --> 00:04:29,880

Next, I'll discuss this service similar to class.



57

00:04:29,880 --> 00:04:36,330

This class is available in the common or simulation Saagar util package.



58

00:04:36,660 --> 00:04:41,160

As the name suggests, it helps in the simulation of a service.



59

00:04:41,490 --> 00:04:43,710

It will become clear once you will see its use.



60

00:04:43,710 --> 00:04:52,020

But at a high level, it introduces a delay by a random duration under ten seconds and it has a single



61

00:04:52,020 --> 00:04:55,380

function similar that takes a single argument.



62

00:04:55,380 --> 00:04:59,760

Success percent if you pass the success percent as one hundred.



63

00:05:00,130 --> 00:05:06,130

That would mean that the service assimilation will return to true, which indicates 100 percent success



64

00:05:06,670 --> 00:05:15,050

if you pass and let's say success percentage of 50, then the chance of success and failure are 50 percent.



65

00:05:15,670 --> 00:05:22,420

And if a true is returned from this similar function, then it is an indication of service success.



66

00:05:22,420 --> 00:05:27,070

Otherwise, it's a failure to set 100 percent chance of failure.



67

00:05:27,400 --> 00:05:35,560

Certainly success person to zero things will become clear, as you will see the implementation of payment



68

00:05:35,560 --> 00:05:37,630

service and reservation service.



69

00:05:38,850 --> 00:05:45,630

It is the call for service similar to Klosters, one static function and it similar that takes the success



70

00:05:45,630 --> 00:05:47,170

percent as the argument.



71

00:05:47,220 --> 00:05:54,570

This is where the heart goes to sleep for random duration under 10 seconds or ten thousand milliseconds.



72

00:05:54,900 --> 00:06:01,740

This code uses Maddog Random to decide whether it'll be a successful call or a failure call.



73

00:06:02,190 --> 00:06:08,310

Payment service and the reservation service are implemented on the same lines as the booking SAAGAR



74

00:06:08,310 --> 00:06:14,610

service they will to implement COFCO Message Handler and they both process even's of their interest.



75

00:06:14,620 --> 00:06:21,650

For example, the payment service listens for even booking added and the even booking reservation for



76

00:06:21,900 --> 00:06:28,740

events, the payment repository and the reservation repository extend the Mongo DB based class.



77

00:06:28,740 --> 00:06:36,930

They provide the functions for managing the estate of payment and the state of reservation for the specific



78

00:06:36,930 --> 00:06:40,110

booking identified by way of the booking ID.



79

00:06:40,610 --> 00:06:46,230

It is the code for payment service that implements the COFCO message handler.



80

00:06:46,500 --> 00:06:49,740

It is the handle function that takes care of two events.



81

00:06:49,740 --> 00:06:56,760

When the event booking added event is received, it executes the transaction for processing the payment



82

00:06:57,180 --> 00:07:04,380

when the booking reservation failure to receive it executes the compensating transaction to reform the



83

00:07:04,380 --> 00:07:06,630

customer in the process payment transaction.



84

00:07:06,660 --> 00:07:09,350

The service simulator is getting used.



85

00:07:09,510 --> 00:07:16,860

Similar function is called with similar success person and that decides the chance of payment processing,



86

00:07:16,860 --> 00:07:18,080

success or failure.



87

00:07:18,240 --> 00:07:20,640

This variable can be set here.



88

00:07:20,730 --> 00:07:28,140

At this point it is set to seventy five, which means that the service simulator will simulate success.



89

00:07:28,290 --> 00:07:32,850

Seventy five percent of the time this class uses the payment repository.



90

00:07:32,850 --> 00:07:36,600

The code in the payment repository is very similar to other repositories.



91

00:07:36,870 --> 00:07:39,360

So please take a look at it on your own.



92

00:07:39,660 --> 00:07:46,380

In the reservation service you will see that we have the similar success person set to sixty five,



93

00:07:46,890 --> 00:07:52,200

meaning that reservation service will be successful sixty five percent of the time.



94

00:07:52,200 --> 00:07:55,530

This class also implements the COFCO message handler.



95

00:07:55,530 --> 00:08:02,220

Here is the handle function that processes the even booking payment success by executing the process



96

00:08:02,220 --> 00:08:08,760

reservation function, which again is using the service similar to class in the last lecture or demonstrated



97

00:08:08,970 --> 00:08:10,920

the working of the booking.



98

00:08:10,920 --> 00:08:11,910

Saagar Flow.



99

00:08:11,940 --> 00:08:16,470

At this time, I'll describe the steps that you can carry out to test out the booking.



100

00:08:16,470 --> 00:08:19,050

Saagar flow locally in your environment.



101

00:08:19,440 --> 00:08:24,000

The first step would be to set up the topic booking saga.



102

00:08:24,630 --> 00:08:31,020

The assumption here is that you're using cloud traffick in the second step, launched the COFCO Consumer



103

00:08:31,380 --> 00:08:33,000

on the Cloud Kafka.



104

00:08:33,330 --> 00:08:39,480

Here you will be able to observe all the events being omitted in the third step, launched the booking,



105

00:08:39,480 --> 00:08:42,000

Saagar Payment Service and Reservation Service.



106

00:08:42,270 --> 00:08:45,510

Each of these have a main function in the forward step.



107

00:08:45,810 --> 00:08:47,580

Execute the run Saagar.



108

00:08:47,580 --> 00:08:52,310

Test with different booking IDs after executing the run Saagar Test.



109

00:08:52,320 --> 00:08:55,680

Observe the Even's flowing in the consumer.



110

00:08:56,160 --> 00:09:03,030

You will also be able to check out the data and the collections in the Akhmatova's database on the cloud



111

00:09:03,030 --> 00:09:04,470

mongered instance.



112

00:09:04,620 --> 00:09:10,440

At this time, I suggest that you try out the booking, Saagar, flow in your environment.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000001.srt -->

1
00:00:00,120 --> 00:00:08,640
Trong các phần trước, bạn biết rằng không phải lúc nào các dịch vụ vi mô cũng có thể sử dụng để đối mặt với Cummock để quản lý giao dịch.

2
00:00:09,270 --> 00:00:17,940
Cách khác là sử dụng mẫu saga.  Thách thức khi xây dựng sagas là chúng rất phức tạp.

3
00:00:18,390 --> 00:00:29,050
Nhưng tin tốt là có sẵn các khuôn khổ để hiện thực hóa sagas.  Các khung này che giấu tất cả sự phức tạp cần thiết để hiện thực hóa mẫu này.

4
00:00:29,460 --> 00:00:38,120
Tôi đã quyết định không sử dụng bất kỳ khuôn khổ nào và lý do là vì tôi muốn cho bạn thấy hoạt động bên trong của mẫu Saagar.

5
00:00:38,490 --> 00:00:45,840
Chúng ta hãy đi qua các mục tiêu học tập cho phần này.  Bạn học mô hình saga.  Bạn sẽ tìm hiểu các loại mẫu Saagar.

6
00:00:46,110 --> 00:00:51,420
Có nhiều cân nhắc triển khai mà bạn cần lưu ý khi xây dựng sagas.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000002.srt -->

1
00:00:00,420 --> 00:00:12,560
Tính nhất quán trong các giao dịch của nhà phân phối trong một trong những bài giảng trước đó được tiết lộ cho Facebook, bài giảng này có thể được sử dụng để quản lý tính nhất quán của dữ liệu trong một cơ sở dữ liệu duy nhất.

2
00:00:12,960 --> 00:00:19,740
Nhưng trong trường hợp giao dịch phân tán, có thể có nhiều cơ sở dữ liệu trên nhiều dịch vụ vi mô.

3
00:00:19,920 --> 00:00:39,030
Trong bài học này, tôi sẽ thảo luận về những thách thức liên quan đến việc quản lý tính nhất quán của dữ liệu trên các dịch vụ vi mô và sau đó tôi sẽ giới thiệu cho bạn mẫu Psagot cung cấp giải pháp quản lý tính nhất quán của dữ liệu trên các dịch vụ vi mô được thiết kế để tránh lỗi.

4
00:00:39,030 --> 00:00:58,380
Nguyên tắc gợi ý rằng bạn nên luôn lường trước những thất bại sẽ xảy ra.  Bạn nên chủ động xác định các điểm lỗi trong kiến ​​trúc của mình liên quan đến các thành phần phân tán hoặc dịch vụ vi mô, sau đó bạn nên giải quyết tất cả các điểm lỗi trong kiến ​​trúc của mình.

5
00:00:58,440 --> 00:01:17,400
Đây là cách thực hành tốt nhất để xây dựng hệ thống phân tán.  Ý tưởng là vì mỗi dịch vụ vi mô có cơ sở dữ liệu riêng nên nếu không giải quyết được lỗi, điều đó sẽ dẫn đến trạng thái dữ liệu không nhất quán trên nhiều cơ sở dữ liệu do dịch vụ vi mô sở hữu.

6
00:01:17,460 --> 00:01:25,560
Điều này cần phải tránh bằng mọi giá.  Tôi sẽ cho bạn một ví dụ.  Hãy xem xét ví dụ này về một trang web thương mại điện tử.

7
00:01:26,100 --> 00:01:50,120
Khách hàng thanh toán cho đơn hàng.  Dịch vụ ô tô chuyển đơn đặt hàng vào cơ sở dữ liệu đơn đặt hàng và sau đó đưa ra một sự kiện mà dịch vụ thanh toán nhận được để xử lý thanh toán sau khi thanh toán được xử lý thành công, dịch vụ thanh toán sẽ thêm thông tin đơn hàng cùng với thông tin thanh toán của chính nó.  cơ sở dữ liệu.

8
00:01:50,390 --> 00:02:00,230
Sau đó, dịch vụ vận chuyển sẽ được gọi.  Dịch vụ vận chuyển cố gắng thêm thông tin đơn hàng và thông tin lô hàng vào cơ sở dữ liệu của chính dịch vụ đó.

9
00:02:00,230 --> 00:02:10,870
Và giả sử kết quả là phần chèn bị lỗi.  Hiện tại, dữ liệu lô hàng không đồng bộ với dữ liệu thanh toán và dữ liệu đơn hàng.

10
00:02:11,150 --> 00:02:20,540
Tác động thực sự của tình huống này là khách hàng đã thanh toán cho các mặt hàng nhưng khách hàng này sẽ không bao giờ nhận được đơn đặt hàng và kết quả của họ.

11
00:02:20,550 --> 00:02:29,680
Chúng tôi sẽ có một khách hàng không hài lòng và một trang web không đáp ứng được những tình huống thất bại như vậy sẽ không thể tồn tại lâu.

12
00:02:31,160 --> 00:02:40,220
Người thiết kế hệ thống phân tán phải đảm bảo rằng dữ liệu nhất quán trên tất cả các dịch vụ phân tán hoặc dịch vụ vi mô.

13
00:02:40,700 --> 00:02:49,060
Trở lại ví dụ về website thương mại điện tử.  Điều này có nghĩa là đơn hàng phải được đánh dấu thành công trong cả ba cơ sở dữ liệu.

14
00:02:49,340 --> 00:03:03,770
Nếu xảy ra lỗi, giả sử cơ sở dữ liệu lô hàng được thực hiện, lỗi đó sẽ dẫn đến thay đổi trạng thái và khoản thanh toán của cơ sở dữ liệu khác sẽ được hoàn lại cho khách hàng và đơn hàng sẽ được đánh dấu là không thành công.

15
00:03:03,980 --> 00:03:15,080
Khách hàng phải được thông báo hoặc dịch vụ đặt hàng phải được thử vào cuối ngày.  Trạng thái của đơn hàng phải nhất quán trên cả ba cơ sở dữ liệu.

16
00:03:15,230 --> 00:03:28,400
Tất cả đều có thể thành công hoặc đều có thể thất bại, nhưng nó không thể là sự kết hợp giữa thành công và thất bại.  Một điểm quan trọng cần ghi nhớ là các giao dịch cục bộ không thể được sử dụng để tránh trạng thái của cơ sở dữ liệu.

17
00:03:28,550 --> 00:03:37,880
Vì vậy, trong trường hợp này, dịch vụ thanh toán và đơn hàng hoặc dịch vụ không thể sử dụng các giao dịch cơ sở dữ liệu cục bộ để khôi phục các thay đổi trong cơ sở dữ liệu.

18
00:03:38,930 --> 00:03:50,780
Saga Pattern cung cấp giải pháp quản lý tính nhất quán của dữ liệu trên các dịch vụ vi mô.  Nó liên quan đến việc sử dụng các giao dịch địa phương cùng với các giao dịch bù đắp.

19
00:03:51,230 --> 00:04:08,930
Hãy để tôi giải thích nó bằng một minh họa.  Giả sử chúng ta có ba dịch vụ vi mô.  Luồng giao dịch bắt đầu bằng việc gọi API trên CNTT của Microsoft, trong đó có giao dịch T1 được thực thi và đó là giao dịch cục bộ dựa trên cơ sở dữ liệu.

20
00:04:08,990 --> 00:04:21,710
Giao dịch này dẫn đến việc gửi một sự kiện được Microsoft nhận dưới dạng B và phản hồi lại Giao dịch B Thực thi T2 của Microsoft đối với cơ sở dữ liệu cục bộ của nó.

21
00:04:21,710 --> 00:04:32,970
T2 dẫn đến cuộc họp của sự kiện, được Microsoft nhận dưới dạng C và để đáp lại, Microsoft C thực thi Giao dịch D ba đối với cơ sở dữ liệu cục bộ của nó.

22
00:04:32,990 --> 00:04:44,740
Cho đến nay, mọi thứ vẫn ổn và dữ liệu có trạng thái không nhất quán trên cả ba cơ sở dữ liệu.  Lúc này mỗi giao dịch này sẽ có một giao dịch bù trừ tương ứng.

23
00:04:44,750 --> 00:05:03,410
Vai trò của các giao dịch đền bù này là thưởng cho những thay đổi trong cơ sở dữ liệu.  Và cách giải quyết là khi giao dịch xảy ra lỗi, chẳng hạn như nếu giao dịch xảy ra lỗi, giao dịch bù trừ T-3 sẽ được thực thi và một sự kiện sẽ bị bỏ qua.

24
00:05:03,440 --> 00:05:15,020
Sự kiện này sẽ được Microsoft tiếp nhận dưới dạng A và B, sau đó mỗi dịch vụ vi mô này sẽ thực hiện các giao dịch đền bù tương ứng của chúng.

25
00:05:15,200 --> 00:05:24,020
Vì vậy, nó sẽ thực thi C một và B sẽ thực thi C hai để đảo ngược các thay đổi trong cơ sở dữ liệu tương ứng của chúng.

26
00:05:24,020 --> 00:05:32,450
Và thông qua các giao dịch đền bù này, tính nhất quán của dữ liệu sẽ đạt được trên cả ba cơ sở dữ liệu.

27
00:05:32,480 --> 00:05:43,480
Vì vậy, điều này có nghĩa là mỗi giao dịch sẽ yêu cầu một giao dịch bù tương ứng.  Hãy để tôi cho bạn một ví dụ về các giao dịch bù đắp.

28
00:05:43,700 --> 00:05:57,570
Hãy xem xét kịch bản thương mại điện tử này trong đó chúng ta có ba dịch vụ hoặc dịch vụ vi mô, nhận đơn đặt hàng từ khách hàng và sau đó dẫn đến yêu cầu giao dịch về dịch vụ thanh toán và dịch vụ kiểm kê.

29
00:05:57,590 --> 00:06:11,200
Vì vậy, dịch vụ đặt hàng sẽ có một giao dịch mà tôi có đơn đặt hàng vào cơ sở dữ liệu cục bộ của nó và sẽ có một giao dịch bù tương ứng để xóa đơn hàng khỏi cơ sở dữ liệu cục bộ hoặc đánh dấu đơn hàng là không thành công.

30
00:06:11,480 --> 00:06:19,430
Dịch vụ thanh toán sẽ có một giao dịch dẫn đến việc tính phí thẻ tín dụng và cập nhật cơ sở dữ liệu địa phương.

31
00:06:19,610 --> 00:06:30,950
Và giao dịch bồi thường tương ứng sẽ là cải tổ thẻ tín dụng và thực hiện các thay đổi đối với cơ sở dữ liệu địa phương để phản ánh rằng khoản phí đã được hoàn lại.

32
00:06:31,250 --> 00:06:48,710
Dịch vụ kiểm kê sẽ có giao dịch giảm số lượng mặt hàng và nếu dịch vụ thanh toán xảy ra lỗi thì giao dịch bù trừ tương ứng trong dịch vụ kiểm kê sẽ tăng số lượng mặt hàng cho đơn hàng bị hoàn tiền hoặc bị hủy.

33
00:06:48,980 --> 00:06:58,900
Mẫu Saagar có thể được áp dụng cho các hệ thống nguyên khối và phân tán.  Khi mẫu câu chuyện được áp dụng cho các hệ thống phân tán, đôi khi nó được gọi là câu chuyện phân tán.

34
00:06:59,240 --> 00:07:08,630
Trong trường hợp này, tôi sẽ sử dụng Soga và phân phối Saga thay thế cho nhau.  Nhưng trong bối cảnh dịch vụ vi mô, chúng tôi đang đề cập đến các dịch vụ phân tán.

35
00:07:08,780 --> 00:07:16,270
Saagar Parathion không phải là mới.  Nó được giới thiệu trong một bài báo xuất bản năm 87.  Đó là liên kết đến bài báo.

36
00:07:16,580 --> 00:07:23,420
Nếu bạn muốn tìm hiểu sâu hơn về mô hình này.  Trong bài học này tôi giới thiệu với các bạn mẫu Psagot.

37
00:07:23,420 --> 00:07:52,150
Mẫu Saga được sử dụng để quản lý tính nhất quán của dữ liệu trên các dịch vụ vi mô.  Nó liên quan đến việc sử dụng.  Các giao dịch cục bộ để duy trì dữ liệu giao dịch đến cơ sở dữ liệu và liên quan đến việc sử dụng các giao dịch bù để thu hồi, cơ sở dữ liệu thay đổi trong trường hợp thất bại, lý do giao dịch bù được sử dụng là vì không thể sử dụng khôi phục giao dịch cơ sở dữ liệu để thu hồi  .

38
00:07:52,450 --> 00:08:00,250
Cơ sở dữ liệu thay đổi trong bài học tiếp theo.  Tôi sẽ thảo luận về những cách khác nhau mà mô hình Taga có thể được hiện thực hóa.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000003.srt -->

1
00:00:00,180 --> 00:00:11,130
Có hai cách để xây dựng, Saagar, than chảy trong bài học này.  Tôi sẽ thảo luận về cách xây dựng các biện pháp bảo vệ bằng cách sử dụng cả vũ đạo và người điều phối chỉ huy.

2
00:00:11,610 --> 00:00:22,170
Asaka được thực hiện theo hai cách.  Cách đầu tiên là sử dụng cái được gọi là tai và vũ đạo trong đó không có thành phần trung tâm nào để quản lý các giao dịch.

3
00:00:22,470 --> 00:00:31,200
Và cách thứ hai để làm điều đó là bằng cách điều phối mệnh lệnh trong đó có thành phần trung tâm để quản lý dòng Soga.

4
00:00:31,560 --> 00:00:39,120
Thành phần trung tâm được gọi là Điều phối viên thực thi Saga.  Chúng ta hãy đi vào chi tiết của từng điều này.

5
00:00:39,810 --> 00:00:51,510
Trong sự kiện vũ đạo saga.  Các dịch vụ vi mô phát và nhận các sự kiện miền và các sự kiện này sau đó được xử lý bởi từng dịch vụ này.

6
00:00:51,660 --> 00:01:04,710
Các dịch vụ độc lập có thể xử lý các sự kiện được quan tâm và phản ứng với các sự kiện đó theo cách tự động và là một phần của quá trình xử lý giao dịch, các dịch vụ này có thể phát ra các sự kiện mới.

7
00:01:05,590 --> 00:01:16,330
Mặc dù việc sử dụng vũ đạo đồng đều dẫn đến các dịch vụ có tính tách rời cao nhưng vẫn có những thách thức.  Đầu tiên là khó thực hiện, kiểm tra và gỡ lỗi.

8
00:01:16,450 --> 00:01:27,160
Tiếp theo là các sự kiện bị bỏ qua và sử dụng bởi từng dịch vụ trong câu chuyện theo kiểu độc lập và điều đó có thể dẫn đến các sự kiện không theo trình tự.

9
00:01:27,550 --> 00:01:35,110
Mỗi dịch vụ trong tổ chức sự kiện cần đảm bảo rằng các sự kiện không theo trình tự được xử lý đúng cách.

10
00:01:35,290 --> 00:01:55,080
Việc xử lý các tình huống lỗi và thậm chí cả biên đạo cũng khó khăn vì không có dịch vụ tập trung điều phối việc khôi phục từ các tình huống lỗi trong quá trình triển khai saga điều phối lệnh, một thành phần trung tâm quản lý các cuộc gọi đến các dịch vụ ở Saagar.

11
00:01:55,510 --> 00:02:10,870
Có hai cách trong đó câu chuyện điều phối lệnh có thể được xây dựng trong phương thức đầu tiên, một đối tượng miền, là một phần của mô hình miền X với vai trò là thành phần trung tâm để quản lý các cuộc gọi đến các dịch vụ khác trong phương thức thứ hai.

12
00:02:10,900 --> 00:02:19,910
Có một bộ điều phối chuyên dụng được xác định bên ngoài mô-đun lệnh để điều phối các cuộc gọi đến các dịch vụ trong câu chuyện.

13
00:02:20,140 --> 00:02:32,200
Thành phần trung tâm này đôi khi được gọi là điều phối viên Thực thi Saga.  Tiếp theo, tôi sẽ thảo luận về cách một đối tượng miền chính có thể đóng vai trò điều phối viên thực thi Soga.

14
00:02:32,380 --> 00:02:42,000
Hãy xem xét ví dụ này cho miền bán lẻ tại đây.  Đối tượng Kinh dị có thể đóng vai trò là người điều phối thực thi.

15
00:02:42,010 --> 00:02:51,400
Nó có thể quản lý trạng thái của các đơn đặt hàng và chịu trách nhiệm bắt đầu giao dịch về các dịch vụ thanh toán và vận chuyển.

16
00:02:51,400 --> 00:03:03,280
Trong trường hợp xảy ra lỗi, dịch vụ đặt hàng có thể phối hợp với dịch vụ thanh toán và vận chuyển để đạt được sự thống nhất về đơn hàng trên tất cả các dịch vụ để tương tác với các dịch vụ.

17
00:03:03,280 --> 00:03:13,390
Đối tượng đơn đặt hàng sẽ sử dụng mẫu trả lời lệnh và sẽ đảm bảo rằng mẫu tin nhắn đáng tin cậy được sử dụng để các số chẵn không bị mất.

18
00:03:13,870 --> 00:03:27,820
Tất cả quản lý trạng thái và logic này sẽ dẫn đến một đối tượng miền phức tạp và sự phức tạp này là lý do tại sao điều phối viên bên ngoài được ưu tiên hơn điều phối viên được tích hợp trong đối tượng miền.

19
00:03:29,430 --> 00:03:53,230
Điều phối viên thực thi Psagot bên ngoài cũng được gọi là người điều phối.  Nó là một thành phần di truyền không có bất kỳ loại logic kinh doanh nào, nó cung cấp một số khả năng nhất định để xác định luồng và thực hiện việc gọi các dịch vụ theo tầng được xác định bởi người thiết kế các dịch vụ vi mô.

20
00:03:53,380 --> 00:04:02,900
Nó cũng thực hiện việc quản lý trạng thái trong bộ lưu trữ liên tục, chuyên dụng của riêng mình và không có mối quan hệ nào với bộ lưu trữ dữ liệu miền.

21
00:04:03,580 --> 00:04:13,240
Có nhiều bộ điều phối bên ngoài có thể được sử dụng để xây dựng câu chuyện với các dịch vụ vi mô.  Ví dụ như BPM hoặc công cụ quy trình làm việc.

22
00:04:13,940 --> 00:04:21,510
Chức năng WEF là một chức năng khác.  Nếu bạn đang sử dụng W.S.  cloud thì đây là cách nhanh chóng để xây dựng sagas.

23
00:04:21,560 --> 00:04:29,020
Sau đó, có nhiều khung công tác bằng các ngôn ngữ khác nhau dành cho khung công tác Java Sprink, có thể được sử dụng để xây dựng sagas.

24
00:04:29,830 --> 00:04:40,240
Hãy gọi ví dụ của A.W.  có chức năng, chức năng LWR.  Hãy để nhà phát triển xác định quy trình kinh doanh theo cách của Jason.

25
00:04:40,840 --> 00:05:04,760
Ngoài ra còn có một công cụ trực quan hiển thị luồng của các cuộc gọi dịch vụ này.  Thông thường, logic kinh doanh là giao dịch và các giao dịch bù được triển khai trong các hàm LAMDA, dịch vụ chức năng dừng trong một trình hỗ trợ điều phối việc thực hiện các giao dịch và các giao dịch bù.

26
00:05:04,810 --> 00:05:21,270
Đây là quy trình làm việc của chức năng nhân viên Eroglu đối với việc đặt gói kỳ nghỉ.  Đây là những dịch vụ được gọi là một phần của câu chuyện và đây là những giao dịch đền bù nhằm đảo ngược tác động của các cuộc gọi dịch vụ này.

27
00:05:21,310 --> 00:05:30,850
Vì vậy, như bạn có thể thấy ở đây, chúng tôi có một quy trình thanh toán và thanh toán hoàn tiền là giao dịch bồi thường và đây là các giao dịch tương ứng cho chuyến bay.

28
00:05:30,850 --> 00:05:40,410
Và hiện tại, việc triển khai Saagar dựa trên người chỉ huy dàn nhạc ít tách rời hơn so với câu chuyện dựa trên vũ đạo đồng đều.

29
00:05:40,690 --> 00:05:51,670
Ngoài ra, bộ điều phối lệnh còn đưa ra một điểm lỗi duy nhất.  Nhưng ngay cả với những điểm yếu đó, việc sử dụng người điều phối lệnh vẫn đơn giản hơn nhiều.

30
00:05:52,090 --> 00:06:08,050
Vì có một thành phần trung tâm xác định luồng lệnh gọi dịch vụ nên các nhà phát triển có thể nhanh chóng hiểu cách hoạt động của câu chuyện về bộ điều phối lệnh và do đó, việc xây dựng, kiểm tra và quản lý chúng rất đơn giản.

31
00:06:08,290 --> 00:06:17,680
Các tình huống thất bại cũng có thể được xử lý dễ dàng hơn nhiều trong những người điều phối lệnh so với các sagas dựa trên vũ đạo đồng đều.

32
00:06:18,010 --> 00:06:26,680
Một số điều phối viên thực thi Soga hoặc công cụ xử lý công việc cũng cung cấp một cách tập trung để kiểm tra trạng thái của luồng.

33
00:06:27,820 --> 00:06:48,430
Trong bài học này, tôi đã nói về cách xây dựng Saga bằng cách sử dụng mô hình vũ đạo đồng đều trong đó không có điều phối viên trung tâm cho luồng giao dịch, cách khác để xây dựng Saga là sử dụng mô hình bộ điều phối lệnh trong đó có một thành phần hoạt động  với tư cách là người điều phối luồng giao dịch.

34
00:06:48,430 --> 00:07:01,600
Một đối tượng miền có thể hoạt động như câu chuyện.  Điều phối viên thực thi cho một máy tính bên ngoài như quy trình làm việc, công cụ hoặc khung có thể được sử dụng làm điều phối viên thực thi saga.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000004.srt -->

1
00:00:00,450 --> 00:00:28,550
Saagar, các cân nhắc triển khai trong bài học này đề cập đến nhiều khía cạnh khác nhau mà bạn cần cân nhắc để triển khai các giao dịch phân tán bằng cách sử dụng Psagot, Baton Synchronoss so với các dịch vụ tòa án không đồng bộ trong Psagot có thể hiển thị lệnh thông qua các ứng dụng, chẳng hạn như RESTABILIZE và những dịch vụ này khôi phục  có thể được gọi, nhưng là người điều phối theo cách đồng bộ.

2
00:00:28,920 --> 00:00:50,970
Vì vậy, điều này là khả thi, nhưng các cơ chế không đồng bộ như nhắn tin là cách tốt nhất nên sử dụng.  Vì vậy, điểm mấu chốt là bất cứ khi nào có thể, hãy sử dụng tính năng nhắn tin thay vì các giao thức đồng bộ như SCDP của nhà hàng, mỗi giao dịch trong Soga phải được chỉ định một danh tính duy nhất.

3
00:00:51,930 --> 00:01:03,090
Ý tưởng đằng sau danh tính duy nhất này là nó giúp tìm nguồn cung ứng đồng đều và các dịch vụ trong câu chuyện có thể sử dụng nó để xác định các giao dịch trùng lặp.

4
00:01:03,210 --> 00:01:13,020
Ý tưởng rất đơn giản.  Nếu giao dịch có ID cụ thể đã được xử lý thì không cần xử lý lại.

5
00:01:13,830 --> 00:01:27,390
Tầm quan trọng của tôi là thuộc tính của một số phép toán trong toán học và khoa học máy tính, nơi chúng có thể được áp dụng nhiều lần mà không làm thay đổi kết quả ngoài ứng dụng ban đầu.

6
00:01:27,750 --> 00:01:36,990
Đây là định nghĩa quan trọng từ Wikipedia.  Trong một câu chuyện, các giao dịch dịch vụ phải khá quan trọng.

7
00:01:37,650 --> 00:01:46,320
Danh tính duy nhất được cung cấp cho mỗi thông báo có thể giúp đạt được hành vi quan trọng đúng đắn của các giao dịch.

8
00:01:46,680 --> 00:02:02,580
Hãy để tôi giải thích cách dịch vụ có thể giữ lại các giao dịch đã xử lý trong nhật ký khi nhận được giao dịch yêu cầu, dịch vụ sẽ kiểm tra xem ID giao dịch đã được xử lý chưa.

9
00:02:02,820 --> 00:02:13,050
Nếu nó chưa được xử lý thì giao dịch sẽ được xử lý.  Một phản hồi sẽ được tạo và lưu vào cơ sở dữ liệu và gửi lại cuộc gọi.

10
00:02:13,740 --> 00:02:24,920
Bây giờ, giả sử có một yêu cầu khác đi kèm với ID giao dịch đã được xử lý.  Trong trường hợp này, dịch vụ sẽ không xử lý lại giao dịch.

11
00:02:24,930 --> 00:02:33,270
Thay vào đó, nó sẽ nhận phản hồi từ cơ sở dữ liệu và gửi lại cho người gọi.  Bây giờ hãy nói về những thất bại.

12
00:02:33,540 --> 00:02:43,050
Lỗi yêu cầu dịch vụ vẫn có thể xảy ra nếu chúng được theo sau bởi các giao dịch bù trừ, nhưng các giao dịch bù trừ không thể thất bại.

13
00:02:43,170 --> 00:02:57,950
Họ phải thực hiện thành công.  Nếu không, dữ liệu trên các dịch vụ vi mô sẽ chuyển sang trạng thái không nhất quán để xây dựng khả năng khôi phục sau các giao dịch bồi thường không thành công.

14
00:02:58,350 --> 00:03:10,890
Cân nhắc sử dụng nước sốt đều.  Trong bài giảng trước đó, tôi đã thảo luận về cách sử dụng các chức năng của nhân viên AWB để xây dựng bộ điều phối lệnh cho dòng chảy Saagar này.

15
00:03:11,190 --> 00:03:20,520
Bây giờ, nếu bạn không sử dụng AWB, bạn vẫn có thể sử dụng một số khung nhất định cung cấp các thành phần nền tảng để xây dựng các giao dịch phân tán.

16
00:03:20,820 --> 00:03:39,080
Dưới đây là một số ví dụ về các khung mà bạn có thể sử dụng trong các dịch vụ vi mô của mình.  Tôi khuyên bạn nên truy cập trang web về các khung này để tìm hiểu cách tận dụng chúng để thúc đẩy sự phát triển của Microsoft. Đã đến lúc đi sâu vào những điểm chính từ bài học này.

17
00:03:39,210 --> 00:03:52,980
Nhắn tin được ưu tiên hơn cho việc liên lạc giữa các dịch vụ trong một câu chuyện.  Mỗi giao dịch phải có một danh tính duy nhất giúp các dịch vụ này đạt được hiệu lực của Eitam.

18
00:03:53,190 --> 00:04:07,170
Điều đó có nghĩa là một số giao dịch có thể được thực hiện nhiều lần mà không làm mất tính nhất quán của dữ liệu.  Giao dịch có thể thất bại, nhưng nếu giao dịch thất bại thì giao dịch bù đắp phải được thực hiện.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000005.srt -->

1
00:00:00,150 --> 00:00:10,270
Trong tất cả các bài giảng của mình, bạn đã biết rằng các tế bào achmea chuẩn bị nhiều đề xuất cho khách hàng khi khách hàng xác nhận một đề xuất.

2
00:00:10,470 --> 00:00:20,920
Quá trình đặt phòng được bắt đầu.  Quá trình đặt phòng bao gồm việc tính phí thẻ tín dụng của khách hàng và đặt chỗ cho tất cả các phần của gói kỳ nghỉ.

3
00:00:21,120 --> 00:00:31,950
Trong bài học này, bạn sẽ tìm hiểu về cách thực hiện quy trình đặt chỗ.  Việc sử dụng mẫu saga sẽ xem xét các tình huống thành công và thất bại trong quá trình đặt chỗ.

4
00:00:31,950 --> 00:00:44,170
Saagar Flow và sau đó bạn sẽ thấy việc đặt sàn Saagar đang hoạt động.  Acme I.T.  nhóm đã quyết định xây dựng quy trình đặt chỗ như một câu chuyện.

5
00:00:44,880 --> 00:01:05,970
Họ hiểu rằng rất khó để triển khai Saga nếu không có khuôn khổ.  Vì vậy, họ sẽ thực hiện một cách tiếp cận tiến hóa, trong đó họ sẽ thực hiện một câu chuyện đặt chỗ mà không có bất kỳ khuôn khổ nào và sẽ giữ mọi thứ đơn giản nhất có thể để họ có thể hiểu cách thức hoạt động của mô hình câu chuyện.

6
00:01:06,210 --> 00:01:20,280
Bài học này thảo luận về cách họ triển khai phiên bản một của việc đặt Saagar Float.  Câu chuyện về luồng đặt phòng sẽ bao gồm ba dịch vụ đặt dịch vụ Soga, dịch vụ thanh toán và dịch vụ đặt chỗ.

7
00:01:20,610 --> 00:01:34,170
Mỗi dịch vụ này sẽ duy trì trạng thái của chúng trong cơ sở dữ liệu riêng cho phiên bản này.  Một lần triển khai, thay vì duy trì trạng thái trong các cơ sở dữ liệu riêng biệt, sẽ duy trì trạng thái và các bộ sưu tập trong cơ sở dữ liệu chung.

8
00:01:34,350 --> 00:01:42,320
Câu chuyện được bắt đầu khi một giao dịch được gọi trên dịch vụ đặt chỗ, tìm kiếm để thêm lượt đặt chỗ.

9
00:01:42,840 --> 00:01:49,650
Điều này sẽ dẫn đến việc đưa ra một sự kiện mà cả dịch vụ thanh toán và dịch vụ đặt chỗ sẽ nhận được.

10
00:01:49,860 --> 00:01:59,550
Dịch vụ đặt chỗ thậm chí sẽ bỏ qua điều này, trong khi dịch vụ thanh toán sẽ thực hiện giao dịch xử lý thanh toán khi xử lý thanh toán thành công.

11
00:01:59,700 --> 00:02:12,290
Dịch vụ thanh toán sẽ cho phép một sự kiện sẽ được dịch vụ đặt chỗ nhận được và để đáp lại việc thanh toán thành công, dịch vụ đặt chỗ sẽ thực hiện giao dịch để xử lý việc đặt chỗ.

12
00:02:12,300 --> 00:02:35,090
Nếu mọi việc suôn sẻ thì việc đặt chỗ sẽ được xác nhận trong câu chuyện đặt chỗ.  Nhưng giả sử có lỗi xảy ra trong dịch vụ đặt chỗ, trong trường hợp đó, các lượt đặt chỗ thành công sẽ bị hủy và dịch vụ đặt chỗ sẽ bỏ qua một sự kiện, cả câu chuyện đặt chỗ và dịch vụ thanh toán sẽ nhận được sự kiện này.

13
00:02:35,340 --> 00:02:45,210
Dịch vụ thanh toán sẽ hoàn lại khoản thanh toán cho khách hàng vì việc đặt chỗ không thành công và câu chuyện đặt chỗ sẽ đánh dấu việc đặt chỗ là không thành công.

14
00:02:46,080 --> 00:02:52,440
Tiếp theo, hãy gọi đó là tình huống trong đó tất cả các giao dịch trong quy trình đặt chỗ đều thành công.

15
00:02:52,920 --> 00:03:04,410
Luồng đặt chỗ Saagar được kích hoạt khi một lượt đặt chỗ được thêm vào lượt đặt chỗ.  Dịch vụ đặt phòng của Saagar, Dịch vụ Saagar, của Emmet và thậm chí cả việc đặt phòng đã được thêm vào.

16
00:03:04,920 --> 00:03:10,860
Sự kiện này được nhận bởi dịch vụ thanh toán.  Dịch vụ thanh toán thực hiện việc xử lý thanh toán.

17
00:03:10,950 --> 00:03:22,050
Nó tính phí vào thẻ tín dụng của khách hàng.  Việc xử lý thành công dẫn đến việc gửi sự kiện Thanh toán thành công mà dịch vụ đặt chỗ nhận được.

18
00:03:22,050 --> 00:03:35,940
Dịch vụ đặt phòng thực hiện việc xử lý các đặt phòng.  Ví dụ: nếu gói chứa khách sạn và thuê ô tô, nó sẽ thực hiện việc đặt phòng cho cả khách sạn và thuê ô tô.

19
00:03:36,180 --> 00:03:46,590
Nếu tất cả các đặt phòng khác đều thành công, nó sẽ bỏ qua sự kiện đặt phòng thành công mà cả dịch vụ Booking Saagar và dịch vụ thanh toán đều nhận được.

20
00:03:46,590 --> 00:03:53,450
Dịch vụ Đặt phòng Saagar khi nhận được các dấu hiệu sự kiện đặt chỗ thành công.  Việc đặt phòng thành công.

21
00:03:54,420 --> 00:04:05,820
Tiếp theo, hãy gọi tình huống trong đó dịch vụ thanh toán không thành công.  Vì vậy, Dịch vụ Đặt chỗ Saagar đã bỏ qua việc đặt chỗ thậm chí đã thêm vào, dịch vụ thanh toán sẽ cố gắng xử lý nó và đã xảy ra lỗi.

22
00:04:06,210 --> 00:04:15,450
Vì vậy, dịch vụ thanh toán thực hiện một giao dịch đền bù và bỏ qua khoản thanh toán, thậm chí không thành công ngay cả khi đặt phòng nhận được.

23
00:04:15,450 --> 00:04:27,630
Saagar Dịch vụ đặt phòng.  Dịch vụ Saagar đánh dấu việc đặt chỗ là không thành công.  Tiếp theo, hãy xem xét tình huống trong đó dịch vụ đặt chỗ không thể đặt chỗ được Saagar Service Emmott's.

24
00:04:27,630 --> 00:04:39,810
Việc đặt chỗ đã được thêm vào, được nhận bởi dịch vụ thanh toán.  Dịch vụ thanh toán thực hiện quá trình xử lý và nhận được thành công thanh toán đồng đều mà dịch vụ đặt chỗ nhận được.

25
00:04:40,290 --> 00:04:54,990
Dịch vụ đặt phòng cố gắng giải quyết các phần khác nhau của gói kỳ nghỉ.  Ví dụ: nếu gói kỳ nghỉ bao gồm thuê ô tô và khách sạn, hãy cố gắng giải quyết cả việc thuê ô tô cũng như khách sạn.

26
00:04:55,290 --> 00:05:10,760
Nếu tất cả các đặt phòng đều thành công thì đặt phòng.  Coi đó là một giao dịch thành công, nếu bất kỳ một trong các lần đặt chỗ nào không thành công thì dịch vụ đặt chỗ coi đó là một thất bại.

27
00:05:10,870 --> 00:05:18,770
Trong trường hợp này, giả sử việc thuê ô tô thành công nhưng việc thuê khách sạn không thành công trong trường hợp đó.

28
00:05:19,300 --> 00:05:26,800
Dịch vụ đặt xe sẽ thực hiện giao dịch bồi thường hủy việc đặt chỗ thuê xe.

29
00:05:27,160 --> 00:05:36,040
Và sau đó, trong bối cảnh sự kiện xảy ra, việc đặt chỗ không thành công, cả dịch vụ thanh toán và dịch vụ đặt chỗ Saagar sẽ nhận được số tiền này.

30
00:05:36,040 --> 00:05:46,260
Và cả hai dịch vụ này sau đó sẽ thực hiện giao dịch bù trừ của mình.  Dịch vụ đặt chỗ Saagar sẽ đánh dấu việc đặt chỗ là trường tiếp theo.

31
00:05:46,270 --> 00:05:57,220
Hãy nói về kho thực hiện cho việc đặt chỗ.  Dòng chảy Sagar.  Trong phiên bản triển khai đầu tiên, một chủ đề chung sẽ được sử dụng cho tất cả các sự kiện.

32
00:05:57,550 --> 00:06:06,420
Tên của chủ đề là câu chuyện đặt phòng.  Hãy nhớ lại rằng nếu bạn đang sử dụng Cloud COFCO, chúng ta cần tuân theo quy ước đặt tên này cho chủ đề.

33
00:06:06,440 --> 00:06:20,500
Tất cả các sự kiện sẽ được công bố cùng với chìa khóa Sacto đặt trước.  Và điều đó có nghĩa là đối với một lượt đặt chỗ cụ thể, tất cả các sự kiện sẽ kết thúc trong cùng một phân vùng và thứ tự của các sự kiện sẽ được đảm bảo.

34
00:06:20,920 --> 00:06:30,100
Mỗi dịch vụ duy trì trạng thái riêng và các bộ sưu tập độc lập trong một nhà cung cấp chung với văn phòng của họ mà chúng tôi đã có.

35
00:06:30,100 --> 00:06:37,480
Ở các phiên bản sau, bạn có thể cân nhắc triển khai tầng này với nhiều chủ đề và nhiều cơ sở dữ liệu.

36
00:06:37,480 --> 00:06:47,440
Nhưng xin lưu ý trong phiên bản một, chúng ta sẽ sử dụng một cơ sở dữ liệu chung và một chủ đề chung.  Trước khi tôi cho bạn thấy câu chuyện đặt phòng đang hoạt động như thế nào, hãy để tôi chỉ cho bạn cách thực hiện nó.

37
00:06:47,710 --> 00:06:53,530
Có ba loại dịch vụ chính, đặt phòng.  Lớp Saagar quản lý trạng thái của câu chuyện đặt chỗ.

38
00:06:54,040 --> 00:07:02,710
Dịch vụ thanh toán mô phỏng quá trình xử lý thanh toán và dịch vụ đặt chỗ mô phỏng quá trình đặt chỗ.

39
00:07:02,950 --> 00:07:12,790
Lớp kiểm tra Deran Saagar thực hiện giao dịch đặt quảng cáo trên Dịch vụ đặt chỗ SAAGAR để bắt đầu quy trình đặt chỗ.

40
00:07:12,910 --> 00:07:25,780
Tôi đã tạo một chủ đề về buôn bán trên nền tảng đám mây.  Chủ đề này được sử dụng để xuất bản các sự kiện từ Kho lưu trữ thanh toán đặt trước Kho lưu trữ Saagar và Kho lưu trữ đặt trước.

41
00:07:26,170 --> 00:07:38,030
Ba dịch vụ lắng nghe các sự kiện.  Vì vậy, lớp SAAGAR đặt chỗ, dịch vụ thanh toán và dịch vụ đặt chỗ được triển khai dưới dạng trình xử lý tin nhắn cho chủ đề.

42
00:07:38,140 --> 00:07:48,370
Tất cả đều là các lớp kho lưu trữ, mở rộng lớp dựa trên thủ công, viết và đọc từ các bộ sưu tập tương ứng của chúng trong cơ sở dữ liệu du lịch và Mongo DB.

43
00:07:48,490 --> 00:08:03,820
Vì vậy, chúng ta hãy tiếp tục và xem việc đặt phòng.  Dòng chảy và hành động của Saagar là bước đầu tiên.  Tôi sắp ra mắt ba dịch vụ nằm trong Saga Booking Saga, Dịch vụ thanh toán và dịch vụ đặt chỗ.

44
00:08:04,090 --> 00:08:10,030
Trong khi điều này đang được khởi chạy, hãy để tôi chỉ cho bạn chủ đề.  Đây là chủ đề mà các dịch vụ này sẽ xuất bản.

45
00:08:10,480 --> 00:08:22,660
Nhấp vào trình duyệt và chúng ta sẽ nghe các tin nhắn về chủ đề này và tất cả các tin nhắn sẽ được xuất bản bởi ba dịch vụ sẽ xuất hiện ở đây.

46
00:08:22,870 --> 00:08:29,560
Bây giờ, trong thử nghiệm, chúng tôi sẽ sử dụng lần chạy, Saagar, để phục vụ, thiết lập ý tưởng đặt chỗ thành một lần chạy được thực hiện tốt.

47
00:08:29,560 --> 00:08:38,680
Bài kiểm tra Sagar.  Nó sẽ kích hoạt một giao dịch trên đối tượng saga đặt chỗ và điều đó sẽ bắt đầu luồng sự kiện.

48
00:08:38,800 --> 00:08:46,450
Vì vậy, hãy tiếp tục và thực hiện.  Chạy.  Saagar, Test sẽ theo dõi các sự kiện xuất hiện trong ứng dụng tiêu dùng tại đây.

49
00:08:46,720 --> 00:09:02,290
Đây là sự kiện đầu tiên của chúng tôi đến từ đối tượng saga đặt phòng.  Sự kiện được thêm vào đặt chỗ và sau đó bộ xử lý thanh toán đã chọn sự kiện, xử lý thanh toán thành công, bỏ qua thành công thanh toán đặt chỗ, thậm chí không thanh toán đặt chỗ.

50
00:09:02,290 --> 00:09:20,020
Thành công đã được thu thập bởi dịch vụ đặt chỗ và nó mô phỏng một lượt đặt chỗ thành công dẫn đến việc thừa nhận thành công đặt chỗ đồng đều, sau đó được chọn bởi Saagar đặt phòng và saga đặt chỗ sau đó bỏ qua việc xác nhận đặt chỗ chẵn.

51
00:09:20,440 --> 00:09:29,200
Chìa khóa ở đây, như bạn có thể thấy, là mã đặt chỗ.  Mỗi dịch vụ trong số ba dịch vụ này đều tạo một bộ sưu tập trong cơ sở dữ liệu du lịch.

52
00:09:29,500 --> 00:09:35,980
Đây là bộ sưu tập để đặt Psagot.  Và như bạn có thể thấy ở đây, chúng tôi có thông tin về việc đặt chỗ.

53
00:09:35,980 --> 00:09:47,560
Việc đặt chỗ đó là một trong những trạng thái hiện tại đang được xác nhận việc đặt chỗ.  Vì vậy, bước tiếp theo sẽ cố gắng mô phỏng thất bại trong việc đặt trước để xem việc đền bù sẽ diễn ra như thế nào.

54
00:09:48,250 --> 00:09:56,380
Để mô phỏng thất bại khi đặt chỗ, hãy nhấp vào dịch vụ đặt chỗ và bạn sẽ thấy thành công tương tự.  Người 65.

55
00:09:56,380 --> 00:10:02,590
Điều đó có nghĩa là 65 phần trăm thời gian.  Sẽ có một lượt đặt chỗ thành công, vì vậy hãy để tôi thay đổi điều này thành 0.

56
00:10:02,680 --> 00:10:14,110
Vì vậy, điều đó có nghĩa là có 100% khả năng thất bại.  Vì vậy, chúng tôi sẽ hủy dịch vụ đặt chỗ để thay đổi này được thực hiện, chạy lại nó, quay lại chạy, Saagar.

57
00:10:14,120 --> 00:10:26,650
Hãy thử nghiệm các thay đổi đối với, giả sử và chúng tôi đã sẵn sàng chạy thử nghiệm của mình trước khi chạy thử nghiệm này.  Chúng ta hãy quay lại bảng điều khiển, nhấp lại vào Người tiêu dùng để hiển thị các thông báo trước đó.

58
00:10:26,710 --> 00:10:40,150
Bây giờ chúng ta đã sẵn sàng chạy thử nghiệm, hãy quay lại trình duyệt.  Đó là quá trình xử lý bộ xử lý đặt chỗ và thanh toán đồng đều và bộ xử lý thanh toán đã thành công, nghiệp dư thậm chí còn đặt phòng thanh toán thành công.

59
00:10:40,300 --> 00:10:50,320
Và đây là sự cố đặt chỗ đặt chỗ không thành công, xảy ra bởi cả đặt phòng Psagot và dịch vụ thanh toán đặt phòng saga ATM.

60
00:10:50,330 --> 00:10:59,890
Việc đặt phòng thậm chí không thành công trong bộ sưu tập đặt phòng.  Như bạn có thể thấy, hiện tại tình trạng đặt vé cũng rất công bằng.

61
00:11:00,130 --> 00:11:09,610
Nếu bạn nhìn vào các đặt phòng, cờ thành công cho việc đặt chỗ đó sẽ khó có thể xảy ra lỗi khi mã xác nhận được đặt thành không thu được thanh toán.

62
00:11:09,700 --> 00:11:20,320
Chúng ta sẽ thấy một khoản hoàn lại.  Và như bạn có thể thấy ở đây, giao dịch đã thành công nhưng cuối cùng nó đã được hoàn lại do đặt chỗ không thành công.

63
00:11:20,320 --> 00:11:29,980
Vì vậy, câu chuyện của chúng tôi dường như đã có tác dụng trong bài học tiếp theo.  Tôi sẽ hướng dẫn bạn mã và thiết kế của quá trình triển khai câu chuyện đặt phòng.

64
00:11:30,190 --> 00:11:38,260
Tôi cũng sẽ chỉ cho bạn các bước mà chúng tôi cần thực hiện để thử nghiệm tầng này tại địa phương.  Vậy hãy cùng tôi tham gia bài học tiếp theo nhé.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\14ManagingDistributedTransactionswithSAGA_VVN\000000006.srt -->

1
00:00:00,090 --> 00:00:08,970
Câu chuyện đặt chỗ, hướng dẫn triển khai trong bài giảng này, tôi sẽ cung cấp cho bạn cái nhìn tổng quan về các lớp học và cách triển khai.

2
00:00:09,330 --> 00:00:17,310
Sau đó, tôi sẽ cung cấp cho bạn thông tin tóm tắt về tòa án, sau đó là các bước bạn có thể thực hiện để kiểm tra việc đăng ký.

3
00:00:17,310 --> 00:00:40,020
Saagar, hãy chảy cục bộ trong môi trường của bạn.  Việc triển khai saga đặt chỗ sử dụng Mongo, DB và COFCO.  Giả định ở đây là bạn đã thiết lập cơ sở dữ liệu của Akhmatova trên phiên bản Mongo DB trên đám mây của mình và bạn là lớp dựa trên Mông Cổ trỏ đến cơ sở dữ liệu của Akhmatova của riêng bạn.

4
00:00:40,320 --> 00:00:51,280
Giả định khác là bạn đã thiết lập tài khoản trên Cloud Karaka và giao diện cấu hình Kafka đang trỏ đến cụm bánh cà phê của riêng bạn.

5
00:00:51,300 --> 00:00:58,380
Cả hai thiết lập này đã được thảo luận trong các bài giảng trước đó trong gói conrod achmad hoặc mô phỏng không.

6
00:00:58,860 --> 00:01:09,120
Có một giao diện có tên đặt chủ đề Saagar có biến tĩnh cuối cùng của chúng tôi trỏ đến tên của chủ đề trong Kafka.

7
00:01:09,150 --> 00:01:23,540
Chủ đề này sẽ được sử dụng bởi tất cả các dịch vụ trong luồng Saagar xung quanh.  Saagar Test thực hiện đặt trước quảng cáo trên kho lưu trữ đặt trước để bắt đầu đặt trước Luồng Saagar.

8
00:01:24,630 --> 00:01:38,700
Mỗi lần thực hiện chạy thử nghiệm Saagar, bạn phải cung cấp một ID đăng ký khác.  Nếu bạn sử dụng cùng một ID đặt chỗ, giao dịch sẽ bị bỏ qua và bạn sẽ không thấy bất kỳ giao dịch nào diễn ra trong câu chuyện đặt chỗ.

9
00:01:39,270 --> 00:01:50,400
Họ không.  Lớp kiểm tra có chức năng chính trong đó chúng tôi đặt ID đặt chỗ.  Mỗi khi bạn chạy lớp này, hãy đảm bảo bạn thay đổi lớp đó thành một ID đặt chỗ khác.

10
00:01:50,760 --> 00:02:04,600
Nếu không, bạn sẽ không thấy hành động bắt đầu luồng.  Một phiên bản mới của kho lưu trữ Soga đăng ký đang được tạo và một đăng ký mới đang được thêm vào kho lưu trữ này.

11
00:02:05,010 --> 00:02:16,170
Đây là cách bắt đầu quy trình trong chủ đề đặt chỗ ở Saagar.  Bạn sẽ thấy biến chứa tên của chủ đề Kafka.

12
00:02:16,170 --> 00:02:26,370
Mình đã tạo chủ đề đó rồi.  Và khi bạn tạo chủ đề, bạn cần đảm bảo rằng tên của chủ đề khớp với biến này.

13
00:02:26,790 --> 00:02:36,870
Nếu không, các sự kiện của bạn sẽ bị mất và bạn sẽ không thấy con ruồi đang hoạt động trong gói.  Kamelot, Achmad hay giả vờ, không phải Saagar hay đặt chỗ.

14
00:02:37,290 --> 00:02:50,550
Có hai lớp quan tâm.  Lớp Booking Saagar là điều phối viên thực hiện saga.  Nó xử lý các sự kiện từ tất cả các thành phần.

15
00:02:51,090 --> 00:03:01,050
Đây là danh sách các sự kiện mà lớp này đang xử lý.  Việc đặt Kho lưu trữ Saagar mở rộng lớp dựa trên Mongo DB.

16
00:03:01,260 --> 00:03:10,890
Nó đảm nhiệm việc quản lý trạng thái đặt chỗ trong lượt đặt chỗ.  Bộ sưu tập Sagar.  Kho lưu trữ cũng bỏ qua các sự kiện thích hợp.

17
00:03:10,890 --> 00:03:21,570
Và đây là những sự kiện bị bỏ qua trong quá trình đặt chỗ.  Kho lưu trữ Saagar.  Giao diện này có định nghĩa về tất cả các trạng thái mà đăng ký chuyển tiếp sang.

18
00:03:21,870 --> 00:03:29,160
Chúng ta hãy xem sơ đồ trạng thái khi lượt đăng ký được thêm vào lượt đăng ký.  Psagot, trạng thái CNTT được đặt thành thanh toán đang chờ xử lý.

19
00:03:29,550 --> 00:03:48,840
Nếu thanh toán không được xử lý thì trạng thái được đặt thành đặt chỗ không thành công.  Nếu thanh toán thành công, trạng thái đặt chỗ được đặt thành đặt chỗ chờ xử lý đặt chỗ không thành công sẽ dẫn đến trạng thái đặt chỗ không thành công và đặt chỗ thành công sẽ dẫn đến trạng thái tuân thủ đặt chỗ.

20
00:03:49,590 --> 00:03:57,540
Lớp Saagar đặt chỗ thực hiện xử lý tin nhắn Kafka.  Phần lớn mã trong lớp này nằm trong hàm xử lý.

21
00:03:57,720 --> 00:04:05,400
Chức năng xử lý đang nhận các sự kiện từ dịch vụ thanh toán và dịch vụ đặt chỗ dựa trên sự kiện.

22
00:04:05,520 --> 00:04:15,750
Giao dịch được thực hiện hoặc giao dịch bù được thực hiện.  Logic cho các giao dịch này và giao dịch bù trừ đều nằm trong việc đặt chỗ.

23
00:04:15,750 --> 00:04:26,430
Kho lưu trữ Saagar mở rộng lớp dựa trên Mongo DV.  Tôi khuyên bạn nên tự mình tham gia lớp học này vì nó rất giống với các kho lưu trữ khác.

24
00:04:27,360 --> 00:04:36,330
Tiếp theo mình sẽ bàn về dịch vụ này tương tự như lớp học.  Lớp này có sẵn trong gói sử dụng Saagar phổ biến hoặc mô phỏng.

25
00:04:36,660 --> 00:04:43,710
Như tên cho thấy, nó giúp mô phỏng một dịch vụ.  Nó sẽ trở nên rõ ràng một khi bạn sẽ thấy công dụng của nó.

26
00:04:43,710 --> 00:04:55,380
Nhưng ở mức độ cao, nó tạo ra độ trễ trong khoảng thời gian ngẫu nhiên dưới 10 giây và nó có một chức năng tương tự duy nhất có một đối số duy nhất.

27
00:04:55,380 --> 00:05:15,050
Phần trăm thành công nếu bạn vượt qua phần trăm thành công là một trăm.  Điều đó có nghĩa là quá trình đồng hóa dịch vụ sẽ trở lại đúng, điều này cho thấy 100% thành công nếu bạn vượt qua và giả sử tỷ lệ thành công là 50, thì khả năng thành công và thất bại là 50%.

28
00:05:15,670 --> 00:05:27,070
Và nếu một giá trị true được trả về từ hàm tương tự này thì đó là dấu hiệu cho thấy dịch vụ đã thành công.  Nếu không, việc đặt ra 100% khả năng thất bại là thất bại.

29
00:05:27,400 --> 00:05:37,630
Chắc chắn người thành công không có chuyện gì sẽ trở nên rõ ràng, vì bạn sẽ thấy việc triển khai dịch vụ thanh toán và dịch vụ đặt chỗ.

30
00:05:38,850 --> 00:05:47,170
Đó là lời kêu gọi dịch vụ tương tự như Klosters, một hàm tĩnh và nó tương tự lấy phần trăm thành công làm đối số.

31
00:05:47,220 --> 00:05:54,570
Đây là nơi trái tim đi vào trạng thái ngủ trong khoảng thời gian ngẫu nhiên dưới 10 giây hoặc mười nghìn mili giây.

32
00:05:54,900 --> 00:06:14,610
Mã này sử dụng Maddog Random để quyết định xem đó sẽ là cuộc gọi thành công hay cuộc gọi thất bại.  Dịch vụ thanh toán và dịch vụ đặt chỗ được triển khai trên cùng một tuyến với dịch vụ đặt chỗ SAAGAR mà họ sẽ triển khai Trình xử lý tin nhắn COFCO và cả hai đều xử lý những mối quan tâm của họ.

33
00:06:14,620 --> 00:06:28,740
Ví dụ: dịch vụ thanh toán lắng nghe đặt chỗ đồng đều được thêm vào và đặt chỗ đồng đều cho các sự kiện, kho lưu trữ thanh toán và kho lưu trữ đặt trước mở rộng lớp dựa trên Mongo DB.

34
00:06:28,740 --> 00:06:40,110
Chúng cung cấp các chức năng để quản lý nội dung thanh toán và trạng thái đặt chỗ cho lượt đặt chỗ cụ thể được xác định bằng ID đặt chỗ.

35
00:06:40,610 --> 00:06:49,740
Đây là mã dành cho dịch vụ thanh toán triển khai trình xử lý tin nhắn COFCO.  Đây là hàm xử lý xử lý hai sự kiện.

36
00:06:49,740 --> 00:07:06,630
Khi nhận được sự kiện đặt chỗ sự kiện đã thêm, nó sẽ thực hiện giao dịch để xử lý thanh toán khi việc đặt chỗ trước không nhận được, nó sẽ thực hiện giao dịch bồi thường để cải tổ khách hàng trong quá trình giao dịch thanh toán.

37
00:07:06,660 --> 00:07:18,080
Trình mô phỏng dịch vụ đang được sử dụng.  Chức năng tương tự được gọi với người thành công tương tự và điều đó quyết định cơ hội xử lý thanh toán, thành công hay thất bại.

38
00:07:18,240 --> 00:07:28,140
Biến này có thể được đặt ở đây.  Tại thời điểm này, nó được đặt thành 75, có nghĩa là trình mô phỏng dịch vụ sẽ mô phỏng thành công.

39
00:07:28,290 --> 00:07:36,600
75% thời gian lớp này sử dụng kho thanh toán.  Mã trong kho thanh toán rất giống với các kho khác.

40
00:07:36,870 --> 00:07:52,200
Vì vậy xin vui lòng xem xét nó một mình.  Trong dịch vụ đặt chỗ, bạn sẽ thấy rằng chúng tôi có người thành công tương tự được đặt ở mức 65, nghĩa là dịch vụ đặt chỗ sẽ thành công 65% thời gian.

41
00:07:52,200 --> 00:08:10,920
Lớp này cũng triển khai trình xử lý thông báo COFCO.  Đây là chức năng xử lý xử lý thành công thanh toán đặt chỗ đồng đều bằng cách thực hiện chức năng đặt chỗ quy trình, một lần nữa đang sử dụng dịch vụ tương tự như lớp học trong bài giảng trước hoặc minh họa hoạt động của việc đặt chỗ.

42
00:08:10,920 --> 00:08:19,050
Dòng chảy Sagar.  Tại thời điểm này, tôi sẽ mô tả các bước mà bạn có thể thực hiện để kiểm tra việc đặt chỗ.  Saagar chảy cục bộ trong môi trường của bạn.

43
00:08:19,440 --> 00:08:33,000
Bước đầu tiên là thiết lập câu chuyện đặt chủ đề.  Giả định ở đây là bạn đang sử dụng buôn bán trên nền tảng đám mây ở bước thứ hai, đã khởi chạy COFCO Consumer trên Cloud Kafka.

44
00:08:33,330 --> 00:08:42,000
Tại đây, bạn sẽ có thể quan sát tất cả các sự kiện bị bỏ qua ở bước thứ ba, khởi chạy dịch vụ đặt chỗ, Dịch vụ thanh toán Saagar và Dịch vụ đặt chỗ.

45
00:08:42,270 --> 00:08:52,310
Mỗi trong số này có một chức năng chính trong bước tiếp theo.  Thực hiện chạy Saagar.  Kiểm tra với các ID đăng ký khác nhau sau khi thực hiện chạy Kiểm tra Saagar.

46
00:08:52,320 --> 00:09:04,470
Quan sát dòng chẵn trong người tiêu dùng.  Bạn cũng sẽ có thể kiểm tra dữ liệu và các bộ sưu tập trong cơ sở dữ liệu của Akhmatova trên phiên bản được hỗ trợ trên đám mây.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\001 Microservices-API Realization.en.srt -->

1

00:00:00,180 --> 00:00:07,440

Let's start this section by defining what is an API, an API, which stands for the application programming



2

00:00:07,440 --> 00:00:15,480

interface, is an interface that defines the interactions between multiple software applications or



3

00:00:15,480 --> 00:00:18,150

mixed hardware software intermediaries.



4

00:00:18,660 --> 00:00:20,700

This is the definition from Wikipedia.



5

00:00:21,420 --> 00:00:27,090

Now our interest is in micro services, which may be thought of as independent applications.



6

00:00:27,240 --> 00:00:31,000

Let's dive deeper into how micro services use APIs.



7

00:00:31,770 --> 00:00:37,560

Micro services expose APIs for consumption by other micro services.



8

00:00:37,590 --> 00:00:47,100

It is common for these apps to be exposed or HTP, but messaging is a preferred protocol for these interactions



9

00:00:47,100 --> 00:00:57,600

between apps disappears or a separate set of apps may be exposed to the external components such as



10

00:00:57,600 --> 00:01:00,910

user interfaces or legacy applications.



11

00:01:01,140 --> 00:01:09,030

Some of these consumers may even be outside of the organization that owns the micro service for such



12

00:01:09,030 --> 00:01:09,870

interactions.



13

00:01:10,200 --> 00:01:17,280

HTP is commonly used and the reason for that is that messaging would require dependency on a specific



14

00:01:17,280 --> 00:01:22,800

messaging technology, which will make the use of API very restrictive.



15

00:01:23,070 --> 00:01:32,160

SCDP being an open standard makes the EPA more available to any type of client that can make extra calls.



16

00:01:32,700 --> 00:01:33,590

Micro services.



17

00:01:33,600 --> 00:01:36,570

We realize these APIs in multiple ways.



18

00:01:36,990 --> 00:01:43,640

Designers of micro services commonly use restfully Hippias and graphical APIs at a high level.



19

00:01:44,100 --> 00:01:50,520

The difference between the two is in how they define the contract between the client and the SO.



20

00:01:51,000 --> 00:01:57,610

Both have pros and cons in the section you learn about the rest, tapirs and graphical.



21

00:01:57,780 --> 00:02:04,440

My hope is that by the end of the section you will be in a position to decide whether to use rest API



22

00:02:04,470 --> 00:02:09,630

or use graphical for the AP exposed by your micro services.



23

00:02:09,660 --> 00:02:13,680

You should also be able to describe the role of API management.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\002 Introduction to REST API.en.srt -->

1

00:00:00,340 --> 00:00:06,240

Restabilize in this lesson, you will learn what makes an API, a restful API.



2

00:00:06,360 --> 00:00:10,860

I'll also provide an overview of the rest architectural constraints.



3

00:00:10,980 --> 00:00:12,080

Let's start with a question.



4

00:00:12,090 --> 00:00:13,980

Is your architecture restful?



5

00:00:14,130 --> 00:00:21,480

Some developers think that by using HTP and Jason, they are creating an application that qualifies



6

00:00:21,630 --> 00:00:25,440

as a restful architecture that may or may not be true.



7

00:00:25,470 --> 00:00:30,680

These applications may not be restful, but they may be rest like Orestis.



8

00:00:30,780 --> 00:00:35,400

Then the obvious question that comes to mind is what makes an architecture useful?



9

00:00:35,640 --> 00:00:43,260

In order for the application architecture to be qualified as restful, it must follow six design rules



10

00:00:43,260 --> 00:00:48,830

and these six design rules are referred to as the rest architecture constraints.



11

00:00:49,140 --> 00:00:50,340

Quick bit of history.



12

00:00:50,490 --> 00:00:57,540

The six architectural constraints for Restfulness were described by Roy Fielding in his dissertation



13

00:00:57,540 --> 00:00:59,710

paper in year 2000.



14

00:00:59,820 --> 00:01:01,260

Let's go over these six.



15

00:01:01,380 --> 00:01:03,270

Reste architectural constraints.



16

00:01:03,690 --> 00:01:09,450

Please note that my intent here is to provide you an overview of the architectural constraints.



17

00:01:09,660 --> 00:01:14,090

If you would like to learn more about these constraints, please do your own research.



18

00:01:14,730 --> 00:01:18,760

So the first architectural constraint for us is client.



19

00:01:18,810 --> 00:01:27,570

So this constraint suggests the use of client server design principles for implementing the rest API.



20

00:01:27,750 --> 00:01:35,850

Second one is the uniform interface that suggest use of well-defined contracts between the client and



21

00:01:35,850 --> 00:01:36,300

the so.



22

00:01:36,600 --> 00:01:44,230

Third one is the statelessness, which suggests that the server should not manage the state of the application.



23

00:01:44,410 --> 00:01:46,020

Fourth one is caching.



24

00:01:46,020 --> 00:01:53,220

The server should use HDB caching headers to cache the responses to the request received from the client.



25

00:01:53,400 --> 00:01:55,380

Fifth one is learing.



26

00:01:55,560 --> 00:02:01,770

This suggests that the architecture should be layered and each of these layers should be manageable



27

00:02:01,770 --> 00:02:02,540

independently.



28

00:02:02,640 --> 00:02:04,370

Plus one is called on demand.



29

00:02:04,620 --> 00:02:10,710

And this suggests that SOA can not only send data to the client in response to the request, but it



30

00:02:10,710 --> 00:02:14,700

also can send code that the client can execute.



31

00:02:14,820 --> 00:02:16,750

This constraint is optional.



32

00:02:17,190 --> 00:02:23,340

So what that means is that as long as your implementation is following the first five constraints,



33

00:02:23,520 --> 00:02:26,250

your architecture will be considered as restful.



34

00:02:26,700 --> 00:02:31,590

Recall that rest APIs are not restricted to HTP protocol.



35

00:02:31,620 --> 00:02:40,590

So if your is using SCDP and it is following the architectural constraints, then it is said to be an



36

00:02:40,590 --> 00:02:44,630

EDP rest API or restore S2P.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\003 REST API Resources & Design constraints.en.srt -->

1

00:00:00,330 --> 00:00:07,650

Just over HTP, in this lesson, you will learn the most important concept of rescue apps, the resources



2

00:00:08,130 --> 00:00:12,840

you learn about the various data format that the rest apps can support.



3

00:00:13,140 --> 00:00:22,290

And I'll cover how HTP methods or verbs are used for managing the state of the resources or real world



4

00:00:22,320 --> 00:00:26,070

objects or resources, maybe described by way of attributes.



5

00:00:26,070 --> 00:00:32,610

For example, a car maybe described by way of the make model year and VIN number.



6

00:00:32,850 --> 00:00:37,460

And this VIN number gives car a unique identity in software systems.



7

00:00:37,500 --> 00:00:41,480

These attributes are managed in some kind of persistent storage.



8

00:00:41,490 --> 00:00:45,740

It may be a RDBMS or it maybe even a nautical database.



9

00:00:45,900 --> 00:00:50,760

There are certain attributes of the object that may change over a period of time.



10

00:00:50,910 --> 00:00:54,270

For example, the owner of the car may change.



11

00:00:54,420 --> 00:01:01,920

Vince bought the new car, so the owner attributes that to wins, then sold the car so he's no more



12

00:01:01,920 --> 00:01:02,670

the owner.



13

00:01:02,700 --> 00:01:09,030

And since he sold the car to Cathy McCarty's, the owner, all of the state data changes are captured



14

00:01:09,030 --> 00:01:10,990

in the persistent storage.



15

00:01:11,130 --> 00:01:16,740

So what we are saying here is that the representational state of the car is managed in the database



16

00:01:16,740 --> 00:01:23,780

and they may be multiple instances of cars which are uniquely identified by way of their VIN number.



17

00:01:24,090 --> 00:01:29,670

Each of these cars have different values for the attributes and different owners.



18

00:01:29,910 --> 00:01:32,590

Now, think of a system that can query this database.



19

00:01:32,670 --> 00:01:38,250

This system may ask the database for details of, let's say, VIN, number one, two, three for this



20

00:01:38,250 --> 00:01:38,640

query.



21

00:01:38,790 --> 00:01:44,730

The database will respond by sending back the representational state of the car with VIN number one,



22

00:01:44,730 --> 00:01:45,270

two, three.



23

00:01:45,480 --> 00:01:52,650

What you just learn is the foundational concept of rest, the representational state transfer.



24

00:01:52,830 --> 00:01:59,760

The owner tracking application received the representational state for the car with VIN number one,



25

00:01:59,760 --> 00:02:02,420

two, three from the source database.



26

00:02:03,000 --> 00:02:06,800

This representational state data may be in any format.



27

00:02:06,810 --> 00:02:10,500

For example, it may be a collection of name value pairs.



28

00:02:10,770 --> 00:02:18,450

It may be in the database record for this internal representation of the state is converted to other



29

00:02:18,450 --> 00:02:18,990

format.



30

00:02:19,320 --> 00:02:25,950

For example, some kind of a logic can be put together to convert it into ethanol, which is consumed



31

00:02:26,100 --> 00:02:27,510

by the browser klencke.



32

00:02:27,810 --> 00:02:34,770

Or it may be converted to CSFI JSON example, which are the popular format for mobile applications,



33

00:02:34,770 --> 00:02:38,370

web applications and partner application integrations.



34

00:02:38,610 --> 00:02:41,910

But those are not the only format it can be converted to.



35

00:02:41,940 --> 00:02:48,660

This representational state may be converted to any format such as Jetpack, PDF, Excel, etc..



36

00:02:48,660 --> 00:02:52,280

For the sake of discussion, let's remove the e-mail formic.



37

00:02:52,320 --> 00:02:58,860

Now, if we replace the logic with the rest API, then this is a good representation of the restful



38

00:02:58,860 --> 00:02:59,400

API.



39

00:02:59,400 --> 00:03:05,550

From the data formats perspective, what this tells you is that Anastacia is not tied to any specific



40

00:03:05,550 --> 00:03:06,420

data format.



41

00:03:06,430 --> 00:03:13,410

In fact, the same instance of our restful API can convert and send back the representational state



42

00:03:13,410 --> 00:03:18,000

of a resource in different formats based on the API client needs.



43

00:03:18,160 --> 00:03:22,530

Indeed is a job posting site which also offers a rest API.



44

00:03:22,770 --> 00:03:31,110

This rest API manages the Job Resources RESTful API, a client interested in getting the information



45

00:03:31,110 --> 00:03:38,970

on the job, make all the get operation with the specific job ID and request the API server to send



46

00:03:38,970 --> 00:03:46,920

back the response and XML format that as full EPA implementation gets the job information from the internal



47

00:03:46,920 --> 00:03:53,220

database or some persistent store convert into XML and send it back to the rest client.



48

00:03:53,370 --> 00:03:59,190

Similarly, the client can ask for that information to be sent back in Gissen format.



49

00:03:59,400 --> 00:04:02,310

Let's check out the documentation for the API.



50

00:04:02,310 --> 00:04:07,860

Just type on Google Search Bar indeed developer API and is the link to the API.



51

00:04:07,920 --> 00:04:13,680

Click on the job search API and let us go through the parameters needed in the request.



52

00:04:13,710 --> 00:04:19,500

These are the request parameters and here you will find that the client will need to set up the format



53

00:04:19,500 --> 00:04:21,450

that they are interested in by default.



54

00:04:21,450 --> 00:04:25,500

The format is set to example, but the API supports XML.



55

00:04:25,500 --> 00:04:29,400

And Jason, let's take a look at the response data format.



56

00:04:29,400 --> 00:04:35,100

So depending on what the client has requested, the API implementation will respond back either with



57

00:04:35,100 --> 00:04:41,910

the XML data for their job or if the client has requested the data to be in use and format, then it



58

00:04:41,910 --> 00:04:44,780

will respond back with this kind of Jason data.



59

00:04:44,790 --> 00:04:50,340

So this is just one example of how an API can support multiple formats.



60

00:04:50,520 --> 00:04:55,890

The API that we just looked at, users SCDP as the communication protocol.



61

00:04:56,310 --> 00:04:59,270

All modern APIs use SCDP.



62

00:04:59,420 --> 00:05:06,890

As the communication protocol and we call such apps SCDP Restabilize, and the reason is because the



63

00:05:06,890 --> 00:05:16,910

rest Abia style itself is not tied to HDTV, you can build apps with other protocols as well as storage



64

00:05:17,330 --> 00:05:20,270

APIs, Expo's and endpoint.



65

00:05:20,270 --> 00:05:24,430

And this endpoint is used for managing the state of the resources.



66

00:05:24,770 --> 00:05:26,940

The key word here is managing the state.



67

00:05:27,410 --> 00:05:33,560

So what that tells you is that you can carry out the covert operations on the resources exposed by the



68

00:05:33,620 --> 00:05:34,780

rest APIs.



69

00:05:35,210 --> 00:05:39,440

You can create, retrieve, update and delete the resources.



70

00:05:39,950 --> 00:05:46,850

In order to carry out the covert operation the client has to use and appropriate htp wob.



71

00:05:47,330 --> 00:05:49,280

Let me explain it with an example.



72

00:05:49,610 --> 00:05:57,410

Let's say Achmad Travel is exposing the vacation packages API so there will be an extra DP endpoint



73

00:05:57,410 --> 00:05:58,340

for the clients.



74

00:05:58,340 --> 00:06:04,040

The client will use this endpoint for carrying out the card operation to create a resource.



75

00:06:04,430 --> 00:06:08,870

The client will have to use the extra DP post-war for retrieve.



76

00:06:09,020 --> 00:06:15,620

The client will have to use the extra get for updating the state of the resource port needs to be used



77

00:06:15,830 --> 00:06:19,720

and for deleting a resource delete will need to be used.



78

00:06:20,420 --> 00:06:21,590

Now it's quiz time.



79

00:06:22,010 --> 00:06:24,010

I would like you to answer this question.



80

00:06:24,050 --> 00:06:26,810

What makes an API restful, Mark?



81

00:06:26,820 --> 00:06:31,750

The correct and incorrect choices suggest that you pause the video and make an attempt.



82

00:06:33,050 --> 00:06:33,670

All right.



83

00:06:33,680 --> 00:06:36,580

Hopefully you have got all the correct answers.



84

00:06:36,620 --> 00:06:38,630

These are the right choices.



85

00:06:38,630 --> 00:06:48,200

Rest apps follow a set of design, principles rest, follow the rest architectural style rest apps expose



86

00:06:48,200 --> 00:06:52,490

resources on which the rest clayne can carry out operations.



87

00:06:52,640 --> 00:06:55,340

And these are the incorrect choices rest.



88

00:06:55,450 --> 00:07:04,040

Tapirs are not tied to any specific technology SJP or does not define any standard for request or response



89

00:07:04,040 --> 00:07:06,470

payloads or how the apps should be.



90

00:07:06,860 --> 00:07:11,720

Less tapirs can use any communication protocol and any data format.



91

00:07:11,720 --> 00:07:16,130

It is not tied to HTP and Jason, which is a common misconception.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\004 API Management.en.srt -->

1

00:00:00,180 --> 00:00:07,080

EPA management, I'll start this lesson by discussing three different types of consumers that use the



2

00:00:07,080 --> 00:00:15,210

EPA's exposed by Michael Services, then I'll discuss what is EPA management and why you should consider



3

00:00:15,390 --> 00:00:18,270

EPA management for your micro services.



4

00:00:18,810 --> 00:00:24,630

EPA exposed Body Micro Services are consumed by three different types of consumers.



5

00:00:25,200 --> 00:00:29,070

The first are the private or internal EPA consumers.



6

00:00:29,460 --> 00:00:37,090

These private consumers are part of the same micro services team or are developers of other maiko services.



7

00:00:37,110 --> 00:00:43,560

The idea is that the private consumers belong to the same organization as the owners of the.



8

00:00:44,430 --> 00:00:48,170

The second type of consumer are the public or external consumers.



9

00:00:48,300 --> 00:00:53,630

These are the independent developers outside of the organization.



10

00:00:53,640 --> 00:01:00,150

So, for example, from ACMS perspective, it may be an independent travel blogger who is invoking the



11

00:01:00,180 --> 00:01:01,870

API exposed by Acme.



12

00:01:02,130 --> 00:01:06,990

The third type of consumer is the partner API, a consumer from Acme contacts.



13

00:01:06,990 --> 00:01:14,100

It may be the resellers or the affiliate, so depending on the consumer of the API and API is marked



14

00:01:14,100 --> 00:01:17,790

as private, public or partner API.



15

00:01:18,390 --> 00:01:24,660

From the implementation perspective, there is no difference between the three types of APIs.



16

00:01:24,930 --> 00:01:28,200

The difference is in how these apps are managed.



17

00:01:28,620 --> 00:01:32,730

Let's compare a private API with public API.



18

00:01:32,880 --> 00:01:41,340

The private API consumer may be able to invoke the API 5000 times per second, whereas the public API



19

00:01:41,340 --> 00:01:46,140

consumers will be allowed to invoke the same API five times per second.



20

00:01:46,770 --> 00:01:54,570

Another example is where the private API consumer may be allowed to access all of the API features,



21

00:01:54,570 --> 00:02:01,930

whereas the public API consumer will be restricted only to certain get calls on the API.



22

00:02:02,160 --> 00:02:12,240

These aspects of an API are managed outside of the micro services implementation by way of API management



23

00:02:12,240 --> 00:02:12,930

platform.



24

00:02:13,870 --> 00:02:20,260

You may think of an app, a management platform as a technology that is used for addressing the Common



25

00:02:20,260 --> 00:02:27,700

Appia concerns, these common concerns are typically the concerns related to the access and authorization



26

00:02:27,970 --> 00:02:32,050

to the apps, logging and analytics quarters.



27

00:02:32,200 --> 00:02:39,370

For example, if the app consumer is allowed to access the API 5000 times per second or five times per



28

00:02:39,370 --> 00:02:47,020

second, and then there is API documentation which provides information to the consumers on how to use



29

00:02:47,020 --> 00:02:47,920

the apps.



30

00:02:48,220 --> 00:02:54,180

Micro services expose their APIs by way of these API management platforms.



31

00:02:54,190 --> 00:03:00,580

The EPA management platform exposes the EPA by way of a proxy point.



32

00:03:00,910 --> 00:03:06,520

The consumers of the EPA invoke the EPA by way of the proxy standpoint.



33

00:03:06,550 --> 00:03:11,980

They never connect directly to the EPA exposed by the MICROS service where the consumer invokes the



34

00:03:11,980 --> 00:03:12,700

EPA.



35

00:03:12,730 --> 00:03:19,960

The EPA management platform applies the management control and based on the outcome of those controls,



36

00:03:20,200 --> 00:03:27,790

the EPA management platform either allows the invocation of the EPA on the micro servers or it denies



37

00:03:27,790 --> 00:03:29,620

the request for invocation.



38

00:03:29,800 --> 00:03:32,140

Let's talk about the management control.



39

00:03:32,170 --> 00:03:38,420

Most EPA management platform offers are declarative or policy based management features.



40

00:03:38,530 --> 00:03:44,110

What that means is that the developer of the micro servers doesn't have to code any of these management



41

00:03:44,110 --> 00:03:44,760

controls.



42

00:03:44,920 --> 00:03:49,600

They can simply put together policies for defining these controls.



43

00:03:49,600 --> 00:03:56,980

For example, a policy may be defined for the internal or private consumer to be such that maximum flexibility



44

00:03:56,980 --> 00:03:58,610

is provided to the consumer.



45

00:03:58,630 --> 00:04:03,180

So in other words, most of their calls will go through for the public domain developers.



46

00:04:03,190 --> 00:04:06,980

The policy may be extremely restricted for the partnerships.



47

00:04:07,090 --> 00:04:11,420

The policy may be such that it define some kind of SLA.



48

00:04:12,160 --> 00:04:18,040

Now, if you're wondering how these policies are defined, these policy definition mechanism is totally



49

00:04:18,040 --> 00:04:20,590

dependent on the EPA management product.



50

00:04:20,950 --> 00:04:24,930

Gissen is commonly used for defining these policies.



51

00:04:24,970 --> 00:04:30,250

So if you're interested in knowing more about how these policies are defined, you'll have to pick up



52

00:04:30,250 --> 00:04:37,660

one of the EPA management products, such as RPG Mughals of WSO to to understand the nature of these



53

00:04:37,660 --> 00:04:38,790

policy documents.



54

00:04:38,920 --> 00:04:47,860

Most cloud vendors today also offer API management services like the Amazon API Gateway and the API



55

00:04:47,860 --> 00:04:48,550

management.



56

00:04:48,770 --> 00:04:54,970

If you're not using an API management platform, I highly recommend that you look at the possibility



57

00:04:54,970 --> 00:04:57,940

of adopting an API management solution.



58

00:04:58,330 --> 00:05:05,680

Although there are multiple benefits of using an API management platform from the micro services development



59

00:05:05,680 --> 00:05:06,850

team perspective.



60

00:05:06,880 --> 00:05:12,850

The biggest benefit is that the team can focus on the domain or the business logic rather than spending



61

00:05:12,850 --> 00:05:17,200

time on common concerns such as security, logging, etc..



62

00:05:17,320 --> 00:05:20,530

As a result, the Microsoft source code is cleaner.



63

00:05:20,860 --> 00:05:27,010

Last but not the least, since the consumers of the EPA do not connect directly to the Microsoft service,



64

00:05:27,220 --> 00:05:29,480

change management become easier.



65

00:05:29,530 --> 00:05:36,910

So what that means is that the Microsoft development team can make the changes to the API and adjust



66

00:05:36,910 --> 00:05:44,600

the proxy on the API management platform to insulate the end consumer from those changes.



67

00:05:45,280 --> 00:05:47,640

Time to go over the key points from this lesson.



68

00:05:48,160 --> 00:05:50,230

There are three types of apps.



69

00:05:50,230 --> 00:05:58,240

Depending on the type of consumers, the private API is consumed by the consumers within the same organization.



70

00:05:58,570 --> 00:06:05,500

Public areas are consumed by consumers that are outside the organization and are in the public domain,



71

00:06:05,860 --> 00:06:10,480

and partnerships are used by the partners of the organization.



72

00:06:10,780 --> 00:06:17,590

Micro services exposed APIs and the consumers do not connect directly to these APIs, but they connect



73

00:06:17,740 --> 00:06:25,960

by way of an API management platform that provides a policy based mechanism for addressing common concerns



74

00:06:25,960 --> 00:06:27,460

related to APIs.



75

00:06:27,460 --> 00:06:33,850

Since these common concerns are addressed by the API management platform, micro services implement



76

00:06:33,850 --> 00:06:37,050

only the business logic for the apps.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\005 Exercise _ ACME REST API for Products.en.srt -->

1

00:00:00,150 --> 00:00:08,190

Acme product AP In this lesson, you learn about the Acme Sales Channel strategy that requires introduction



2

00:00:08,190 --> 00:00:16,650

of an API that will be consumed by independent Web developers and Hackman's partners in one of the earlier



3

00:00:16,650 --> 00:00:19,360

lectures under the section Domain Driven Design.



4

00:00:19,830 --> 00:00:25,110

We analyzed the transcript for an interview with Acme product manager.



5

00:00:25,440 --> 00:00:30,990

We also developed the ubiquitous language for the product management bounded context.



6

00:00:31,440 --> 00:00:35,660

This lecture is a continuation from where we left that discussion.



7

00:00:36,150 --> 00:00:41,280

So I suggest that you pause the video, go to the interview transcript and then proceed.



8

00:00:42,220 --> 00:00:49,180

The Microsoft services team for the products domain work closely with the product manager, and this



9

00:00:49,180 --> 00:00:55,900

is what they have learned from Paul, the product manager, Eckmann is looking to expand its sales channel



10

00:00:56,080 --> 00:00:56,500

today.



11

00:00:56,590 --> 00:01:04,930

ACMS sells vacation packages by way of its website, by way of its call center and by way of partner



12

00:01:04,930 --> 00:01:06,100

travel agents.



13

00:01:06,400 --> 00:01:13,360

Achmea is looking to expand its partner network by providing easy access to the Acme products.



14

00:01:13,570 --> 00:01:22,270

And they're also looking to engage independent web developers as well as bloggers to sell Acme products



15

00:01:22,570 --> 00:01:24,680

in exchange for selling the Achmea products.



16

00:01:24,910 --> 00:01:32,890

These independent developers and bloggers will make money in terms of commissions based on the desired



17

00:01:32,890 --> 00:01:41,890

outcome shared by all the EITE lead for the products or services team decided to build a rest API for



18

00:01:41,890 --> 00:01:48,130

external consumers, since messaging cannot be used for external consumers.



19

00:01:48,400 --> 00:01:53,740

It was decided to build the API as a restaurant SCDP API.



20

00:01:54,100 --> 00:01:59,950

These apps will be exposed to the external public developers and bloggers.



21

00:02:00,160 --> 00:02:07,690

Concerns such as securities, logging and analytics quota's will be managed by the Alpha API management



22

00:02:07,690 --> 00:02:08,380

solution.



23

00:02:08,650 --> 00:02:15,400

In the first phase, only the rest API will be developed and tested and later on the API management



24

00:02:15,400 --> 00:02:17,080

solution will be added.



25

00:02:18,020 --> 00:02:25,700

The products Michael Service will expose the products and the provider information by way of a rest



26

00:02:25,700 --> 00:02:26,330

API.



27

00:02:26,420 --> 00:02:29,090

Consumers will be external to Acme.



28

00:02:29,240 --> 00:02:35,320

They will be the public domain developers and bloggers, or they may be the partners of Achmat.



29

00:02:35,390 --> 00:02:42,150

They'll invoke the rest API to get information on the products based on the criteria.



30

00:02:42,410 --> 00:02:47,690

They'll also be able to pull the information for providers based on the criteria.



31

00:02:47,720 --> 00:02:54,770

At a later date, API management will be added for better management of the common API concerns.



32

00:02:55,610 --> 00:03:03,680

The expectation for this API is that Web developers and travel bloggers will integrate the API with



33

00:03:03,680 --> 00:03:04,850

their websites.



34

00:03:05,150 --> 00:03:10,310

They'll make a recommendation to their visitors on the various navigation packages.



35

00:03:10,640 --> 00:03:17,320

For example, a travel blogger may recommend the Bahamas package to its visitors.



36

00:03:17,330 --> 00:03:24,920

The website will use the product API to get information on the Bahamas package website will use the



37

00:03:24,920 --> 00:03:31,840

provider API to get the information on the various providers that are part of the package.



38

00:03:31,850 --> 00:03:39,440

For example, the Bahamas package may consist of airline tickets from United Airlines and five night



39

00:03:39,470 --> 00:03:41,270

hotel stay in Hilton.



40

00:03:41,570 --> 00:03:49,460

If the visitor on the website buys the package, then the blogger or the developer of the website will



41

00:03:49,460 --> 00:03:51,290

get the commission from Acme.



42

00:03:52,100 --> 00:04:00,560

Distressed API may be developed in different languages using the appropriate frameworks, and the Acme



43

00:04:00,560 --> 00:04:06,790

Products Micro Services Team has decided to build trust Abia using Springboard.



44

00:04:06,920 --> 00:04:13,490

In the next lecture, I'll walk you through the implementation of the product and provider API implemented



45

00:04:13,520 --> 00:04:15,620

with Java and Springboard.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\006 Hands On _ ACME REST API in action.en.srt -->

1

00:00:00,150 --> 00:00:07,410

Acme Products API implementation in this lesson, I'll walk you through the class diagram for the products



2

00:00:07,410 --> 00:00:15,690

model, then we will see the rest API for products in action and at the end, I'll walk you through



3

00:00:16,050 --> 00:00:21,120

some of the classes in the rest API implementation for Acme.



4

00:00:21,480 --> 00:00:26,690

Please note my intent is to demonstrate a walking rest EPA.



5

00:00:26,880 --> 00:00:34,350

It is not to teach spraying, but if you knew the spring mood, then I suggest that you visit this link



6

00:00:34,350 --> 00:00:38,760

and go through the rest API tutorial for Springwood.



7

00:00:39,090 --> 00:00:44,850

If you already have experience with Springboard, then you're good to go and it'll be easy for you to



8

00:00:44,850 --> 00:00:46,640

understand the code.



9

00:00:46,650 --> 00:00:48,770

Then I'll walk you through in this lecture.



10

00:00:49,380 --> 00:00:55,430

Please note that the code that I'm walking you through in this lesson is available in the product repository.



11

00:00:55,710 --> 00:01:02,190

Please go ahead and Kloner to your local machine if you haven't done so already and check out the branch



12

00:01:02,460 --> 00:01:03,150

API.



13

00:01:03,780 --> 00:01:06,150

The module classes for the products.



14

00:01:06,150 --> 00:01:11,520

Bounded contexts are defined in the contract achmad or product start model package.



15

00:01:11,760 --> 00:01:19,590

The product, which is a vacation package in the sales bonded context is defined in the product class



16

00:01:20,010 --> 00:01:25,200

and the product repository is defined by an interface product REPL.



17

00:01:25,680 --> 00:01:33,810

The product repo exposes the product function and it exposes a fine product function that takes multiple



18

00:01:33,810 --> 00:01:38,000

criteria parameters to extract the products.



19

00:01:38,010 --> 00:01:43,560

Fulfilling that criteria, the provider classes are in the provider package.



20

00:01:43,860 --> 00:01:51,660

A common interface is defined for the providers and each of the provider types implement this common



21

00:01:51,660 --> 00:01:59,520

provider interface provider REPL provides a function for adding the provider to the repository and the



22

00:01:59,520 --> 00:02:06,780

phone provider function takes the identity of the provider to return the provider instance to the column.



23

00:02:07,620 --> 00:02:15,120

DECLASSE Products Rest appear controller in the package Kondor Achmad or Product Appia implements the



24

00:02:15,120 --> 00:02:18,570

rest controller for the springboard application.



25

00:02:18,930 --> 00:02:24,510

It exposes two endpoints, products and providers.



26

00:02:24,780 --> 00:02:32,190

The rest API controller instance holds an instance of the product repository and a provider repository



27

00:02:32,460 --> 00:02:35,790

that implement the respective repro interfaces.



28

00:02:35,940 --> 00:02:43,970

The main class for launching the rest API controller is the wrong products rest API under the Commodore



29

00:02:44,100 --> 00:02:46,080

Act or test package.



30

00:02:46,950 --> 00:02:51,570

The Act mirrors APIs for products will provide to endpoints.



31

00:02:51,570 --> 00:02:59,960

The first endpoint is the product endpoint that will also take query parameters for specifying the product



32

00:02:59,970 --> 00:03:01,860

or the vacation package criteria.



33

00:03:01,860 --> 00:03:05,580

Coller may provide the public idy for the product.



34

00:03:05,730 --> 00:03:12,300

They may specify the destination, the minimum number of night and the maximum number of night for that



35

00:03:12,300 --> 00:03:13,650

package or product.



36

00:03:14,070 --> 00:03:21,030

The second endpoint is the providers endpoint for which the idea of the provider need to be specified



37

00:03:21,390 --> 00:03:26,100

and this endpoint will return the information on the provider.



38

00:03:26,970 --> 00:03:30,000

Let's go ahead and launch our API.



39

00:03:30,300 --> 00:03:33,690

Click on Contact Me the test package.



40

00:03:34,080 --> 00:03:41,040

Right, click on the run products rest API and this will launch our API.



41

00:03:41,460 --> 00:03:49,980

Give it a few seconds, open a browser window, hit the URL, SCDP, localhost Collinet 080 products.



42

00:03:50,010 --> 00:03:54,300

This will pull all the products defined in the FAQ repository.



43

00:03:54,420 --> 00:04:02,850

Now to use a criteria based search, just add a question mark at the end and provide destination as,



44

00:04:02,850 --> 00:04:04,070

let's say, Florida.



45

00:04:04,320 --> 00:04:09,630

So what this will do is it will pull our products which have the destinations are to Florida.



46

00:04:10,050 --> 00:04:14,010

We can also use the max night as the criteria.



47

00:04:14,010 --> 00:04:19,710

So let's say we are looking for packages which have a maximum light stay of five nights.



48

00:04:19,890 --> 00:04:26,400

So here are the packages in which the number of nights is less than or equal to five.



49

00:04:26,400 --> 00:04:30,180

So this was our rest API for products.



50

00:04:30,570 --> 00:04:35,070

Now, if you look at the providers, we have the provider Idiz here.



51

00:04:35,310 --> 00:04:40,080

And so to get the information on the providers will have to use the provider API.



52

00:04:40,170 --> 00:04:48,810

So replace the product with providers and provide an ID questionmark ID equal to let's say three hundred.



53

00:04:49,140 --> 00:04:52,890

And here is the provider for ID equal to 300.



54

00:04:52,920 --> 00:04:56,910

This provider is a hotel and the name of the hotel is Hilton.



55

00:04:57,300 --> 00:04:58,640

Let's see what is it.



56

00:04:58,800 --> 00:04:59,840

Four hundred sort of.



57

00:04:59,950 --> 00:05:08,470

Place the provider, I leave it for the provider, it 400 years of pipe airline and the name of the



58

00:05:08,470 --> 00:05:10,380

airline is United Airlines.



59

00:05:10,510 --> 00:05:14,640

So these are the apps for the product and the providers.



60

00:05:14,860 --> 00:05:18,250

I suggest that you try out these apps on your own.



61

00:05:18,880 --> 00:05:24,280

The data that we have used for testing is available and the products fake repo class.



62

00:05:24,430 --> 00:05:29,850

Here are the four products that are in the products fake repository to check out the provider data,



63

00:05:29,860 --> 00:05:32,230

click on the provider fake repo.



64

00:05:32,470 --> 00:05:35,460

And here is the data for the providers.



65

00:05:35,470 --> 00:05:41,890

I suggest that you go through the code in the fake reviews on your own to check out the code in the



66

00:05:41,890 --> 00:05:46,150

rest API controller, click on the products rest API controller.



67

00:05:46,210 --> 00:05:49,500

As you can see, it's a springboard controller.



68

00:05:49,630 --> 00:05:54,100

Here is the mapping for products and the mapping for providers.



69

00:05:54,100 --> 00:06:00,670

Before you go through this class, I suggest that you go to the tutorial on how apps are implemented



70

00:06:00,670 --> 00:06:01,900

using Springboard.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\007 Introduction to GraphQL.en.srt -->

1

00:00:00,270 --> 00:00:07,800

Introduction to graphic in this lesson, you will learn what is graphic and how it addresses certain



2

00:00:07,950 --> 00:00:10,400

issues associated with rest.



3

00:00:11,490 --> 00:00:17,790

You will learn about the graphical salvos and by the end of this lecture, you should be able to explain



4

00:00:18,090 --> 00:00:22,200

the differences between arrest apps and a graphical API.



5

00:00:22,620 --> 00:00:30,450

Let's start with what is graphical graphics is a query language for apps that is not tied to any specific



6

00:00:30,450 --> 00:00:33,960

database or technology or network protocol.



7

00:00:34,380 --> 00:00:38,390

GAF Cual is a specification for query language.



8

00:00:38,700 --> 00:00:39,420

At times.



9

00:00:39,430 --> 00:00:47,670

The term graphical is also used for referring to a component that implements the graphical specifications.



10

00:00:48,270 --> 00:00:56,790

A graphical server exposes the graphical API endpoint that is used by the graphical clients to invoke



11

00:00:56,790 --> 00:00:58,500

graphical operations.



12

00:00:59,010 --> 00:01:06,770

Quick Bit of History Graphical was developed by Facebook for use in their mobile application in 2012.



13

00:01:07,170 --> 00:01:10,440

It was open source in 2015.



14

00:01:10,830 --> 00:01:18,180

At this time, there are many small to large organizations that have adopted graphical as a standard



15

00:01:18,180 --> 00:01:19,260

for their apps.



16

00:01:19,680 --> 00:01:28,260

I'll explain the graphical API by comparing it with the rest API arrest API exposes the API interface



17

00:01:28,260 --> 00:01:30,540

to the client by way of a contract.



18

00:01:31,020 --> 00:01:38,310

The API contract defines the schema for the request paillard that the client sends to the server, and



19

00:01:38,310 --> 00:01:43,710

it also defines the schema for the response payload that the server sends to the client.



20

00:01:43,740 --> 00:01:50,700

The structure of the request and response schemas is fixed and the client receives all of the data in



21

00:01:50,700 --> 00:01:53,890

the response payload, whether it needs it or not.



22

00:01:53,910 --> 00:02:02,100

So if you think about the rest API server as a data source, then it's like executing the select start



23

00:02:02,110 --> 00:02:08,620

from the table as the client has no choice in terms of what it needs in the response schema.



24

00:02:09,330 --> 00:02:14,760

This issue with the rest API, where the client is fetching more data than it needs, is referred to



25

00:02:14,760 --> 00:02:16,590

as the overarching issue.



26

00:02:17,010 --> 00:02:19,650

Now let's talk about graphical contract.



27

00:02:20,040 --> 00:02:27,360

Graphical contract is in the form of a graphical schema that defines the operations that are supported



28

00:02:27,360 --> 00:02:27,990

by the graphics.



29

00:02:28,230 --> 00:02:34,800

So these operations can be query operations, which is equivalent to the retrieves and operation can



30

00:02:34,800 --> 00:02:41,400

be of type mutation's, which are for updating, creating or deleting the data managed on the graph.



31

00:02:41,400 --> 00:02:46,470

Curole So the graphical schema also have type definitions, algo.



32

00:02:46,470 --> 00:02:48,270

What a schema in details.



33

00:02:48,450 --> 00:02:55,600

A little later, client can invoke the queries and tell the server what it needs in the response payload.



34

00:02:55,800 --> 00:02:58,680

So now the client has control over the response.



35

00:02:58,710 --> 00:03:03,840

So it is like calling the select with the feelings from a database table.



36

00:03:04,020 --> 00:03:10,430

This way the client is able to get only what it needs and not have the overarching issue.



37

00:03:11,280 --> 00:03:14,250

Next, let's talk about the rest API granularity.



38

00:03:14,760 --> 00:03:23,400

Generally, the rest APIs are built as highly granular services and this is done to meet the needs of



39

00:03:23,400 --> 00:03:25,390

multiple types of clients.



40

00:03:25,440 --> 00:03:26,790

This leads to an issue.



41

00:03:26,970 --> 00:03:32,370

Let me explain it with the earlier example of the rest API for Acme.



42

00:03:32,400 --> 00:03:39,360

The website gets the information about the package or the product, and then it needs to make additional



43

00:03:39,360 --> 00:03:42,540

calls to get information about the providers.



44

00:03:42,590 --> 00:03:48,720

Now, in this scenario, we are just talking about three calls, but it is common to see NS or even



45

00:03:48,720 --> 00:03:54,690

hundreds of calls made by the website to the appears to meet the requirements.



46

00:03:54,900 --> 00:03:56,610

And this leads to another problem.



47

00:03:56,850 --> 00:04:03,300

Since the client is not receiving all the data it needs, it is leading to the underfunding problem.



48

00:04:03,300 --> 00:04:11,280

And this under fetching is causing the client to make multiple network calls to the server to get the



49

00:04:11,280 --> 00:04:14,390

required data and that leads to a performance hit.



50

00:04:15,330 --> 00:04:23,340

So if we were to replace DWP with graphical, the app provider will put together the graphical specification,



51

00:04:23,730 --> 00:04:31,860

which will be used by the web developer to invoke the graphical queries against the API.



52

00:04:31,890 --> 00:04:38,700

Endpoint in the query decline site will specify the fields that it would like to receive.



53

00:04:38,700 --> 00:04:45,960

As part of the response, Sara will process the query and respond back with the requested fields in



54

00:04:45,960 --> 00:04:46,670

the response.



55

00:04:46,680 --> 00:04:51,810

So with this setup, with a single call, the client side is able to retrieve the required data.



56

00:04:52,110 --> 00:04:59,580

Hence, both the under fetching and the offsetting issues are addressed by Dolf it a graphical SOHR.



57

00:04:59,770 --> 00:05:06,360

Is implemented as a layer to manage all the client interactions it sits in front of the application



58

00:05:06,360 --> 00:05:15,270

to this layer, implements the graphical specification and is responsible for managing the client interactions



59

00:05:15,540 --> 00:05:17,440

on invocation of the API.



60

00:05:17,760 --> 00:05:25,590

This layer interacts with the components in the application to the developer of the graphical API needs



61

00:05:25,590 --> 00:05:31,830

to put together the graphical specifications which are used by the graphical server.



62

00:05:32,460 --> 00:05:35,420

There is no standard implementation of Gaskill.



63

00:05:35,550 --> 00:05:40,170

There are multiple frameworks available for different languages.



64

00:05:40,320 --> 00:05:45,260

Each of these frameworks have a different requirement from the application perspective.



65

00:05:45,480 --> 00:05:53,050

Most frameworks require the developers to create graphical components that get wired to the graphical.



66

00:05:53,100 --> 00:05:53,630

So.



67

00:05:53,660 --> 00:05:58,720

So the components that the developer need to put together depends on the framework.



68

00:05:59,160 --> 00:06:05,970

Next, I'll walk you through the flow of a graphical operation in a typical implementation of the graphical.



69

00:06:05,970 --> 00:06:12,090

So client invokes the operation on the endpoint exposed by the graphical.



70

00:06:12,090 --> 00:06:19,620

So the graphical server on receiving this invocation validates the request against the schema definition.



71

00:06:19,770 --> 00:06:25,860

If everything is good, then it requires the application to create an instance of a component referred



72

00:06:25,860 --> 00:06:27,540

to as the data fetcher.



73

00:06:27,660 --> 00:06:32,130

This data fetcher component provides the implementation for the operation.



74

00:06:32,160 --> 00:06:35,580

This component is also referred to as the query resolver.



75

00:06:35,670 --> 00:06:41,070

The data, which are component then interacts with the data sources, which can be a database or it



76

00:06:41,070 --> 00:06:42,720

can be other components.



77

00:06:42,750 --> 00:06:49,350

The idea is that the data fetcher retrieves the data from one or more sources after receiving the data



78

00:06:49,350 --> 00:06:54,540

from the data source that Delveccio then creates one or more instances of the resolvers.



79

00:06:54,570 --> 00:06:58,440

These resolvers are then returned back to the graphical Solia.



80

00:06:58,830 --> 00:07:05,760

The graph also invokes the functions on these resolvers to get the data for the fields that need to



81

00:07:05,760 --> 00:07:06,450

be passed.



82

00:07:06,450 --> 00:07:13,740

In the response, you will see all of these components and graphical in action in a later lecture.



83

00:07:14,430 --> 00:07:21,720

The graphical server implementation is available in multiple languages to learn more about these implementations.



84

00:07:21,930 --> 00:07:26,580

I suggest that you check out this link graphical advantages.



85

00:07:26,580 --> 00:07:33,390

You've already learned that graphical addresses the overfitting and the underfunding issue faced by



86

00:07:33,390 --> 00:07:35,010

the rest API client.



87

00:07:35,160 --> 00:07:41,460

The graphical client is in full control of the responses documentation photograph.



88

00:07:41,460 --> 00:07:47,160

CUAL is provided in the form of schema, so there is no need for a separate documentation.



89

00:07:47,370 --> 00:07:54,000

The graphical SOLIA provides very descriptive error information to the client, which can be used by



90

00:07:54,000 --> 00:08:02,550

the client side to understand the exact issue in their request to the graphical so graphical disadvantages.



91

00:08:02,550 --> 00:08:07,410

The biggest one is that there may be performance challenges with complex queries.



92

00:08:07,920 --> 00:08:15,510

Web caching is not as straightforward to implement with graphical as it is with the rest apps.



93

00:08:15,720 --> 00:08:20,250

Rest APIs are easy to learn compared to the graphical APIs.



94

00:08:21,600 --> 00:08:27,840

Let's go over the side by side comparison between the rest apps and graphical APIs.



95

00:08:27,870 --> 00:08:35,790

From the design perspective, rest APIs are defined in terms of resources and endpoints, whereas the



96

00:08:35,790 --> 00:08:44,160

graphical APIs are exposed over a single endpoint and the contract is in the form of a schema definition.



97

00:08:44,310 --> 00:08:50,940

From the control perspective, the client side has no control on the response, whereas the client has



98

00:08:50,940 --> 00:08:52,590

full control on the response.



99

00:08:52,770 --> 00:08:59,850

In the case of graphical restabilize expose card operations using HTP Wab's.



100

00:08:59,850 --> 00:09:06,840

Whereas in the case of graphical, all operations are invoked with either HTP, GECC or post.



101

00:09:07,050 --> 00:09:11,810

And there are three types of operations query, mutation and subscription.



102

00:09:12,150 --> 00:09:13,350

More on this later.



103

00:09:13,470 --> 00:09:20,580

From the network performance perspective, rest API client needs to make multiple network calls together



104

00:09:20,580 --> 00:09:28,560

the required information, whereas graphical API leads to reduced network traffic and that may lead



105

00:09:28,560 --> 00:09:31,710

to better performance from use cases perspective.



106

00:09:31,710 --> 00:09:40,500

Rest API are suited for resource driven applications, whereas graphical APIs are more suited for data



107

00:09:40,500 --> 00:09:41,880

driven applications.



108

00:09:42,540 --> 00:09:50,340

In this lesson you learned about graphical graphical is a specification for APIs graphical addresses,



109

00:09:50,340 --> 00:09:55,740

the underrating and the overwatching issues related to the rest API.



110

00:09:55,980 --> 00:09:59,610

A graphical server, implements the graphical special.



111

00:09:59,690 --> 00:10:06,590

Vacations, a graphical developer, needs to put together the schema definition for the API, and they



112

00:10:06,590 --> 00:10:12,200

also need to implement the components needed by the graphics server.



113

00:10:12,290 --> 00:10:19,040

The type of components that the developer has to put together depends on the graphical server in use.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\008 GraphQL Schema Definition.en.srt -->

1

00:00:00,330 --> 00:00:06,330

Schema definition language in this lesson are discussed, the golf war type system, you will learn



2

00:00:06,330 --> 00:00:10,960

how the client and the server use the schema for the execution of a query.



3

00:00:11,010 --> 00:00:14,290

I'll also share with you some tips for the creation of the schema.



4

00:00:14,700 --> 00:00:19,620

Please note, my intent is to provide you an overview of schema definition language.



5

00:00:19,620 --> 00:00:23,970

For details, please refer to the documentation which is available at this link.



6

00:00:24,300 --> 00:00:26,700

I'll start this lesson with a question.



7

00:00:27,120 --> 00:00:29,690

Which one would you use for your micro services?



8

00:00:29,700 --> 00:00:31,830

RESTful APIs or graphical?



9

00:00:32,750 --> 00:00:36,840

Well, the answer is that the two are not mutually exclusive.



10

00:00:37,250 --> 00:00:43,640

You need to pick up the one which makes more sense to your particular usage at this time.



11

00:00:43,640 --> 00:00:50,210

RESTful APIs are much more common than graphical APIs, but that is changing.



12

00:00:50,480 --> 00:00:55,040

So evaluate your requirements and then decide which one to go for.



13

00:00:56,000 --> 00:01:03,320

The graphical type system refers to the fact that graphical service defines a set of pipes which completely



14

00:01:03,320 --> 00:01:05,350

describe the set of possible data.



15

00:01:05,630 --> 00:01:12,680

You can query on the service the incoming queries are validated and executed against that schema.



16

00:01:12,980 --> 00:01:20,120

The schema is defined by way of the schema definition language which is programming language agnostic



17

00:01:20,360 --> 00:01:21,320

schema definition.



18

00:01:21,320 --> 00:01:26,030

Language is adjacent like language for defining the schema.



19

00:01:26,270 --> 00:01:31,100

For the graphical APIs, a schema consists of two parts.



20

00:01:31,310 --> 00:01:36,140

The first part are the operations supported by the graphical server.



21

00:01:36,290 --> 00:01:41,150

These operations can be queries, mutations and subscriptions.



22

00:01:41,330 --> 00:01:48,980

The other part has the pipes, which are the software defined objects, and each of these objects have



23

00:01:48,980 --> 00:01:53,360

fields of specific types supported by the graphical schema.



24

00:01:53,960 --> 00:02:00,140

In the context of schema definition, language operations are also referred to as the root types.



25

00:02:00,590 --> 00:02:07,550

The root type query is used by the client for retrieval of objects defined on the sofa in the schema



26

00:02:07,550 --> 00:02:08,690

definition language.



27

00:02:09,020 --> 00:02:14,450

The root type query lists out all of the name queries.



28

00:02:14,570 --> 00:02:17,360

For example, products is a name query.



29

00:02:17,750 --> 00:02:21,200

Each query is defined with a list of arguments.



30

00:02:21,230 --> 00:02:24,860

The arguments are the query criteria.



31

00:02:25,190 --> 00:02:32,060

Each of the arguments have a type and there is also a response type, which in this case is an array



32

00:02:32,090 --> 00:02:33,440

of product objects.



33

00:02:33,890 --> 00:02:41,060

In this particular set of the product query, all of the arguments are optional or they can be marked



34

00:02:41,060 --> 00:02:44,960

as required to make an argument as required.



35

00:02:45,590 --> 00:02:48,760

The type needs to be suffixed with an exclamation mark.



36

00:02:49,160 --> 00:02:55,970

So if public ID was to be a required argument that I think will be suffixed with an exclamation mark,



37

00:02:56,600 --> 00:03:03,500

a graph, Kosovo may allow the client to modify the state of object maintain on the server.



38

00:03:03,500 --> 00:03:07,970

And it does this by defining the root types notation.



39

00:03:08,120 --> 00:03:14,900

The root type notation is similar to the rootie query in the sense that there are named mutations in



40

00:03:14,900 --> 00:03:15,920

the specification.



41

00:03:16,040 --> 00:03:22,790

And these named mutations also take arguments and return object like named queries.



42

00:03:22,790 --> 00:03:27,980

And the last root type is the subscription root type, which is different from the query and mutation



43

00:03:27,980 --> 00:03:31,970

in the sense that subscription operation is not initiated by the client.



44

00:03:32,000 --> 00:03:38,240

The client subscribes to the events on the server and the server pushes the data to the client.



45

00:03:38,240 --> 00:03:44,990

In response to the events, types are used for defining the structure of the domain object.



46

00:03:45,320 --> 00:03:49,910

The scalar types are the standard types defined in the schema.



47

00:03:49,910 --> 00:03:56,510

Definition, language, integer, float, string and boolean are the foundational scalar types.



48

00:03:56,780 --> 00:04:04,220

Idee is a special type, which is not part of the business domain data, but is primarily used for managing



49

00:04:04,220 --> 00:04:06,440

the caching of the query data.



50

00:04:06,680 --> 00:04:12,890

The graphical service defines the complex type by combining the standard scalar types.



51

00:04:13,070 --> 00:04:18,800

This is no different from the way you define objects in any object oriented programming.



52

00:04:18,800 --> 00:04:24,080

Language fields may be thought of as an attribute in an object.



53

00:04:24,680 --> 00:04:29,240

These attributes have a type which may be scalar or complex type.



54

00:04:29,570 --> 00:04:32,120

Here's an example of a complex type.



55

00:04:32,300 --> 00:04:35,000

The name of this complex type is product.



56

00:04:35,000 --> 00:04:41,320

The first four fields are scalar types and each of these fields are required to the providers.



57

00:04:41,330 --> 00:04:45,950

Field is an array of complex type elements in the area are required.



58

00:04:46,320 --> 00:04:51,380

The provider type is defined separately in the schema definition by the server.



59

00:04:51,590 --> 00:04:58,080

It is the definition of the provider type which consists of five scalar fields which are all required.



60

00:04:58,100 --> 00:05:04,910

So what this tells you is that complex types can be nested, meaning one complex type may contain other



61

00:05:04,910 --> 00:05:05,870

complex types.



62

00:05:06,170 --> 00:05:13,130

One important thing to keep in mind is that deep nesting of object definitions can impact the performance



63

00:05:13,130 --> 00:05:13,940

of the server.



64

00:05:13,940 --> 00:05:21,200

And this is because deeply nested complex types would require hierarchical resolver implementations



65

00:05:21,470 --> 00:05:27,290

and that will in turn also lead to the complexity of implementing the graph also.



66

00:05:27,490 --> 00:05:31,460

So these are certain things that you need to keep in mind when designing your types.



67

00:05:32,410 --> 00:05:36,700

Talk about how a client executes the query on a graph.



68

00:05:37,060 --> 00:05:41,880

So the first thing the client needs to do is prepare the request payload.



69

00:05:41,920 --> 00:05:45,010

This request payload is a Jason like document.



70

00:05:45,190 --> 00:05:50,630

The structure of this document is defined by graphic Huet, and the client has to comply with it.



71

00:05:50,860 --> 00:05:56,380

The first thing you see here is the route type, which is set to query this could be mutation or this



72

00:05:56,380 --> 00:05:58,240

could be subscription as well.



73

00:05:58,630 --> 00:06:01,630

Then there is a name query in this example.



74

00:06:01,630 --> 00:06:03,510

The name query is the products.



75

00:06:03,520 --> 00:06:10,510

The products query is defined in this schema definition to take multiple optional arguments since for



76

00:06:10,510 --> 00:06:13,090

the products, all of the arguments are optional.



77

00:06:13,090 --> 00:06:16,540

The client may specify zero or more argument values.



78

00:06:16,780 --> 00:06:20,590

These arguments act as the criteria for the query.



79

00:06:20,740 --> 00:06:26,200

Now let's talk about what makes graphical different from the rest API query.



80

00:06:26,350 --> 00:06:34,030

As you can see here, the client can specify the fields that it desires to receive from the server in



81

00:06:34,030 --> 00:06:34,800

the response.



82

00:06:34,810 --> 00:06:38,520

And this is what makes things interesting and graphical.



83

00:06:38,950 --> 00:06:41,420

You cannot do this in APIs.



84

00:06:41,560 --> 00:06:48,220

So here in this example, the client is requesting the server to return description, destination and



85

00:06:48,220 --> 00:06:50,230

number of nights fill only.



86

00:06:50,800 --> 00:06:57,880

The client will then send the request payload to the server on the server in the graphical so will first



87

00:06:57,880 --> 00:06:59,200

validate the request.



88

00:06:59,290 --> 00:07:03,880

The server delegated the request processing to the Microsoft Office as components.



89

00:07:03,880 --> 00:07:09,280

The Microsoft Office will then create the resolver instances and pass those back to the graphical.



90

00:07:09,280 --> 00:07:16,540

Some of the Greyscale server, in turn, will create the response pillared based on the request from



91

00:07:16,540 --> 00:07:19,330

the client and the request from the client.



92

00:07:19,330 --> 00:07:23,980

In this particular example is to receive only three fields.



93

00:07:24,370 --> 00:07:30,250

So the graph crossover will send back the product information in such a way that each of the product



94

00:07:30,250 --> 00:07:35,830

in the response will have information or data only for those three fields.



95

00:07:36,490 --> 00:07:38,230

Graphical developer tools.



96

00:07:38,230 --> 00:07:43,600

In the last couple of years, the ecosystem around graphical has evolved a lot.



97

00:07:43,630 --> 00:07:49,130

There are multiple tools that you can use to assist with the graphical development.



98

00:07:49,510 --> 00:07:52,630

These are some of the tools that I have personally liked.



99

00:07:52,750 --> 00:07:58,450

In fact, one of these tools, the graphical playground, is the one that I have used for testing my



100

00:07:58,450 --> 00:08:02,020

graphical in this case, and you will see it in action.



101

00:08:02,050 --> 00:08:08,050

Please do your own research and share your thoughts on other tools that you may find useful.



102

00:08:08,620 --> 00:08:14,580

I learned this lesson by sharing some tips on designing the schema for your graphical apps.



103

00:08:15,040 --> 00:08:18,990

Think of the schema definition as a shared language.



104

00:08:19,000 --> 00:08:22,270

Don't forget your ubiquitous language for the domain.



105

00:08:22,660 --> 00:08:29,410

So make sure that your schema definitions are mapping to the terms in the ubiquitous language.



106

00:08:30,010 --> 00:08:33,010

Take an evolutionary approach to create the API.



107

00:08:33,310 --> 00:08:34,600

Don't try to do everything.



108

00:08:34,600 --> 00:08:42,010

At the same time, the idea is to publish version one of the API and then look at how the client or



109

00:08:42,010 --> 00:08:46,210

the consumers or the API are using your service.



110

00:08:46,540 --> 00:08:50,440

And based on that evol, the schema for your APIs.



111

00:08:51,040 --> 00:08:57,370

Time to go over the key points from this lesson schema definition language is used by the server to



112

00:08:57,370 --> 00:09:00,490

define the schema or the contract for the API.



113

00:09:00,910 --> 00:09:06,670

Sarah uses the schema to validate the incoming request for operations.



114

00:09:06,790 --> 00:09:12,910

Sara also uses the schema for creating the responses that it sends back to the client.



115

00:09:13,120 --> 00:09:20,230

Client uses the schema to create the request payload and to parse the responses it receives from the



116

00:09:20,350 --> 00:09:20,890

server.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\009 Exercise _ ACME  GraphQL API for Products.en.srt -->

1

00:00:00,210 --> 00:00:08,820

Acme products that the application developers who are using the Acme Product API are complaining and



2

00:00:08,820 --> 00:00:15,700

the Acme Products Micro Services Team has decided to implement a graphical API for the product.



3

00:00:15,720 --> 00:00:21,480

In this lesson, I'll walk you through the schema definition for the products and the providers that



4

00:00:21,480 --> 00:00:28,160

the product micro services team has decided to use for the Acme Products Graphical API.



5

00:00:28,620 --> 00:00:35,460

The mobile and web application developers at Acme are complaining that the rest API is not working out



6

00:00:35,460 --> 00:00:40,890

well, and the reason for that is that it requires complex logic to be buried in the applications.



7

00:00:41,040 --> 00:00:47,580

And the performance of these applications is bad due to multiple network calls that the applications



8

00:00:47,580 --> 00:00:48,360

need to make.



9

00:00:48,360 --> 00:00:50,550

So that elite carried out analysis.



10

00:00:50,550 --> 00:00:57,060

And what he discovered is that overfishing was a big issue of hedging means that there was a lot more



11

00:00:57,060 --> 00:01:01,540

data being sent back to the applications than required.



12

00:01:01,560 --> 00:01:07,680

He made the decision that there is a need to reduce the amount of data sent from the API and there is



13

00:01:07,680 --> 00:01:13,500

a need for the developers to have more control on what they receive from the API at that point.



14

00:01:13,740 --> 00:01:18,060

The decision was clear and graphic here is meant for these kind of scenarios.



15

00:01:18,060 --> 00:01:23,050

So the committee has decided to build a graphical for products.



16

00:01:23,070 --> 00:01:29,820

The idea is that the scenario where the rest API is getting called multiple times from the Web application



17

00:01:30,150 --> 00:01:37,930

will be replaced by a graphical based API wherein the application will query the product by sending



18

00:01:37,930 --> 00:01:45,420

in the product query with the required arguments as criteria and then receive back a response which



19

00:01:45,420 --> 00:01:49,510

will contain only the requested fields for the product.



20

00:01:49,530 --> 00:01:56,370

It'll be a consolidated query, meaning the application will not have to make multiple calls to get



21

00:01:56,370 --> 00:01:58,890

the data from the products Microsoft is.



22

00:01:59,430 --> 00:02:06,120

This product API would require the schema definition, so the team has decided to put together the schema



23

00:02:06,120 --> 00:02:12,900

definition with the query operation for the product and the provider domain models.



24

00:02:13,230 --> 00:02:19,050

This query API will be exposed over a common endpoint which will have this format.



25

00:02:19,410 --> 00:02:27,120

All future graphical operations such as queries and the mutation's will also be exposed by way of this



26

00:02:27,120 --> 00:02:29,560

common endpoint next.



27

00:02:29,580 --> 00:02:33,690

I'll walk you through the schema definition for the product and provider's query.



28

00:02:33,690 --> 00:02:39,990

The schema that I'm walking you through is available and this repository and make sure to check out



29

00:02:39,990 --> 00:02:41,460

the branch API.



30

00:02:41,880 --> 00:02:49,260

These schema definition for the product graphical API is available under the resources subfolder in



31

00:02:49,260 --> 00:02:51,210

the file room Dawidoff keywords.



32

00:02:51,450 --> 00:02:58,110

There is a product query that makes for optional arguments, public idea of the product or the vacation



33

00:02:58,110 --> 00:03:03,990

package, destination minimum number of nights and the maximum number of nights.



34

00:03:04,140 --> 00:03:09,840

In response to this query, the server sends back an array of products.



35

00:03:10,140 --> 00:03:12,660

The second query is the provider's query.



36

00:03:12,690 --> 00:03:16,320

That takes one argument of type in.



37

00:03:16,530 --> 00:03:20,980

This exclamation mark here indicates that this is a required argument.



38

00:03:21,000 --> 00:03:26,100

Notice that none of the arguments for the product have the exclamation mark.



39

00:03:26,340 --> 00:03:32,610

And that is the reason I said that these arguments for the products query are optional.



40

00:03:32,820 --> 00:03:37,740

The provider query responds back with an object of type provider.



41

00:03:38,100 --> 00:03:40,230

Let's take a look at the type product.



42

00:03:40,230 --> 00:03:46,170

The product type has all the attributes which are part of the product object and the domain model,



43

00:03:46,170 --> 00:03:51,180

public ID description, number of night destination and providers.



44

00:03:51,210 --> 00:03:54,090

The big difference is in the providers.



45

00:03:54,090 --> 00:04:00,750

Instead of holding just the provider ID, the provider's attribute is holding an area of the actual



46

00:04:00,750 --> 00:04:01,680

provider type.



47

00:04:01,690 --> 00:04:09,030

So what that means is that response to the query for products will return the product object with all



48

00:04:09,030 --> 00:04:12,010

the information for the providers as well.



49

00:04:12,030 --> 00:04:18,420

As a result, the quality of the product query will not have to make multiple calls to get the information



50

00:04:18,420 --> 00:04:23,490

for the providers, and that is where the client's performance is expected to improve.



51

00:04:23,520 --> 00:04:25,860

Let's take a quick look at the provider as well.



52

00:04:25,860 --> 00:04:31,650

So Provider has all the attributes that are there and the provider class in the domain model.



53

00:04:31,800 --> 00:04:37,230

I suggest that you take a look at the domain object defined under the model package.



54

00:04:37,230 --> 00:04:41,810

Product has the same attributes that are defined in the query definition file.



55

00:04:41,910 --> 00:04:48,260

Similarly, the provider has the same set of attributes that are there in the provider classes.



56

00:04:48,300 --> 00:04:52,170

In the next lesson you will see these queries in action.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15 Microservices and API\010 Hands On _ ACME GraphQL API in action.en.srt -->

1

00:00:00,630 --> 00:00:08,320

Products, graphical implementation, in this lesson, you will see the graphical product API in action.



2

00:00:08,430 --> 00:00:14,790

I'll also walk you through the class diagram and the code for the products API implementation.



3

00:00:15,030 --> 00:00:21,090

Since the product's micro services team has been using Springboard, they have decided to go with the



4

00:00:21,090 --> 00:00:24,810

springboard for the implementation of their graphical API.



5

00:00:24,870 --> 00:00:32,820

Springboard internally uses the graphical Java implementation of these specifications to gain better



6

00:00:32,820 --> 00:00:35,890

understanding of graphical Java implementation.



7

00:00:35,940 --> 00:00:40,190

I suggest that you visit the site graphical dash Java dot com.



8

00:00:41,040 --> 00:00:43,970

We will be using graphical playground for testing.



9

00:00:44,070 --> 00:00:50,250

So if you are interested in following along, please post the video, download the graphical playground



10

00:00:50,370 --> 00:00:55,570

and set it up on your machine before proceeding for schema definition development.



11

00:00:55,590 --> 00:01:03,520

I highly suggest that you install the graphical plugin in your ID, such as intelligent visual code.



12

00:01:03,720 --> 00:01:08,430

I have this plugin installed in my intelligence setup to test out.



13

00:01:08,430 --> 00:01:10,250

The graph will appear.



14

00:01:10,710 --> 00:01:19,230

We will first launch the graph CALIPSO, then launch the graphical playground and execute queries from



15

00:01:19,230 --> 00:01:27,120

the graphical prasugrel against the graphical API exposed by our products Microsoft Office to launch



16

00:01:27,120 --> 00:01:28,680

the graphical SOA right.



17

00:01:28,680 --> 00:01:33,330

Click on the run products here and hit run.



18

00:01:33,630 --> 00:01:37,400

We need to launch the graphical playground to connect with the server.



19

00:01:37,500 --> 00:01:46,110

Click on your endpoint, provide the endpoint which is localhost eighty slash graph cual click on Open.



20

00:01:46,110 --> 00:01:52,500

When the playground connects to the server, it fetches the schema so you will see the content pulled



21

00:01:52,500 --> 00:01:54,280

from the schema definition file.



22

00:01:54,300 --> 00:02:00,540

Here are the queries for the product, the provider, and then there is the object definition with all



23

00:02:00,540 --> 00:02:02,940

the fields for the provider and the product.



24

00:02:02,970 --> 00:02:06,300

Let's go ahead and try out a query query.



25

00:02:06,300 --> 00:02:08,060

Start with the keyword query.



26

00:02:08,100 --> 00:02:11,790

Next, we have to tell which query we want to execute the product.



27

00:02:11,790 --> 00:02:18,160

We need to provide the arguments, let's just say number of midnight and set it two, three.



28

00:02:18,330 --> 00:02:22,200

Next, we need to specify the fields that we are interested in receiving.



29

00:02:22,620 --> 00:02:28,860

So let's put description destination number of nights, go ahead and execute it.



30

00:02:29,040 --> 00:02:35,120

And here are the packages of the product in which the minimum number of nights is three.



31

00:02:35,160 --> 00:02:37,770

Let's change this to five and see what happens.



32

00:02:38,040 --> 00:02:43,920

And as you can see now, we are seeing the product in which the minimum number of nights is five.



33

00:02:43,930 --> 00:02:46,560

Let's change this criteria to destination.



34

00:02:46,680 --> 00:02:51,270

Let's say we are interested in products for which the destination is Florida.



35

00:02:51,780 --> 00:02:57,000

And here is the response from the server with a single product for Florida.



36

00:02:57,060 --> 00:03:02,700

Now, the best part, we can ask the server to return to us the information on the providers, and we



37

00:03:02,700 --> 00:03:05,640

need to specify the fields for the providers.



38

00:03:05,640 --> 00:03:10,020

So let's say a name and let's say type, execute the query.



39

00:03:10,350 --> 00:03:16,950

And now, as you can see, we received the information about the package and we also received the information



40

00:03:16,950 --> 00:03:20,370

about the two providers, which are part of the package.



41

00:03:20,370 --> 00:03:25,800

And for these two providers, we are receiving only the information that we requested, the name and



42

00:03:25,800 --> 00:03:26,310

the type.



43

00:03:26,310 --> 00:03:32,060

So as you can see here with a single call, we received all the information that we needed.



44

00:03:32,250 --> 00:03:37,740

I suggest that you install the graphical playground and try out these queries on your own.



45

00:03:38,640 --> 00:03:45,390

The implementation classes for the API are in the Commodore Achmat or Product Start graphical package.



46

00:03:45,420 --> 00:03:50,670

The main class here is the graphical provider that is used for bootstrapping.



47

00:03:50,670 --> 00:03:52,410

The Springboard application.



48

00:03:52,530 --> 00:03:57,780

The main test class where the springboard application gets launched is the run product.



49

00:03:57,910 --> 00:04:02,430

Rafeal Appia under the Commodore Achmad or test package.



50

00:04:02,610 --> 00:04:10,920

The Graph Kuhar Data Fetcher class is a factory for creating the data features for the product query



51

00:04:11,100 --> 00:04:12,750

and the provider query.



52

00:04:12,930 --> 00:04:21,240

Didkovsky provider uses the graphical data fetcher for creating the instances of these data features



53

00:04:21,420 --> 00:04:27,690

the data fetcher for product users, the product query model, which may be thought of as a wrapper



54

00:04:27,690 --> 00:04:30,620

for the product and the provider information.



55

00:04:30,660 --> 00:04:33,060

This is the resolver for the product query.



56

00:04:33,060 --> 00:04:41,320

It exposes function for each of the fields defined in the schema definition for the API when the graph



57

00:04:41,670 --> 00:04:46,590

server receives a request for execution of query delegates.



58

00:04:46,590 --> 00:04:51,060

That request to the data features also known as query resolvers.



59

00:04:51,060 --> 00:04:59,310

So in the case of the product API, there is an instance of the data fetcher for product and there is



60

00:04:59,320 --> 00:04:59,520

a.



61

00:04:59,930 --> 00:05:08,900

And of Fetcher for providing these instances expose functions which get executed on query requests for



62

00:05:08,900 --> 00:05:10,250

product and provider.



63

00:05:10,700 --> 00:05:13,430

Let's take a look at the code for these data.



64

00:05:13,430 --> 00:05:21,260

Fetches declasse Grauwe Cuadrilla features is the factory for creating instances for the data fetches



65

00:05:21,560 --> 00:05:27,680

each of the data fetcher implements the interface data feature and has one function get.



66

00:05:27,950 --> 00:05:33,650

So this is where we are creating an instance of the data fetcher for the product class and in the code



67

00:05:33,650 --> 00:05:40,400

forget you will find that the first thing we are doing is getting the query arguments after that, executing



68

00:05:40,400 --> 00:05:48,920

the query on the product repo, then wrapping the product object with the product query model object



69

00:05:49,160 --> 00:05:56,480

that holds instance of the product as well as all of the providers that are part of the product.



70

00:05:56,660 --> 00:05:59,600

And this area is returned back to the server.



71

00:05:59,780 --> 00:06:06,830

Essentially, this whole thing, resolvers for the product, objects that are sent back to the caller.



72

00:06:07,220 --> 00:06:11,900

Similarly, there is a fetcher getting created for the provider query.



73

00:06:12,170 --> 00:06:15,220

And this feature is relatively very simple.



74

00:06:15,560 --> 00:06:20,750

We are simply using the provider repo and sending back the instance of the provider.



75

00:06:20,870 --> 00:06:27,820

The provider instance that we are sending back is the resolver for the provider queries the data for



76

00:06:27,830 --> 00:06:33,870

the product API responds back with an array of resolver object for the product.



77

00:06:34,430 --> 00:06:42,620

These are resolver objects, expo's functions corresponding to each of these fields in the schema definition



78

00:06:42,830 --> 00:06:43,610

for the product.



79

00:06:44,060 --> 00:06:50,890

So for example, it is the gate description function for retrieving the information on the description



80

00:06:51,230 --> 00:06:58,580

that says the get public its function for getting the public ID and there are other functions corresponding



81

00:06:58,580 --> 00:06:59,720

to each of the fields.



82

00:07:00,020 --> 00:07:06,650

The server calls these functions to get the information for each of the field that it needs to return



83

00:07:06,650 --> 00:07:07,790

back to the column.



84

00:07:08,480 --> 00:07:14,920

In this lesson, you saw the product in action and you saw the implementation for the product query.



85

00:07:15,290 --> 00:07:19,040

I suggest that you try out the providers query on your own.



86

00:07:19,310 --> 00:07:24,050

Take a look at the implementation of the provider query as an exercise.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000001.srt -->

1
00:00:00,180 --> 00:00:18,150
Hãy bắt đầu phần này bằng cách xác định API là gì, API là viết tắt của giao diện lập trình ứng dụng, là giao diện xác định sự tương tác giữa nhiều ứng dụng phần mềm hoặc các phần mềm trung gian phần cứng hỗn hợp.

2
00:00:18,660 --> 00:00:27,090
Đây là định nghĩa từ Wikipedia.  Bây giờ mối quan tâm của chúng tôi là các dịch vụ vi mô, có thể được coi là các ứng dụng độc lập.

3
00:00:27,240 --> 00:00:37,560
Hãy cùng tìm hiểu sâu hơn về cách các dịch vụ vi mô sử dụng API.  Các dịch vụ vi mô cung cấp API để các dịch vụ vi mô khác sử dụng.

4
00:00:37,590 --> 00:01:00,910
Thông thường, các ứng dụng này sẽ bị lộ hoặc HTP, nhưng nhắn tin là giao thức ưu tiên vì những tương tác giữa các ứng dụng này sẽ biến mất hoặc một nhóm ứng dụng riêng biệt có thể bị lộ với các thành phần bên ngoài như giao diện người dùng hoặc ứng dụng cũ.

5
00:01:01,140 --> 00:01:09,870
Một số người tiêu dùng này thậm chí có thể ở bên ngoài tổ chức sở hữu dịch vụ vi mô cho những tương tác như vậy.

6
00:01:10,200 --> 00:01:22,800
HTP được sử dụng phổ biến và lý do là việc nhắn tin sẽ yêu cầu sự phụ thuộc vào một công nghệ nhắn tin cụ thể, điều này sẽ khiến việc sử dụng API trở nên rất hạn chế.

7
00:01:23,070 --> 00:01:32,160
SCDP là một tiêu chuẩn mở giúp EPA dễ dàng tiếp cận hơn với bất kỳ loại khách hàng nào có thể thực hiện các cuộc gọi bổ sung.

8
00:01:32,700 --> 00:01:43,640
Dịch vụ vi mô.  Chúng tôi nhận ra các API này theo nhiều cách.  Các nhà thiết kế dịch vụ vi mô thường sử dụng Hippias và API đồ họa ở mức cao.

9
00:01:44,100 --> 00:01:57,610
Sự khác biệt giữa hai điều này là ở cách họ xác định hợp đồng giữa khách hàng và SO.  Cả hai đều có ưu và nhược điểm trong phần bạn tìm hiểu về phần còn lại, heo vòi và đồ họa.

10
00:01:57,780 --> 00:02:09,630
Tôi hy vọng rằng đến cuối phần này, bạn sẽ có thể quyết định nên sử dụng API còn lại hay sử dụng đồ họa cho AP được hiển thị bởi các dịch vụ vi mô của bạn.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000002.srt -->

1
00:00:00,340 --> 00:00:10,860
Ổn định lại trong bài học này, bạn sẽ tìm hiểu điều gì tạo nên một API, một API an toàn.  Tôi cũng sẽ cung cấp một cái nhìn tổng quan về các hạn chế kiến ​​trúc còn lại.

2
00:00:10,980 --> 00:00:25,440
Hãy bắt đầu bằng một câu hỏi.  Kiến trúc của bạn có yên tĩnh không?  Một số nhà phát triển nghĩ rằng bằng cách sử dụng HTP và Jason, họ đang tạo ra một ứng dụng đủ tiêu chuẩn là một kiến ​​trúc yên tĩnh, điều này có thể đúng hoặc có thể không đúng.

3
00:00:25,470 --> 00:00:35,400
Những ứng dụng này có thể không yên tĩnh, nhưng chúng có thể yên tĩnh như Orestis.  Sau đó, câu hỏi hiển nhiên xuất hiện trong đầu là điều gì khiến một kiến ​​trúc trở nên hữu ích?

4
00:00:35,640 --> 00:00:48,830
Để kiến ​​trúc ứng dụng đủ điều kiện là yên tĩnh, nó phải tuân theo sáu quy tắc thiết kế và sáu quy tắc thiết kế này được gọi là các ràng buộc về kiến ​​trúc còn lại.

5
00:00:49,140 --> 00:00:59,710
Một chút lịch sử nhanh chóng.  Sáu hạn chế về mặt kiến ​​trúc cho Sự yên tĩnh đã được Roy Fielding mô tả trong bài luận văn của ông vào năm 2000.

6
00:00:59,820 --> 00:01:09,450
Chúng ta hãy đi qua sáu điều này.  Khôi phục các hạn chế về kiến ​​trúc.  Xin lưu ý rằng mục đích của tôi ở đây là cung cấp cho bạn cái nhìn tổng quan về các ràng buộc về kiến ​​trúc.

7
00:01:09,660 --> 00:01:18,760
Nếu bạn muốn tìm hiểu thêm về những hạn chế này, vui lòng tự nghiên cứu.  Vì vậy, hạn chế về kiến ​​trúc đầu tiên đối với chúng tôi là khách hàng.

8
00:01:18,810 --> 00:01:27,570
Vì vậy, ràng buộc này gợi ý việc sử dụng các nguyên tắc thiết kế máy chủ của khách hàng để triển khai API còn lại.

9
00:01:27,750 --> 00:01:36,300
Thứ hai là giao diện thống nhất đề xuất sử dụng các hợp đồng được xác định rõ ràng giữa khách hàng và bên đó.

10
00:01:36,600 --> 00:01:44,230
Thứ ba là tình trạng không trạng thái, điều này cho thấy máy chủ không nên quản lý trạng thái của ứng dụng.

11
00:01:44,410 --> 00:01:53,220
Thứ tư là bộ nhớ đệm.  Máy chủ nên sử dụng các tiêu đề bộ nhớ đệm HDB để lưu vào bộ nhớ đệm các phản hồi đối với yêu cầu nhận được từ máy khách.

12
00:01:53,400 --> 00:02:02,540
Thứ năm là học tập.  Điều này gợi ý rằng kiến ​​trúc nên được phân lớp và mỗi lớp này phải được quản lý độc lập.

13
00:02:02,640 --> 00:02:14,700
Thêm một cái được gọi theo yêu cầu.  Và điều này cho thấy rằng SOA không chỉ có thể gửi dữ liệu đến máy khách để đáp ứng yêu cầu mà còn có thể gửi mã mà máy khách có thể thực thi.

14
00:02:14,820 --> 00:02:26,250
Ràng buộc này là tùy chọn.  Vì vậy, điều đó có nghĩa là miễn là việc triển khai của bạn tuân theo năm ràng buộc đầu tiên thì kiến ​​trúc của bạn sẽ được coi là yên tĩnh.

15
00:02:26,700 --> 00:02:44,630
Hãy nhớ lại rằng các API còn lại không bị giới hạn ở giao thức HTP.  Vì vậy, nếu bạn đang sử dụng SCDP và nó tuân theo các ràng buộc về kiến ​​​​trúc thì nó được cho là API còn lại EDP hoặc khôi phục S2P.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000003.srt -->

1
00:00:00,330 --> 00:00:12,840
Chỉ qua HTP, trong bài học này, bạn sẽ tìm hiểu khái niệm quan trọng nhất về ứng dụng cứu hộ, các tài nguyên bạn tìm hiểu về các định dạng dữ liệu khác nhau mà các ứng dụng còn lại có thể hỗ trợ.

2
00:00:13,140 --> 00:00:26,070
Và tôi sẽ đề cập đến cách sử dụng các phương thức hoặc động từ HTP để quản lý trạng thái của tài nguyên hoặc các đối tượng hoặc tài nguyên trong thế giới thực, có thể được mô tả bằng các thuộc tính.

3
00:00:26,070 --> 00:00:37,460
Ví dụ: một chiếc ô tô có thể được mô tả bằng năm sản xuất và số VIN.  Và số VIN này mang lại cho ô tô một bản sắc riêng trong hệ thống phần mềm.

4
00:00:37,500 --> 00:00:45,740
Các thuộc tính này được quản lý trong một số loại lưu trữ liên tục.  Nó có thể là RDBMS hoặc thậm chí có thể là cơ sở dữ liệu hàng hải.

5
00:00:45,900 --> 00:00:54,270
Có một số thuộc tính nhất định của đối tượng có thể thay đổi theo thời gian.  Ví dụ, chủ sở hữu của chiếc xe có thể thay đổi.

6
00:00:54,420 --> 00:01:02,670
Vince mua xe mới nên chủ xe cho là thắng, sau đó bán xe nên không còn là chủ sở hữu nữa.

7
00:01:02,700 --> 00:01:10,990
Và kể từ khi anh ấy bán chiếc xe cho chủ sở hữu Cathy McCarty's, tất cả các thay đổi về dữ liệu trạng thái đều được ghi lại trong bộ lưu trữ lâu dài.

8
00:01:11,130 --> 00:01:23,780
Vì vậy, điều chúng tôi đang nói ở đây là trạng thái đại diện của ô tô được quản lý trong cơ sở dữ liệu và chúng có thể là nhiều phiên bản ô tô được xác định duy nhất bằng số VIN của chúng.

9
00:01:24,090 --> 00:01:32,590
Mỗi chiếc xe này có các giá trị khác nhau cho các thuộc tính và chủ sở hữu khác nhau.  Bây giờ hãy nghĩ đến một hệ thống có thể truy vấn cơ sở dữ liệu này.

10
00:01:32,670 --> 00:01:38,640
Hệ thống này có thể yêu cầu cơ sở dữ liệu cung cấp thông tin chi tiết về số VIN, số một, hai, ba cho truy vấn này.

11
00:01:38,790 --> 00:01:45,270
Cơ sở dữ liệu sẽ phản hồi bằng cách gửi lại trạng thái đại diện của ô tô có số VIN một, hai, ba.

12
00:01:45,480 --> 00:02:02,420
Những gì bạn vừa học là khái niệm cơ bản về trạng thái nghỉ, sự chuyển giao trạng thái biểu diễn.  Ứng dụng theo dõi chủ sở hữu đã nhận được trạng thái đại diện cho chiếc ô tô có số VIN một, hai, ba từ cơ sở dữ liệu nguồn.

13
00:02:03,000 --> 00:02:10,500
Dữ liệu trạng thái biểu diễn này có thể ở bất kỳ định dạng nào.  Ví dụ: nó có thể là tập hợp các cặp giá trị tên.

14
00:02:10,770 --> 00:02:18,990
Nó có thể nằm trong bản ghi cơ sở dữ liệu để biểu diễn trạng thái nội bộ này được chuyển đổi sang định dạng khác.

15
00:02:19,320 --> 00:02:27,510
Ví dụ: một số loại logic có thể được kết hợp với nhau để chuyển đổi nó thành ethanol, chất này được trình duyệt klencke tiêu thụ.

16
00:02:27,810 --> 00:02:38,370
Hoặc nó có thể được chuyển đổi sang ví dụ JSON CSFI, đây là định dạng phổ biến cho các ứng dụng di động, ứng dụng web và tích hợp ứng dụng đối tác.

17
00:02:38,610 --> 00:02:48,660
Nhưng đó không phải là định dạng duy nhất nó có thể được chuyển đổi sang.  Trạng thái biểu diễn này có thể được chuyển đổi sang bất kỳ định dạng nào như Jetpack, PDF, Excel, v.v.

18
00:02:48,660 --> 00:02:59,400
Để thảo luận, chúng ta hãy xóa biểu mẫu e-mail.  Bây giờ, nếu chúng ta thay thế logic bằng API còn lại thì đây là một đại diện tốt cho API an toàn.

19
00:02:59,400 --> 00:03:06,420
Từ góc độ định dạng dữ liệu, điều này cho bạn biết rằng Anastacia không bị ràng buộc với bất kỳ định dạng dữ liệu cụ thể nào.

20
00:03:06,430 --> 00:03:18,000
Trên thực tế, cùng một phiên bản API an toàn của chúng tôi có thể chuyển đổi và gửi lại trạng thái biểu diễn của tài nguyên ở các định dạng khác nhau dựa trên nhu cầu của khách hàng API.

21
00:03:18,160 --> 00:03:53,220
Indeed là một trang đăng việc làm cũng cung cấp API nghỉ ngơi.  API còn lại này quản lý API RESTful của tài nguyên công việc, một khách hàng quan tâm đến việc lấy thông tin về công việc, thực hiện tất cả thao tác lấy với ID công việc cụ thể và yêu cầu máy chủ API gửi lại phản hồi và định dạng XML khi triển khai EPA đầy đủ.  thông tin công việc từ cơ sở dữ liệu nội bộ hoặc một số kho lưu trữ liên tục chuyển đổi thành XML và gửi lại cho máy khách còn lại.

22
00:03:53,370 --> 00:04:02,310
Tương tự, khách hàng có thể yêu cầu gửi lại thông tin đó ở định dạng Gissen.  Hãy xem tài liệu về API.

23
00:04:02,310 --> 00:04:13,680
Chỉ cần gõ vào Google Search Bar thực sự là API của nhà phát triển và là liên kết đến API.  Nhấp vào API tìm kiếm việc làm và để chúng tôi xem qua các tham số cần thiết trong yêu cầu.

24
00:04:13,710 --> 00:04:21,450
Đây là các tham số yêu cầu và ở đây bạn sẽ thấy rằng khách hàng sẽ cần thiết lập định dạng mà họ quan tâm theo mặc định.

25
00:04:21,450 --> 00:04:29,400
Định dạng được đặt thành ví dụ nhưng API hỗ trợ XML.  Và Jason, chúng ta hãy xem định dạng dữ liệu phản hồi.

26
00:04:29,400 --> 00:04:44,780
Vì vậy, tùy thuộc vào những gì khách hàng đã yêu cầu, việc triển khai API sẽ phản hồi lại bằng dữ liệu XML cho công việc của họ hoặc nếu khách hàng đã yêu cầu sử dụng và định dạng dữ liệu thì nó sẽ phản hồi lại bằng loại dữ liệu Jason này.

27
00:04:44,790 --> 00:04:55,890
Vì vậy, đây chỉ là một ví dụ về cách API có thể hỗ trợ nhiều định dạng.  API mà chúng ta vừa xem xét, người dùng SCDP làm giao thức truyền thông.

28
00:04:56,310 --> 00:05:20,270
Tất cả các API hiện đại đều sử dụng SCDP.  Vì giao thức truyền thông và chúng tôi gọi các ứng dụng đó là SCDP Restabilize và lý do là vì bản thân kiểu Abia còn lại không bị ràng buộc với HDTV, bạn có thể xây dựng ứng dụng với các giao thức khác cũng như API lưu trữ, Expo và điểm cuối.

29
00:05:20,270 --> 00:05:26,940
Và điểm cuối này được sử dụng để quản lý trạng thái của tài nguyên.  Từ khóa ở đây là quản lý nhà nước.

30
00:05:27,410 --> 00:05:34,780
Vì vậy, điều đó cho bạn biết là bạn có thể thực hiện các hoạt động bí mật trên các tài nguyên được các API còn lại cung cấp.

31
00:05:35,210 --> 00:05:46,850
Bạn có thể tạo, truy xuất, cập nhật và xóa tài nguyên.  Để thực hiện hoạt động bí mật, khách hàng phải sử dụng htp wob thích hợp.

32
00:05:47,330 --> 00:05:58,340
Hãy để tôi giải thích nó bằng một ví dụ.  Giả sử Achmad Travel đang hiển thị API gói kỳ nghỉ nên sẽ có thêm điểm cuối DP cho khách hàng.

33
00:05:58,340 --> 00:06:08,870
Máy khách sẽ sử dụng điểm cuối này để thực hiện thao tác thẻ nhằm tạo tài nguyên.  Khách hàng sẽ phải sử dụng thêm DP sau chiến tranh để lấy lại.

34
00:06:09,020 --> 00:06:19,720
Máy khách sẽ phải sử dụng get bổ sung để cập nhật trạng thái của cổng tài nguyên cần được sử dụng và để xóa tài nguyên, việc xóa sẽ cần được sử dụng.

35
00:06:20,420 --> 00:06:31,750
Bây giờ là thời gian đố vui.  Tôi muốn bạn trả lời câu hỏi này.  Điều gì làm cho API yên tĩnh, Mark?  Các lựa chọn đúng và sai đề nghị bạn tạm dừng video và thử xem.

36
00:06:33,050 --> 00:06:52,490
Được rồi.  Hy vọng rằng bạn đã có tất cả các câu trả lời chính xác.  Đây là những lựa chọn đúng đắn.  Các ứng dụng còn lại tuân theo một bộ thiết kế, các nguyên tắc còn lại, tuân theo các ứng dụng còn lại theo phong cách kiến ​​trúc còn lại hiển thị các tài nguyên mà các phần còn lại của Clayne có thể thực hiện các hoạt động.

37
00:06:52,640 --> 00:07:06,470
Và đây là những lựa chọn sai lầm còn lại.  Lợn vòi không bị ràng buộc với bất kỳ SJP công nghệ cụ thể nào hoặc không xác định bất kỳ tiêu chuẩn nào về tải trọng yêu cầu hoặc phản hồi cũng như cách ứng dụng phải như thế nào.

38
00:07:06,860 --> 00:07:16,130
Ít heo vòi hơn có thể sử dụng bất kỳ giao thức truyền thông và bất kỳ định dạng dữ liệu nào.  Nó không gắn liền với HTP và Jason, đây là một quan niệm sai lầm phổ biến.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000004.srt -->

1
00:00:00,180 --> 00:00:18,270
Quản lý EPA, tôi sẽ bắt đầu bài học này bằng cách thảo luận về ba loại người tiêu dùng khác nhau sử dụng EPA do Michael Services cung cấp, sau đó tôi sẽ thảo luận quản lý EPA là gì và tại sao bạn nên xem xét quản lý EPA cho các dịch vụ vi mô của mình.

2
00:00:18,810 --> 00:00:29,070
EPA tiếp xúc với Body Micro Services được sử dụng bởi ba loại người tiêu dùng khác nhau.  Đầu tiên là người tiêu dùng EPA tư nhân hoặc nội bộ.

3
00:00:29,460 --> 00:00:37,090
Những người tiêu dùng tư nhân này là thành viên của cùng một nhóm dịch vụ vi mô hoặc là nhà phát triển các dịch vụ maiko khác.

4
00:00:37,110 --> 00:00:48,170
Ý tưởng là người tiêu dùng tư nhân thuộc về cùng một tổ chức với chủ sở hữu của.  Loại người tiêu dùng thứ hai là người tiêu dùng công cộng hoặc người tiêu dùng bên ngoài.

5
00:00:48,300 --> 00:01:01,870
Đây là những nhà phát triển độc lập bên ngoài tổ chức.  Vì vậy, ví dụ, từ góc độ ACMS, có thể một blogger du lịch độc lập đang gọi API do Acme cung cấp.

6
00:01:02,130 --> 00:01:17,790
Loại người tiêu dùng thứ ba là API đối tác, người tiêu dùng từ danh bạ Acme.  Nó có thể là đại lý hoặc đơn vị liên kết, do đó tùy thuộc vào người tiêu dùng API và API được đánh dấu là API riêng tư, công khai hoặc đối tác.

7
00:01:18,390 --> 00:01:28,200
Từ góc độ triển khai, không có sự khác biệt giữa ba loại API.  Sự khác biệt nằm ở cách quản lý các ứng dụng này.

8
00:01:28,620 --> 00:01:46,140
Hãy so sánh API riêng tư với API công khai.  Người sử dụng API riêng tư có thể gọi API 5000 lần mỗi giây, trong khi người tiêu dùng API công khai sẽ được phép gọi cùng một API năm lần mỗi giây.

9
00:01:46,770 --> 00:02:01,930
Một ví dụ khác là nơi người dùng API riêng tư có thể được phép truy cập tất cả các tính năng API, trong khi người dùng API công khai sẽ chỉ bị hạn chế đối với một số lệnh gọi nhất định trên API.

10
00:02:02,160 --> 00:02:12,930
Các khía cạnh này của API được quản lý bên ngoài việc triển khai các dịch vụ vi mô bằng nền tảng quản lý API.

11
00:02:13,870 --> 00:02:32,050
Bạn có thể coi ứng dụng, nền tảng quản lý là một công nghệ được sử dụng để giải quyết các mối quan ngại chung của Appia, những mối quan tâm chung này thường là những mối quan tâm liên quan đến quyền truy cập và ủy quyền cho ứng dụng, khu vực ghi nhật ký và phân tích.

12
00:02:32,200 --> 00:02:47,920
Ví dụ: nếu người tiêu dùng ứng dụng được phép truy cập API 5000 lần mỗi giây hoặc năm lần mỗi giây và sau đó sẽ có tài liệu API cung cấp thông tin cho người tiêu dùng về cách sử dụng ứng dụng.

13
00:02:48,220 --> 00:03:00,580
Các dịch vụ vi mô hiển thị API của họ thông qua các nền tảng quản lý API này.  Nền tảng quản lý EPA hiển thị EPA thông qua một điểm proxy.

14
00:03:00,910 --> 00:03:12,700
Người tiêu dùng EPA viện dẫn EPA theo quan điểm ủy quyền.  Họ không bao giờ kết nối trực tiếp với EPA do dịch vụ MICROS cung cấp khi người tiêu dùng yêu cầu EPA.

15
00:03:12,730 --> 00:03:29,620
Nền tảng quản lý EPA áp dụng biện pháp kiểm soát quản lý và dựa trên kết quả của các biện pháp kiểm soát đó, nền tảng quản lý EPA cho phép gọi EPA trên các máy chủ vi mô hoặc từ chối yêu cầu gọi.

16
00:03:29,800 --> 00:03:38,420
Hãy nói về kiểm soát quản lý.  Hầu hết các ưu đãi của nền tảng quản lý EPA đều là các tính năng quản lý dựa trên chính sách hoặc khai báo.

17
00:03:38,530 --> 00:03:44,760
Điều đó có nghĩa là nhà phát triển máy chủ vi mô không phải viết mã bất kỳ biện pháp kiểm soát quản lý nào.

18
00:03:44,920 --> 00:03:58,610
Họ có thể đơn giản tập hợp các chính sách để xác định các biện pháp kiểm soát này.  Ví dụ: một chính sách có thể được xác định cho người tiêu dùng nội bộ hoặc tư nhân sao cho mang lại sự linh hoạt tối đa cho người tiêu dùng.

19
00:03:58,630 --> 00:04:06,980
Vì vậy, nói cách khác, hầu hết các cuộc gọi của họ sẽ thuộc về các nhà phát triển thuộc phạm vi công cộng.  Chính sách có thể cực kỳ hạn chế đối với các quan hệ đối tác.

20
00:04:07,090 --> 00:04:20,590
Chính sách có thể xác định một số loại SLA.  Bây giờ, nếu bạn đang thắc mắc các chính sách này được xác định như thế nào thì cơ chế xác định chính sách này hoàn toàn phụ thuộc vào sản phẩm quản lý EPA.

21
00:04:20,950 --> 00:04:38,790
Gissen thường được sử dụng để xác định các chính sách này.  Vì vậy, nếu bạn muốn biết thêm về cách xác định các chính sách này, bạn sẽ phải chọn một trong các sản phẩm quản lý EPA, chẳng hạn như RPG Mughals của WSO để hiểu bản chất của các tài liệu chính sách này.

22
00:04:38,920 --> 00:04:48,550
Hầu hết các nhà cung cấp đám mây ngày nay cũng cung cấp các dịch vụ quản lý API như Amazon API Gateway và quản lý API.

23
00:04:48,770 --> 00:04:57,940
Nếu bạn không sử dụng nền tảng quản lý API, tôi thực sự khuyên bạn nên xem xét khả năng áp dụng giải pháp quản lý API.

24
00:04:58,330 --> 00:05:06,850
Mặc dù có nhiều lợi ích khi sử dụng nền tảng quản lý API từ góc độ nhóm phát triển dịch vụ vi mô.

25
00:05:06,880 --> 00:05:17,200
Lợi ích lớn nhất là nhóm có thể tập trung vào miền hoặc logic nghiệp vụ thay vì dành thời gian cho các mối quan tâm chung như bảo mật, ghi nhật ký, v.v..

26
00:05:17,320 --> 00:05:29,480
Kết quả là mã nguồn của Microsoft sạch hơn.  Cuối cùng nhưng không kém phần quan trọng, vì người tiêu dùng EPA không kết nối trực tiếp với dịch vụ của Microsoft nên việc quản lý thay đổi trở nên dễ dàng hơn.

27
00:05:29,530 --> 00:05:44,600
Vì vậy, điều đó có nghĩa là nhóm phát triển của Microsoft có thể thực hiện các thay đổi đối với API và điều chỉnh proxy trên nền tảng quản lý API để bảo vệ người tiêu dùng cuối khỏi những thay đổi đó.

28
00:05:45,280 --> 00:05:58,240
Đã đến lúc ôn lại những điểm chính của bài học này.  Có ba loại ứng dụng.  Tùy thuộc vào loại người tiêu dùng, API riêng tư sẽ được người tiêu dùng trong cùng một tổ chức sử dụng.

29
00:05:58,570 --> 00:06:10,480
Các khu vực công cộng được sử dụng bởi những người tiêu dùng bên ngoài tổ chức và thuộc phạm vi công cộng, và các đối tác của tổ chức sử dụng các mối quan hệ đối tác.

30
00:06:10,780 --> 00:06:27,460
Các dịch vụ vi mô cung cấp API và người tiêu dùng không kết nối trực tiếp với các API này mà kết nối thông qua nền tảng quản lý API cung cấp cơ chế dựa trên chính sách để giải quyết các mối quan tâm chung liên quan đến API.

31
00:06:27,460 --> 00:06:37,050
Vì những mối quan tâm chung này được giải quyết bằng nền tảng quản lý API nên các dịch vụ vi mô chỉ triển khai logic nghiệp vụ cho ứng dụng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000005.srt -->

1
00:00:00,150 --> 00:00:19,360
AP của sản phẩm Acme Trong bài học này, bạn tìm hiểu về chiến lược Kênh bán hàng Acme yêu cầu giới thiệu một API sẽ được các nhà phát triển Web độc lập và đối tác của Hackman sử dụng trong một trong những bài giảng trước đó trong phần Thiết kế dựa trên miền.

2
00:00:19,830 --> 00:00:30,990
Chúng tôi đã phân tích bản ghi cho cuộc phỏng vấn với giám đốc sản phẩm Acme.  Chúng tôi cũng đã phát triển ngôn ngữ phổ biến cho bối cảnh giới hạn về quản lý sản phẩm.

3
00:00:31,440 --> 00:00:41,280
Bài giảng này là sự tiếp nối từ nơi chúng ta đã dừng cuộc thảo luận đó.  Vì vậy, tôi khuyên bạn nên tạm dừng video, xem bản ghi cuộc phỏng vấn và sau đó tiếp tục.

4
00:00:42,220 --> 00:00:56,500
Nhóm dịch vụ của Microsoft cho miền sản phẩm hợp tác chặt chẽ với người quản lý sản phẩm và đây là điều họ đã học được từ Paul, người quản lý sản phẩm, Eckmann đang tìm cách mở rộng kênh bán hàng của mình hiện nay.

5
00:00:56,590 --> 00:01:06,100
ACMS bán các gói kỳ nghỉ qua trang web của mình, qua trung tâm cuộc gọi và qua các đại lý du lịch đối tác.

6
00:01:06,400 --> 00:01:24,680
Achmea đang tìm cách mở rộng mạng lưới đối tác của mình bằng cách cung cấp quyền truy cập dễ dàng vào các sản phẩm Acme.  Và họ cũng đang tìm cách thu hút các nhà phát triển web độc lập cũng như các blogger bán sản phẩm Acme để đổi lấy việc bán các sản phẩm Achmea.

7
00:01:24,910 --> 00:01:48,130
Các nhà phát triển và blogger độc lập này sẽ kiếm tiền dưới dạng hoa hồng dựa trên kết quả mong muốn được chia sẻ bởi tất cả lãnh đạo EITE cho nhóm sản phẩm hoặc dịch vụ đã quyết định xây dựng API còn lại cho người tiêu dùng bên ngoài vì không thể sử dụng tính năng nhắn tin cho người tiêu dùng bên ngoài.

8
00:01:48,400 --> 00:01:59,950
Người ta đã quyết định xây dựng API dưới dạng API SCDP của nhà hàng.  Các ứng dụng này sẽ được hiển thị cho các nhà phát triển và người viết blog công cộng bên ngoài.

9
00:02:00,160 --> 00:02:08,380
Các mối quan tâm như chứng khoán, hạn ngạch ghi nhật ký và phân tích sẽ được quản lý bằng giải pháp quản lý API Alpha.

10
00:02:08,650 --> 00:02:17,080
Trong giai đoạn đầu tiên, chỉ API còn lại sẽ được phát triển và thử nghiệm, sau đó giải pháp quản lý API sẽ được bổ sung.

11
00:02:18,020 --> 00:02:26,330
Các sản phẩm Michael Service sẽ hiển thị thông tin về sản phẩm và nhà cung cấp thông qua API còn lại.

12
00:02:26,420 --> 00:02:35,320
Người tiêu dùng sẽ ở bên ngoài Acme.  Họ sẽ là nhà phát triển và người viết blog trong phạm vi công cộng hoặc họ có thể là đối tác của Achmat.

13
00:02:35,390 --> 00:02:47,690
Họ sẽ gọi API còn lại để lấy thông tin về sản phẩm dựa trên tiêu chí.  Họ cũng có thể lấy thông tin về các nhà cung cấp dựa trên các tiêu chí.

14
00:02:47,720 --> 00:03:04,850
Sau này, tính năng quản lý API sẽ được bổ sung để quản lý tốt hơn các vấn đề chung về API.  Kỳ vọng đối với API này là các nhà phát triển Web và các blogger du lịch sẽ tích hợp API với trang web của họ.

15
00:03:05,150 --> 00:03:17,320
Họ sẽ đưa ra đề xuất cho khách truy cập về các gói điều hướng khác nhau.  Ví dụ: một blogger du lịch có thể giới thiệu gói Bahamas cho khách truy cập.

16
00:03:17,330 --> 00:03:31,840
Trang web sẽ sử dụng API sản phẩm để lấy thông tin về gói Bahamas. Trang web sẽ sử dụng API của nhà cung cấp để lấy thông tin về các nhà cung cấp khác nhau nằm trong gói.

17
00:03:31,850 --> 00:03:41,270
Ví dụ: gói Bahamas có thể bao gồm vé máy bay từ United Airlines và 5 đêm lưu trú tại khách sạn Hilton.

18
00:03:41,570 --> 00:03:51,290
Nếu khách truy cập vào trang web mua gói thì blogger hoặc nhà phát triển trang web sẽ nhận được hoa hồng từ Acme.

19
00:03:52,100 --> 00:04:06,790
API đau khổ có thể được phát triển bằng các ngôn ngữ khác nhau bằng cách sử dụng các khung thích hợp và Nhóm dịch vụ vi mô của sản phẩm Acme đã quyết định xây dựng niềm tin cho Abia bằng cách sử dụng Springboard.

20
00:04:06,920 --> 00:04:15,620
Trong bài giảng tiếp theo, tôi sẽ hướng dẫn bạn cách triển khai API sản phẩm và nhà cung cấp được triển khai bằng Java và Springboard.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000006.srt -->

1
00:00:00,150 --> 00:00:21,120
Việc triển khai API sản phẩm Acme trong bài học này, tôi sẽ hướng dẫn bạn qua sơ đồ lớp cho mô hình sản phẩm, sau đó chúng ta sẽ thấy API còn lại cho các sản phẩm đang hoạt động và cuối cùng, tôi sẽ hướng dẫn bạn một số lớp trong API còn lại  triển khai cho Acme.

2
00:00:21,480 --> 00:00:38,760
Xin lưu ý mục đích của tôi là để chứng minh EPA nghỉ ngơi khi đi bộ.  Nó không phải để dạy phun thuốc, nhưng nếu bạn biết tâm trạng mùa xuân, thì tôi khuyên bạn nên truy cập liên kết này và xem phần hướng dẫn API còn lại cho Springwood.

3
00:00:39,090 --> 00:00:46,640
Nếu bạn đã có kinh nghiệm với Springboard thì bạn có thể bắt đầu và bạn sẽ dễ dàng hiểu được mã này.

4
00:00:46,650 --> 00:00:55,430
Sau đó tôi sẽ hướng dẫn bạn trong bài giảng này.  Xin lưu ý rằng mã mà tôi hướng dẫn bạn trong bài học này có sẵn trong kho sản phẩm.

5
00:00:55,710 --> 00:01:03,150
Vui lòng tiếp tục và Kloner đến máy cục bộ của bạn nếu bạn chưa làm như vậy và kiểm tra API chi nhánh.

6
00:01:03,780 --> 00:01:11,520
Các lớp mô-đun cho sản phẩm.  Các bối cảnh bị giới hạn được xác định trong gói mô hình bắt đầu sản phẩm hoặc achmad hợp đồng.

7
00:01:11,760 --> 00:01:25,200
Sản phẩm là gói kỳ nghỉ trong bối cảnh liên kết bán hàng được xác định trong lớp sản phẩm và kho lưu trữ sản phẩm được xác định bởi REPL của sản phẩm giao diện.

8
00:01:25,680 --> 00:01:38,000
Kho lưu trữ sản phẩm hiển thị chức năng sản phẩm và nó hiển thị chức năng sản phẩm tốt có nhiều tham số tiêu chí để trích xuất sản phẩm.

9
00:01:38,010 --> 00:02:06,780
Đáp ứng tiêu chí đó, các lớp nhà cung cấp nằm trong gói nhà cung cấp.  Một giao diện chung được xác định cho các nhà cung cấp và mỗi loại nhà cung cấp triển khai giao diện nhà cung cấp chung này REPL cung cấp chức năng thêm nhà cung cấp vào kho lưu trữ và chức năng nhà cung cấp điện thoại lấy danh tính của nhà cung cấp để trả về phiên bản nhà cung cấp cho cột  .

10
00:02:07,620 --> 00:02:18,570
KHAI THÁC Sản phẩm Rest xuất hiện bộ điều khiển trong gói Kondor Achmad hoặc Product Appia triển khai bộ điều khiển phần còn lại cho ứng dụng bàn đạp.

11
00:02:18,930 --> 00:02:35,790
Nó hiển thị hai điểm cuối, sản phẩm và nhà cung cấp.  Phiên bản bộ điều khiển API còn lại chứa một phiên bản của kho lưu trữ sản phẩm và kho lưu trữ của nhà cung cấp triển khai các giao diện repro tương ứng.

12
00:02:35,940 --> 00:02:46,080
Lớp chính để khởi chạy bộ điều khiển API còn lại là API còn lại của sản phẩm không đúng theo Đạo luật Hàng hóa hoặc gói thử nghiệm.

13
00:02:46,950 --> 00:03:01,860
API phản ánh Đạo luật cho các sản phẩm sẽ cung cấp cho các điểm cuối.  Điểm cuối đầu tiên là điểm cuối của sản phẩm cũng sẽ lấy các tham số truy vấn để chỉ định tiêu chí sản phẩm hoặc gói kỳ nghỉ.

14
00:03:01,860 --> 00:03:13,650
Coller có thể cung cấp thông tin đại chúng về sản phẩm.  Họ có thể chỉ định điểm đến, số đêm tối thiểu và số đêm tối đa cho gói hàng hoặc sản phẩm đó.

15
00:03:14,070 --> 00:03:26,100
Điểm cuối thứ hai là điểm cuối của nhà cung cấp mà ý tưởng của nhà cung cấp cần được chỉ định và điểm cuối này sẽ trả về thông tin về nhà cung cấp.

16
00:03:26,970 --> 00:03:41,040
Hãy tiếp tục và khởi chạy API của chúng tôi.  Bấm vào Liên hệ với tôi gói thử nghiệm.  Đúng, hãy nhấp vào API còn lại của sản phẩm đang chạy và thao tác này sẽ khởi chạy API của chúng tôi.

17
00:03:41,460 --> 00:03:54,300
Đợi vài giây, mở cửa sổ trình duyệt, nhấn URL, SCDP, localhost các sản phẩm Collinet 080.  Điều này sẽ lấy tất cả các sản phẩm được xác định trong kho Câu hỏi thường gặp.

18
00:03:54,420 --> 00:04:04,070
Bây giờ, để sử dụng tìm kiếm dựa trên tiêu chí, bạn chỉ cần thêm dấu chấm hỏi ở cuối và cung cấp điểm đến, chẳng hạn như Florida.

19
00:04:04,320 --> 00:04:14,010
Vì vậy, điều này sẽ làm là nó sẽ kéo các sản phẩm của chúng tôi có điểm đến là Florida.  Chúng ta cũng có thể sử dụng đêm tối đa làm tiêu chí.

20
00:04:14,010 --> 00:04:26,400
Vì vậy, giả sử chúng tôi đang tìm kiếm các gói có thời gian lưu trú ánh sáng tối đa là năm đêm.  Vì vậy, đây là các gói có số đêm nhỏ hơn hoặc bằng năm.

21
00:04:26,400 --> 00:04:35,070
Vì vậy, đây là API còn lại của chúng tôi dành cho sản phẩm.  Bây giờ, nếu bạn nhìn vào các nhà cung cấp, chúng ta có nhà cung cấp Idiz ở đây.

22
00:04:35,310 --> 00:04:48,810
Và vì vậy để có được thông tin về các nhà cung cấp sẽ phải sử dụng API của nhà cung cấp.  Vì vậy, hãy thay thế sản phẩm bằng nhà cung cấp và cung cấp ID dấu chấm hỏi ID bằng giả sử ba trăm.

23
00:04:49,140 --> 00:04:56,910
Và đây là nhà cung cấp ID bằng 300. Nhà cung cấp này là một khách sạn và tên khách sạn là Hilton.

24
00:04:57,300 --> 00:05:10,380
Hãy xem nó là gì.  Bốn trăm loại.  Đặt nhà cung cấp, tôi để lại cho nhà cung cấp, đó là hãng hàng không đường ống 400 năm và tên của hãng hàng không là United Airlines.

25
00:05:10,510 --> 00:05:18,250
Đây là những ứng dụng dành cho sản phẩm và nhà cung cấp.  Tôi khuyên bạn nên tự mình thử các ứng dụng này.

26
00:05:18,880 --> 00:05:32,230
Dữ liệu mà chúng tôi đã sử dụng để thử nghiệm đều có sẵn và lớp repo giả mạo của sản phẩm.  Dưới đây là 4 sản phẩm nằm trong kho sản phẩm giả mạo. Để kiểm tra dữ liệu nhà cung cấp, hãy nhấp vào kho lưu trữ giả mạo của nhà cung cấp.

27
00:05:32,470 --> 00:05:46,150
Và đây là dữ liệu cho các nhà cung cấp.  Tôi khuyên bạn nên tự mình xem qua mã trong các đánh giá giả mạo để kiểm tra mã trong bộ điều khiển API còn lại, nhấp vào bộ điều khiển API còn lại của sản phẩm.

28
00:05:46,210 --> 00:05:54,100
Như bạn có thể thấy, nó là một bộ điều khiển bàn đạp.  Đây là bản đồ cho các sản phẩm và bản đồ cho các nhà cung cấp.

29
00:05:54,100 --> 00:06:01,900
Trước khi học lớp này, tôi khuyên bạn nên xem phần hướng dẫn về cách triển khai ứng dụng bằng Springboard.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000007.srt -->

1
00:00:00,270 --> 00:00:10,400
Giới thiệu về đồ họa trong bài học này, bạn sẽ tìm hiểu đồ họa là gì và cách nó giải quyết một số vấn đề nhất định liên quan đến phần còn lại.

2
00:00:11,490 --> 00:00:22,200
Bạn sẽ tìm hiểu về các loạt đồ họa và khi kết thúc bài giảng này, bạn sẽ có thể giải thích sự khác biệt giữa các ứng dụng bắt giữ và API đồ họa.

3
00:00:22,620 --> 00:00:33,960
Hãy bắt đầu với đồ họa đồ họa là ngôn ngữ truy vấn dành cho các ứng dụng không bị ràng buộc với bất kỳ cơ sở dữ liệu, công nghệ hoặc giao thức mạng cụ thể nào.

4
00:00:34,380 --> 00:00:47,670
GAF Cual là đặc tả cho ngôn ngữ truy vấn.  Đôi khi.  Thuật ngữ đồ họa cũng được sử dụng để chỉ một thành phần thực hiện các đặc tả đồ họa.

5
00:00:48,270 --> 00:00:58,500
Máy chủ đồ họa hiển thị điểm cuối API đồ họa được máy khách đồ họa sử dụng để gọi các hoạt động đồ họa.

6
00:00:59,010 --> 00:01:06,770
Quick Bit of History Graphical được Facebook phát triển để sử dụng trong ứng dụng di động của họ vào năm 2012.

7
00:01:07,170 --> 00:01:19,260
Nó là nguồn mở vào năm 2015. Tại thời điểm này, có nhiều tổ chức từ nhỏ đến lớn đã áp dụng đồ họa làm tiêu chuẩn cho ứng dụng của họ.

8
00:01:19,680 --> 00:01:30,540
Tôi sẽ giải thích API đồ họa bằng cách so sánh nó với API bắt giữ API còn lại hiển thị giao diện API cho khách hàng thông qua một hợp đồng.

9
00:01:31,020 --> 00:01:43,710
Hợp đồng API xác định lược đồ cho paillard yêu cầu mà máy khách gửi đến máy chủ, đồng thời nó cũng xác định lược đồ cho tải trọng phản hồi mà máy chủ gửi cho máy khách.

10
00:01:43,740 --> 00:01:53,890
Cấu trúc của lược đồ yêu cầu và phản hồi được cố định và máy khách nhận được tất cả dữ liệu trong tải trọng phản hồi, cho dù nó có cần hay không.

11
00:01:53,910 --> 00:02:08,620
Vì vậy, nếu bạn coi máy chủ API còn lại là nguồn dữ liệu thì việc này giống như thực hiện thao tác bắt đầu chọn từ bảng vì máy khách không có lựa chọn nào về những gì nó cần trong lược đồ phản hồi.

12
00:02:09,330 --> 00:02:16,590
Sự cố này xảy ra với API còn lại, trong đó ứng dụng khách đang tìm nạp nhiều dữ liệu hơn mức cần thiết, được gọi là sự cố tổng thể.

13
00:02:17,010 --> 00:02:27,990
Bây giờ hãy nói về hợp đồng đồ họa.  Hợp đồng đồ họa ở dạng lược đồ đồ họa xác định các hoạt động được hỗ trợ bởi đồ họa.

14
00:02:28,230 --> 00:02:41,400
Vì vậy, các thao tác này có thể là các thao tác truy vấn, tương đương với các thao tác truy xuất và thao tác có thể thuộc loại đột biến, dùng để cập nhật, tạo hoặc xóa dữ liệu được quản lý trên biểu đồ.

15
00:02:41,400 --> 00:02:55,600
Curole Vì vậy, lược đồ đồ họa cũng có các định nghĩa kiểu, thuật toán.  Thật là một lược đồ chi tiết.  Một lát sau, máy khách có thể gọi các truy vấn và cho máy chủ biết những gì nó cần trong tải trọng phản hồi.

16
00:02:55,800 --> 00:03:03,840
Vì vậy, bây giờ khách hàng có quyền kiểm soát phản hồi.  Vì vậy, nó giống như gọi phần chọn bằng cảm giác từ một bảng cơ sở dữ liệu.

17
00:03:04,020 --> 00:03:14,250
Bằng cách này, khách hàng chỉ có thể nhận được những gì họ cần và không gặp phải vấn đề tổng thể.  Tiếp theo, hãy nói về mức độ chi tiết còn lại của API.

18
00:03:14,760 --> 00:03:25,390
Nói chung, các API còn lại được xây dựng dưới dạng dịch vụ có độ chi tiết cao và điều này được thực hiện để đáp ứng nhu cầu của nhiều loại khách hàng.

19
00:03:25,440 --> 00:03:42,540
Điều này dẫn đến một vấn đề.  Hãy để tôi giải thích nó bằng ví dụ trước đó về API còn lại cho Acme.  Trang web lấy thông tin về gói hàng hoặc sản phẩm, sau đó cần thực hiện các cuộc gọi bổ sung để nhận thông tin về nhà cung cấp.

20
00:03:42,590 --> 00:03:54,690
Bây giờ, trong kịch bản này, chúng ta chỉ nói về ba cuộc gọi, nhưng người ta thường thấy NS hoặc thậm chí hàng trăm cuộc gọi do trang web thực hiện đều xuất hiện để đáp ứng yêu cầu.

21
00:03:54,900 --> 00:04:03,300
Và điều này dẫn đến một vấn đề khác.  Vì khách hàng không nhận được tất cả dữ liệu cần thiết nên dẫn đến vấn đề thiếu vốn.

22
00:04:03,300 --> 00:04:14,390
Và điều này đang khiến máy khách thực hiện nhiều cuộc gọi mạng đến máy chủ để nhận dữ liệu cần thiết và điều đó dẫn đến ảnh hưởng đến hiệu suất.

23
00:04:15,330 --> 00:04:31,860
Vì vậy, nếu chúng tôi thay thế DWP bằng đồ họa, nhà cung cấp ứng dụng sẽ kết hợp đặc tả đồ họa, đặc tả này sẽ được nhà phát triển web sử dụng để gọi các truy vấn đồ họa đối với API.

24
00:04:31,890 --> 00:04:46,670
Điểm cuối trong trang từ chối truy vấn sẽ chỉ định các trường mà nó muốn nhận.  Là một phần của phản hồi, Sara sẽ xử lý truy vấn và phản hồi lại bằng các trường được yêu cầu trong phản hồi.

25
00:04:46,680 --> 00:04:59,580
Vì vậy, với thiết lập này, chỉ với một lệnh gọi, phía khách hàng có thể truy xuất dữ liệu được yêu cầu.  Do đó, cả vấn đề tìm nạp dưới mức và vấn đề bù đắp đều được Dolf giải quyết bằng SOHR đồ họa.

26
00:04:59,770 --> 00:05:17,440
Được triển khai dưới dạng một lớp để quản lý tất cả các tương tác của máy khách, nó nằm ở phía trước ứng dụng đối với lớp này, triển khai đặc tả đồ họa và chịu trách nhiệm quản lý các tương tác của máy khách khi gọi API.

27
00:05:17,760 --> 00:05:31,830
Lớp này tương tác với các thành phần trong ứng dụng để nhà phát triển API đồ họa cần tập hợp các thông số kỹ thuật đồ họa được máy chủ đồ họa sử dụng.

28
00:05:32,460 --> 00:05:40,170
Không có cách triển khai tiêu chuẩn nào cho Gaskill.  Có nhiều khung có sẵn cho các ngôn ngữ khác nhau.

29
00:05:40,320 --> 00:05:53,050
Mỗi khung này có một yêu cầu khác nhau từ góc độ ứng dụng.  Hầu hết các khung công tác đều yêu cầu nhà phát triển tạo các thành phần đồ họa được kết nối với đồ họa.

30
00:05:53,100 --> 00:06:05,970
Vì thế.  Vì vậy các thành phần mà nhà phát triển cần ghép lại với nhau tùy thuộc vào framework.  Tiếp theo, tôi sẽ hướng dẫn bạn quy trình của thao tác đồ họa trong cách triển khai đồ họa điển hình.

31
00:06:05,970 --> 00:06:19,620
Vì vậy, máy khách gọi thao tác trên điểm cuối được hiển thị bởi đồ họa.  Vì vậy, máy chủ đồ họa khi nhận được lệnh gọi này sẽ xác thực yêu cầu dựa trên định nghĩa lược đồ.

32
00:06:19,770 --> 00:06:27,540
Nếu mọi thứ đều ổn thì nó yêu cầu ứng dụng tạo một phiên bản của thành phần được gọi là trình tìm nạp dữ liệu.

33
00:06:27,660 --> 00:06:35,580
Thành phần trình tìm nạp dữ liệu này cung cấp việc triển khai cho hoạt động.  Thành phần này còn được gọi là trình giải quyết truy vấn.

34
00:06:35,670 --> 00:06:42,720
Dữ liệu là thành phần sau đó tương tác với các nguồn dữ liệu, có thể là cơ sở dữ liệu hoặc có thể là các thành phần khác.

35
00:06:42,750 --> 00:06:54,540
Ý tưởng là trình tìm nạp dữ liệu sẽ truy xuất dữ liệu từ một hoặc nhiều nguồn sau khi nhận được dữ liệu từ nguồn dữ liệu mà Delveccio sau đó sẽ tạo một hoặc nhiều phiên bản của trình phân giải.

36
00:06:54,570 --> 00:07:06,450
Những trình phân giải này sau đó được đưa trở lại Solia đồ họa.  Biểu đồ cũng gọi các hàm trên các trình phân giải này để lấy dữ liệu cho các trường cần được chuyển.

37
00:07:06,450 --> 00:07:21,720
Trong phần phản hồi, bạn sẽ thấy tất cả các thành phần và đồ họa này hoạt động trong bài giảng sau.  Việc triển khai máy chủ đồ họa có sẵn bằng nhiều ngôn ngữ để tìm hiểu thêm về những cách triển khai này.

38
00:07:21,930 --> 00:07:35,010
Tôi khuyên bạn nên kiểm tra liên kết này lợi thế về đồ họa.  Bạn đã biết rằng đồ họa giải quyết vấn đề trang bị quá mức và thiếu vốn mà ứng dụng khách API còn lại gặp phải.

39
00:07:35,160 --> 00:07:47,160
Máy khách đồ họa có toàn quyền kiểm soát ảnh tài liệu phản hồi.  CUAL được cung cấp dưới dạng lược đồ nên không cần có tài liệu riêng.

40
00:07:47,370 --> 00:08:02,550
SOLIA đồ họa cung cấp thông tin lỗi rất mô tả cho khách hàng, phía khách hàng có thể sử dụng thông tin này để hiểu vấn đề chính xác trong yêu cầu của họ đối với những nhược điểm về đồ họa cũng như đồ họa.

41
00:08:02,550 --> 00:08:15,510
Vấn đề lớn nhất là có thể có những thách thức về hiệu suất với các truy vấn phức tạp.  Bộ nhớ đệm web không dễ triển khai bằng đồ họa như với các ứng dụng còn lại.

42
00:08:15,720 --> 00:08:27,840
Các API còn lại rất dễ học so với các API đồ họa.  Chúng ta hãy so sánh từng phần giữa các ứng dụng còn lại và API đồ họa.

43
00:08:27,870 --> 00:08:44,160
Từ góc độ thiết kế, các API còn lại được xác định theo tài nguyên và điểm cuối, trong khi các API đồ họa được hiển thị trên một điểm cuối duy nhất và hợp đồng ở dạng định nghĩa lược đồ.

44
00:08:44,310 --> 00:08:52,590
Từ góc độ điều khiển, phía máy khách không có quyền kiểm soát phản hồi, trong khi máy khách có toàn quyền kiểm soát phản hồi.

45
00:08:52,770 --> 00:09:06,840
Trong trường hợp ổn định lại đồ họa, hãy hiển thị các hoạt động của thẻ bằng cách sử dụng HTP Wab.  Trong khi đó, trong trường hợp đồ họa, tất cả các hoạt động được gọi bằng HTP, GECC hoặc post.

46
00:09:07,050 --> 00:09:31,710
Và có ba loại hoạt động truy vấn, đột biến và đăng ký.  Thêm về điều này sau.  Từ góc độ hiệu suất mạng, ứng dụng khách API còn lại cần thực hiện nhiều cuộc gọi mạng cùng với thông tin cần thiết, trong khi API đồ họa dẫn đến giảm lưu lượng mạng và điều đó có thể dẫn đến hiệu suất tốt hơn từ góc độ trường hợp sử dụng.

47
00:09:31,710 --> 00:09:41,880
API còn lại phù hợp với các ứng dụng điều khiển tài nguyên, trong khi API đồ họa phù hợp hơn với các ứng dụng điều khiển dữ liệu.

48
00:09:42,540 --> 00:09:55,740
Trong bài học này, bạn đã tìm hiểu về đồ họa đồ họa là một đặc tả cho các địa chỉ đồ họa API, các vấn đề về đánh giá thấp và giám sát liên quan đến API còn lại.

49
00:09:55,980 --> 00:10:12,200
Một máy chủ đồ họa, thực hiện đồ họa đặc biệt.  Holidays, một nhà phát triển đồ họa, cần tập hợp định nghĩa lược đồ cho API và họ cũng cần triển khai các thành phần cần thiết cho máy chủ đồ họa.

50
00:10:12,290 --> 00:10:19,040
Loại thành phần mà nhà phát triển phải kết hợp với nhau tùy thuộc vào máy chủ đồ họa đang sử dụng.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000008.srt -->

1
00:00:00,330 --> 00:00:10,960
Ngôn ngữ định nghĩa lược đồ trong bài học này sẽ được thảo luận, hệ thống loại chiến tranh golf, bạn sẽ tìm hiểu cách máy khách và máy chủ sử dụng lược đồ để thực hiện một truy vấn.

2
00:00:11,010 --> 00:00:19,620
Tôi cũng sẽ chia sẻ với bạn một số mẹo để tạo lược đồ.  Xin lưu ý, mục đích của tôi là cung cấp cho bạn cái nhìn tổng quan về ngôn ngữ định nghĩa lược đồ.

3
00:00:19,620 --> 00:00:26,700
Để biết chi tiết, vui lòng tham khảo tài liệu có sẵn tại liên kết này.  Tôi sẽ bắt đầu bài học này bằng một câu hỏi.

4
00:00:27,120 --> 00:00:36,840
Bạn sẽ sử dụng dịch vụ nào cho các dịch vụ vi mô của mình?  API RESTful hoặc đồ họa?  Vâng, câu trả lời là cả hai không loại trừ lẫn nhau.

5
00:00:37,250 --> 00:00:50,210
Bạn cần chọn cái phù hợp hơn với mục đích sử dụng cụ thể của bạn tại thời điểm này.  API RESTful phổ biến hơn nhiều so với API đồ họa, nhưng điều đó đang thay đổi.

6
00:00:50,480 --> 00:01:05,350
Vì vậy, hãy đánh giá các yêu cầu của bạn và sau đó quyết định nên chọn cái nào.  Hệ thống kiểu đồ họa đề cập đến thực tế là dịch vụ đồ họa xác định một tập hợp các đường dẫn mô tả đầy đủ tập hợp dữ liệu có thể có.

7
00:01:05,630 --> 00:01:21,320
Bạn có thể truy vấn trên dịch vụ, các truy vấn đến được xác thực và thực thi dựa trên lược đồ đó.  Lược đồ được xác định bằng ngôn ngữ định nghĩa lược đồ là định nghĩa lược đồ bất khả tri của ngôn ngữ lập trình.

8
00:01:21,320 --> 00:01:31,100
Ngôn ngữ liền kề giống như ngôn ngữ để xác định lược đồ.  Đối với các API đồ họa, lược đồ bao gồm hai phần.

9
00:01:31,310 --> 00:01:41,150
Phần đầu tiên là các hoạt động được hỗ trợ bởi máy chủ đồ họa.  Các hoạt động này có thể là truy vấn, đột biến và đăng ký.

10
00:01:41,330 --> 00:01:53,360
Phần còn lại có các đường ống, là các đối tượng được xác định bằng phần mềm và mỗi đối tượng này có các trường thuộc loại cụ thể được hỗ trợ bởi lược đồ đồ họa.

11
00:01:53,960 --> 00:02:08,690
Trong bối cảnh định nghĩa lược đồ, các thao tác ngôn ngữ cũng được gọi là kiểu gốc.  Máy khách sử dụng truy vấn loại gốc để truy xuất các đối tượng được xác định trên ghế sofa bằng ngôn ngữ định nghĩa lược đồ.

12
00:02:09,020 --> 00:02:21,200
Truy vấn loại gốc liệt kê tất cả các truy vấn tên.  Ví dụ: sản phẩm là một truy vấn tên.  Mỗi truy vấn được xác định bằng một danh sách các đối số.

13
00:02:21,230 --> 00:02:33,440
Các đối số là tiêu chí truy vấn.  Mỗi đối số có một loại và cũng có một loại phản hồi, trong trường hợp này là một mảng các đối tượng sản phẩm.

14
00:02:33,890 --> 00:02:44,960
Trong tập hợp truy vấn sản phẩm cụ thể này, tất cả các đối số đều là tùy chọn hoặc chúng có thể được đánh dấu là bắt buộc để tạo đối số theo yêu cầu.

15
00:02:45,590 --> 00:03:03,500
Loại cần phải được gắn với dấu chấm than.  Vì vậy, nếu ID công khai là đối số bắt buộc mà tôi nghĩ sẽ có hậu tố là dấu chấm than, biểu đồ thì Kosovo có thể cho phép khách hàng sửa đổi trạng thái duy trì đối tượng trên máy chủ.

16
00:03:03,500 --> 00:03:15,920
Và nó thực hiện điều này bằng cách xác định ký hiệu kiểu gốc.  Ký hiệu kiểu gốc tương tự như truy vấn rootie theo nghĩa là có các đột biến được đặt tên trong đặc tả.

17
00:03:16,040 --> 00:03:31,970
Và những đột biến được đặt tên này cũng lấy đối số và trả về đối tượng giống như các truy vấn được đặt tên.  Và loại gốc cuối cùng là loại gốc đăng ký, khác với truy vấn và đột biến theo nghĩa là hoạt động đăng ký không được khách hàng khởi tạo.

18
00:03:32,000 --> 00:03:44,990
Máy khách đăng ký các sự kiện trên máy chủ và máy chủ sẽ đẩy dữ liệu đến máy khách.  Để đáp lại các sự kiện, các kiểu được sử dụng để xác định cấu trúc của đối tượng miền.

19
00:03:45,320 --> 00:03:56,510
Các kiểu vô hướng là các kiểu tiêu chuẩn được xác định trong lược đồ.  Định nghĩa, ngôn ngữ, số nguyên, float, chuỗi và boolean là các kiểu vô hướng cơ bản.

20
00:03:56,780 --> 00:04:06,440
Idee là một loại đặc biệt, không phải là một phần của dữ liệu miền doanh nghiệp nhưng chủ yếu được sử dụng để quản lý bộ nhớ đệm của dữ liệu truy vấn.

21
00:04:06,680 --> 00:04:18,800
Dịch vụ đồ họa xác định loại phức tạp bằng cách kết hợp các loại vô hướng tiêu chuẩn.  Điều này không khác với cách bạn xác định đối tượng trong bất kỳ chương trình hướng đối tượng nào.

22
00:04:18,800 --> 00:04:29,240
Các trường ngôn ngữ có thể được coi là một thuộc tính của một đối tượng.  Các thuộc tính này có kiểu có thể là kiểu vô hướng hoặc kiểu phức.

23
00:04:29,570 --> 00:04:41,320
Đây là một ví dụ về một loại phức tạp.  Tên của loại phức tạp này là sản phẩm.  Bốn trường đầu tiên là loại vô hướng và mỗi trường này đều bắt buộc đối với nhà cung cấp.

24
00:04:41,330 --> 00:04:51,380
Trường là một mảng có kiểu phần tử phức tạp trong vùng được yêu cầu.  Loại nhà cung cấp được xác định riêng trong định nghĩa lược đồ bởi máy chủ.

25
00:04:51,590 --> 00:04:58,080
Đó là định nghĩa về loại nhà cung cấp bao gồm năm trường vô hướng, tất cả đều bắt buộc.

26
00:04:58,100 --> 00:05:05,870
Vì vậy, điều này cho bạn biết rằng các kiểu phức tạp có thể được lồng vào nhau, nghĩa là một kiểu phức tạp có thể chứa các kiểu phức tạp khác.

27
00:05:06,170 --> 00:05:13,940
Một điều quan trọng cần ghi nhớ là việc lồng sâu các định nghĩa đối tượng có thể ảnh hưởng đến hiệu suất của máy chủ.

28
00:05:13,940 --> 00:05:27,290
Và điều này là do các kiểu phức tạp được lồng sâu sẽ yêu cầu triển khai trình phân giải phân cấp và điều đó cũng sẽ dẫn đến sự phức tạp khi triển khai biểu đồ.

29
00:05:27,490 --> 00:05:36,700
Vì vậy, đây là những điều nhất định mà bạn cần lưu ý khi thiết kế các loại của mình.  Nói về cách khách hàng thực hiện truy vấn trên biểu đồ.

30
00:05:37,060 --> 00:05:45,010
Vì vậy, điều đầu tiên khách hàng cần làm là chuẩn bị tải trọng yêu cầu.  Tải trọng yêu cầu này là một tài liệu giống như Jason.

31
00:05:45,190 --> 00:05:58,240
Cấu trúc của tài liệu này được xác định bởi đồ họa Huet và khách hàng phải tuân thủ nó.  Điều đầu tiên bạn thấy ở đây là loại tuyến đường, được đặt để truy vấn đây có thể là đột biến hoặc đây cũng có thể là đăng ký.

32
00:05:58,630 --> 00:06:13,090
Sau đó có một truy vấn tên trong ví dụ này.  Truy vấn tên là các sản phẩm.  Truy vấn sản phẩm được xác định trong định nghĩa lược đồ này để nhận nhiều đối số tùy chọn vì đối với sản phẩm, tất cả các đối số đều là tùy chọn.

33
00:06:13,090 --> 00:06:20,590
Máy khách có thể chỉ định 0 hoặc nhiều giá trị đối số.  Các đối số này đóng vai trò là tiêu chí cho truy vấn.

34
00:06:20,740 --> 00:06:34,800
Bây giờ hãy nói về điều gì làm cho đồ họa trở nên khác biệt so với truy vấn API còn lại.  Như bạn có thể thấy ở đây, máy khách có thể chỉ định các trường mà nó muốn nhận từ máy chủ trong phản hồi.

35
00:06:34,810 --> 00:06:50,230
Và đây chính là điều khiến mọi thứ trở nên thú vị và sinh động.  Bạn không thể làm điều này trong API.  Vì vậy, trong ví dụ này, khách hàng đang yêu cầu máy chủ trả về mô tả, điểm đến và số đêm chỉ được lấp đầy.

36
00:06:50,800 --> 00:06:59,200
Sau đó, máy khách sẽ gửi tải trọng yêu cầu đến máy chủ trên máy chủ trong đồ họa để trước tiên sẽ xác thực yêu cầu.

37
00:06:59,290 --> 00:07:09,280
Máy chủ đã ủy quyền xử lý yêu cầu cho Microsoft Office dưới dạng các thành phần.  Sau đó, Microsoft Office sẽ tạo các phiên bản trình phân giải và chuyển chúng trở lại đồ họa.

38
00:07:09,280 --> 00:07:19,330
Ngược lại, một số máy chủ Greyscale sẽ tạo ra phản hồi dựa trên yêu cầu từ máy khách và yêu cầu từ máy khách.

39
00:07:19,330 --> 00:07:35,830
Trong ví dụ cụ thể này chỉ nhận được ba trường.  Vì vậy, việc giao nhau biểu đồ sẽ gửi lại thông tin sản phẩm theo cách mà mỗi sản phẩm trong phản hồi sẽ chỉ có thông tin hoặc dữ liệu cho ba trường đó.

40
00:07:36,490 --> 00:07:43,600
Công cụ phát triển đồ họa.  Trong vài năm gần đây, hệ sinh thái xung quanh đồ họa đã phát triển rất nhiều.

41
00:07:43,630 --> 00:07:52,630
Có nhiều công cụ mà bạn có thể sử dụng để hỗ trợ phát triển đồ họa.  Đây là một số công cụ mà cá nhân tôi thích.

42
00:07:52,750 --> 00:08:02,020
Trên thực tế, một trong những công cụ này, sân chơi đồ họa, là công cụ mà tôi đã sử dụng để kiểm tra đồ họa của mình trong trường hợp này và bạn sẽ thấy nó hoạt động.

43
00:08:02,050 --> 00:08:14,580
Vui lòng tự nghiên cứu và chia sẻ suy nghĩ của bạn về các công cụ khác mà bạn có thể thấy hữu ích.  Tôi đã học được bài học này bằng cách chia sẻ một số mẹo về thiết kế lược đồ cho ứng dụng đồ họa của bạn.

44
00:08:15,040 --> 00:08:22,270
Hãy coi định nghĩa lược đồ như một ngôn ngữ được chia sẻ.  Đừng quên ngôn ngữ phổ biến của bạn cho tên miền.

45
00:08:22,660 --> 00:08:33,010
Vì vậy, hãy đảm bảo rằng các định nghĩa lược đồ của bạn được ánh xạ tới các thuật ngữ trong ngôn ngữ phổ biến.  Thực hiện một cách tiếp cận tiến hóa để tạo API.

46
00:08:33,310 --> 00:08:46,210
Đừng cố gắng làm mọi thứ.  Đồng thời, ý tưởng là xuất bản phiên bản một của API và sau đó xem xét cách khách hàng hoặc người tiêu dùng hoặc API đang sử dụng dịch vụ của bạn.

47
00:08:46,540 --> 00:09:00,490
Và dựa trên sự phát triển đó, lược đồ cho API của bạn.  Đã đến lúc xem qua các điểm chính từ ngôn ngữ định nghĩa lược đồ của bài học này được máy chủ sử dụng để xác định lược đồ hoặc hợp đồng cho API.

48
00:09:00,910 --> 00:09:12,910
Sarah sử dụng lược đồ để xác thực yêu cầu hoạt động đến.  Sara cũng sử dụng lược đồ để tạo phản hồi gửi lại cho khách hàng.

49
00:09:13,120 --> 00:09:20,890
Máy khách sử dụng lược đồ để tạo tải trọng yêu cầu và phân tích các phản hồi mà nó nhận được từ máy chủ.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000009.srt -->

1
00:00:00,210 --> 00:00:15,700
Các sản phẩm của Acme mà các nhà phát triển ứng dụng đang sử dụng API sản phẩm Acme đang phàn nàn và Nhóm dịch vụ vi mô của sản phẩm Acme đã quyết định triển khai API đồ họa cho sản phẩm.

2
00:00:15,720 --> 00:00:28,160
Trong bài học này, tôi sẽ hướng dẫn bạn định nghĩa lược đồ cho các sản phẩm và nhà cung cấp mà nhóm dịch vụ vi mô sản phẩm đã quyết định sử dụng cho API đồ họa của Sản phẩm Acme.

3
00:00:28,620 --> 00:00:40,890
Các nhà phát triển ứng dụng web và di động tại Acme đang phàn nàn rằng API còn lại không hoạt động tốt và lý do là nó đòi hỏi logic phức tạp phải được chôn trong các ứng dụng.

4
00:00:41,040 --> 00:00:48,360
Và hiệu suất của các ứng dụng này kém do ứng dụng cần thực hiện nhiều cuộc gọi mạng.

5
00:00:48,360 --> 00:01:01,540
Vì vậy, giới thượng lưu đó đã tiến hành phân tích.  Và điều ông phát hiện ra là việc đánh bắt quá mức là một vấn đề lớn trong phòng ngừa rủi ro, nghĩa là có rất nhiều dữ liệu được gửi trở lại ứng dụng hơn mức yêu cầu.

6
00:01:01,560 --> 00:01:13,500
Ông đã đưa ra quyết định rằng cần phải giảm lượng dữ liệu được gửi từ API và các nhà phát triển cần có nhiều quyền kiểm soát hơn đối với những gì họ nhận được từ API vào thời điểm đó.

7
00:01:13,740 --> 00:01:23,050
Quyết định rất rõ ràng và đồ họa ở đây dành cho những tình huống như thế này.  Vì vậy hội đồng đã quyết định xây dựng đồ họa cho sản phẩm.

8
00:01:23,070 --> 00:01:49,510
Ý tưởng là kịch bản trong đó API còn lại được gọi nhiều lần từ ứng dụng Web sẽ được thay thế bằng API dựa trên đồ họa trong đó ứng dụng sẽ truy vấn sản phẩm bằng cách gửi truy vấn sản phẩm với các đối số bắt buộc làm tiêu chí và sau đó nhận lại  một phản hồi sẽ chỉ chứa các trường được yêu cầu cho sản phẩm.

9
00:01:49,530 --> 00:01:58,890
Đây sẽ là một truy vấn tổng hợp, nghĩa là ứng dụng sẽ không phải thực hiện nhiều lệnh gọi để lấy dữ liệu từ các sản phẩm của Microsoft.

10
00:01:59,430 --> 00:02:12,900
API sản phẩm này sẽ yêu cầu định nghĩa lược đồ, vì vậy nhóm đã quyết định kết hợp định nghĩa lược đồ với thao tác truy vấn cho sản phẩm và mô hình miền của nhà cung cấp.

11
00:02:13,230 --> 00:02:29,560
API truy vấn này sẽ được hiển thị qua điểm cuối chung có định dạng này.  Tất cả các hoạt động đồ họa trong tương lai như truy vấn và đột biến cũng sẽ được hiển thị thông qua điểm cuối chung này tiếp theo.

12
00:02:29,580 --> 00:02:41,460
Tôi sẽ hướng dẫn bạn định nghĩa lược đồ cho truy vấn của sản phẩm và nhà cung cấp.  Lược đồ mà tôi đang hướng dẫn bạn có sẵn và kho lưu trữ này, đồng thời hãy đảm bảo kiểm tra API nhánh.

13
00:02:41,880 --> 00:02:51,210
Các định nghĩa lược đồ này cho API đồ họa của sản phẩm có sẵn trong thư mục con tài nguyên trong phòng tệp Từ khóa Dawidoff.

14
00:02:51,450 --> 00:03:03,990
Có một truy vấn sản phẩm đưa ra các đối số tùy chọn, ý tưởng công khai về sản phẩm hoặc gói kỳ nghỉ, số đêm tối thiểu của điểm đến và số đêm tối đa.

15
00:03:04,140 --> 00:03:12,660
Để trả lời truy vấn này, máy chủ sẽ gửi lại một loạt sản phẩm.  Truy vấn thứ hai là truy vấn của nhà cung cấp.

16
00:03:12,690 --> 00:03:20,980
Điều đó cần một đối số được nhập vào. Dấu chấm than này ở đây cho biết rằng đây là đối số bắt buộc.

17
00:03:21,000 --> 00:03:32,610
Lưu ý rằng không có đối số nào cho sản phẩm có dấu chấm than.  Và đó là lý do tôi nói rằng những đối số này cho truy vấn sản phẩm là tùy chọn.

18
00:03:32,820 --> 00:03:40,230
Truy vấn của nhà cung cấp phản hồi lại bằng một đối tượng thuộc loại nhà cung cấp.  Chúng ta hãy nhìn vào loại sản phẩm.

19
00:03:40,230 --> 00:03:51,180
Loại sản phẩm có tất cả các thuộc tính là một phần của đối tượng sản phẩm và mô hình miền, mô tả ID công khai, số điểm đến ban đêm và nhà cung cấp.

20
00:03:51,210 --> 00:04:01,680
Sự khác biệt lớn nhất là ở các nhà cung cấp.  Thay vì chỉ giữ ID nhà cung cấp, thuộc tính của nhà cung cấp đang giữ một khu vực thuộc loại nhà cung cấp thực tế.

21
00:04:01,690 --> 00:04:12,010
Vì vậy, điều đó có nghĩa là phản hồi cho truy vấn về sản phẩm cũng sẽ trả về đối tượng sản phẩm cùng với tất cả thông tin dành cho nhà cung cấp.

22
00:04:12,030 --> 00:04:23,490
Do đó, chất lượng của truy vấn sản phẩm sẽ không phải thực hiện nhiều cuộc gọi để lấy thông tin cho nhà cung cấp và đó là lúc hiệu suất của khách hàng dự kiến ​​sẽ được cải thiện.

23
00:04:23,520 --> 00:04:31,650
Chúng ta hãy xem nhanh nhà cung cấp.  Vì vậy, Nhà cung cấp có tất cả các thuộc tính ở đó và lớp nhà cung cấp trong mô hình miền.

24
00:04:31,800 --> 00:04:41,810
Tôi khuyên bạn nên xem xét đối tượng miền được xác định trong gói mô hình.  Sản phẩm có cùng thuộc tính được xác định trong tệp định nghĩa truy vấn.

25
00:04:41,910 --> 00:04:52,170
Tương tự, nhà cung cấp có cùng một bộ thuộc tính có trong các lớp nhà cung cấp. Trong bài học tiếp theo, bạn sẽ thấy những truy vấn này hoạt động như thế nào.

<!--@ C:\Users\vvn20206205\Downloads\_______test\z\_DDD\15MicroservicesandAPI_VVN\000000010.srt -->

1
00:00:00,630 --> 00:00:08,320
Sản phẩm, triển khai đồ họa, trong bài học này, bạn sẽ thấy hoạt động của API sản phẩm đồ họa.

2
00:00:08,430 --> 00:00:24,810
Tôi cũng sẽ hướng dẫn bạn sơ đồ lớp và mã để triển khai API sản phẩm.  Vì nhóm dịch vụ vi mô của sản phẩm đã sử dụng Springboard nên họ đã quyết định sử dụng bàn đạp này để triển khai API đồ họa của mình.

3
00:00:24,870 --> 00:00:35,890
Springboard sử dụng nội bộ cách triển khai Java đồ họa của các thông số kỹ thuật này để hiểu rõ hơn về cách triển khai Java đồ họa.

4
00:00:35,940 --> 00:00:43,970
Tôi khuyên bạn nên truy cập trang web đồ họa Java dot com.  Chúng tôi sẽ sử dụng sân chơi đồ họa để thử nghiệm.

5
00:00:44,070 --> 00:00:55,570
Vì vậy, nếu bạn muốn theo dõi, vui lòng đăng video, tải xuống sân chơi đồ họa và thiết lập nó trên máy của bạn trước khi tiếp tục phát triển định nghĩa lược đồ.

6
00:00:55,590 --> 00:01:08,430
Tôi thực sự khuyên bạn nên cài đặt plugin đồ họa trong ID của mình, chẳng hạn như mã hình ảnh thông minh.  Tôi đã cài đặt plugin này trong thiết lập thông minh của mình để kiểm tra.

7
00:01:08,430 --> 00:01:28,680
Biểu đồ sẽ xuất hiện.  Trước tiên, chúng tôi sẽ khởi chạy biểu đồ CALIPSO, sau đó khởi chạy sân chơi đồ họa và thực hiện các truy vấn từ prasugrel đồ họa dựa trên API đồ họa do các sản phẩm Microsoft Office của chúng tôi cung cấp để khởi chạy SOA đồ họa ngay.

8
00:01:28,680 --> 00:01:37,400
Bấm vào các sản phẩm đang chạy ở đây và nhấn chạy.  Chúng ta cần khởi chạy sân chơi đồ họa để kết nối với máy chủ.

9
00:01:37,500 --> 00:01:46,110
Nhấp vào điểm cuối của bạn, cung cấp điểm cuối là biểu đồ 80 dấu gạch chéo localhost và nhấp vào Mở.

10
00:01:46,110 --> 00:01:54,280
Khi sân chơi kết nối với máy chủ, nó sẽ tìm nạp lược đồ để bạn sẽ thấy nội dung được lấy từ tệp định nghĩa lược đồ.

11
00:01:54,300 --> 00:02:02,940
Dưới đây là các truy vấn dành cho sản phẩm, nhà cung cấp và sau đó là định nghĩa đối tượng với tất cả các trường dành cho nhà cung cấp và sản phẩm.

12
00:02:02,970 --> 00:02:11,790
Hãy tiếp tục và thử một truy vấn truy vấn.  Bắt đầu với truy vấn từ khóa.  Tiếp theo, chúng ta phải cho biết truy vấn nào chúng ta muốn thực hiện sản phẩm.

13
00:02:11,790 --> 00:02:22,200
Chúng ta cần cung cấp các đối số, giả sử số nửa đêm và đặt nó là hai, ba.  Tiếp theo, chúng ta cần chỉ định các trường mà chúng ta muốn nhận.

14
00:02:22,620 --> 00:02:35,120
Vì vậy, hãy đặt mô tả về số đêm đích đến, hãy tiếp tục và thực hiện nó.  Và đây là các gói sản phẩm có số đêm tối thiểu là ba.

15
00:02:35,160 --> 00:02:43,920
Hãy thay đổi số này thành 5 và xem điều gì sẽ xảy ra.  Và như bạn có thể thấy bây giờ, chúng ta đang thấy sản phẩm có số đêm tối thiểu là năm.

16
00:02:43,930 --> 00:02:51,270
Hãy thay đổi tiêu chí này thành đích đến.  Giả sử chúng ta quan tâm đến các sản phẩm có điểm đến là Florida.

17
00:02:51,780 --> 00:03:05,640
Và đây là phản hồi từ máy chủ với một sản phẩm duy nhất dành cho Florida.  Bây giờ, phần hay nhất là chúng ta có thể yêu cầu máy chủ trả lại cho chúng ta thông tin về nhà cung cấp và chúng ta cần chỉ định các trường cho nhà cung cấp.

18
00:03:05,640 --> 00:03:20,370
Vì vậy, hãy nói tên và giả sử loại, thực hiện truy vấn.  Và bây giờ, như bạn có thể thấy, chúng tôi đã nhận được thông tin về gói và chúng tôi cũng nhận được thông tin về hai nhà cung cấp, là một phần của gói.

19
00:03:20,370 --> 00:03:26,310
Và đối với hai nhà cung cấp này, chúng tôi chỉ nhận được thông tin mà chúng tôi yêu cầu, tên và loại.

20
00:03:26,310 --> 00:03:37,740
Như bạn có thể thấy ở đây chỉ với một cuộc gọi, chúng tôi đã nhận được tất cả thông tin mà chúng tôi cần.  Tôi khuyên bạn nên cài đặt sân chơi đồ họa và tự mình thử các truy vấn này.

21
00:03:38,640 --> 00:03:45,390
Các lớp triển khai cho API nằm trong gói đồ họa Commodore Achmat hoặc Product Start.

22
00:03:45,420 --> 00:03:52,410
Lớp chính ở đây là nhà cung cấp đồ họa được sử dụng để khởi động.  Ứng dụng Springboard.

23
00:03:52,530 --> 00:04:02,430
Lớp thử nghiệm chính nơi ứng dụng bàn đạp được khởi chạy là sản phẩm đang chạy.  Rafeal Appia theo gói Commodore Achmad hoặc gói thử nghiệm.

24
00:04:02,610 --> 00:04:12,750
Lớp Trình tải dữ liệu Graph Kuhar là một nhà máy để tạo các tính năng dữ liệu cho truy vấn sản phẩm và truy vấn nhà cung cấp.

25
00:04:12,930 --> 00:04:30,620
Nhà cung cấp Didkovsky sử dụng trình tìm nạp dữ liệu đồ họa để tạo các phiên bản của những dữ liệu này, có tính năng là trình tìm nạp dữ liệu cho người dùng sản phẩm, mô hình truy vấn sản phẩm, có thể được coi là trình bao bọc cho sản phẩm và thông tin nhà cung cấp.

26
00:04:30,660 --> 00:04:46,590
Đây là trình giải quyết cho truy vấn sản phẩm.  Nó hiển thị hàm cho từng trường được xác định trong định nghĩa lược đồ cho API khi máy chủ biểu đồ nhận được yêu cầu thực thi các đại biểu truy vấn.

27
00:04:46,590 --> 00:04:59,520
Yêu cầu đó đối với các tính năng dữ liệu còn được gọi là trình giải quyết truy vấn.  Vì vậy, trong trường hợp API sản phẩm, có một phiên bản của trình tìm nạp dữ liệu cho sản phẩm và có một.

28
00:04:59,930 --> 00:05:10,250
Và về Trình tìm nạp vì đã cung cấp các phiên bản này, hiển thị các hàm được thực thi theo yêu cầu truy vấn đối với sản phẩm và nhà cung cấp.

29
00:05:10,700 --> 00:05:27,680
Chúng ta hãy xem mã cho những dữ liệu này.  Tìm nạp declasse Các tính năng của Grauwe Cuadrilla là nhà máy để tạo các phiên bản cho việc tìm nạp dữ liệu, mỗi trình tìm nạp dữ liệu thực hiện tính năng dữ liệu giao diện và có một chức năng nhận.

30
00:05:27,950 --> 00:05:56,480
Vì vậy, đây là nơi chúng tôi đang tạo một phiên bản của trình tìm nạp dữ liệu cho lớp sản phẩm và trong mã quên bạn sẽ thấy rằng điều đầu tiên chúng tôi đang làm là lấy các đối số truy vấn sau đó, thực hiện truy vấn trên repo sản phẩm, sau đó gói  đối tượng sản phẩm với đối tượng mô hình truy vấn sản phẩm chứa phiên bản của sản phẩm cũng như tất cả các nhà cung cấp là một phần của sản phẩm.

31
00:05:56,660 --> 00:06:06,830
Và khu vực này được trả về máy chủ.  Về cơ bản, toàn bộ điều này là các bộ phân giải cho sản phẩm, các đối tượng được gửi lại cho người gọi.

32
00:06:07,220 --> 00:06:15,220
Tương tự, có một trình tìm nạp được tạo cho truy vấn của nhà cung cấp.  Và tính năng này tương đối rất đơn giản.

33
00:06:15,560 --> 00:06:33,870
Chúng tôi chỉ đơn giản sử dụng repo của nhà cung cấp và gửi lại phiên bản của nhà cung cấp.  Phiên bản nhà cung cấp mà chúng tôi đang gửi lại là trình phân giải để nhà cung cấp truy vấn dữ liệu cho API sản phẩm phản hồi lại bằng một mảng đối tượng trình phân giải cho sản phẩm.

34
00:06:34,430 --> 00:06:43,610
Đây là các đối tượng của trình phân giải, các hàm của expo tương ứng với từng trường này trong định nghĩa lược đồ cho sản phẩm.

35
00:06:44,060 --> 00:06:59,720
Vì vậy, ví dụ, chức năng mô tả cổng để truy xuất thông tin trên mô tả cho biết chức năng công khai của nó là lấy ID công khai và có các chức năng khác tương ứng với từng trường.

36
00:07:00,020 --> 00:07:07,790
Máy chủ gọi các hàm này để lấy thông tin cho từng trường mà nó cần quay lại cột.

37
00:07:08,480 --> 00:07:19,040
Trong bài học này, bạn đã thấy sản phẩm hoạt động và bạn đã thấy cách triển khai truy vấn sản phẩm.  Tôi khuyên bạn nên tự mình thử truy vấn của nhà cung cấp.

