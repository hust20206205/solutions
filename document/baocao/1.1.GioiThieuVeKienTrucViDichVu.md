
Sau khi có thiết kế Class Diagram ta có cơ sở dữ liệu. Do em dùng kỹ thuật lập trình ORM nên từ claas của code sẽ tạo các bảng cơ sở dữ liệu.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
! Trình bày về kiến trúc kiến trúc vi dịch vụ
\chapter{Trình bày về kiến trúc kiến trúc vi dịch vụ}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%! Mô hình kiến trúc nguyên khối
\section{Mô hình kiến trúc nguyên khối}
Trước khi kiến trúc vi dịch vụ trở nên phổ biến, mô hình kiến trúc nguyên khối đã được áp dụng rộng rãi trong kiến trúc phần mềm truyền thống. Mô hình kiến trúc nguyên khối là một kiểu kiến trúc phần mềm, trong đó toàn bộ ứng dụng hoặc hệ thống được xây dựng và triển khai như một thực thể duy nhất, gom chung các thành phần chức năng vào một lớp duy nhất.
\subsection{Giới thiệu về Mô hình kiến trúc nguyên khối}
kiến trúc nguyên khối là một kiểu kiến trúc phần mềm truyền thống, trong đó toàn bộ ứng dụng hoặc hệ thống được xây dựng và triển khai như một đơn vị duy nhất. Trong kiến trúc kiến trúc nguyên khối, tất cả các thành phần chức năng của ứng dụng được tích hợp vào một lớp duy nhất. Điều này có nghĩa là tất cả các tính năng, quy trình và dữ liệu được xử lý và quản lý trong một đơn vị lớn duy nhất.

Mô hình kiến trúc nguyên khối có nhiều dạng và biến thể khác nhau. Dưới đây là hai ví dụ phổ biến về mô hình kiến trúc nguyên khối:
\subsubsection{Mô hình 3 lớp}
% \end{enumerate} item
Trong mô hình 3 lớp, ứng dụng được chia thành ba lớp chính:
\begin{enumerate}
\item \textbf{Presentation Layer (Lớp giao diện người dùng):} Lớp này là giao diện người dùng, nơi người dùng tương tác với ứng dụng. Nó có trách nhiệm hiển thị thông tin và gửi các yêu cầu từ người dùng đến lớp Logic Layer (Lớp xử lý logic).
\item \textbf{Logic Layer (Lớp xử lý logic):} Lớp này chứa các quy tắc kinh doanh và logic xử lý dữ liệu. Nó nhận các yêu cầu từ Presentation Layer, thực hiện xử lý và truy cập dữ liệu từ Data Layer (Lớp dữ liệu).
\item \textbf{Data Layer (Lớp dữ liệu):} Lớp này là nơi dữ liệu được lưu trữ và quản lý. Nó truy cập vào cơ sở dữ liệu và cung cấp dữ liệu cho Logic Layer để xử lý các yêu cầu.
\subsubsection{Mô hình MVC (Model-View-Controller)}
Mô hình MVC là một trong những biến thể của kiến trúc kiến trúc nguyên khối. Trong mô hình này, ứng dụng được chia thành ba thành phần chính:
\end{enumerate}
\begin{enumerate}
\item \textbf{Model (Mô hình):} Đại diện cho dữ liệu và logic xử lý dữ liệu. Nó là nơi lưu trữ các đối tượng dữ liệu và các hàm để truy xuất và xử lý dữ liệu.
\item \textbf{View (Giao diện):} Đại diện cho phần giao diện người dùng của ứng dụng. Nó hiển thị dữ liệu từ Model và cho phép người dùng tương tác với ứng dụng.
\item \textbf{Controller (Bộ điều khiển):} Chịu trách nhiệm giữa Model và View. Nó nhận các yêu cầu từ người dùng thông qua View, sau đó tương tác với Model để lấy dữ liệu và cập nhật View để hiển thị kết quả cho người dùng.
\end{enumerate}
Tuy mô hình kiến trúc nguyên khối có những ưu điểm như dễ triển khai ban đầu, đơn giản và hiệu suất tốt, nhưng nó cũng đối mặt với một số nhược điểm khi ứng dụng ngày càng lớn và phức tạp.
\subsection{Ưu điểm của Mô hình kiến trúc nguyên khối}
Mô hình kiến trúc nguyên khối có một số ưu điểm nhất định, đặc biệt là trong các trường hợp ứng dụng có quy mô nhỏ và cần triển khai nhanh chóng. Các ưu điểm của mô hình kiến trúc nguyên khối bao gồm:
\begin{enumerate}
\item \textbf{Đơn giản và dễ hiểu:} Kiến trúc kiến trúc nguyên khối đơn giản, dễ hiểu và dễ tiếp cận cho các nhà phát triển, đặc biệt là khi xây dựng các ứng dụng nhỏ và đơn giản.
\item \textbf{Triển khai dễ dàng:} Việc triển khai một ứng dụng kiến trúc nguyên khối đơn giản hơn so với các kiểu kiến trúc phức tạp hơn như kiến trúc phân tầng hoặc kiến trúc phân tán.
\item \textbf{Hiệu suất tốt:} Vì tất cả các thành phần chức năng được tích hợp vào một lớp duy nhất, việc gọi và xử lý các hàm có thể nhanh chóng và hiệu quả.
\end{enumerate}
\subsection{Nhược điểm của Mô hình kiến trúc nguyên khối}
Tuy mô hình kiến trúc nguyên khối có những ưu điểm nhất định, nhưng nó cũng đối mặt với một số nhược điểm đáng lưu ý, đặc biệt là khi ứng dụng ngày càng lớn và
phức tạp. Một số nhược điểm của mô hình kiến trúc nguyên khối bao gồm:
\begin{enumerate}
\item \textbf{Khó tái sử dụng:} Vì tất cả các tính năng được kết hợp vào một lớp duy nhất, việc tái sử dụng các phần mã có thể trở nên khó khăn và tốn kém.
\item \textbf{Không linh hoạt:} Bất kỳ thay đổi nào trong một thành phần cũng có thể ảnh hưởng đến các thành phần khác, làm cho việc cập nhật và bảo trì trở nên phức tạp.
\item \textbf{Khó mở rộng:} Khi ứng dụng mở rộng và quy mô tăng lên, việc thêm các tính năng mới có thể trở nên khó khăn và dễ dàng gây ra sự không ổn định.
\item \textbf{Khó khăn trong quản lý dự án lớn:} Khi dự án phức tạp với nhiều chức năng và đội ngũ lớn, việc đóng gói toàn bộ chức năng vào một tệp duy nhất có thể làm cho việc phát triển và kiểm thử trở nên cồng kềnh và mất thời gian.
\item \textbf{Độ phức tạp và tốc độ phát triển:} Khi dự án ngày càng lớn, việc thêm mới các chức năng có thể gây ra sự ràng buộc và tác động đến các chức năng khác, dẫn đến việc phát triển chậm lại và việc test tích hợp càng ngày càng phức tạp.
\item \textbf{Giới hạn ngôn ngữ và framework:} Khi các chức năng được đóng gói chặt chẽ, thì việc sử dụng ngôn ngữ và framework chỉ có thể giới hạn trong phạm vi của chương trình. Điều này có thể làm giảm khả năng sử dụng các công nghệ mới và hiện đại, khiến dự án trở nên khó khăn trong việc bảo trì và nâng cấp.
\end{enumerate}
Để giải quyết những vấn đề này, khi dự án có quy mô lớn và phức tạp thường áp dụng các các mô hình kiến trúc phân tán và hiện đại hơn, như kiến trúc dựa trên hướng dịch vụ (kiến trúc vi dịch vụ) hoặc kiến trúc hướng sự kiện. Các mô hình này giúp phân chia dự án thành các thành phần riêng biệt và độc lập, giúp cho việc phát triển và quản lý dự án trở nên dễ dàng hơn, cũng như cho phép sử dụng nhiều ngôn ngữ và framework khác nhau trong cùng một dự án.
%! Mô hình kiến trúc vi dịch vụ
\section{Mô hình kiến trúc vi dịch vụ}
\subsection{Giới thiệu kiến trúc vi dịch vụ}
kiến trúc vi dịch vụ là một kiểu kiến trúc phần mềm đang trở nên phổ biến trong các ứng dụng phần mềm hiện đại. Khác với mô hình kiến trúc nguyên khối, mô hình kiến trúc vi dịch vụ chia ứng dụng thành các thành phần nhỏ hơn, độc lập và có thể triển khai độc lập với nhau. Mỗi thành phần nhỏ này được gọi là một dịch vụ "service", và mỗi dịch vụ đóng gói các tính năng liên quan vào một đơn vị độc lập. Các dịch vụ này có thể được triển khai trên các máy chủ hoặc môi trường khác nhau.

Mô hình kiến trúc vi dịch vụ thúc đẩy sự phân tách và độc lập giữa các thành phần của ứng dụng. Mỗi dịch vụ có thể được phát triển bởi một nhóm phát triển riêng biệt và sử dụng ngôn ngữ và công nghệ khác nhau, cho phép tận dụng hiệu quả những lợi ích của từng công nghệ.

Mô hình kiến trúc vi dịch vụ cũng khuyến khích sử dụng các giao thức gọn nhẹ và hướng dịch vụ (REST, gRPC, \dots) để giao tiếp giữa các dịch vụ, giúp giảm thiểu sự ràng buộc và tăng tính linh hoạt của hệ thống.
\subsection{Ưu điểm kiến trúc vi dịch vụ}
Mô hình kiến trúc vi dịch vụ mang đến nhiều ưu điểm đáng chú ý, đặc biệt là trong các ứng dụng có quy mô lớn và phức tạp. Một số ưu điểm của mô hình kiến trúc vi dịch vụ bao gồm:
\begin{enumerate}
\item \textbf{Tích hợp dễ dàng:} Vì mỗi dịch vụ là một đơn vị độc lập, việc tích hợp và triển khai các dịch vụ mới trở nên dễ dàng hơn. Điều này giúp tăng tốc độ phát triển và giảm thiểu thời gian triển khai.
\item \textbf{Mở rộng linh hoạt:} Mô hình kiến trúc vi dịch vụ cho phép mở rộng các dịch vụ một cách linh hoạt và độc lập. Khi nhu cầu tăng cường hiệu suất hoặc sức chứa của một dịch vụ, chỉ cần mở rộng dịch vụ đó mà không ảnh hưởng đến các dịch vụ khác.
\item \textbf{Tích hợp ngôn ngữ và công nghệ đa dạng:} Mỗi dịch vụ có thể sử dụng ngôn ngữ và công nghệ phù hợp nhất với tính chất và yêu cầu của nó. Điều này giúp tận dụng tối đa khả năng của từng công nghệ và ngôn ngữ, thay vì bị ràng buộc bởi một ngôn ngữ và công nghệ duy nhất như trong mô hình kiến trúc nguyên khối.
\item \textbf{Dễ quản lý và bảo trì:} Mỗi dịch vụ độc lập với nhau, giúp giảm thiểu rủi ro lỗi lan tỏa và tăng tính ổn định của hệ thống. Quản lý và bảo trì các dịch vụ trở nên dễ dàng hơn khi chỉ tập trung vào một phần nhỏ của ứng dụng.
\item \textbf{Độc lập phát triển và triển khai:} Mỗi dịch vụ có thể được phát triển và triển khai độc lập với các dịch vụ khác. Điều này giúp tăng tốc độ phát triển và giảm thiểu các xung đột trong quá trình phát triển.
\end{enumerate}
\subsection{Nhược điểm kiến trúc vi dịch vụ}
Mặc dù mô hình kiến trúc vi dịch vụ có nhiều ưu điểm, nhưng nó cũng không phải là giải pháp hoàn hảo cho mọi trường hợp. Một số nhược điểm của mô hình kiến trúc vi dịch vụ bao gồm:
\begin{enumerate}
\item \textbf{Khó quản lý mạng lưới dịch vụ:} Khi ứng dụng được chia thành nhiều dịch vụ nhỏ, việc quản lý và giám sát các dịch vụ này trở nên phức tạp hơn. Điều này đòi hỏi hệ thống quản lý mạng lưới dịch vụ phải được triển khai và duy trì một cách chặt chẽ.
\item \textbf{Tăng chi phí khởi đầu:} Mô hình kiến trúc vi dịch vụ yêu cầu phải triển khai nhiều dịch vụ độc lập và xây dựng các hệ thống quản lý dịch vụ phức tạp. Điều này có thể dẫn đến tăng chi phí khởi đầu cho dự án.
\item \textbf{Rủi ro về bảo mật:} Khi mô hình kiến trúc vi dịch vụ triển khai nhiều dịch vụ độc lập, điều này có thể tạo ra các điểm yếu bảo mật trong hệ thống. Điều này yêu cầu tăng cường bảo mật cho từng dịch vụ và sử dụng các biện pháp bảo mật phù hợp.
\item \textbf{Phức tạp trong việc theo dõi và gỡ lỗi:} Khi có sự phân tán và độc lập giữa các dịch vụ, việc theo dõi và gỡ lỗi trong hệ thống trở nên phức tạp hơn. Điều này đòi hỏi hệ thống giám sát và công cụ gỡ lỗi phải được triển khai một cách hiệu quả.
\item \textbf{Khó khăn trong việc quản lý sự thay đổi:} Khi ứng dụng có nhiều dịch vụ, việc thay đổi một dịch vụ có thể ảnh hưởng đến các dịch vụ khác. Điều này đòi hỏi phải có quy trình quản lý sự thay đổi chặt chẽ và kiểm tra tích hợp mạnh mẽ.
\end{enumerate}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%! Triển khai Kiến trúc kiến trúc vi dịch vụ
\section{Triển khai Kiến trúc kiến trúc vi dịch vụ}
Kiến trúc kiến trúc vi dịch vụ là một phương pháp phát triển phần mềm hiện đại, trong đó ứng dụng được xây dựng dưới dạng các dịch vụ nhỏ, độc lập và phân tán. Mỗi dịch vụ này được thiết kế để thực hiện một chức năng cụ thể trong ứng dụng và có thể được triển khai, mở rộng và quản lý một cách độc lập.

Triển khai kiến trúc kiến trúc vi dịch vụ đòi hỏi sự tập trung vào thiết kế chặt chẽ, cũng như sự hỗ trợ từ các công nghệ và công cụ phù hợp để thành công trong việc xây dựng và quản lý các ứng dụng phức tạp và phân tán.

Một số lưu ý khi triển khai kiến trúc kiến trúc vi dịch vụ là:
\begin{itemize}
\item Cần phải xem xét cẩn thận việc chia nhỏ ứng dụng thành các dịch vụ nhỏ sao cho phù hợp với đặc thù của từng ứng dụng cụ thể.
\item Sử dụng các công nghệ và công cụ phù hợp để quản lý, theo dõi và điều phối các dịch vụ một cách hiệu quả.
\item Xác định rõ ràng các tiêu chuẩn giao tiếp và cơ chế đồng bộ hóa giữa các dịch vụ để đảm bảo tính nhất quán của hệ thống.
\end{itemize}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% %! Git
\subsection{Git}
Git là một hệ thống quản lý phiên bản được sử dụng rộng rãi trong phát triển phần mềm.
\subsubsection{Mục đích}
Mục đích sử dụng Git là để theo dõi và quản lý các phiên bản của mã nguồn trong quá trình phát triển phần mềm.
\begin{itemize}
\item \textbf{Theo dõi lịch sử thay đổi:} Git lưu trữ toàn bộ lịch sử thay đổi của mã nguồn, cho phép xem và theo dõi sự thay đổi từng bước một.
\item \textbf{Cộng tác nhóm:} Git cho phép làm việc cùng nhau trên cùng một dự án mà không gặp xung đột.
\item \textbf{Tách nhánh (Branching) và Hợp nhất (Merging):} Git cho phép tạo nhiều nhánh (branch) riêng biệt để phát triển tính năng hoặc sửa lỗi mà không ảnh hưởng đến nhánh chính. Sau đó, các nhánh này có thể hợp nhất lại với nhau để kết hợp các thay đổi.
\item \textbf{An toàn và phục hồi dữ liệu:} Vì Git lưu trữ phiên bản của mã nguồn trên nhiều máy tính khác nhau, dữ liệu được sao lưu và bảo vệ an toàn. Nếu có sự cố, người dùng có thể dễ dàng phục hồi dữ liệu từ kho chứa chính.
\item \textbf{Khả năng làm việc ngoại tuyến:} Git cho phép làm việc với kho chứa mà không cần kết nối Internet.
\end{itemize}
\subsubsection{Các khái niệm cơ bản trong Git}
\begin{itemize}
\item \textbf{Repository :} là nơi lưu trữ dự án và tất cả lịch sử thay đổi của mã nguồn.
\item \textbf{Branch :} là một phiên bản độc lậ








Kiến trúc vi dịch là một kiến trúc phần mềm được chia thành các thành phần nhỏ hơn, gọi là vi dịch, mỗi kiến trúc vi dịch chịu trách nhiệm cho một chức năng cụ thể. Các kiến trúc vi dịch có thể được phát triển, triển khai, và quản lý độc lập, thường thông qua các ngôn ngữ và công nghệ khác nhau. Sự tách biệt giữa các kiến trúc vi dịch được thực hiện thông qua giao thức như HTTP hoặc message bus.



2. **kiến trúc vi dịch:**
- Giải thích khái niệm của kiến trúc vi dịch.
- Đặc điểm và lợi ích của việc sử dụng kiến trúc vi dịch.
- So sánh với kiến trúc kiến trúc nguyên khối.


**2. kiến trúc vi dịch:**

**Giải Thích Khái Niệm của kiến trúc vi dịch:**


**Đặc Điểm và Lợi Ích của kiến trúc vi dịch:**

- *Tách Biệt và Độc Lập:* Mỗi kiến trúc vi dịch hoạt động độc lập, không phụ thuộc vào các kiến trúc vi dịch khác. Điều này giúp giảm rủi ro và tăng tính linh hoạt trong việc phát triển và triển khai.

- *Tính Mở Rộng và Hiệu Suất:* Việc có thể mở rộng và triển khai riêng lẻ từng kiến trúc vi dịch giúp tối ưu hóa hiệu suất và quản lý tài nguyên một cách hiệu quả.

- *Ngôn Ngữ và Công Nghệ Đa Dạng:* Các kiến trúc vi dịch có thể được viết bằng ngôn ngữ và sử dụng công nghệ khác nhau tùy thuộc vào yêu cầu cụ thể của chúng. Điều này mang lại sự linh hoạt lớn trong việc lựa chọn công nghệ.

- *Dễ Quản Lý và Phát Triển:* Mỗi kiến trúc vi dịch có thể được quản lý và phát triển độc lập. Điều này giúp giảm thiểu thời gian và rủi ro trong quá trình phát triển và cải thiện khả năng chấp nhận thay đổi nhanh chóng.

**So Sánh với Kiến Trúc kiến trúc nguyên khối:**

- *Độ Phức Tạp:* Trong kiến trúc kiến trúc nguyên khối, toàn bộ ứng dụng được xây dựng và triển khai như một đơn vị lớn. Điều này có thể dẫn đến sự phức tạp trong quản lý mã nguồn và triển khai.

- *Khả Năng Mở Rộng:* Kiến trúc kiến trúc nguyên khối thường khó mở rộng do phải triển khai toàn bộ ứng dụng khi có thay đổi. Ngược lại, kiến trúc vi dịch cho phép mở rộng chỉ các phần cần thiết.

- *Khả Năng Đáp Ứng:* kiến trúc vi dịch giúp ứng dụng dễ dàng thích ứng với thay đổi, giảm thời gian và rủi ro khi triển khai các cập nhật và thay đổi. Trong khi đó, kiến trúc kiến trúc nguyên khối thường đòi hỏi quá trình triển khai toàn bộ ứng dụng.

- *Quản Lý Lỗi:* kiến trúc vi dịch cung cấp khả năng quản lý lỗi tốt hơn do lỗi thường chỉ ảnh hưởng đến một hoặc vài kiến trúc vi dịch, trong khi trong kiến trúc kiến trúc nguyên khối, một lỗi có thể ảnh hưởng đến toàn bộ hệ thống.


<!--Giới thiệu-->

kiến trúc vi dịch VÀ NGUYÊN KHỐI...
SO SÁNH....
Kiến trúc kiến trúc vi dịch là một xu hướng quan trọng trong phát triển phần mềm và tiềm năng mang lại nhiều lợi ích.

Sử dụng kiến trúc kiến trúc vi dịch giúp tách các chức năng khác nhau thành các dịch vụ nhỏ độc lập nhau, giúp cải thiện tính linh hoạt, khả năng mở rộng và dễ dàng phát triển và bảo trì hệ thống.

Kiến trúc kiến trúc vi dịch cho phép các kiến trúc vi dịch hoạt động độc lập linh hoạt và đáng tin cậy trong việc quản lý người dùng, quản lý sản phẩm, quản lý đơn hàng và thanh toán.

<!--GIỚI THIỆU-->

<!--Kiến trúc nguyên khối-->

Kiến trúc nguyên khối là một cách xây dựng ứng dụng truyền thống. Một ứng dụng nguyên khối, được thiết kế tốt bao gồm nhiều mô-đun, được triển khai bằng một hoặc nhiều cơ sở mã lớn hoặc lập trình chung.

Ngôn ngữ thường được sử dụng để xây dựng tất cả các thành phần trong một ứng dụng nguyên khối và có sự liên kết chặt chẽ giữa các thành phần tạo nên ứng dụng nguyên khối mà các nhóm hình thành.

Tất cả các nhóm cần phải tập hợp lại và điều phối việc phát hành các phiên bản mới của ứng dụng.

<!--Microserrvice-->

Bây giờ, hãy nói về các dịch vụ vi mô, kiến ​​trúc, dịch vụ vi mô, kiến ​​trúc sắp xếp một ứng dụng như một tập hợp các dịch vụ được liên kết lỏng lẻo trong kiến ​​trúc dịch vụ vi mô mà các dịch vụ đang tìm kiếm và các giao thức rất nhẹ.

Các dịch vụ này là các đơn vị khép kín được xây dựng để hiện thực hóa khả năng kinh doanh cụ thể.

<!--Ví dụ-->
<!--Vì vậy, trong trường hợp doanh nghiệp bán lẻ, các dịch vụ này có thể được xây dựng dựa trên đơn đặt hàng, khả năng vận chuyển và tiếp thị của doanh nghiệp bán lẻ.-->
<!--Trong trường hợp ngân hàng, các dịch vụ này có thể được tổ chức xung quanh các sản phẩm mà ngân hàng giao dịch, chẳng hạn như tài khoản bán lẻ, thẻ tín dụng và khoản vay.-->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!--interface , service là gì?-->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!--nhiều thách thức, và việc duy trì sự linh hoạt và tái cấu trúc là quan trọng để đảm bảo sự thành công trong dài hạn.-->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
<!---->

<!---->
<!---->
<!---->
<!---->

Hiện nay, các tổ chức doanh nghiệp có nhu cầu thay đổi, phát triển liên tục từ đó hoạt động kinh doanh yêu cầu thay đổi và sự đổi mới nhanh chóng hệ thống và ứng dụng với Nhu Cầu và Mong Đợi của Khách Hàng.

<!--Ví dụ-->
<!--Microsoft chuyển từ bán phần mềm đóng gói sang mô hình đăng ký.-->
<!--Amazon từ hiệu sách trực tuyến thành thị trường cho nhà cung cấp khác.-->
<!--Nefifc-->
<!--Baemin-->

=> Kiến trúc của Microserrvice giải quyết những thách thức và giúp chuyển đổi nhanh chóng

Vì không có sự phụ thuộc giữa các dịch vụ vi mô nên tốc độ thực hiện và phát hành những thay đổi này sẽ nhanh hơn nhiều so với kiến ​​trúc nguyên khối nơi có sự phụ thuộc lẫn nhau giữa nhiều mô-đun thực hiện chức năng kinh doanh khác nhau. <!--test, phụ thuộc,ràng buộc video youtube (xxxxxxxx)-->

<!--mỗi dịch vụ vi mô được gán cho một nhóm nhỏ.-->
<!--và các nhóm này được hỗ trợ bởi các chuyên gia tên miền.-->

<!--Lợi ích đầu tiên của việc tổ chức các dịch vụ vi mô xoay quanh khả năng kinh doanh là mỗi dịch vụ có thể phát triển độc lập.-->
<!--Dễ dàng thay đổi, phát triển riêng-->
<!--Tập trung trong nghiệp vụ service-->
<!--Trên thực tế, điều này sẽ dẫn đến tốc độ định giá doanh nghiệp nhanh hơn.-->

Một điểm quan trọng cần lưu ý là nhóm kiến ​​trúc dịch vụ vi mô phải tạo ra phạm vi kinh doanh phù hợp cho từng dịch vụ vi mô để duy trì tính độc lập.

<!--Một điều quan trọng cần lưu ý là để tận dụng tối đa kiến ​​trúc dịch vụ vi mô, điều quan trọng đối với nhóm dịch vụ vi mô là phải tạo ra mã nghiệp vụ phù hợp cho từng máy chủ vi mô.-->
<!--Nếu không thực hiện đúng sẽ dẫn đến tình trạng các nhóm phụ thuộc lẫn nhau và điều đó sẽ dẫn đến mất đi lợi thế của kiến ​​trúc dịch vụ vi mô.-->
<!--Và đây là lúc thiết kế Theo nhu cầu xuất hiện. Bối cảnh giới hạn của thiết kế hướng miền là sự thể hiện phạm vi kinh doanh của dịch vụ vi mô.-->

=> mẫu thiết kế hướng miền sử dụng để xây dựng các dịch vụ vi mô.

<!--Kiến trúc của Microserrvice gợi ý việc tạo ra một tập hợp các dịch vụ được kết nối lỏng lẻo để xây dựng các ứng dụng.-->
<!--Mỗi dịch vụ này đều có cơ sở mã độc lập và điều đó có nghĩa là chúng có thể được triển khai độc lập.-->
<!--Các dịch vụ này tương tác với nhau qua mạng-->

<!--ưu và nhược điểm của kiến ​​trúc Microserrvice .-->
<!--Việc quản lý các thay đổi trong ứng dụng dịch vụ vi mô sẽ dễ dàng hơn và chỉ có một thay đổi trong một dịch vụ.-->
<!--các nhóm không tuân theo kế hoạch triển khai chung-->
<!--IDE nhẹ-->
<!--đa ngôn ngữ.-->
<!--hình các ngôn ngữ nodejs , python, java,...-->
<!--Khả năng chịu lỗi-->
<!--mở rộng quy mô độc lập-->

<!--một số nhược điểm của kiến ​​trúc dịch vụ vi mô.-->
<!--Vì tương tác với nhau qua giao thức mạng-->
<!--mỗi dịch vụ vi mô sẽ quản lý cơ sở dữ liệu riêng dẫn đến sự phức tạp trong việc quản lý tính toàn vẹn dữ liệu.-->
<!--Khả năng transaction (giao dịch) khó khăn-->
<!--việc giám sát và gỡ lỗi các dịch vụ vi mô khó khăn.-->
<!--Và điều này dẫn đến độ phức tạp cao hơn.-->
<!--Bảo mật-->
<!--Chi phí-->
<!--Kĩ thuật công nghệ-->
<!--hình 1 triệu service Amazon và Netflix-->
<!--Đồng bộ ... phân tán-->

<!---->
<!---->
<!---->
<!---->
<!---->
<!---->
